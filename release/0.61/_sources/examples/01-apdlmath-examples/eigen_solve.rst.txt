
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/01-apdlmath-examples/eigen_solve.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_01-apdlmath-examples_eigen_solve.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_01-apdlmath-examples_eigen_solve.py:


.. _ref_mapdl_math_eigen_solve:

Using APDLMath to solve Eigenproblems
-------------------------------------
Use APDLMath to solve eigenproblems.

This example uses a verification manual input file, but you can use
your own sparse or dense matrices and solve those.

.. GENERATED FROM PYTHON SOURCE LINES 12-25

.. code-block:: default

    import time

    import matplotlib.pylab as plt
    import numpy as np

    from ansys.mapdl.core import launch_mapdl
    from ansys.mapdl.core.examples import vmfiles

    # Start MAPDL as a service and create an APDLMath object
    mapdl = launch_mapdl(loglevel="ERROR")
    mm = mapdl.math









.. GENERATED FROM PYTHON SOURCE LINES 26-29

First we get the `STIFF` and `MASS` matrices from the full file
after running the input file from Verification Manual 153


.. GENERATED FROM PYTHON SOURCE LINES 29-35

.. code-block:: default

    out = mapdl.input(vmfiles["vm153"])

    k = mm.stiff(fname="PRSMEMB.full")
    m = mm.mass(fname="PRSMEMB.full")









.. GENERATED FROM PYTHON SOURCE LINES 36-37

Display size of the M and K matrices

.. GENERATED FROM PYTHON SOURCE LINES 37-40

.. code-block:: default

    print(m.shape)
    print(k.shape)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    (126, 126)
    (126, 126)




.. GENERATED FROM PYTHON SOURCE LINES 41-44

Allocate an array to store the eigenshapes.
where `nev` is the number of eigenvalues requested


.. GENERATED FROM PYTHON SOURCE LINES 44-48

.. code-block:: default

    nev = 10
    a = mm.mat(k.nrow, nev)
    a





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    Dense APDLMath Matrix (126, 10)



.. GENERATED FROM PYTHON SOURCE LINES 49-54

Perform the the modal analysis.

The algorithm is automatically chosen with respect to the matrices
properties (e.g. scalar, storage, symmetry...)


.. GENERATED FROM PYTHON SOURCE LINES 54-61

.. code-block:: default

    print("Calling MAPDL to solve the eigenproblem...")

    t1 = time.time()
    ev = mm.eigs(nev, k, m, phi=a)
    print(f"Elapsed time to solve this problem: {time.time() - t1}")






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Calling MAPDL to solve the eigenproblem...
    /opt/hostedtoolcache/Python/3.8.15/x64/lib/python3.8/site-packages/ansys/mapdl/core/math.py:1453: UserWarning: Call to ``sym`` cannot evaluate if this matrix is symmetric with this version of MAPDL.
      warn(
    Elapsed time to solve this problem: 0.03235197067260742




.. GENERATED FROM PYTHON SOURCE LINES 62-63

This is the vector of eigenfrequencies.

.. GENERATED FROM PYTHON SOURCE LINES 63-65

.. code-block:: default

    print(ev)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    DVIJEE :
     Size : 10
      3.381e+02   3.381e+02   6.266e+02   6.266e+02   9.283e+02      <       5
      9.283e+02   1.250e+03   1.250e+03   1.424e+03   1.424e+03      <       10




.. GENERATED FROM PYTHON SOURCE LINES 66-72

Verify the accuracy of eigenresults
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Check the residual error for the first eigenresult
:math:`R_1=||(K-\lambda_1.M).\phi_1||_2`

First, we compute :math:`\lambda_1 = \omega_1^2 = (2.\pi.f_1)^2`

.. GENERATED FROM PYTHON SOURCE LINES 72-80

.. code-block:: default


    # Eigenfrequency (Hz)
    i = 0
    f = ev[0]
    omega = 2 * np.pi * f
    lam = omega * omega









.. GENERATED FROM PYTHON SOURCE LINES 81-83

Then we get the 1st Eigenshape :math:`\phi_1`, and compute
:math:`K.\phi_1` and :math:`M.\phi_1`

.. GENERATED FROM PYTHON SOURCE LINES 83-94

.. code-block:: default


    # shape
    phi = a[0]

    # APDL Command: *MULT,K,,Phi,,KPhi
    kphi = k.dot(phi)

    # APDL Command: *MULT,M,,Phi,,MPhi
    mphi = m.dot(phi)









.. GENERATED FROM PYTHON SOURCE LINES 95-97

Next, compute the `math`:||K.\phi_1||_2 quantity and normalize the
residual value.

.. GENERATED FROM PYTHON SOURCE LINES 97-106

.. code-block:: default


    # APDL Command: *MULT,K,,Phi,,KPhi
    kphi = k.dot(phi)


    # APDL Command: *NRM,KPhi,NRM2,KPhiNrm
    kphinrm = kphi.norm()









.. GENERATED FROM PYTHON SOURCE LINES 107-110

Then we add these two vectors, using the :math:`\lambda_1` scalar
factor and finally compute the normalized residual value
:math:`\frac{R_1}{||K.\phi_1||_2}`

.. GENERATED FROM PYTHON SOURCE LINES 110-119

.. code-block:: default


    # APDL Command: *AXPY,-lambda,,MPhi,1,,KPhi
    mphi *= lam
    kphi -= mphi

    # Compute the residual
    res = kphi.norm() / kphinrm
    print(res)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    7.11275926845182e-11




.. GENERATED FROM PYTHON SOURCE LINES 120-122

This residual can be computed for all eigenmodes


.. GENERATED FROM PYTHON SOURCE LINES 122-162

.. code-block:: default



    def get_res(i):
        """Compute the residual for a given eigenmode"""
        # Eigenfrequency (Hz)
        f = ev[i]

        # omega = 2.pi.Frequency
        omega = 2 * np.pi * f

        # lambda = omega^2
        lam = omega * omega

        # i-th eigenshape
        phi = a[i]

        # K.Phi
        kphi = k.dot(phi)

        # M.Phi
        mphi = m.dot(phi)

        # Normalization scalar value
        kphinrm = kphi.norm()

        # (K-\lambda.M).Phi
        mphi *= lam
        kphi -= mphi

        # return the residual
        return kphi.norm() / kphinrm


    mapdl_acc = np.zeros(nev)

    for i in range(nev):
        f = ev[i]
        mapdl_acc[i] = get_res(i)
        print(f"[{i}] : Freq = {f}\t - Residual = {mapdl_acc[i]}")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [0] : Freq = 338.06666355063646  - Residual = 7.11275926845182e-11
    [1] : Freq = 338.06666355063675  - Residual = 6.746171206219663e-11
    [2] : Freq = 626.645098092703    - Residual = 1.7213067209485443e-11
    [3] : Freq = 626.6450980927034   - Residual = 3.4196464654380337e-11
    [4] : Freq = 928.2598500574524   - Residual = 6.447818437869047e-12
    [5] : Freq = 928.2598500574531   - Residual = 1.2195745273859991e-11
    [6] : Freq = 1249.8421074363494  - Residual = 1.9669862802830984e-11
    [7] : Freq = 1249.8421074363505  - Residual = 1.8811190184372674e-11
    [8] : Freq = 1423.993890941667   - Residual = 3.132913660044634e-10
    [9] : Freq = 1423.9938909416703  - Residual = 1.2587507950775475e-09




.. GENERATED FROM PYTHON SOURCE LINES 163-164

Plot Accuracy of Eigenresults

.. GENERATED FROM PYTHON SOURCE LINES 164-176

.. code-block:: default


    fig = plt.figure(figsize=(12, 10))
    ax = plt.axes()
    x = np.linspace(1, nev, nev)
    plt.title("APDL Math Residual Error (%)")
    plt.yscale("log")
    plt.ylim([10e-13, 10e-7])
    plt.xlabel("Frequency #")
    plt.ylabel("Errors (%)")
    ax.bar(x, mapdl_acc, label="MAPDL Results")





.. image-sg:: /examples/01-apdlmath-examples/images/sphx_glr_eigen_solve_001.png
   :alt: APDL Math Residual Error (%)
   :srcset: /examples/01-apdlmath-examples/images/sphx_glr_eigen_solve_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    <BarContainer object of 10 artists>



.. GENERATED FROM PYTHON SOURCE LINES 177-178

stop mapdl

.. GENERATED FROM PYTHON SOURCE LINES 178-179

.. code-block:: default

    mapdl.exit()








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  1.045 seconds)


.. _sphx_glr_download_examples_01-apdlmath-examples_eigen_solve.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: eigen_solve.py <eigen_solve.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: eigen_solve.ipynb <eigen_solve.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
