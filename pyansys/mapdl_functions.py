"""
Built using ansys documentation from
https://www.sharcnet.ca/Software/Ansys/

"""

# consider moving the docstrings into a different module


class _MapdlCommands(object):
    """ANSYS class containing MAPDl functions generated from ANSYS 16.2

    """

    def mforder(self, fnumb1="", fnumb2="", fnumb3="", fnumb4="", fnumb5="",
                fnumb6="", fnumb7="", fnumb8="", fnumb9="", fnumb10="",
                fnumb11="", fnumb12="", fnumb13="", fnumb14="", fnumb15="",
                fnumb16="", fnumb17="", fnumb18="", fnumb19="", fnumb20="",
                **kwargs):
        """APDL Command: MFORDER

        Specifies field solution order for an ANSYS Multi-field solver
        analysis.

        Parameters
        ----------
        fnumb1, fnumb2, fnumb3, . . . , fnumb20
            Field numbers defined by the MFELEM command .

        Notes
        -----
        You can define up to twenty fields in an ANSYS Multi-field solver
        analysis.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFORDER,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(fnumb1), str(fnumb2), str(fnumb3), str(fnumb4), str(fnumb5), str(fnumb6), str(fnumb7), str(fnumb8), str(fnumb9), str(fnumb10), str(fnumb11), str(fnumb12), str(fnumb13), str(fnumb14), str(fnumb15), str(fnumb16), str(fnumb17), str(fnumb18), str(fnumb19), str(fnumb20))
        return self.run(command, **kwargs)

    def pdshis(self, rlab="", name="", type="", conf="", **kwargs):
        """APDL Command: PDSHIS

        Plots the sample history values.

        Parameters
        ----------
        rlab
            Result set label. Identifies the result set to be used for
            postprocessing. A result set label can be the solution set label
            you defined in a PDEXE command, or the response surface set label
            defined in an RSFIT command.

        name
            Parameter name. The parameter must have been previously defined as
            a random input variable or a random output parameter using the
            PDVAR command.

        type
            Keyword to identify which type of data is to be plotted:

            SAMP - Sampled values (default).

            MEAN - Mean values for results based on Monte Carlo simulation methods only.

            STDV - Standard deviations for results based on Monte Carlo simulation methods only.

            MIN - Minimum values for results based on Monte Carlo simulation methods only.

            MAX - Maximum values for results based on Monte Carlo simulation methods only.

        conf
            Confidence level. The confidence level is used to plot confidence
            bounds for the history value. The value for the confidence level
            must be between 0.0 and 1.0 and it defaults to 0.95 (95%).
            Confidence bound(s) plotting is suppressed for CONF  0.5. This
            option is ignored for Type = SAMP (no confidence bounds are
            plotted).

        Notes
        -----
        Plots the sample history values as a function of the number of
        simulation loops.

        If Rlab is left blank, then the result set label is inherited from the
        last PDEXE command (Slab), RSFIT command (RSlab), or the most recently
        used PDS postprocessing command where a result set label was explicitly
        specified.

        The confidence level is a probability expressing the confidence that
        the value for the requested probability is in fact between the
        confidence bounds. The larger the confidence level, the wider the
        confidence bounds. For Type = MEAN and Type = STDV, lower and upper
        confidence curves are plotted. For Type = MEAN, the mean value curve
        starts at the first simulation and the confidence bounds start with
        simulation number 2. For Type = MIN only the upper confidence bound is
        shown (the interpretation is that by a certain probability the true
        minimum value is below this curve). This probability (or confidence) is
        set using CONF. Likewise, for Type = MAX, only the lower confidence
        bound is shown. For all Type options, confidence curves are plotted
        starting with the simulation at which enough data is available to
        calculate the bounds. However, for scaling reasons, no confidence
        bounds are plotted for simulation numbers 1 to 5 even if they might be
        available.
        """
        command = "PDSHIS,%s,%s,%s,%s" % (str(rlab), str(name), str(type), str(conf))
        return self.run(command, **kwargs)

    def cscir(self, kcn="", kthet="", kphi="", **kwargs):
        """APDL Command: CSCIR

        Locates the singularity for non-Cartesian local coordinate systems.

        Parameters
        ----------
        kcn
            Number of the local coordinate system in which singularity location
            is to be changed.  Must be greater than 10.

        kthet
            Theta singularity location for cylindrical, spherical, and toroidal
            systems:

            0 - Singularity at ±180°.

            1 - Singularity at 0° (360°).

        kphi
            Phi singularity location for toroidal systems:

            0 - Singularity in phi direction at ±180°.

            1 - Singularity in phi direction at 0° (360°).

        Notes
        -----
        Continuous closed surfaces (circles, cylinders, spheres, etc.) have a
        singularity (discontinuity) at θ = ±180°. For local cylindrical,
        spherical, and toroidal coordinate systems, this singularity location
        may be changed to 0° (360°).

        An additional, similar singularity occurs in the toroidal coordinate
        system at: Φ = ±180° and can be moved with KPHI.  Additional
        singularities occur in the spherical coordinate system at: Φ = ±90°,
        but cannot be moved.

        This command is valid in any processor.
        """
        command = "CSCIR,%s,%s,%s" % (str(kcn), str(kthet), str(kphi))
        return self.run(command, **kwargs)

    def pras(self, quantity="", loadstep="", substep="", **kwargs):
        """APDL Command: PRAS

        Calculates a specified acoustic quantity on the selected exterior
        surface or the frequency-band sound pressure level (SPL).

        Parameters
        ----------
        quantity
            The acoustic quantity to calculate:

            SIMP - Specific acoustic impedance on the selected surface.

            AIMP  - Acoustic impedance on the selected surface.

            MIMP  - Mechanical impedance on the selected surface.

            PRES  - Average pressure on the selected surface.

            FORC  - Force on the selected surface.

            POWE  - Acoustic power on the selected surface.

            BSPL  - Frequency-band sound pressure level.

            BSPA  - A-weighted frequency-band sound pressure level.

        loadstep
            Specified load step. Default = 1.

        substep
            Specified substep. Default = All substeps at the specified load
            step. Not valid for Quantity = BSPL or BSPA.

        Notes
        -----
        The PRAS command calculates a specified acoustic quantity on the
        selected exterior surface in postprocessing. The calculation is based
        on the pressure and velocity solution or the frequency-band sound
        pressure level (SPL).

        The total pressure and velocity are used if the selected surface is the
        excitation source surface. To calculate the incoming and outgoing
        acoustic power, and other sound power parameters, on the excitation
        source surface, issue the SF,,PORT and SPOWER commands.

        The sound pressure level of the octave bands and general frequency band
        (defined via the HARFRQ command) is calculated at the selected nodes in
        the model.
        """
        command = "PRAS,%s,%s,%s" % (str(quantity), str(loadstep), str(substep))
        return self.run(command, **kwargs)

    def tbplot(self, lab="", mat="", tbopt="", temp="", segn="", **kwargs):
        """APDL Command: TBPLOT

        Displays the material data table.

        Parameters
        ----------
        lab
            Data table label.  Valid labels are:  MKIN, KINH, MELAS, MISO,
            BKIN, BISO, BH, GASKET, and JOIN.  Defaults to the active table
            label.  For B-H data, also valid are: NB to display NU-B2, MH to
            display MU vs. H, and SBH, SNB, SMH to display the slopes of the
            corresponding data.

        mat
            Material number to be displayed (defaults to the active material).

        tbopt
            Gasket material or joint element material option to be plotted.

            ALL - Plots all gasket data.

            COMP - Plots gasket compression data only.

            LUNL - Plots gasket linear unloading data with compression curve.

            NUNL - Plots gasket nonlinear unloading data only.

        temp
            Specific temperature at which gasket data or joint element material
            data will be plotted (used only when Lab = GASKET or JOIN). Use
            TEMP = ALL to plot gasket data or joint element material data at
            all temperatures.

        segn
            Segment number of plotted curve (valid only when Lab = GASKET):

            NO - Segment number is not added to plotted curve (default).

            YES - Segment number is added to plotted curve. This option is ignored if the number
                  of data points in a curve exceeds 20.

        Notes
        -----
        Only data for stress-strain, B-H, gasket curves, or joint element
        nonlinear material model curves can be displayed.

        The TBOPT and TEMP values are valid only when Lab = GASKET or JOIN.

        The SEGN value is valid only when Lab = GASKET.

        This command is valid in any processor.
        """
        command = "TBPLOT,%s,%s,%s,%s,%s" % (str(lab), str(mat), str(tbopt), str(temp), str(segn))
        return self.run(command, **kwargs)

    def hptdelete(self, np1="", np2="", ninc="", **kwargs):
        """APDL Command: HPTDELETE

        Deletes selected hardpoints.

        Parameters
        ----------
        np1, np2, ninc
            Delete the pattern of hard points beginning with NP1 to NP2 in
            steps of NINC (defaults to 1).  If NP1 = ALL, NP2 and NINC are
            ignored and the pattern is all selected hard points [KSEL].  If NP1
            = P, graphical picking is enabled and all remaining command fields
            are ignored.

        Notes
        -----
        Deletes all attributes attached to the designated hard points as well
        as the hard points themselves.  If any entity is attached to a
        designated hard point, the command detaches the hard point from that
        entity (the program will alert you that this will occur).
        """
        command = "HPTDELETE,%s,%s,%s" % (str(np1), str(np2), str(ninc))
        return self.run(command, **kwargs)

    def sfcalc(self, labr="", labs="", labt="", type="", **kwargs):
        """APDL Command: SFCALC

        Calculates the safety factor or margin of safety.

        Parameters
        ----------
        labr
            Label assigned to results.  If same as existing label, the existing
            values will be overwritten by these results.

        labs
            Labeled result item corresponding to the element stress.

        labt
            Labeled result item corresponding to the element temperature.

        type
            Type of calculation:

            0 or 1 - Use safety factor (SF) calculation.

            2 - Use margin of safety (MS) calculation.

            3 - Use 1/SF calculation.

        Notes
        -----
        Calculates safety factor (SF) or margin of safety (MS) as described for
        the SFACT command for any labeled result item (see ETABLE command) for
        the selected elements.  Use the PRETAB or PLETAB command to display
        results.  Allowable element stress is determined from the SALLOW-TALLOW
        table [SALLOW, TALLOW].
        """
        command = "SFCALC,%s,%s,%s,%s" % (str(labr), str(labs), str(labt), str(type))
        return self.run(command, **kwargs)

    def writemap(self, fname="", **kwargs):
        """APDL Command: WRITEMAP

        Writes interpolated pressure data to a file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        Notes
        -----
        Writes the interpolated pressure data to the specified file. The data
        is written as SFE commands applied to the SURF154 elements that are on
        the target surface. You may read this data for inclusion in an analysis
        by using /INPUT,Fname.
        """
        command = "WRITEMAP,%s" % (str(fname))
        return self.run(command, **kwargs)

    def ewrite(self, fname="", ext="", unused="", kappnd="", format="", **kwargs):
        """APDL Command: EWRITE

        Writes elements to a file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        kappnd
            Append key:

            0 - Rewind file before the write operation.

            1 - Append data to the end of the existing file.

        format
            Format key:

            SHORT - I6 format (the default).

            LONG - I8 format.

        Notes
        -----
        Writes the selected elements to a file. The write operation is not
        necessary in a standard ANSYS run but is provided as convenience to
        users wanting a coded element file. If issuing EWRITE from ANSYS to be
        used in ANSYS, you must also issue NWRITE to store nodal information
        for later use. Only elements having all of their nodes defined (and
        selected) are written. Data are written in a coded format. The data
        description of each record is: I, J, K, L, M, N, O, P, MAT, TYPE, REAL,
        SECNUM, ESYS, IEL, where MAT, TYPE, REAL, and ESYS are attribute
        numbers, SECNUM is the beam section number, and IEL is the element
        number.

        The format is (14I6) if Format is set to SHORT and (14I8) if the Format
        is set to LONG, with one element description per record for elements
        having eight nodes of less. For elements having more than eight nodes,
        nodes nine and above are written on a second record with the same
        format.
        """
        command = "EWRITE,%s,%s,%s,%s,%s" % (str(fname), str(ext), str(unused),
                                             str(kappnd), str(format))
        return self.run(command, **kwargs)

    def f(self, node="", lab="", value="", value2="", nend="", ninc="",
          **kwargs):
        """APDL Command: F

        Specifies force loads at nodes.

        Parameters
        ----------
        node
            Node at which force is to be specified.  If ALL, NEND and NINC are
            ignored and forces are applied to all selected nodes [NSEL]. If
            NODE = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI).  A component name may
            also be substituted for NODE.

        lab
            Valid force label.  Structural labels:  FX, FY, or FZ (forces); MX,
            MY, or MZ (moments).  Thermal labels:  HEAT, HBOT, HE2, HE3, . . .,
            HTOP (heat flow).  Fluid labels:  FLOW (fluid flow).   Electric
            labels:  AMPS (current flow), CHRG (electric charge).  Magnetic
            labels:  FLUX (magnetic flux);  CSGX, CSGY, or CSGZ (magnetic
            current segments).  Diffusion labels: RATE (diffusion flow rate).

        value
            Force value or table name reference for specifying tabular boundary
            conditions.  To specify a table, enclose the table name in percent
            signs (%), e.g., F, NODE,HEAT,%tabname%).  Use the *DIM command to
            define a table.

        value2
            Second force value (if any).  If the analysis type and the force
            allow a complex input, VALUE (above) is the real component and
            VALUE2 is the imaginary component.

        nend, ninc
            Specifies the same values of force at the nodes ranging from NODE
            to NEND (defaults to NODE), in steps of NINC (defaults to 1).

        Notes
        -----
        The available force loads per node correspond to the degrees of freedom
        listed under "Degrees of Freedom" in the input table for each element
        type in the Element Reference.  If both a force and a constrained
        degree of freedom [D] are specified at the same node, the constraint
        takes precedence.  Forces are defined in the nodal coordinate system.
        The positive directions of structural forces and moments are along and
        about the positive nodal axis directions.  The node and the degree of
        freedom label corresponding to the force must be selected [NSEL,
        DOFSEL].

        For hydrostatic fluid elements (HSFLD241 and HSFLD242), DVOL is used to
        specify fluid mass flow rate (with units of mass/time) at the pressure
        node. This allows fluid to be added or taken out of the fluid elements
        sharing the pressure node. A fluid density must also be specified (via
        the MP command or TB command) to apply a volume change corresponding to
        the prescribed fluid mass flow rate.

        Tabular boundary conditions (VALUE = %tabname%) are available only for
        the following labels: Fluid (FLOW), Electric (AMPS), Structural force
        (FX, FY, FZ, MX, MY, MZ), and Thermal (HEAT, HBOT, HE2, HE3, . . .,
        HTOP). Tabular boundary conditions are valid only in static
        (ANTYPE,STATIC), full transient (ANTYPE,TRANS), full harmonic (ANTYPE,
        HARMIC), modal superposition harmonic and modal superposition transient
        analyses.

        This command is also valid in PREP7.
        """
        command = "F,%s,%s,%s,%s,%s,%s" % (str(node), str(lab), str(value), str(value2), str(nend), str(ninc))
        return self.run(command, **kwargs)

    def bfadele(self, area="", lab="", **kwargs):
        """APDL Command: BFADELE

        Deletes body force loads on an area.

        Parameters
        ----------
        area
            Area at which body load is to be deleted.  If ALL, delete for all
            selected areas [ASEL]. A component name may also be substituted for
            AREA.

        lab
            Valid body load label. If ALL, use all appropriate labels. Load
            labels are listed under "Body Loads" in the input table for each
            element type in the Element Reference. See the BFA command for
            labels.

        Notes
        -----
        Deletes body force loads (and all corresponding finite element loads)
        for a specified area and label.  Body loads may be defined on an area
        with the BFA command.

        Graphical picking is available only via the listed menu paths.

        This command is also valid in PREP7.
        """
        command = "BFADELE,%s,%s" % (str(area), str(lab))
        return self.run(command, **kwargs)

    def voper(self, parr="", par1="", oper="", par2="", con1="", con2="",
              **kwargs):
        """APDL Command: *VOPER

        Operates on two array parameters.

        Parameters
        ----------
        parr
            The name of the resulting array parameter vector.  See *SET  for
            name restrictions.

        par1
            First array parameter vector in the operation.  May also be a
            scalar parameter or a literal constant.

        oper
            Operations:

            Addition: Par1+Par2. - Subtraction: Par1-Par2.

            Multiplication: Par1*Par2. - Division: Par1/Par2  (a divide by zero results in a value of zero).

            Minimum: minimum of Par1 and Par2. - Maximum: maximum of Par1 and Par2.

            Less than comparison: Par1<Par2 gives 1.0 if true, 0.0 if false. - Less than or equal comparison: Par1 Par2 gives 1.0 if true, 0.0 if false.

            Equal comparison: Par1 = Par2 gives 1.0 if true, 0.0 if false. - Not equal comparison: Par1 ≠ Par2 gives 1.0 if true, 0.0 if false.

            Greater than or equal comparison: Par1 Par2 gives 1.0 if true, 0.0 if false. - Greater than comparison: Par1>Par2 gives 1.0 if true, 0.0 if false.

            First derivative: d(Par1)/d(Par2).  The derivative at a point is determined  over points half way between the previous and next points (by linear  interpolation). Par1 must be a function (a unique Par1 value for each Par2 value) and Par2 must be in ascending order. - Second derivative: d2(Par1)/d(Par2)2.  See also DER1.

            Single integral:    Par1 d(Par2), where CON1 is the integration constant.  The integral at a point is determined by using the single integration procedure described in the Mechanical APDL Theory Reference. - Double integral:       Par1 d(Par2), where CON1 is the integration constant of
                              the first integral and CON2 is the integration
                              constant of the second integral.  If Par1
                              contains acceleration data, CON1 is the initial
                              velocity and CON2 is the initial displacement.
                              See also INT1.

            Dot product: Par1  . Par2.  Par1 and Par2 must each have three consecutive columns of data, with the columns containing the i, j, and k vector components, respectively.  Only the starting row index and the column index for the i components are specified for Par1 and Par2, such as A(1,1).  The j and k components of the vector are assumed to begin in the corresponding next columns, such as A(1,2) and A(1,3). - Cross product: Par1 x Par2.  Par1, Par2, and ParR must each have 3 components,
                              respectively.  Only the starting row index and
                              the column index for the i components are
                              specified for Par1, Par2, and ParR, such as
                              A(1,1).  The j and k components of the vector are
                              assumed to begin in the corresponding next
                              columns, such as A(1,2) and A(1,3).

            Gather:  For a vector of position numbers, Par2, copy the value of Par1 at each position number to ParR.  Example:  for Par1 = 10,20,30,40 and Par2 = 2,4,1;  ParR = 20,40,10. - Scatter:  Opposite of GATH operation.  For a vector of position numbers, Par2,
                              copy the value of Par1 to that position number in
                              ParR.  Example: for Par1 = 10,20,30,40,50 and
                              Par2 = 2,1,0,5,3; ParR = 20,10,50,0,40.

            Arctangent: arctangent of Par1/Par2 with the sign of each component considered. - Transform the data in Par1 from the global Cartesian coordinate system to the
                              local coordinate system given in CON1. Par1 must
                              be an N x 3 (i.e., vector) or an N x 6 (i.e.,
                              stress or strain tensor) array. If the local
                              coordinate system is a cylindrical, spherical, or
                              toroidal system, then you must provide the global
                              Cartesian coordinates in Par2 as an N x 3 array.
                              Set CON2 = 1 if the data is strain data.

        par2
            Second array parameter vector in the operation.  May also be a
            scalar parameter or a literal constant.

        con1
            First constant (used only with the INT1 and INT2 operations).

        con2
            Second constant (used only with the INT2 operation).

        Notes
        -----
        Operates on two input array parameter vectors and produces one output
        array parameter vector according to:

        ParR = Par1 o Par2

        where the operations (o) are described below.  ParR may be the same as
        Par1 or Par2.  Absolute values and scale factors may be applied to all
        parameters [*VABS, *VFACT].  Results may be cumulative [*VCUM].
        Starting array element numbers must be defined for each array parameter
        vector if it does not start at the first location, such as
        *VOPER,A,B(5),ADD,C(3) which adds the third element of C to the fifth
        element of B and stores the result in the first element of A.
        Operations continue on successive array elements [*VLEN, *VMASK] with
        the default being all successive elements.  Skipping array elements via
        *VMASK or *VLEN for the DER_ and INT_ functions skips only the writing
        of the results (skipped array element data are used in all
        calculations).

        Parameter functions and operations are available to operate on a scalar
        parameter or a single element of an array parameter, such as SQRT(B) or
        SQRT(A(4)).  See the *SET command for details.  Operations on a
        sequence of array elements can be done by repeating the desired
        function or operation in a do-loop [*DO].  The vector operations within
        the ANSYS program (*VXX commands) are internally programmed do-loops
        that conveniently perform the indicated operation over a sequence of
        array elements.  If the array is multidimensional, only the first
        subscript is incremented in the do-loop, that is, the operation repeats
        in column vector fashion "down" the array.  For example, for A(1,5),
        A(2,5), A(3,5), etc.  The starting location of the row index must be
        defined for each parameter read and for the result written.

        The default number of loops is from the starting result location to the
        last result location and can be altered with the *VLEN command.  A
        logical mask vector may be defined to control at which locations the
        operations are to be skipped [*VMASK].  The default is to skip no
        locations.  Repeat operations automatically terminate at the last array
        element of the result array column if the number of loops is undefined
        or if it exceeds the last result array element.  Zeroes are used in
        operations for values read beyond the last array element of an input
        array column.  Existing values in the rows and columns of the results
        matrix
        """
        command = "*VOPER,%s,%s,%s,%s,%s,%s" % (str(parr), str(par1), str(oper), str(par2), str(con1), str(con2))
        return self.run(command, **kwargs)

    def keep(self, key="", **kwargs):
        """APDL Command: KEEP

        Stores POST26 definitions and data during active session.

        Parameters
        ----------
        key
            State or value

            On or 1  - Allows you to exit and reenter /POST26 without losing your current time history
                       variable information. Keeps a cache of the /POST26
                       variable information including the active file name
                       (FILE),  variable definitions (NSOL, ESOL, GAPF, RFORCE,
                       SOLU, and EDREAD) and stored variable data in memory for
                       the current ANSYS session.

            Off or 0  - /POST26 variable information is deleted when you exit /POST26.

        Notes
        -----
        Your variable information is saved in memory only for the current
        active ANSYS session. It is deleted when you exit ANSYS. This
        information is also deleted when you issue /CLEAR, RESUME, SOLVE, or
        RESET.

        When you reenter /POST26 all time history variable data is available
        for use. When you issue STORE,NEW, variable definitions created by math
        operations such as ADD or PROD will not be restored. However, variables
        defined with NSOL, ESOL, GAPF, RFORCE, SOLU, and EDREAD will be
        restored. Only the last active results file name is kept in memory
        (FILE).

        Commands such as LAYERP26, SHELL, and FORCE that specify the location
        or a component of data to be stored will retain the setting at the time
        of exiting /POST26 .
        """
        command = "KEEP,%s" % (str(key))
        return self.run(command, **kwargs)

    def czmesh(self, ecomps1="", ecomps2="", kcn="", kdir="", value="",
               cztol="", **kwargs):
        """APDL Command: CZMESH

        Create and mesh an interface area composed of cohesive zone elements.

        Parameters
        ----------
        ecomps1
            Component name or number for the group of plane or solid structural
            elements adjacent to the interface being meshed.

        ecomps2
            Component name or number for the opposing (from ecomps1) group of
            plane or solid structural elements adjacent to the interface being
            meshed.

        kcn
            Coordinate system number for the separation surface and normal
            direction. (if ecomps1 and ecomps2 not specified)

        kdir
            Direction (x, y, or z) normal to separation surface in the KCN
            coordinate system (if ecomps1 and ecomps2 not specified).

        value
            Coordinate value along the KDIR axis at which to locate the
            interface (if ecomps1 and ecomps2 not specified).

        cztol
            Optional absolute tolerance about VALUE (if ecomps1 and ecomps2 not
            specified). Allows nodes occurring slightly above or below the
            separation to be grouped properly. The following expression
            represents the default value:

        Notes
        -----
        CZMESH is used on a mesh with shared nodes at the interface.

        If ecomps1 and ecomps2 are specified, the CZMESH command creates/meshes
        interface elements (INTER202, INTER203, INTER204, INTER205) along the
        boundary between the two components or groups of elements.

        The elements in each of the components or groups of elements will share
        nodes with each other and also with the interface elements. This one-
        element thick boundary of interface elements will split the body
        between the two components or groups of elements.

        Subsequent separation (delamination and failure) of the interface zone
        will result in an increasing displacement between the nodes (within the
        interface element) along the cohesive zone elements. Unless otherwise
        specified, the CZMESH command analyzes the configuration and geometry
        of the adjacent structural elements and provides the appropriate
        interface element.

        The CZMESH operation copies any nodal temperatures you have defined on
        the split surface of the original mesh from the original nodes to the
        newly created coincident duplicate nodes. However, displacements,
        forces, and other boundary conditions are not copied.

        The CZMESH command is valid for structural analyses only.
        """
        command = "CZMESH,%s,%s,%s,%s,%s,%s" % (str(ecomps1), str(ecomps2), str(kcn), str(kdir), str(value), str(cztol))
        return self.run(command, **kwargs)

    def edsp(self, option="", min="", max="", inc="", **kwargs):
        """APDL Command: EDSP

        Specifies small penetration checking for contact entities in an
        explicit dynamic analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed (no default).

            ON   - Turn small penetration checking on for specified contact entities.

            OFF - Turn small penetration checking off for specified contact entities.

            LIST   - List current setting for penetration checking.

        min
            Minimum contact entity number for which to turn on/off small
            penetration check (default = 1).

        max
            Maximum contact entity number for which to turn on/off small
            penetration check (defaults to MIN).

        inc
            Contact entity number increment (default = 1).

        Notes
        -----
        This command controls small penetration checking in an explicit dynamic
        analysis. EDSP is applicable only to the following contact types: STS,
        NTS, OSTS, TNTS, and TSTS. The penetration checking specified by EDSP
        is similar to PENCHK on the EDCONTACT command. However, EDSP controls
        penetration checking for individual contact entities whereas PENCHK is
        a global control that applies to all defined contact (of the types
        mentioned above). EDSP can be used in a new analysis, or in a small
        restart (EDSTART,2).

        Use the EDCLIST command to list the contact entity numbers for all
        defined contact.

        This command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDSP,%s,%s,%s,%s" % (str(option), str(min), str(max), str(inc))
        return self.run(command, **kwargs)

    def rmclist(self, **kwargs):
        """APDL Command: RMCLIST

        Lists all lumped capacitance pairs defined.

        Notes
        -----
        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMCLIST," % ()
        return self.run(command, **kwargs)

    def latt(self, mat="", real="", type="", unused="", kb="", ke="", secnum="",
             **kwargs):
        """APDL Command: LATT

        Associates element attributes with the selected, unmeshed lines.

        Parameters
        ----------
        mat, real, type
            Material number, real constant set number, and type number to be
            associated with selected, unmeshed lines.

        --
            Unused field.

        kb, ke
            Beginning and ending orientation keypoints to be associated with
            selected, unmeshed lines.  ANSYS uses the location of these
            keypoints to determine how to orient beam cross sections during
            beam meshing.  Beam elements may be created along a line with a
            constant orientation by specifying only one orientation keypoint
            (KB), or a pre-twisted beam may be created by selecting different
            orientation keypoints at each end of the line (KB and KE).  (For a
            line bounded by two keypoints (KP1 and KP2), the orientation vector
            at the beginning of the line extends from KP1 to KB, and the
            orientation vector at the end of the line extends from KP2 to KE.
            The orientation vectors are used to compute the orientation nodes
            of the elements.)

        secnum
            Section identifier to be associated with selected, unmeshed lines.
            For details, see the description of the SECTYPE and SECNUM
            commands.

        Notes
        -----
        The element attributes specified by the LATT command will be used when
        the lines are meshed.

        Lines subsequently generated from the lines will also have the
        attributes specified by MAT, REAL, TYPE, and SECNUM.  If a line does
        not have these attributes associated with it (by this command) at the
        time it is meshed, the attributes are obtained from the then current
        MAT, REAL, TYPE, and SECNUM command settings.

        In contrast, the values specified by KB and KE apply only to the
        selected lines; that is, lines subsequently generated from these lines
        will not share these attributes.  Similarly, if a line does not have KB
        and KE attributes associated with it via the LATT command at the time
        it is meshed, ANSYS cannot obtain the attributes from elsewhere.  See
        the discussion on beam meshing in Meshing Your Solid Model in the
        Modeling and Meshing Guide for more information.

        Reissue the LATT command (before lines are meshed) to change the
        attributes.  A zero (or blank) argument removes the corresponding
        association. If any of the arguments are defined as -1, then that value
        will be left unchanged in the selected set.

        In some cases, ANSYS can proceed with a line meshing operation even
        when no logical element type has been assigned via LATT,,,TYPE or TYPE.
        See Meshing Your Solid Model in the Modeling and Meshing Guide for more
        information about setting element attributes.
        """
        command = "LATT,%s,%s,%s,%s,%s,%s,%s" % (str(mat), str(real), str(type),
                                                 str(unused), str(kb), str(ke),
                                                 str(secnum))
        return self.run(command, **kwargs)

    def fdele(self, node="", lab="", nend="", ninc="", lkey="", **kwargs):
        """APDL Command: FDELE

        Deletes force loads on nodes.

        Parameters
        ----------
        node
            Node for which force is to be deleted.  If ALL, NEND and NINC are
            ignored and forces are deleted on all selected nodes [NSEL].  If
            NODE = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI).  A component name may
            also be substituted for NODE.

        lab
            Valid force label.  If ALL, use all appropriate labels.  Structural
            labels:  FX, FY, or FZ (forces); MX, MY, or MZ (moments).  Thermal
            labels:  HEAT, HBOT, HE2, HE3, . . ., HTOP (heat flow).  Fluid
            labels:  FLOW (fluid flow).  Electric labels:  AMPS (current flow),
            CHRG (electric charge).  Magnetic labels:  FLUX (magnetic flux);
            CSGX, CSGY, or CSGZ (magnetic current segments).  Diffusion labels:
            RATE (diffusion flow rate).

        nend, ninc
            Delete forces from NODE to NEND (defaults to NODE) in steps of NINC
            (defaults to 1).

        lkey
            Lock key:

            (blank) - The DOF is not locked (default).

            FIXED - Displacement on the specified degrees of freedom (Lab) is locked. The program
                    prescribes the degree of freedom to the “current” relative
                    displacement value in addition to deleting the force. If a
                    displacement constraint (for example, D command) is applied
                    in conjunction with this option, the actual applied
                    displacement will be ramped during the next load step. The
                    displacement is ramped from the current value to the newly
                    defined value. This option is only valid for the following
                    labels: FX, FY, FZ, MX, MY, MZ. This option is intended
                    primarily for use in the ANSYS Workbench interface to apply
                    an increment length adjustment (bolt pretension loading).

        Notes
        -----
        The node and the degree of freedom label corresponding to the force
        must be selected [NSEL, DOFSEL].

        This command is also valid in PREP7.
        """
        command = "FDELE,%s,%s,%s,%s,%s" % (str(node), str(lab), str(nend), str(ninc), str(lkey))
        return self.run(command, **kwargs)

    def edri(self, option="", part="", xc="", yc="", zc="", tm="", ixx="",
             iyy="", izz="", ixy="", iyz="", ixz="", **kwargs):
        """APDL Command: EDRI

        Defines inertia properties for a new rigid body that is created when a
        deformable part is switched to rigid in an explicit dynamic analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed.

            ADD - Define inertia for specified part (default).

            DELE - Delete inertia definition for specified part.

            LIST - List inertia definitions.

        part
            Part number for which inertia is defined (no default).

        xc, yc, zc
            X, Y, and Z-coordinates of the center of mass (no defaults).

        tm
            Translational mass (no default).

        ixx, iyy, izz, ixy, iyz, ixz
            Components (xx, yy, etc.) of inertia tensor. IXX, IYY, and IZZ must
            be input (no defaults). IXY, IYZ, and IXZ default to zero.

        Notes
        -----
        Use this command to define inertia properties for a rigid body that is
        created when a deformable part is switched to rigid (using the EDRD,D2R
        command) in an explicit dynamic analysis. If these properties are not
        defined, LS-DYNA will compute the new rigid body properties from the
        finite element mesh (which requires an accurate mesh representation of
        the body). When rigid bodies are merged to a master rigid body, the
        inertia properties defined for the master rigid body apply to all
        members of the merged set.

        EDRI can only be issued in a new analysis. Therefore, if you are going
        to use inertia properties in a subsequent restart analysis, you must
        issue EDRI in the original analysis for the part that will later be
        switched to rigid in the restart.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDRI,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(part), str(xc), str(yc), str(zc), str(tm), str(ixx), str(iyy), str(izz), str(ixy), str(iyz), str(ixz))
        return self.run(command, **kwargs)

    def mfdtime(self, dtime="", dtmin="", dtmax="", carry="", **kwargs):
        """APDL Command: MFDTIME

        Sets time step sizes for an ANSYS Multi-field solver analysis.

        Parameters
        ----------
        dtime
            Multi-field time step size.  If automatic time stepping is being
            used [see Notes below], DTIME is the starting time step.

        dtmin
            Minimum time step. Defaults to DTIME.

        dtmax
            Maximum time step. Defaults to DTIME.

        carry
            Time step carryover key.

            OFF  - Use DTIME as the starting time step for the next restart run (default).

            ON  - Use the final time step from the previous run as the starting time step for the
                  next restart run.

        Notes
        -----
        This command specifies time step sizes for an ANSYS Multi-field solver
        analysis. If either DTMIN or DTMAX is not equal to DTIME, auto time-
        stepping is turned on for the multi-field loop. ANSYS will
        automatically adjust the time step size for the next multi-field step
        between DTMIN and DTMAX, based on the status of the current
        convergence, the number of target stagger iterations (specified by
        MFITER), and the actual number of iterations needed to reach
        convergence at the current time step.

        If auto time-stepping is turned off, the time step size must be evenly
        divisible into the end time (specified by MFTIME) minus the start time
        (0 for a new analysis or a restart time specified by MFRSTART).

        You can use a smaller time step within each ANSYS field analysis. This
        is called subcycling. Use the DELTIM and AUTOTS commands to subcycle a
        structural, thermal, or electromagnetic analysis.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFDTIME,%s,%s,%s,%s" % (str(dtime), str(dtmin), str(dtmax), str(carry))
        return self.run(command, **kwargs)

    def ocread(self, fname="", ext="", option="", **kwargs):
        """APDL Command: OCREAD

        Reads externally defined ocean data.

        Parameters
        ----------
        fname
            External ocean data file name (excluding the filename extension)
            and directory path containing the file. For more information, see
            the Notes section.

        ext
            Filename extension (limited to eight characters).

        --
            Reserved field.

        option
            Integer value passed to the userOceanRead subroutine (as iOption)
            for user-defined waves. This value does not apply to the diffracted
            wave type.

        Notes
        -----
        The OCREAD command imports ocean data that has been defined externally
        (for example, via the Hydrodynamic Diffraction System (AQWA)).

        The command operates on the ocean load ID specified via the most
        recently issued OCTYPE command. Issue a separate OCREAD command for
        each ocean load that you want to read into the program.

        Fname is limited to 248 characters, including the directory path. If
        Fname does not include a directory path, the program searches for the
        specified file in the current working directory. An unspecified Fname
        defaults to Jobname.

        For the diffracted wave type (KWAVE = 8 on the OCDATA command), you
        must issue an OCREAD command for the ocean wave ID in order to import
        the hydrodynamic data from the hydrodynamic analysis.

        For more information, see Applying Ocean Loading from a Hydrodynamic
        Analysis in the Advanced Analysis Guide.

        To learn more about creating user-defined waves, see Subroutine
        userPanelHydFor (Calculating Panel Loads Caused by Ocean Loading) in
        the Programmer's Reference.

        This command is also valid in PREP7.
        """
        command = "OCREAD,%s,%s,%s" % (str(fname), str(ext), str(option))
        return self.run(command, **kwargs)

    def anim(self, ncycl="", kcycl="", delay="", **kwargs):
        """APDL Command: ANIM

        Displays animated graphics data for linear problems.

        Parameters
        ----------
        ncycl
            Number of cycles associated with the animation (defaults to 5 in
            non-GUI mode only)

        kcycl
            Animation mode:

            0 - Continuous animation cycle (forward-reverse-forward-etc.) (default).

            1 - Discontinuous animation cycle (forward-reset-forward-etc.).

        delay
            Time delay (seconds) between animation frames (defaults to 0.1
            seconds).

        Notes
        -----
        Use the ANIM command to create animations for linear problems only. The
        command uses the currently displayed picture based on one particular
        data set from the results file, and linearly interpolates that data
        into different sets, displaying pictures of each interpolated data set
        in sequence to create animation.  For information about creating
        animations for nonlinear problems, see the ANDATA command.

        This command is device-dependent.

        Do not resize the graphic while animation is in progress; doing so can
        result in distorted plots.

        For more information, see the /SEG command for details about segment
        storage, and the ANCNTR macro for a convenient method of storing
        graphics frames in terminal memory segments.

        This command is valid in any processor.
        """
        command = "ANIM,%s,%s,%s" % (str(ncycl), str(kcycl), str(delay))
        return self.run(command, **kwargs)

    def lcsum(self, lab="", **kwargs):
        """APDL Command: LCSUM

        Specifies whether to process non-summable items in load case
        operations.

        Parameters
        ----------
        lab
            Combination option

            (blank) - Only combine summable items [default].

            ALL - Combine all items including non summable items.

        Notes
        -----
        Allows non-summable items (e.g. plastic strains) to be included in load
        combinations.  Issue LCSUM,ALL before the first load case operation
        (LCXX command).  May also be used to include nonsummable items in the
        appending of a results file (RAPPND command).
        """
        command = "LCSUM,%s" % (str(lab))
        return self.run(command, **kwargs)

    def bfalist(self, area="", lab="", **kwargs):
        """APDL Command: BFALIST

        Lists the body force loads on an area.

        Parameters
        ----------
        area
            Area at which body load is to be listed.  If ALL (or blank), list
            for all selected areas [ASEL].  If AREA = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for AREA.

        lab
            Valid body load label. If ALL, use all appropriate labels. Load
            labels are listed under "Body Loads" in the input table for each
            element type in the Element Reference. See the BFA command for
            labels.

        Notes
        -----
        Lists the body force loads for the specified area and label.  Body
        loads may be defined on an area with the BFA command.

        This command is valid in any processor.
        """
        command = "BFALIST,%s,%s" % (str(area), str(lab))
        return self.run(command, **kwargs)

    def etable(self, lab="", item="", comp="", option="", **kwargs):
        """APDL Command: ETABLE

        Fills a table of element values for further processing.

        Parameters
        ----------
        lab
            Any unique user defined label for use in subsequent commands and
            output headings (maximum of eight characters and not a General
            predefined Item label). Defaults to an eight character label formed
            by concatenating the first four characters of the Item and Comp
            labels. If the same as a previous user label, this result item will
            be included under the same label. Up to 200 different labels may be
            defined. The following labels are predefined and are not available
            for user-defined labels:  REFL, STAT, and ERAS.  Lab = REFL refills
            all tables previously defined with the ETABLE commands (not the
            CALC module commands) according to the latest ETABLE specifications
            and is convenient for refilling tables after the load step (SET)
            has been changed. Remaining fields will be ignored if Lab is REFL.
            Lab = STAT displays stored table values.  Lab = ERAS erases the
            entire table.

        item
            Label identifying the item. General item labels are shown in the
            table below. Some items also require a component label. Character
            parameters may be used. Item = ERAS erases a Lab column.

        comp
            Component of the item (if required). General component labels are
            shown in the table below. Character parameters may be used.

        option
            Option for storing element table data:

            MIN - Store minimum element nodal value of the specified item component.

            MAX - Store maximum element nodal value of the specified item component.

            AVG - Store averaged element centroid value of the specified item component
                  (default).

        Notes
        -----
        The ETABLE command defines a table of values per element (the element
        table) for use in further processing. The element table is organized
        similar to spreadsheet, with rows representing all selected elements
        and columns consisting of result items which have been moved into the
        table (Item,Comp) via ETABLE. Each column of data is identified by a
        user-defined label (Lab) for listings and displays.

        After entering the data into the element table, you are not limited to
        merely listing or displaying your data (PLESOL, PRESOL, etc.). You may
        also perform many types of operations on your data, such as adding or
        multiplying columns (SADD, SMULT), defining allowable stresses for
        safety calculations (SALLOW), or multiplying one column by another
        (SMULT).  See Getting Started in theBasic Analysis Guide for more
        information.

        Various results data can be stored in the element table. For example,
        many items for an element are inherently single-valued (one value per
        element). The single-valued items include: SERR, SDSG, TERR, TDSG,
        SENE, SEDN, TENE, KENE, AENE, JHEAT, JS, VOLU, and CENT. All other
        items are multivalued (varying over the element, such that there is a
        different value at each node). Because only one value is stored in the
        element table per element, an average value (based on the number of
        contributing nodes) is calculated for multivalued items. Exceptions to
        this averaging procedure are FMAG and all element force items, which
        represent the sum only of the contributing nodal values.

        Two methods of data access can be used with the ETABLE command. The
        method you select depends upon the type of data that you want to store.
        Some results can be accessed via a generic label (Component Name
        method), while others require a label and number (Sequence Number
        method).

        The Component Name method is used to access the General element data
        (that is, element data which is generally available to most element
        types or groups of element types). All of the single-valued items and
        some of the more general multivalued items are accessible with the
        Component Name method.  Various element results depend on the
        calculation method and the selected results location (AVPRIN, RSYS,
        LAYER, SHELL, and ESEL).

        Although nodal data is readily available for listings and displays
        (PRNSOL, PLNSOL) without using the element table, you may also use the
        Component Name method to enter these results into the element table for
        further "worksheet" manipulation. (See Getting Started in theBasic
        Analysis Guide for more information.) A listing of the General Item and
        Comp labels for the Component Name method is shown below.

        The Sequence Number method allows you to view results for data that is
        not averaged (such as pressures at nodes, temperatures at integration
        points, etc.), or data that is not easily described in a generic
        fashion (such as all derived data for structural line elements and
        contact elements, all derived data for thermal line elements, layer
        data for layered elements, etc.). A table illustrating the Items (such
        as LS, LEPEL, LEPTH, SMISC, NMISC, SURF, etc.) and corresponding
        sequence numbers for each element is shown in the Output Data section
        of each element description found in the Element Reference.

        Some element table data are reported in the results coordinate system.
        These include all component results (for example, UX, UY, etc.; SX, SY,
        etc.). The solution writes component results in the database and on the
        results file in the solution coordinate system. When you issue the
        ETABLE command, these results are then transformed into the results
        coordinate system (RSYS) before being stored in the element table. The
        default results coordinate system is global Cartesian (RSYS,0).  All
        other data are retrieved from the database and stored in the element
        table with no coordinate transformation.

        Use the PRETAB, PLETAB, or ETABLE,STAT commands to display the stored
        table values. Issue ETABLE,ERAS to erase the entire table. Issue
        ETABLE,Lab,ERAS to erase a Lab column.

        When the GUI is on, if a Delete operation in a Define Element Table
        Data dialog box writes this command to a log file (Jobname.LOG or
        Jobname.LGW), you will observe that Lab is blank, Item = ERASE, and
        Comp is an integer number. In this case, the GUI has assigned a value
        of Comp that corresponds to the location of a chosen variable name in
        the dialog box's list. It is not intended that you type in such a
        location value for Comp in a session.  However, a file that contains a
        GUI-generated ETABLE command of this form can be used for batch input
        or for use with the /INPUT command.

        The element table data option (Option) is not available for all output
        items. See the table below for supported items.

        Table: 135:: : ETABLE - General Item and Component Labels
        """
        command = "ETABLE,%s,%s,%s,%s" % (str(lab), str(item), str(comp), str(option))
        return self.run(command, **kwargs)

    def mult(self, m1="", t1="", m2="", t2="", m3="", **kwargs):
        """APDL Command: *MULT

        Performs the matrix multiplication M3 = M1(T1)*M2(T2).

        Parameters
        ----------
        m1
            Name of matrix M1. Must have been previously specified by a *DMAT
            or *SMAT command.

        t1
            Transpose key. Set T1 = TRANS to use the transpose of M1. If blank,
            transpose will not be used.

        m2
            Name of matrix M2. Must have been previously specified by a *DMAT
            command.

        t2
            Transpose key. Set T2 = TRANS to use the transpose of M2. If blank,
            transpose will not be used.

        m3
            Name of resulting matrix, M3. Must be specified.

        Notes
        -----
        The matrices must be dimensionally consistent such that the number of
        columns of M1 (or the transposed matrix, if requested) is equal to the
        number of rows of M2 (or the transposed matrix, if requested).

        You cannot multiply two sparse matrices with this command (that is, M1
        and M2 cannot both be sparse). The resulting matrix, M3, will always be
        a dense matrix, no matter what combination of input matrices is used
        (dense*sparse, sparse*dense, or dense*dense).
        """
        command = "*MULT,%s,%s,%s,%s,%s" % (str(m1), str(t1), str(m2), str(t2), str(m3))
        return self.run(command, **kwargs)

    def norl(self, line="", area="", ndir="", **kwargs):
        """APDL Command: NORL

        Rotates nodal coordinate systems perpendicular to line normal

        Parameters
        ----------
        line
            Line number containing the nodes to be rotated. If ALL, applies to
            all selected lines (see the LSEL command). If LINE = P, graphical
            picking is enabled.

        area
            The area number containing the selected lines. The normal of the
            line(s) selected is supposed to lie on this area. Defaults to the
            lowest numbered selected area containing the line number.

        ndir
            Direction of the normal. If NDIR = -1, the nodal coordinate system
            is rotated in the opposite direction of the line normal. The
            default is the same direction as the surface normal.

        Notes
        -----
        The NORL command rotates the X-axis of the nodal coordinate
        perpendicular to the line normal. The rotated nodal coordinate systems
        may be displayed through the /PSYMB command. In case multiple lines are
        selected, there could be conflicts at the boundaries. If a node belongs
        to two lines that have a different normal, its nodal coordinate system
        will be rotated to the line normal with the lowest number. Keep the
        following in mind when using the NORL command:

        If the nodal coordinate system is parallel to the global Cartesian
        system, it is not displayed through the /PSYMB command.

        Previously specified rotation on the selected nodes are overridden.
        """
        command = "NORL,%s,%s,%s" % (str(line), str(area), str(ndir))
        return self.run(command, **kwargs)

    def trplis(self, ntrp1="", ntrp2="", trpinc="", opt="", **kwargs):
        """APDL Command: TRPLIS

        Lists the particle flow or charged particle trace points.

        Parameters
        ----------
        ntrp1, ntrp2, trpinc
            List points from NTRP1 to NTRP2 (defaults to NTRP1) in steps of
            TRPINC (defaults to 1).  If NTRP1 = ALL, NTRP2 and TRPINC are
            ignored and all trace points are listed.  If NTRP1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).

        opt
            Opt = LOC lists the trace point number location (X, Y, Z). Default.

        Notes
        -----
        Lists the particle flow or charged particle trace points in the active
        display coordinate system [DSYS].  Trace points are defined with the
        TRPOIN command.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "TRPLIS,%s,%s,%s,%s" % (str(ntrp1), str(ntrp2), str(trpinc), str(opt))
        return self.run(command, **kwargs)

    def mfem(self, fnumb="", itype1="", itype2="", itype3="", itype4="",
             itype5="", itype6="", itype7="", itype8="", itype9="", itype10="",
             **kwargs):
        """APDL Command: MFEM

        Add more element types to a previously defined field number.

        Parameters
        ----------
        fnumb
            Existing field number defined by the MFELEM command.

        itype1, itype2, itype3, . . . , itype10
            Element types defined by the ET command.

        Notes
        -----
        You can add up to ten element types per MFEM command. This command
        should not be used after an initial solution.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFEM,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(fnumb), str(itype1), str(itype2), str(itype3), str(itype4), str(itype5), str(itype6), str(itype7), str(itype8), str(itype9), str(itype10))
        return self.run(command, **kwargs)

    def ksel(self, type="", item="", comp="", vmin="", vmax="", vinc="",
             kabs="", **kwargs):
        """APDL Command: KSEL

        Selects a subset of keypoints or hard points.

        Parameters
        ----------
        type
            Label identifying the type of select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

            ALL - Restore the full set.

            NONE - Unselect the full set.

            INVE - Invert the current set (selected becomes unselected and vice versa).

            STAT - Display the current select status.

        Notes
        -----
        Selects a subset of keypoints or hard points.  For example, to select a
        new set of keypoints based on keypoint numbers 1 through 7, use
        KSEL,S,KP,,1,7.  The selected subset is used when the ALL label is
        entered (or implied) on other commands, such as KLIST,ALL.  Only data
        identified by keypoint number are selected.  Data are flagged as
        selected and unselected; no data are actually deleted from the
        database.

        This command is valid in any processor.

        For selections based on non-integer numbers (coordinates, results,
        etc.), items that are within the range VMIN -Toler and VMAX + Toler are
        selected. The default tolerance Toler is based on the relative values
        of VMIN and VMAX as follows:

        If VMIN = VMAX, Toler = 0.005 x VMIN.

        If VMIN = VMAX = 0.0, Toler = 1.0E-6.

         If VMAX ≠ VMIN, Toler = 1.0E-8 x (VMAX - VMIN).

        Use the SELTOL command to override this default and specify Toler
        explicitly.

        Table: 203:: : KSEL - Valid Item and Component Labels
        """
        command = "KSEL,%s,%s,%s,%s,%s,%s,%s" % (str(type), str(item), str(comp), str(vmin), str(vmax), str(vinc), str(kabs))
        return self.run(command, **kwargs)

    def modseloption(self, dir1="", dir2="", dir3="", dir4="", dir5="", dir6
                     ="", **kwargs):
        """APDL Command: MODSELOPTION

        Specifies the criteria for selecting the modes to be expanded.

        Parameters
        ----------
        dir1, dir2, …, dir6
            Selection of the direction to be expanded.

        Notes
        -----
        This command is only applicable when a mode selection method is defined
        (ModeSelMethod on the MXPAND command). See Using Mode Selection in the
        Mechanical APDL Structural Analysis Guide for more details.

        If a numerical value is specified for a direction, the significance
        threshold (SIGNIF on the MXPAND command) is ignored for the selection
        of the modes in this direction.

        If a mode is determined to be expanded in any of the 6 directions, it
        will be expanded in the .MODE file. : Otherwise, the mode will not be
        expanded.

        The default behavior is to consider all directions for expansion.
        """
        command = "MODSELOPTION,%s,%s,%s,%s,%s,%s" % (str(dir1), str(dir2), str(dir3), str(dir4), str(dir5), str(dir6 ))
        return self.run(command, **kwargs)

    def block(self, x1="", x2="", y1="", y2="", z1="", z2="", **kwargs):
        """APDL Command: BLOCK

        Creates a block volume based on working plane coordinates.

        Parameters
        ----------
        x1, x2
            Working plane X coordinates of the block.

        y1, y2
            Working plane Y coordinates of the block.

        z1, z2
            Working plane Z coordinates of the block.

        Notes
        -----
        Defines a hexahedral volume based on the working plane.  The block must
        have a spatial volume greater than zero (i.e., this volume primitive
        command cannot be used to create a degenerate volume as a means of
        creating an area.)  The volume will be defined with eight keypoints,
        twelve lines, and six areas, with the top and bottom faces parallel to
        the working plane.  See the BLC4 and BLC5 commands for alternate ways
        to create blocks.
        """
        command = "BLOCK,%s,%s,%s,%s,%s,%s" % (str(x1), str(x2), str(y1), str(y2), str(z1), str(z2))
        return self.run(command, **kwargs)

    def device(self, label="", key="", **kwargs):
        """APDL Command: /DEVICE

        Controls graphics device options.

        Parameters
        ----------
        label
            Device function label:

            BBOX - Bounding box mode. For PowerGraphics plots involving elements with /SHOW,x11
                   and /SHOW,win32, ANSYS generally displays dynamic rotations
                   faster. If KEY = 1 (ON), then a bounding box (not the
                   elements) encompassing the model is displayed and rotated,
                   rather than the element outlines (ON is default in
                   preprocessing). When KEY = 0 (OFF), then dynamic rotations
                   may be slower (ANSYS redraws the element outlines) for plots
                   involving elements with /SHOW,x11 and /SHOW,win32.  OFF is
                   default in postprocessing. This command is ignored if
                   /EDGE,WN,1 is set for any WN. This is ignored in POST1 and
                   SOLUTION plots.

            For any PowerGraphics plots involving elements, regardless of /SHOW settings, plots will generally be displayed faster. - VECTOR

            Vector mode. In vector mode, areas, volumes, elements, and postprocessing display geometries are shown as outlines (wireframes).  When vector mode is off (default), these entities are shown filled with color. - DITHER

            When dithering is turned on (default), color intensity transitions are smoothed.  This selection a - applies only to smooth-shaded images, i.e., Z-buffered [/TYPE], or raster plots
                              with Gouraud or Phong shading [/SHADE].

            ANIM - Select the animation type used on 2-D devices on the PC platform. A KEY value
                   of BMP (or 0) sets animation mode to ANSYS Animation
                   Controller (default). A KEY value of AVI (or 2) sets
                   animation mode to AVI movie player file.

            FONT - Font selection for the ANSYS graphics window. When Label = FONT, the command
                   format is: /DEVICE,FONT,KEY,Val1,Val2,Val3,Val4,Val5,Val6
                   where KEY determines the type of font being controlled, and
                   values 1 through 6 control various font parameters. Note
                   that these values are device specific; using the same
                   command input file [/INPUT] on different machines may yield
                   different results.. The following KEY values determine the
                   font information that will be supplied to the appropriate
                   driver (e.g., Postscript, X11, Win32, JPEG, ...):

            KEY = 1 - The command controls the LEGEND (documentation column) font.

            KEY = 2 - The command controls the ENTITY (node and keypoint number) font.

            KEY = 3 - The command controls the ANNOTATION/GRAPH font.

            Linux: Values 1 through 4 are used to find a match in the X11 database of font strings. Values 1, 2, and 3 are character strings; value 4 is a nonzero integer:    - Val1

            Family name (e.g., Courier). If Val1 = MENU, all other values are ignored and a font selection menu appears (GUI must be active). - Val2

            Weight (e.g., medium) - Val3

            Slant (e.g., r) - Val4

            Pixel size (e.g., 14). Note that this value does no affect the annotation fonts (KEY = 3). Use the /TSPEC command for annotation font size.  - Val5

            unused - Val6

            unused - PC: The values are encoded in a PC logical font
                     structure.  Value 1 is a character string, and
                     the remaining values are integers:

            Val1 - Family name (e.g., Courier*New) Substitute an asterisk (*) for any blank
                   character that appears in a family name. If Val1 = MENU, all
                   other values are ignored and a font selection menu appears
                   (GUI must be active). When this value is blank ANSYS uses
                   the first available resource it finds.

            Val2 - Weight (0 - 1000)

            Val3 - Orientation (in tenths of a degree)

            Val4 - Height (in logical units)

            Val5 - Width (in logical units)

            Val6 - Italics (0 = OFF, 1 = ON)

            TEXT - Text size specification for the ANSYS Graphics window.  Using this label with
                   the /DEVICE command requires the following form:
                   /DEVICE,TEXT,KEY,PERCENT.  KEY = 1 for LEGEND fonts; KEY = 2
                   for ENTITY fonts.  PERCENT specifies the new text size as a
                   percent of the default text size.  If PERCENT = 100, the new
                   text size is precisely the default size.  If PERCENT = 200,
                   the new text size is twice the default text size.

        key
            Control key:

            OFF or 0 - Turns specified function off.

            ON or 1 - Turns specified function on or designates the LEGEND font.

            2 - Designates the ENTITY font.

            3 - Designates the ANNOTATION/GRAPH font.

        Notes
        -----
        This command is valid in any processor.

        The /DEVICE,BBOX command is ignored in POST1 and SOLUTION plots. Also,
        the elements are displayed and rotated if you use /DEVICE,BBOX,ON and
        /EDGE,WN,1,ANGLE (effectively ignoring the BBOX option).
        """
        command = "/DEVICE,%s,%s" % (str(label), str(key))
        return self.run(command, **kwargs)

    def intsrf(self, lab="", **kwargs):
        """APDL Command: INTSRF

        Integrates nodal results on an exterior surface.

        Parameters
        ----------
        lab
            Label indicating degree of freedom to be integrated:

            PRES - Pressure.

            TAUW - Wall shear stress.

            FLOW - Both pressure and wall shear stress.

        Notes
        -----
        Integrates nodal results on a surface.  Use node selection (such as the
        EXT option of the NSEL command) to indicate the surface(s) of element
        faces to be used in the integration.  A surface can be "created" by
        unselecting elements (such as unselecting non-fluid elements that are
        adjacent to fluid elements for the postprocessing of fluid flow
        result).  Element faces attached to the selected nodes will be
        automatically determined.  All nodes on a face must be selected for the
        face to be used.  The integration results will cancel for nodes on
        common faces of adjacent selected elements.

        Integration results are in the active coordinate system (see the RSYS
        command). The type of results coordinate system must match the type
        used in the analysis. However, you may translate and rotate forces and
        moments as needed. Use the *GET command (Utility Menu> Parameters> Get
        Scalar Data) to retrieve the results.
        """
        command = "INTSRF,%s" % (str(lab))
        return self.run(command, **kwargs)

    def mshkey(self, key="", **kwargs):
        """APDL Command: MSHKEY

        Specifies whether free meshing or mapped meshing should be used to mesh
        a model.

        Parameters
        ----------
        key
            Key indicating the type of meshing to be used:

            0 - Use free meshing (the default).

            1 - Use mapped meshing.

            2 - Use mapped meshing if possible; otherwise, use free meshing.  If you specify
                MSHKEY,2, SmartSizing will be inactive even while free meshing
                non-map-meshable areas.

        Notes
        -----
        The MSHKEY, MSHAPE, and MSHMID commands replace the functionality that
        was provided by the ESHAPE command in ANSYS 5.3 and earlier releases.

        This command is also valid for rezoning.
        """
        command = "MSHKEY,%s" % (str(key))
        return self.run(command, **kwargs)

    def edint(self, shellip="", beamip="", **kwargs):
        """APDL Command: EDINT

        Specifies number of integration points for explicit shell and beam
        output.

        Parameters
        ----------
        shellip
            Number of shell integration points used for output (defaults to 3).
            For element SHELL163, each integration point is associated with a
            layer. SHELLIP must be  3. If SHELLIP = 3, results are written for
            the shell top, middle, and bottom. If SHELLIP >3, then the results
            for the first SHELLIP layers are written.

        beamip
            Number of beam integration points used for stress output for
            BEAM161 (defaults to 4).

        Notes
        -----
        The number of integration points is defined by the element real
        constant NIP for both the beam elements (in the cross section) and the
        shell elements (through the thickness).

        For shell elements that have only 1 or 2 integration points (NIP = 1 or
        2), use the default of SHELLIP = 3. If NIP = 1, the same results are
        reported at the top, middle, and bottom layers.  If the NIP = 2, the
        results at the bottom correspond to integration point 1, the results at
        the top correspond to integration point 2, and the results at the
        middle are an average of the top and bottom results.

        For shell elements with 2 x 2 integration points in the plane, the data
        from the four points are averaged, and there is a single output value
        for each layer.

        If you set BEAMIP = 0, no stress output is written for BEAM161
        elements. In this case, the beams will not appear in any POST1 plots
        because the program assumes they are failed elements.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDINT,%s,%s" % (str(shellip), str(beamip))
        return self.run(command, **kwargs)

    def rsfit(self, rslab="", slab="", name="", rmod="", ytrans="", yval="",
              xfilt="", conf="", **kwargs):
        """APDL Command: RSFIT

        Fit a response surface for an output parameter in a solution set.

        Parameters
        ----------
        rslab
            Response surface set label. Identifies the response surface results
            for later postprocessing. This label can be used as Rlab for
            postprocessing response surface results, and for evaluating the fit
            results with RSPLOT and RSPRNT. You must have separate
            identification labels for the solution sets and for the response
            surface sets, because you can perform a response surface fit based
            on Monte Carlo results. For this case, the original Monte Carlo
            results are identified by the solution set label provided in the
            PDEXE command and the results generated with the fitted response
            surfaces are identified by the response surface set label (RSlab)
            provided here. RSlab must not contain blanks. Maximum length of
            this field is 16 characters; if this field contains more than 16
            characters, it will be truncated to 16 characters.

        slab
            Solution set label that identifies the probabilistic analysis
            containing the results to be fitted. This solution set label is
            defined with the PDEXE command.

        name
            Parameter name. The parameter must have been previously defined as
            a random output parameter with the PDVAR command. The result values
            of this parameter (stored in the solution set identified by Slab)
            are fitted as a function of all random input variables.

        rmod
            Regression model to use for the evaluation of the response surface.

            LIN - Regression model with linear terms only.

            QUAD - Regression model with linear and pure quadratic terms (no cross-terms).

            QUAX - Regression model with linear and all quadratic terms (including cross-terms).
                   (Default.)

        ytrans
            Option for the transformation type applied to the output parameter
            identified with Name.

            NONE - The values of the output parameter Name are not transformed (default).

            EXP - The values of the output parameter Name are transformed according to Y* =
                  exp(Y). The transformed values Y* are used for the fitting
                  process.

            LOGA - The values of the output parameter Name are transformed according to Y* =
                   loga(Y), where the basis a is specified by Yval. The
                   transformed values Y* are used for the fitting process.

        yval
            Value needed for Ytrans = LOGA, Ytrans = POW, and Ytrans = BOX.
            Ignored for all other options of Ytrans. For Ytrans = LOGA and
            Ytrans = POW, the default value is Yval = 1.0. For Ytrans = BOX,
            the default value is Yval = 0.01.

        xfilt
            Option that specifies if irrelevant terms of the regression model
            should be filtered out.

            NONE - Regression term filtering is not done. A full regression model as specified
                   with the Rmod option is evaluated.

            FSR - Use the "forward-stepwise-regression" to automatically filter out individual
                  and irrelevant terms of the regression model. If irrelevant
                  terms are sorted out this leads to a smaller number of
                  coefficients to be determined in the regression analysis,
                  which then leads to increased accuracy of the coefficients of
                  the remaining terms in the regression model (default).

        conf
            Confidence level that is used to filter the terms of the regression
            model if the Xfilt = FSR option has been selected. The value of
            CONF must be between 0.0 and 1.0 (default is 0.95). The higher this
            value, the more terms will be filtered out. Consequently, higher
            CONF values lead to a fewer terms in the regression model.
            Likewise, lower CONF values lead to more terms being included in
            the regression model.

        Notes
        -----
        Evaluates a response surface for a random output parameter Name. The
        result values for the parameter Name as stored in the solution set Slab
        are fitted as a function of all random input parameters. There can be
        only one response surface set for each solution set. A response surface
        set can include the fitted response surfaces of one or more output
        parameters.

        Note:: : If the RSFIT command is used for an existing response surface
        set for which Monte Carlo simulations have already been generated using
        the RSSIMS command then these Monte Carlo samples are deleted by the
        RSFIT command. In this case they need to be generated again using the
        RSSIMS command. It is necessary to delete the Monte Carlo simulations
        in order to make sure that the samples, their statistics and
        correlations are consistent with the response surfaces.
        """
        command = "RSFIT,%s,%s,%s,%s,%s,%s,%s,%s" % (str(rslab), str(slab), str(name), str(rmod), str(ytrans), str(yval), str(xfilt), str(conf))
        return self.run(command, **kwargs)

    def pdlhs(self, nsim="", nrep="", isopt="", unused="", astop="", accmean="",
              accstdv="", check="", seed="", **kwargs):
        """APDL Command: PDLHS

        Specifies options for Monte Carlo Simulations using Latin-Hypercube
        sampling.

        Parameters
        ----------
        nsim
            Number of simulation loops per repetition cycle.

        nrep
            Number of repetition cycles of the analysis.

        isopt
            Latin-Hypercube sampling divides the domain of each random input
            variable into intervals of equal probability. The interval sampling
            option ISopt determines where the samples are located within each
            interval.

            RAND - Picks a random location within the interval (default).

            MEAN - Picks the mean value location within the interval.

            MEDI - Picks the median value location within the interval.

        --
            Unused field.

        astop
            Autostop option label.

            AUTO - Enable Autostop. When Autostop is used, the PDS feature continues the
                   simulation loops until the convergence criteria for the mean
                   value and the standard deviation have been met or until the
                   number of simulations NSIM are complete, whichever comes
                   first. The convergence criteria (mean value and standard
                   deviations of all random output parameters) are specified by
                   the ACCMEAN and ACCSTDEV parameters. The criteria are met if
                   the mean value and the standard deviations converge within
                   the accuracy specified in the ACCMEAN and ACCSTDEV options.
                   The convergence check is done every i-th loop, where i is
                   specified in the CHECK parameter.

            ALL - Disable Autostop option. All Monte Carlo Simulations as specified by NSIM and
                  NREP are performed (default).

        accmean
            Accuracy of the mean values of all random output parameters that
            must be met to activate Autostop. Default is 0.01 (1%). ACCMEAN is
            ignored for Astop = ALL. The convergence for the mean values is met
            if for all random output parameters y the following equation is
            true:

        accstdev
            Accuracy of the standard deviations of all random output parameters
            that must be met to activate Autostop. The default is 0.02 (2%).
            ACCSTDEV is ignored for Astop = ALL. The convergence for the
            standard deviations is met if for all random output parameters y
            the following equation is true:

        check
            Sets how often conditions for convergence are checked for Autostop.
            The PDS feature checks if the convergence criteria are met every
            i-th loop, where i is given by the CHECK parameter. The default
            value is 10. It not recommended to use CHECK = 1, because it could
            cause Autostop to terminate the simulations prematurely. The mean
            values and standard deviation might not show large differences
            between all simulation loops but might still have a visible
            "global" trend if viewed over several simulations. This behavior
            indicates that convergence has not really been achieved. If you set
            CHECK = 1, then Autostop is not able to detect such a global trend.
            CHECK is ignored for Astop = ALL.

        seed
            Seed value label. Random number generators require a seed value
            that is used to calculate the next random number. After each random
            number generation finishes, the seed value is updated and is used
            again to calculate the next random number. ANSYS initializes the
            seed value with the system time when the ANSYS session started.

            CONT - Continues updating using the derived seed value (default).

            TIME - Initializes the seed value with the system time. You can use this if you want
                   the seed value set to a specific value for one analysis and
                   then you want to continue with a "random" seed in the next
                   analysis. It is not recommended to "randomize" the seed
                   value with the Seed = TIME option for multiple analyses. If
                   the Monte Carlo simulations requested with this command will
                   be appended to previously existing simulations, then the
                   Seed option is ignored and Seed = CONT is used.

            INIT - Initializes the seed value using 123457 (a typical recommendation). This option
                   leads to identical random numbers for all random input
                   variables when the exact analysis will be repeated, making
                   it useful for benchmarking and validation purposes (where
                   identical random numbers are desired). If the Monte Carlo
                   simulations requested with this command will be appended to
                   previously existing simulations, then the Seed option is
                   ignored and Seed = CONT is used.

            Value - Uses the specified (positive) value for the initialization of the seed value.
                    This option has the same effect as Seed = INIT, except you
                    can chose an arbitrary (positive) number for the
                    initialization. If the Monte Carlo simulations requested
                    with this command will be appended to previously existing
                    simulations, then the Seed option is ignored and Seed =
                    CONT is used.

        Notes
        -----
        Defines the number of simulations per repetition cycle, number of
        repetition cycles, specification of the Autostop option, checking
        frequency for the Autostop option, and the seed value for random number
        generation.

        For Latin-Hypercube sampling, it is advantageous to divide the total
        number of requested simulations into a few repetitions. This adds more
        randomness to the sampling process. If NTOT is the total number of
        simulations, then as a rough rule of thumb NTOT should be NREP =
        repetitions. The number obtained with this rule of thumb must be
        adjusted such that NTOT = NREP*NSIM. For example if NTOT = 1000 then
        NREP =  = 10, so the 1000 simulations can be done in 100 simulations
        with 10 repetitions. If for example NTOT = 100 then NREP =  = 3.16,
        which means that the 100 simulations could be broken up into either
        2*50 or 4*25 simulations.

        If Autostop is enabled then the maximum number of simulations to be
        performed is given by NSIM*NREP. The Autostop option will terminate the
        simulations before the NSIM*NREP simulations are done if the
        convergence criteria are met.
        """
        command = "PDLHS,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nsim),
                                                        str(nrep),
                                                        str(isopt),
                                                        str(unused),
                                                        str(astop),
                                                        str(accmean),
                                                        str(accstdv),
                                                        str(check),
                                                        str(seed))
        return self.run(command, **kwargs)

    def plvar(self, nvar1="", nvar2="", nvar3="", nvar4="", nvar5="", nvar6="",
              nvar7="", nvar8="", nvar9="", nvar10="", **kwargs):
        """APDL Command: PLVAR

        Displays up to ten variables in the form of a graph.

        Parameters
        ----------
        nvar1, nvar2, nvar3, . . . , nvar10
            Variables to be displayed, defined either by the reference number
            or a unique thirty-two character name. If duplicate names are used
            the command will plot the data for the lowest-numbered variable
            with that name.

        Notes
        -----
        Variables are displayed vs. variable N on the XVAR command. The string
        value will be a predefined, unique name. For complex variables, the
        amplitude is displayed by default [PLCPLX].  Each PLVAR command
        produces a new frame.  See the /GRTYP command for displaying multiple
        variables in a single frame with separate Y-axes.
        """
        command = "PLVAR,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nvar1), str(nvar2), str(nvar3), str(nvar4), str(nvar5), str(nvar6), str(nvar7), str(nvar8), str(nvar9), str(nvar10))
        return self.run(command, **kwargs)

    def dsurf(self, kcn="", xsurf="", ysurf="", zsurf="", **kwargs):
        """APDL Command: DSURF

        Defines the surface upon which digitized nodes lie.

        Parameters
        ----------
        kcn
            Surface is located in coordinate system KCN.  KCN may be 0,1,2 or
            any previously defined local coordinate system number.

        xsurf, ysurf, zsurf
            Input one value to define the surface constant.  Input 999 in the
            other two fields.  Interpret fields as R, θ, Z for cylindrical or
            R, θ, Φ for spherical or toroidal coordinate systems.  XSURF and
            YSURF default to 999 if KCN = 0.

        Notes
        -----
        Defines the surface upon which the nodes to be digitized (with the DIG
        command) actually lie.  Surfaces are defined by a coordinate system
        number and a coordinate constant [MOVE].  Two coordinates are
        determined from the drawing and converted to surface coordinates.  The
        third coordinate is defined from the input surface constant.  If nodes
        lie on warped or undefined surfaces, use the DMOVE command.
        """
        command = "DSURF,%s,%s,%s,%s" % (str(kcn), str(xsurf), str(ysurf), str(zsurf))
        return self.run(command, **kwargs)

    def tbpt(self, oper="", x1="", x2="", x3="", xn="", **kwargs):
        """APDL Command: TBPT

        Defines a point on a nonlinear data curve.

        Parameters
        ----------
        oper
            Operation to perform:

            DEFI - Defines a new data point (default).  The point is inserted into the table in
                   ascending order of X1.  If a point already exists with the
                   same X1 value, it is replaced.

            DELE - Deletes an existing point.  The X1 value must match the X1 value of the point
                   to be deleted (XN is ignored).

        x1, x2, ..., xn
            The N components of the point. N depends on the type of data table.
            Except for TB,EXPE all other TB Tables support only 2 components.

        Notes
        -----
        TBPT defines a point on a nonlinear data curve (such as a stress-strain
        curve, B-H curve, etc.) at the temperature specified on the last TBTEMP
        command. The meaning of the values depends on the type of data table
        specified on the last TB command (MISO, BH, etc.).

        This command is also valid in SOLUTION.
        """
        command = "TBPT,%s,%s,%s,%s,%s" % (str(oper), str(x1), str(x2), str(x3), str(xn))
        return self.run(command, **kwargs)

    def cmsel(self, type="", name="", entity="", **kwargs):
        """APDL Command: CMSEL

        Selects a subset of components and assemblies.

        Parameters
        ----------
        type
            Label identifying the type of select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

            ALL - Also select all components.

            NONE - Unselect all components.

        name
            Name of component or assembly whose items are to be selected (valid
            only if Type = S, R, A, or U).

        entity
            If Name is blank, then the following entity types can be specified:

            VOLU - Select the volume components only.

            AREA - Select the area components only.

            LINE - Select the line components only.

            KP - Select the keypoint components only.

            ELEM - Select the element components only.

            NODE - Select the node components only.

        Notes
        -----
        Selecting by component is a convenient adjunct to individual item
        selection (e.g., VSEL, ESEL, etc.). CMSEL, ALL allows you to select
        components in addition to other items you have already selected.

        If Type = R for an assembly selection [CMSEL,R,<assembly-name>], the
        reselect operation is performed on each component in the assembly in
        the order in which the components make up the assembly.  Thus, if one
        reselect operation results in an empty set, subsequent operations will
        also result in empty sets.  For example, if the first reselect
        operation tries to reselect node 1 from the selected set of nodes 3, 4,
        and 5, the operation results in an empty set (that is, no nodes are
        selected).  Since the current set is now an empty set, if the second
        reselect operation tries to reselect any nodes, the second operation
        also results in an empty set, and so on.  This is equivalent to
        repeating the command CMSEL,R,<component-name> once for each component
        making up the assembly.

        This command is valid in any processor.
        """
        command = "CMSEL,%s,%s,%s" % (str(type), str(name), str(entity))
        return self.run(command, **kwargs)

    def pvect(self, oper="", labxr="", labyr="", labzr="", **kwargs):
        """APDL Command: PVECT

        Interpolates a set of items onto a path.

        Parameters
        ----------
        oper
            Valid operations for geometry operations along a path are:

            NORM - Defines a unit normal vector at each interpolation point in the direction of
                   the cross product of the tangent to the path and the active
                   Z axis.  Resulting vector components are in the active
                   coordinate system (which must be Cartesian).

            TANG - Defines a unit vector tangent to the path at each interpolation point.  Vector
                   components are in the active coordinate system (which must
                   be Cartesian).

            RADI - Defines the position vector of each interpolation point of the path from the
                   center of the active coordinate system (which must be
                   Cartesian).

        labxr
            Label (8 characters maximum) assigned to X-component of the
            resulting vector.

        labyr
            Label (8 characters maximum) assigned to Y-component of the
            resulting vector.

        labzr
            Label (8 characters maximum) assigned to Z-component of the
            resulting vector.

        Notes
        -----
        Defines and interpolates a set of labeled path items along predefined
        path [PATH] and performs various geometric operations on these path
        items.  A path item must be defined before it can be used with other
        path operations.  Additional path items may be defined with the PDEF,
        PCALC, PDOT, and PCROSS commands.  Path items may be listed or
        displayed with the PLPATH, PLPAGM and PRPATH commands.  Path geometry
        items (XG, YG, ZG, S) are automatically interpolated (in the active
        CSYS) if not done so previously with the PDEF command.
        """
        command = "PVECT,%s,%s,%s,%s" % (str(oper), str(labxr), str(labyr), str(labzr))
        return self.run(command, **kwargs)

    def clrmshln(self, **kwargs):
        """APDL Command: CLRMSHLN

        Clears meshed entities.

        Notes
        -----
        When you use the GUI method to set the number of elements on specified
        lines, and any of those lines is connected to one or more meshed lines,
        areas, or volumes, ANSYS gives you the option to clear the meshed
        entities.  (This occurs only when you perform this operation via the
        GUI; ANSYS does not provide such an option when you use the command
        method [LESIZE].)

        If you activate the mesh clearing option, the program invokes an ANSYS
        macro, CLRMSHLN, that clears the meshed entities.  This macro name will
        appear in the log file (Jobname.LOG).  This macro is for the ANSYS
        program's internal use only.  This command is not intended to be typed
        in directly in an ANSYS session, although it can be included in an
        input file for batch input or for use with the /INPUT command.
        """
        command = "CLRMSHLN," % ()
        return self.run(command, **kwargs)

    def ppath(self, point="", node="", x="", y="", z="", cs="", **kwargs):
        """APDL Command: PPATH

        Defines a path by picking or defining nodes, or locations on the
        currently active working plane, or by entering specific coordinate
        locations.

        Parameters
        ----------
        point
            The point number.  It must be greater than zero and less than or
            equal to the nPts value specified on the PATH command if graphical
            picking is not being used.

        node
            The node number defining this point.  If blank, use the X, Y, Z
            coordinates to define the point.  A valid node number will override
            X, Y, Z coordinate arguments.

        x, y, z
            The location of the point in the global Cartesian coordinate
            system.  Use these arguments only if you omit the NODE argument.

        cs
            The coordinate system for interpolation of the path between the
            previous point and this point.  Omit this argument if you wish to
            use the currently active (CSYS) coordinate system.  If the
            coordinate system of two adjacent points is different, the CS value
            of the latter point will be used.

        Notes
        -----
        For linearized stress calculations, the path must be defined with
        nodes.

        This command is designed and works best in interactive (GUI) mode,
        using the menu paths listed below. For command line operations, issue
        PPATH,P to define your path by picking nodes.

        For information on displaying paths you have defined, see Defining Data
        to be Retrieved in the Basic Analysis Guide.
        """
        command = "PPATH,%s,%s,%s,%s,%s,%s" % (str(point), str(node), str(x), str(y), str(z), str(cs))
        return self.run(command, **kwargs)

    def fclist(self, mat="", unused="", temp="", **kwargs):
        """APDL Command: FCLIST

        To list what the failure criteria is that you have input.

        Parameters
        ----------
        mat
             Material number (defaults to ALL for all materials).

        --
            Unused field.

        temp
            Temperature to be evaluated at (defaults to TUNIF).

        Notes
        -----
        This command allows you to see what you have already input for failure
        criteria using the FC commands.
        """
        command = "FCLIST,%s,%s,%s" % (str(mat), str(unused), str(temp))
        return self.run(command, **kwargs)

    def d(self, node="", lab="", value="", value2="", nend="", ninc="",
          lab2="", lab3="", lab4="", lab5="", lab6="", **kwargs):
        """APDL Command: D

        Defines degree-of-freedom constraints at nodes.

        Parameters
        ----------
        node
            Node at which constraint is to be specified. If ALL, NEND and NINC
            are ignored and constraints are applied to all selected nodes
            (NSEL). If Node = P, graphical picking is enabled and all remaining
            command fields are ignored (valid only in the GUI).  A component
            name may also be substituted for Node.

        lab
            Valid degree-of-freedom label.  If ALL, use all appropriate labels.

        value
            Degree-of-freedom value or table name reference for tabular
            boundary conditions.  To specify a table, enclose the table name in
            percent (%) signs (for example, D,Node,TEMP,%tabname%). Use the
            *DIM command to define a table.

        value2
            Second degree-of-freedom value (if any).  If the analysis type and
            the degree of freedom allow a complex input, Value (above) is the
            real component and VALUE2 is the imaginary component.

        nend, ninc
            Specifies the same values of constraint at the range of nodes from
            Node to NEND (defaults to Node), in steps of NINC (defaults to 1).

        lab2, lab3, lab4, lab5, lab6
            Additional degree-of-freedom labels. The same values are applied to
            the nodes for these labels.

        Notes
        -----
        The available degrees of freedom per node are listed under "Degrees of
        Freedom" in the input table for each element type in the Element
        Reference.  Degrees of freedom are defined in the nodal coordinate
        system.  The positive directions of structural translations and
        rotations are along and about the positive nodal axes directions.
        Structural rotations should be input in radians.  The node and the
        degree-of-freedom label must be selected (NSEL, DOFSEL).

        In a structural analysis, you can apply only one displacement,
        velocity, or acceleration load at any degree of freedom. If multiple
        loads are specified, the last applied load overrides the previous ones.
        For example, the following commands apply loads to node 100:

        In this case, the velocity load (VELX) applied in the last command will
        override the displacement load (UX).

        For elements used in static and low frequency electromagnetic analysis
        (SOLID236 and SOLID237), the AZ degree of freedom is not a z-component
        of a vector potential, but rather the flux contribution on the element
        edge.  To specify a flux-parallel condition, set AZ = 0.  For more
        information, see 3-D Magnetostatics and Fundamentals of Edge-based
        Analysis in the Low-Frequency Electromagnetic Analysis Guide.

        In an explicit dynamic analysis, the D command can only be used to fix
        nodes in the model. The degree-of-freedom value must be zero; no other
        values are valid. Use the EDLOAD command to apply a nonzero
        displacement in an explicit dynamic analysis.

        For ELBOW290 cross-section degrees of freedom (Lab = SE, SO, SW, SRA,
        SRT, or SECT), the D command can only specify fixed constraints. The
        degree-of-freedom value must be zero; no other values are valid.

        For hydrostatic fluid elements (HSFLD241 and HSFLD242), the HDSP
        degree-of-freedom constraint at the pressure node prescribes the
        pressure value for all the fluid elements sharing the pressure node.

        Tabular boundary conditions (VALUE = %tabname%) are available only for
        the following degree-of-freedom labels: Electric (VOLT), structural
        (UX, UY, UZ, ROTX, ROTY, ROTZ, and velocity and acceleration loads
        VELX, VELY, VELZ, OMGX, OMGY, OMGZ, ACCX, ACCY, ACCZ, DMGX, DMGY,
        DMGZ), acoustic (PRES, UX, UY, UZ,), and temperature (TEMP, TBOT, TE2,
        TE3, . . ., TTOP). All labels are valid only in static (ANTYPE,STATIC)
        and full transient (ANTYPE,TRANS) analyses.

        %_FIX% is an ANSYS reserved table name. When VALUE is set to %_FIX%,
        ANSYS will prescribe the degree of freedom to the “current” relative
        displacement value. This option is only valid for the following labels:
        UX, UY, UZ, ROTX, ROTY, ROTZ. Alternatively, functions UX(), UY(), etc.
        may be used (see *GET for a complete list of available functions). In
        most cases, %_FIX% usage is efficient and recommended for all
        structural degrees of freedom.

        When Value = SUPPORT, specify only the minimum number of displacement
        constraints necessary to prevent rigid body motion: three constraints
        (or fewer, depending on the element type) for 2-D models and six (or
        fewer) for 3-D models.

        If constraints and initial conditions (IC) are applied at the same
        node, the constraint specification overrides. This combination is
        useful when a constraint degree-of-freedom value needs to start with a
        nonzero value at time = 0.0. For example, if the constraint degree-of-
        freedom value is prescribed to be a cosine function, then specifying an
        initial condition for the same node and degree of freedom ensures that
        the initial value for the constraint degree of freedom at time = 0.0 is
        same as the cosine function evaluated at time = 0.0. If initial
        conditions are not specified, the constraint degree-of-freedom value
        ramps from zero in the first substep of the first loadstep.

        If more than one rotational degrees of freedom are constrained with
        non-zero rotations (ROTX, ROTY, ROTZ), rotational velocities (OMGX,
        OMGY, OMGZ), or rotational accelerations (DMGX, DMGY, DMGZ), then the
        rotation of the constrained node from its initial configuration to its
        final configuration depends on the combination and the sequence in
        which the constraints are applied. See Rotations in a Large-Deflection
        Analysis in Structural Analysis Guide.

        This command is also valid in PREP7.
        """
        command = "D,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(node), str(lab), str(value), str(value2), str(nend), str(ninc), str(lab2), str(lab3), str(lab4), str(lab5), str(lab6))
        return self.run(command, **kwargs)

    def klist(self, np1="", np2="", ninc="", lab="", **kwargs):
        """APDL Command: KLIST

        Lists the defined keypoints or hard points.

        Parameters
        ----------
        np1, np2, ninc
            List keypoints from NP1 to NP2 (defaults to NP1) in steps of NINC
            (defaults to 1).  If NP1 = ALL (default), NP2 and NINC are ignored
            and all selected keypoints [KSEL] are listed.  If NP1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NP1 (NP2 and NINC are ignored).

        lab
            Coordinate listing key:

            (blank) - List all keypoint information.

            COORD - Suppress all but the keypoint coordinates (shown to a higher degree of accuracy
                    than when displayed with all information).

            HPT - List only hard point information.

        Notes
        -----
        Lists keypoints in the active display coordinate system [DSYS].  An
        attribute (TYPE, MAT, REAL, or ESYS) listed as a zero is unassigned;
        one listed as a positive value indicates that the attribute was
        assigned with the KATT command (and will not be reset to zero if the
        mesh is cleared); one listed as a negative value indicates that the
        attribute was assigned using the attribute pointer [TYPE, MAT, REAL, or
        ESYS] that was active during meshing (and will be reset to zero if the
        mesh is cleared).

        This command is valid in any processor.
        """
        command = "KLIST,%s,%s,%s,%s" % (str(np1), str(np2), str(ninc), str(lab))
        return self.run(command, **kwargs)

    def edadapt(self, part="", key="", **kwargs):
        """APDL Command: EDADAPT

        Activates adaptive meshing in an explicit dynamic analysis.

        Parameters
        ----------
        part
            Part ID (number) for which adaptive meshing is to be turned on (or
            off). Use PART = STAT to list the current adaptive meshing
            definitions.

        key
            Adaptivity key:

            OFF - Do not use adaptive meshing for the specified part ID (default).

            ON - Use adaptive meshing for the specified part ID.

        Notes
        -----
        When adaptive meshing (adaptivity) is turned on, the mesh will
        automatically be regenerated to ensure adequate element aspect ratios.
        Adaptive meshing is most commonly used in the analysis of large
        deformation processes such as metal forming, in which the blank would
        need to be adaptively meshed.

        Adaptive meshing is only valid for parts consisting of SHELL163
        elements. By default, adaptive meshing is OFF for all parts in the
        model. To specify adaptive meshing for more than one part in the model,
        you must issue the EDADAPT command for each part ID. Use the EDPART
        command to create and list valid part IDs. Use the EDCADAPT command to
        define additional adaptive meshing parameters.

        The EDADAPT command is not supported in an explicit dynamic full
        restart analysis (EDSTART,3). In addition, a full restart cannot be
        performed successfully if adaptive meshing was used in the previous
        analysis.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDADAPT,%s,%s" % (str(part), str(key))
        return self.run(command, **kwargs)

    def fsplot(self, nloc="", nev="", item="", **kwargs):
        """APDL Command: FSPLOT

        Displays a fatigue stress item for a fatigue location and event.

        Parameters
        ----------
        nloc
            Display stresses associated with location NLOC.

        nev
            Display stresses associated with event NEV.

        item
            Display stresses associated with item number ITEM.  Items are as
            follows:

            1-6 - SX, SY, SZ, SXY, SYZ, SXZ total stress components

            7 - Temperature

            8-13 - SX, SY, SZ, SXY, SYZ, SXZ membrane-plus-bending stress components.

            14 - Time

        Notes
        -----
        Displays a fatigue stress item as a function of loading number for a
        particular fatigue location and event.
        """
        command = "FSPLOT,%s,%s,%s" % (str(nloc), str(nev), str(item))
        return self.run(command, **kwargs)

    def filname(self, fname="", key="", **kwargs):
        """APDL Command: /FILNAME

        Changes the Jobname for the analysis.

        Parameters
        ----------
        fname
            Name (32 characters maximum) to be used as the Jobname.  Defaults
            to the initial Jobname as specified on the ANSYS execution command,
            or to file if none specified.

        key
            Specify whether to use the existing log, error, lock, page, and
            output files (.LOG, .ERR, .LOCK, .PAGE and .OUT) or start new
            files.

            0, OFF - Continue using current log, error, lock, page, and output files.

            1, ON - Start new log, error, lock, page, and output files (old log and error files are
                    closed and saved, but old lock, page, and output files are
                    deleted). Existing log and error files are appended.

        Notes
        -----
        All subsequently created files will be named with this Jobname if Key =
        0.  Use Key = 1 to start new log, error, lock, page, and output files.
        The previous Jobname is typically defined on the ANSYS program
        execution line (see the Operations Guide).  This command is useful when
        different groups of files created throughout the run are to have
        different names.  For example, the command may be used before each
        substructure pass to avoid overwriting files or having to rename each
        file individually.

        This command is valid only at the Begin level.
        """
        command = "/FILNAME,%s,%s" % (str(fname), str(key))
        return self.run(command, **kwargs)

    def cformat(self, nfirst="", nl_ast="", **kwargs):
        """APDL Command: /CFORMAT

        Controls the graphical display of alphanumeric character strings for
        parameters, components, assemblies, and tables.

        Parameters
        ----------
        nfirst
            Display the first n characters of the parameter, component,
            assembly, or table name, up to 32. Defaults to 32.

        nlast
            Display the last n characters of the parameter, component,
            assembly, or table name, up to 32. Defaults to 0.

        Notes
        -----
        Use this command to control the length of the character string that is
        shown in the graphics window for a parameter, component, assembly, or
        table name.

        The total number of characters (NFIRST + NLAST +3) cannot exceed 32.

        If NFIRST is greater than zero and NLAST = 0, only the NFIRST
        characters are displayed, followed by an ellipsis.

        If NFIRST = 0 and NLAST is greater than zero, only the NLAST characters
        are displayed, preceded by an ellipsis (...).

        If both NFIRST and NLAST are greater than zero, the name will be shown
        as NFIRST, followed by an ellipsis (...), followed by NLAST, up to a
        maximum of 32 characters.

        For example, if NFIRST = 6 and NLAST = 3, and the character string is
        LENGTHOFSIDEONE, then it will appear in the graphics window as
        LENGTH...ONE.

        If the actual length of the character string is less than the specified
        combination of NFIRST + NLAST +3, then the actual string will be used.

        This command is valid in any processor.
        """
        command = "/CFORMAT,%s,%s" % (str(nfirst), str(nl_ast))
        return self.run(command, **kwargs)

    def radopt(self, unused="", fluxtol="", solver="", maxiter="",
               toler="", overrlex="", maxfluxiter="", **kwargs):
        """APDL Command: RADOPT

        Specifies Radiosity Solver options.

        Parameters
        ----------
        --
            Unused field.

        fluxtol
            Convergence tolerance for radiation flux. Defaults to 0.0001. This
            value is a relative tolerance.

        solver
            Choice of solver for radiosity calculation:

            0 - Gauss-Seidel iterative solver (default).

            1 - Direct solver.

            2 - Jacobi solver.

        maxiter
            Maximum number of iterations for iterative solver (SOLVER = 0 or
            2). Defaults to 1000.

        toler
            Convergence tolerance for the iterative solver (SOLVER = 0 or 2).
            Defaults to 0.1.

        overrlex
            Over-relaxation factor applied to the iterative solver (SOLVER = 0
            or 2). Defaults to 0.1.

        --, --, --, --
            Unused fields

        maxfluxiter
            Maximum number of flux iterations to be performed according to the
            specified solver type:

            0 - If the FULL solver is specified (THOPT,FULL), convergence criteria are
                monitored and iterations are performed until convergence
                occurs. If the QUASI solver is specified (THOPT,QUASI),
                convergence criteria are ignored and one iteration is
                performed. This value is the default.

            1, 2, 3, ...N  - If the FULL solver is specified (THOPT,FULL), convergence criteria are
                             monitored and iterations are performed until
                             convergence occurs, or until the specified number
                             of iterations has been completed, whichever comes
                             first. If the QUASI solver is specified
                             (THOPT,QUASI), convergence criteria are ignored
                             and the specified number of iterations are
                             completed.

        Notes
        -----
        The radiation heat flux is linearized, resulting in robust convergence.

        The radiation flux norm for FLUXTOL is expressed as:

        where i is the pass or iteration number and j is the surface facet for
        radiation.

        For a sufficiently small absolute tolerance value, relative tolerance
        converges in fewer iterations than absolute tolerance. For a
        sufficiently large absolute tolerance value, relative tolerance may
        cause convergence difficulties.

        For more information about FLUXTOL and MAXFLUXITER usage, see Figure:
        3.5:: FULL Solution Method When Radiosity Is Present and Figure: 3.6::
        QUASI Solution Method When Radiosity Is Present in the Thermal Analysis
        Guide.

        In Figure: 3.5:: FULL Solution Method When Radiosity Is Present and
        Figure: 3.6:: QUASI Solution Method When Radiosity Is Present (under
        Solving for Temperature and Radiosity in the Thermal Analysis Guide),
        refer to the KQQ = FQ equation system via the iterative method:

        If TOLER ≥ 0, the iterative solver is converged for maximum value over
        a different j as shown:

        If TOLER < 0, the iterative solver is converged for maximum value over
        a different j as shown:

        where:

        The Jacobi solver (SOLVER = 2) is suitable when using Distributed
        ANSYS. This option is only available for 3-D models; if SOLVER is set
        to 2 for a 2-D analysis, the Gauss-Seidel iterative solver (SOLVER = 0)
        is used.
        """
        command = "RADOPT,%s,%s,%s,%s,%s,%s" % (str(unused),
                                                str(fluxtol),
                                                str(solver),
                                                str(maxiter),
                                                str(toler),
                                                str(overrlex),
                                                str(maxfluxiter))
        return self.run(command, **kwargs)

    def tiff(self, kywrd="", opt="", **kwargs):
        """APDL Command: TIFF

        Provides TIFF file Export for ANSYS Displays.

        Parameters
        ----------
        kywrd
            Specifies various TIFF file export options.

            COMP - If Kywrd = COMP, then OPT controls data compression for the output file. If
                   COMP = 0, then compression is off. If COMP = 1 (default),
                   then compression is on.

            ORIENT - If Kywrd = ORIENT, then OPT will determine the orientation of the entire plot.
                     OPT can be either Horizontal (default) or Vertical.

            COLOR - If Kywrd = COLOR, then OPT will determine the color attribute of the saved
                    file. OPT can be 0, 1, or 2, corresponding to Black and
                    White, Grayscale, and Color (default), respectively.

            TMOD - If Kywrd = TMOD, then OPT will determine the text method. OPT can be either 1
                   or 0, corresponding to bitmap text (default) or line stroke
                   text, respectively.

            DEFAULT - If Kywrd = DEFAULT, then all of the default values, for all of the Kywrd
                      parameters listed above, are active.

        opt
            OPT can have the following names or values, depending on the value
            for Kywrd (see above).

            1 or 0 - If Kywrd = COMP, a value or 1 (on) or 0 (off) will control compression for the
                     TIFF file.

            Horizontal, Vertical - If Kywrd = ORIENT, the terms Horizontal or Vertical determine the orientation
                              of the plot.

            0, 1, 2 - If Kywrd = COLOR, the numbers 0, 1, and 2 correspond to Black and White ,
                      Grayscale and Color, respectively.

            1, 0 - If Kywrd = TMOD, the values 1 and 0 determine whether bitmap (1) or stroke text
                   (0) fonts will be used
        """
        command = "TIFF,%s,%s" % (str(kywrd), str(opt))
        return self.run(command, **kwargs)

    def impd(self, vpath="", ipath="", vsymm="", isymm="", **kwargs):
        """APDL Command: IMPD

        Calculates the impedance of a conductor at a reference plane.

        Parameters
        ----------
        vpath
            Path name for a predefined path [PATH command] for calculating the
            EMF (voltage drop) from the conductor to a reference point. The
            path should start at the outer conductor wall and end at a
            reference voltage point.

        ipath
            Path name for a predefined path [PATH command] for calculating the
            MMF (current) in a conductor. The path should traverse a closed
            contour surrounding the conductor, and you should define the path
            in a counterclockwise direction.

        vsymm
            Symmetry factor applied to the calculated EMF (voltage drop). The
            EMF (voltage drop) from the conductor to the reference point is
            multiplied by Vsymm.

        isymm
            Symmetry factor applied to the calculated current. The calculated
            current is multiplied by Isymm.

        Notes
        -----
        Used in a harmonic high-frequency electromagnetic analysis, IMPD
        calculates the impedance of a conductor at a reference plane from the
        EMF (voltage) and MMF (current) at the reference plane. The EMF
        (voltage drop) is calculated by a line integral from the input path
        name (specified by the Vpath argument) that extends from the conductor
        to a reference point. The MMF (current) is calculated by a closed path
        around the conductor from the input path name (specified with Ipath).
        In cases having modeled symmetry, you can multiply the voltage drop or
        current by symmetry factors (Vsymm and Isymm respectively).

        This command macro returns the scalar parameters Zre and Zim,
        representing the real and imaginary components of the impedance.

        See magnetic macros for further details.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "IMPD,%s,%s,%s,%s" % (str(vpath), str(ipath), str(vsymm), str(isymm))
        return self.run(command, **kwargs)

    def vsbv(self, nv1="", nv2="", sepo="", keep1="", keep2="", **kwargs):
        """APDL Command: VSBV

        Subtracts volumes from volumes.

        Parameters
        ----------
        nv1
            Volume (or volumes, if picking is used) to be subtracted from.  If
            ALL, use all selected volumes.  Volumes specified in set NV2 are
            removed from set NV1.  If P, graphical picking is enabled (valid
            only in the GUI) and remaining fields are ignored.  A component
            name may also be substituted for NV1.

        nv2
            Volume (or volumes, if picking is used) to subtract.  If ALL, use
            all selected volumes (except those included in the NV1 argument).
            A component name may also be substituted for NV2.

        sepo
            Behavior if the intersection of the NV1 volumes and the NV2 volumes
            is an area or areas:

            (blank) - The resulting volumes will share area(s) where they touch.

            SEPO - The resulting volumes will have separate, but coincident area(s) where they
                   touch.

        keep1
            Specifies whether NV1 volumes are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NV1 volumes after VSBV operation (override BOPTN command settings).

            KEEP - Keep NV1 volumes after VSBV operation (override BOPTN command settings).

        keep2
            Specifies whether NV2 volumes are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NV2 volumes after VSBV operation (override BOPTN command settings).

            KEEP - Keep NV2 volumes after VSBV operation (override BOPTN command settings).

        Notes
        -----
        Generates new volumes by subtracting the regions common to both NV1 and
        NV2 volumes (the intersection) from the NV1 volumes.  The intersection
        can be a volume(s) or area(s).  If the intersection is an area and SEPO
        is blank, the NV1 volume is divided at the area and the resulting
        volumes will be connected, sharing a common area where they touch.  If
        SEPO is set to SEPO, NV1 is divided into two unconnected volumes with
        separate areas where they touch.  See the Modeling and Meshing Guide
        for an illustration.  See the BOPTN command for an explanation of the
        options available to Boolean operations.  Element attributes and solid
        model boundary conditions assigned to the original entities will not be
        transferred to the new entities generated.  VSBV,ALL,ALL will have no
        effect because all the volumes in set NV1will have been moved to set
        NV2.
        """
        command = "VSBV,%s,%s,%s,%s,%s" % (str(nv1), str(nv2), str(sepo), str(keep1), str(keep2))
        return self.run(command, **kwargs)

    def sfl(self, line="", lab="", vali="", valj="", val2i="", val2j="",
            **kwargs):
        """APDL Command: SFL

        Specifies surface loads on lines of an area.

        Parameters
        ----------
        line
            Line to which surface load applies.  If ALL, apply load to all
            selected lines [LSEL].  If Line = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).  A component name may be substituted for Line.

        lab
            Valid surface load label.  Load labels are listed under "Surface
            Loads" in the input table for each element type in the Element
            Reference.

        vali, valj
            Surface load values at the first keypoint (VALI) and at the second
            keypoint (VALJ) of the line, or table name for specifying tabular
            boundary conditions.  If VALJ is blank, it defaults to VALI.  If
            VALJ is zero, a zero is used.  If Lab = CONV, VALI and VALJ are the
            film coefficients and VAL2I and VAL2J are the bulk temperatures.
            To specify a table, enclose the table name in percent signs (%),
            e.g., %tabname%.  Use the *DIM command to define a table.  If Lab =
            CONV and VALI = -N, the film coefficient may be a function of
            temperature and is determined from the HF property table for
            material N [MP].  If Lab = RAD, VALI and VALJ values are surface
            emissivities and VAL2I and VAL2J are ambient temperatures.  The
            temperature used to evaluate the film coefficient is usually the
            average between the bulk and wall temperatures, but may be user
            defined for some elements.  If Lab = RDSF, VALI is the emissivity
            value; the following condition apply: If VALI = -N, the emissivity
            may be a function of the temperature and is determined from the
            EMISS property table for material N [MP]. If Lab = FSIN in a Multi-
            field solver (single or multiple code coupling) analysis, VALI is
            the surface interface number. If Lab = FSIN in a unidirectional
            ANSYS to CFX analysis, VALJ is the surface interface number (not
            available from within the GUI) and VALI is not used unless the
            ANSYS analysis is performed using the Multi-field solver.

        val2i, val2j
            Second surface load values (if any).  If Lab = CONV, VAL2I and
            VAL2J are the bulk temperatures. If Lab = RAD, VAL2I and VAL2J are
            the ambient temperatures. If Lab = RDSF, VAL2I is the enclosure
            number. Radiation will occur between surfaces flagged with the same
            enclosure numbers. If the enclosure is open, radiation will occur
            to the ambient. VAL2I and VAL2J are not used for other surface load
            labels.  If VAL2J is blank, it defaults to VAL2I.  If VAL2J is
            zero, a zero is used.  To specify a table (Lab = CONV), enclose the
            table name in percent signs (%), e.g., %tabname%.  Use the *DIM
            command to define a table.

        Notes
        -----
        Specifies surface loads on the selected lines of area regions.  The
        lines represent either the edges of area elements or axisymmetric shell
        elements themselves.  Surface loads may be transferred from lines to
        elements with the SFTRAN or SBCTRAN commands.  See the SFE command for
        a description of surface loads.  Loads input on this command may be
        tapered.  See the SFGRAD command for an alternate tapered load
        capability.

        You can specify a table name only when using structural (PRES) and
        thermal (CONV [film coefficient and/or bulk temperature], HFLUX), and
        surface emissivity and ambient temperature (RAD) surface load labels.
        VALJ and VAL2J are ignored for tabular boundary conditions.

        This command is also valid in PREP7.
        """
        command = "SFL,%s,%s,%s,%s,%s,%s" % (str(line), str(lab), str(vali), str(valj), str(val2i), str(val2j))
        return self.run(command, **kwargs)

    def srss(self, signif="", label="", abssumkey="", forcetype="", **kwargs):
        """APDL Command: SRSS

        Specifies the square root of sum of squares mode combination method.

        Parameters
        ----------
        signif
            Combine only those modes whose significance level exceeds the
            SIGNIF threshold.  For single point, multipoint, or DDAM response
            (SPOPT,SPRS, MPRS or DDAM), the significance level of a mode is
            defined as the mode coefficient of the mode, divided by the maximum
            mode coefficient of all modes.  Any mode whose significance level
            is less than SIGNIF is considered insignificant and is not
            contributed to the mode combinations.  The higher the SIGNIF
            threshold, the fewer the number of modes combined. SIGNIF defaults
            to 0.001.  If SIGNIF is specified as 0.0, it is taken as 0.0.
            (This mode combination method is not valid for SPOPT,PSD.)

        label
            Label identifying the combined mode solution output.

            DISP - Displacement solution (default).  Displacements, stresses, forces, etc., are
                   available.

            VELO - Velocity solution.  Velocities, "stress velocities," "force velocities," etc.,
                   are available.

            ACEL - Acceleration solution.  Accelerations, "stress accelerations," "force
                   accelerations," etc., are available.

        abssumkey
            Absolute Sum combination key (for SPOPT,MPRS only):

            NO - Do not use the Absolute Sum method (default).

            YES - Combine the modes per excitation direction using the Absolute Sum method, then
                  combine the resulting quantities using the square root of sum
                  of squares method.

        forcetype
            Label identifying the forces to be combined:

            STATIC - Combine the modal static forces (default).

            TOTAL - Combine the modal static plus inertial forces.

        Notes
        -----
        This command is also valid for PREP7.
        """
        command = "SRSS,%s,%s,%s,%s" % (str(signif), str(label), str(abssumkey), str(forcetype))
        return self.run(command, **kwargs)

    def eusort(self, **kwargs):
        """APDL Command: EUSORT

        Restores original order of the element table.

        Notes
        -----
        Changing the selected element set [ESEL] also restores the original
        element order.
        """
        command = "EUSORT," % ()
        return self.run(command, **kwargs)

    def vsum(self, lab="", **kwargs):
        """APDL Command: VSUM

        Calculates and prints geometry statistics of the selected volumes.

        Parameters
        ----------
        lab
            Controls the degree of tessellation used in the calculation of area
            properties.  If LAB = DEFAULT, area calculations will use the
            degree of tessellation set through the /FACET command.  If LAB =
            FINE, area calculations are based on a finer tessellation.

        Notes
        -----
        Calculates and prints geometry statistics (volume, centroid location,
        moments of inertia, etc.) associated with the selected volumes.
        Geometry items are reported in the global Cartesian coordinate system.
        A unit density is assumed unless the volumes have a material
        association via the VATT command.  Items calculated by VSUM and later
        retrieved by a *GET or *VGET command are valid only if the model is not
        modified after the VSUM command is issued.

        Setting a finer degree of tessellation will provide area calculations
        with greater accuracy, especially for thin, hollow models.  However,
        using a finer degree of tessellation requires longer processing.

        For very thin volumes, such that the ratio of the minimum to the
        maximum dimension is less than 0.01, the VSUM command can provide
        erroneous volume information.  To ensure that such calculations are
        accurate, make certain that you subdivide such volumes so that the
        ratio of the minimum to the maximum is at least 0.05.
        """
        command = "VSUM,%s" % (str(lab))
        return self.run(command, **kwargs)

    def smin(self, labr="", lab1="", lab2="", fact1="", fact2="", **kwargs):
        """APDL Command: SMIN

        Forms an element table item from the minimum of two other items.

        Parameters
        ----------
        labr
            Label assigned to results.  If same as existing label, the existing
            values will be overwritten by these results.

        lab1
            First labeled result item in operation.

        lab2
            Second labeled result item in operation (may be blank).

        fact1
            Scale factor applied to Lab1. A (blank) or '0' entry defaults to
            1.0.

        fact2
            Scale factor applied to Lab2. A (blank) or '0' entry defaults to
            1.0.

        Notes
        -----
        Forms a labeled result item (see ETABLE command) for the selected
        elements by comparing two existing labeled result items according to
        the operation:

        LabR = (FACT1 x Lab1) cmn (FACT2 x Lab2)

        where "cmn" means "compare and save minimum."  If absolute values are
        requested [SABS,1], the absolute values of Lab1 and Lab2 are used.
        """
        command = "SMIN,%s,%s,%s,%s,%s" % (str(labr), str(lab1), str(lab2), str(fact1), str(fact2))
        return self.run(command, **kwargs)

    def mplib(self, r_w_opt="", path="", **kwargs):
        """APDL Command: /MPLIB

        Sets the default material library read and write paths.

        Parameters
        ----------
        r-w_opt
            Determines what path is being set.  Possible values are:

            READ - Set the read path.

            WRITE - Set the write path.

            STAT - Report what read and write paths are currently in use.

        path
            The directory path to be used for material library files.

        Notes
        -----
        The /MPLIB command sets two path strings used in conjunction with the
        material library feature and the MPREAD and MPWRITE commands.

        For MPREAD, when you use the LIB option and no directory path is given
        in the file name, the command searches for the file in these locations:
        the current working directory, the user's home directory, the user-
        specified material library directory (as defined by the
        /MPLIB,READ,PATH command), and /ansys_dir/matlib.

        For MPWRITE, when you use the LIB option and the directory portion of
        the specification for the material library file is blank, the command
        writes the material  library file to the directory specified by the
        /MPLIB,WRITE,PATH command (if that path has been set).  If the path has
        not been set, the default is to write the file to the current working
        directory.

        The Material Library files supplied with the distribution disks are
        meant for demonstration purposes only.  These files are not intended
        for use in customer applications.
        """
        command = "/MPLIB,%s,%s" % (str(r_w_opt), str(path))
        return self.run(command, **kwargs)

    def asbl(self, na="", nl="", unused="", keepa="", keepl="", **kwargs):
        """APDL Command: ASBL

        Subtracts lines from areas.

        Parameters
        ----------
        na
            Area (or areas, if picking is used) to be subtracted from.  If ALL,
            use all selected areas.  If P, graphical picking is enabled (valid
            only in the GUI) and remaining fields are ignored.  A component
            name may also be substituted for NA.

        nl
            Line (or lines, if picking is used) to subtract.  If ALL, use all
            selected lines.    A component name may also be substituted for NL.

        --
            Unused field.

        keepa
            Specifies whether NA areas are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NA areas after ASBL operation (override BOPTN command settings).

            KEEP - Keep NA areas after ASBL operation (override BOPTN command settings).

        keepl
            Specifies whether NL lines are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NL lines after ASBL operation (override BOPTN command settings).

            KEEP - Keep NL lines after ASBL operation (override BOPTN command settings).

        Notes
        -----
        Generates new areas by subtracting the regions common to both the areas
        and lines (the intersection) from the NA areas.  The intersection will
        be a line(s).  See Solid Modeling in the Modeling and Meshing Guide for
        an illustration.  See the BOPTN command for an explanation of the
        options available to Boolean operations.  Element attributes and solid
        model boundary conditions assigned to the original entities will not be
        transferred to the new entities generated.
        """
        command = "ASBL,%s,%s,%s,%s,%s" % (str(na),
                                           str(nl),
                                           str(unused),
                                           str(keepa),
                                           str(keepl))
        return self.run(command, **kwargs)

    def neqit(self, neqit="", forcekey="", **kwargs):
        """APDL Command: NEQIT

        Specifies the maximum number of equilibrium iterations for nonlinear
        analyses.

        Parameters
        ----------
        neqit
            Maximum number of equilibrium iterations allowed each substep.

        forcekey
            One iteration forcing key:

            FORCE - Forces one iteration per substep. Leave this field blank otherwise.

        Notes
        -----
        This command is also valid in PREP7.
        """
        command = "NEQIT,%s,%s" % (str(neqit), str(forcekey))
        return self.run(command, **kwargs)

    def bfescal(self, lab="", fact="", tb_ase="", **kwargs):
        """APDL Command: BFESCAL

        Scales element body force loads.

        Parameters
        ----------
        lab
            Valid body load label.  If ALL, use all appropriate labels.

        fact
            Scale factor for the element body load values.  Zero (or blank)
            defaults  to 1.0.  Use a small number for a "zero" scale factor.
            The scale factor is not applied to body load phase angles.

        tbase
            Base temperature for temperature difference.  Used only with Lab =
            TEMP.  Scale factor is applied to the temperature difference (T -
            TBASE)  and then added to TBASE.  T is the current temperature.

        Notes
        -----
        Scales element body force loads on the selected elements in the
        database.  Issue the BFELIST command to list the element body loads.
        Solid model boundary conditions are not scaled by this command, but
        boundary conditions on the FE model are scaled.  (Note that such scaled
        FE boundary conditions may still be overwritten by unscaled solid model
        boundary conditions if a subsequent boundary condition transfer
        occurs.)

        BFESCAL does not work for tabular boundary conditions.

        This command is also valid in PREP7.
        """
        command = "BFESCAL,%s,%s,%s" % (str(lab), str(fact), str(tb_ase))
        return self.run(command, **kwargs)

    def edtp(self, option="", value1="", value2="", **kwargs):
        """APDL Command: EDTP

        Plots explicit elements based on their time step size.

        Parameters
        ----------
        option
             Plotting option (default = 1).

            1 - Plots the elements with the smallest time step sizes. The number of elements
                plotted and listed is equal to VALUE1 (which defaults to 100).
                Each element is shaded red or yellow based on its time step
                value (see "Notes" for details).

            2 - Produces the same plot as for OPTION = 1, and also produces a list of the
                plotted elements and their corresponding time step values.

            3 - Produces a plot similar to OPTION = 1, except that all selected elements are
                plotted. Elements beyond the first VALUE1 elements are blue and
                translucent. The amount of translucency is specified by VALUE2.
                This option also produces a list of the first VALUE1 elements
                with their corresponding time step values.

        value1
            Number of elements to be plotted and listed (default = 100). For
            example, if VALUE1 = 10, only the elements with the 10 smallest
            time step sizes are plotted and listed.

        value2
            Translucency level ranging from 0 to 1 (default = 0.9). VALUE2 is
            only used when OPTION = 3, and only for the elements plotted in
            blue. To plot these elements as non-translucent, set VALUE2 = 0.

        Notes
        -----
        EDTP invokes an ANSYS macro that plots and lists explicit elements
        based on their time step size. For OPTION = 1 or 2, the number of
        elements plotted is equal to VALUE1 (default = 100). For OPTION = 3,
        all selected elements are plotted.

        The elements are shaded red, yellow, or blue based on their time step
        size. Red represents the smallest time step sizes, yellow represents
        the intermediate time step sizes, and blue represents the largest time
        step sizes. For example, if you specify VALUE1 = 30, and if T1 is the
        smallest critical time step of all elements and T30 is the time step of
        the 30th smallest element, then the elements are shaded as follows:

        Translucent blue elements only appear when OPTION = 3.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDTP,%s,%s,%s" % (str(option), str(value1), str(value2))
        return self.run(command, **kwargs)

    def arctrm(self, lab="", val="", node="", dof="", **kwargs):
        """APDL Command: ARCTRM

        Controls termination of the solution when the arc-length method is
        used.

        Parameters
        ----------
        lab
            Specifies the basis of solution termination:

            OFF - Does not use ARCTRM to terminate analysis (default).

            L - Terminates the analysis if the first limit point has been reached.  The first
                limit point is that point in the response history when the
                tangent stiffness matrix becomes singular (i.e., the point at
                which the structure becomes unstable).  If Lab = L, arguments
                VAL, NODE, DOF are ignored.

            U - Terminates the analysis when the displacement first equals or exceeds the
                maximum desired value.

        val
            Maximum desired displacement (absolute value).  Valid only if Lab =
            U.  The analysis terminates whenever the calculated displacement
            first equals or exceeds this value.  For rotational degrees of
            freedom, VAL must be in radians (not degrees).

        node
            Node number corresponding to displacement used to compare with
            displacement specified by VAL.  If blank, the maximum displacement
            will be used.  Valid only if Lab = U.

        dof
            Valid degree of freedom label for nodal displacement specified by
            NODE.  Valid labels are UX, UY, UZ, ROTX, ROTY, ROTZ.  Valid only
            if NODE>0 and Lab = U.

        Notes
        -----
        The ARCTRM command is valid only when the arc-length method (ARCLEN,ON)
        is used.

        It can be convenient to use this command to terminate the analysis when
        the first limit point is reached. In addition, the NCNV command should
        be used to limit the maximum number of iterations. If the ARCTRM
        command is not used, and the applied load is so large that the solution
        path can never reach that load, the arc-length solution will continue
        to run until a CPU time limit or a "maximum number of iterations" is
        reached.
        """
        command = "ARCTRM,%s,%s,%s,%s" % (str(lab), str(val), str(node), str(dof))
        return self.run(command, **kwargs)

    def bfv(self, volu="", lab="", val1="", val2="", val3="", ph_ase="",
            **kwargs):
        """APDL Command: BFV

        Defines a body force load on a volume.

        Parameters
        ----------
        volu
            Volume to which body load applies.  If ALL, apply to all selected
            volumes [VSEL]. A component name may also be substituted for Volu.

        lab
            Valid body load label. Load labels are listed under "Body Loads" in
            the input table for each element type in the Element Reference.

        val1, val2, val3
            Value associated with the Lab item or a table name for specifying
            tabular boundary conditions.  Use only VAL1 for TEMP, FLUE, HGEN,
            and CHRGD.  Use VAL1, VAL2, and VAL3 for the X, Y, and Z components
            of JS.  For Lab = JS in magnetics, use VAL1, VAL2, and VAL3 for the
            X, Y, and Z components. For acoustics, if Lab = JS,  use VAL1 for
            mass source in a harmonic analysis or mass source rate in a
            transient analysis, and ignoreVAL2 and VAL3. For Lab = VLTG, VAL1
            is the voltage drop and VAL2 is the phase angle.  When specifying a
            table name, you must enclose the table name in percent signs (%),
            e.g., BFV,Volu,Lab,%tabname%.  Use the *DIM command to define a
            table.

        phase
            Phase angle in degrees associated with the JS label.

        Notes
        -----
        Defines a body force load (such as temperature in a structural
        analysis, heat generation rate in a thermal analysis, etc.) on a
        volume.  Body loads may be transferred from volumes to volume elements
        (or to nodes if volume elements do not exist) with the BFTRAN or
        SBCTRAN commands.  Body loads default to the value specified on the
        BFUNIF command, if it was previously specified.

        You can specify a table name only when using temperature (TEMP) and
        heat generation rate (HGEN) body load labels.

        Body loads specified by the BFV command can conflict with other
        specified body loads.  See Resolution of Conflicting Body Load
        Specifications in the Basic Analysis Guide for details.

        Graphical picking is available only via the listed menu paths.

        This command is also valid in PREP7.
        """
        command = "BFV,%s,%s,%s,%s,%s,%s" % (str(volu), str(lab), str(val1), str(val2), str(val3), str(ph_ase))
        return self.run(command, **kwargs)

    def anfile(self, lab="", fname="", ext="", **kwargs):
        """APDL Command: /ANFILE

        Saves or resumes an animation sequence to or from a file.

        Parameters
        ----------
        lab
            Label type.

            SAVE - Save the current animation to a file.

            RESUME - Resume an animation from a file.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        This command saves an animation to a file from local terminal segments
        or resumes an animation from a file to local terminal segments.  See
        the /SEG command for details on segment storage.  See the ANCNTR macro
        for a convenient method of storing graphics frames in terminal memory
        segments.  This command is device dependent and is valid in any
        processor.
        """
        command = "/ANFILE,%s,%s,%s" % (str(lab), str(fname), str(ext))
        return self.run(command, **kwargs)

    def mptgen(self, stloc="", num="", tstrt="", tinc="", **kwargs):
        """APDL Command: MPTGEN

        Adds temperatures to the temperature table by generation.

        Parameters
        ----------
        stloc
            Starting location in table for generating temperatures.  Defaults
            to last location filled + 1.

        num
            Number of temperatures to be generated (1-100).

        tstrt
            Temperature assigned to STLOC location.

        tinc
            Increment previous temperature by TINC and assign to next location
            until all NUM locations are filled.

        Notes
        -----
        Adds temperatures to the temperature table by generation.  May be used
        in combination (or in place of) the MPTEMP command.

        This command is also valid in SOLUTION.
        """
        command = "MPTGEN,%s,%s,%s,%s" % (str(stloc), str(num), str(tstrt), str(tinc))
        return self.run(command, **kwargs)

    def mpdres(self, labf="", matf="", labt="", matt="", **kwargs):
        """APDL Command: MPDRES

        Reassembles existing material data with the temperature table.

        Parameters
        ----------
        labf
            Material property label associated with MATF.

        matf
            Material reference number of property to restore from virtual
            space.

        labt
            Material property label associated with MATT (defaults to label
            associated with MATF).

        matt
            Material reference number assigned to generated property (defaults
            to MATF).

        Notes
        -----
        Restores into the database (from virtual space) a data table previously
        defined [MP] for a particular property, assembles data with current
        database temperature table, and stores back in virtual space as a new
        property.

        This command is also valid in SOLUTION.
        """
        command = "MPDRES,%s,%s,%s,%s" % (str(labf), str(matf), str(labt), str(matt))
        return self.run(command, **kwargs)

    def a(self, p1="", p2="", p3="", p4="", p5="", p6="", p7="", p8="", p9="",
          p10="", p11="", p12="", p13="", p14="", p15="", p16="", p17="",
          p18="", **kwargs):
        """APDL Command: A

        Defines an area by connecting keypoints.

        Parameters
        ----------
        p1, p2, p3, . . . , p18
            List of keypoints defining the area (18 maximum if using keyboard
            entry).  At least 3 keypoints must be entered.  If P1 = P,
            graphical picking is enabled and all remaining arguments are
            ignored (valid only in the GUI).

        Returns
        -------
        result : int
            Returns the area number of the created area or None,
            if something went wrong.

        Notes
        -----
        Keypoints (P1 through P18) must be input in a clockwise or
        counterclockwise order around the area.  This order also determines the
        positive normal direction of the area according to the right-hand rule.
        Existing lines between adjacent keypoints will be used; missing lines
        are generated "straight" in the active coordinate system and assigned
        the lowest available numbers [NUMSTR].  If more than one line exists
        between two keypoints, the shorter one will be chosen.  If the area is
        to be defined with more than four keypoints, the required keypoints and
        lines must lie on a constant coordinate value in the active coordinate
        system (such as a plane or a cylinder).  Areas may be redefined only if
        not yet attached to a volume.  Solid modeling in a toroidal coordinate
        system is not recommended.
        """
        command = "A,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(p1), str(p2), str(p3), str(p4), str(p5), str(p6), str(p7), str(p8), str(p9), str(p10), str(p11), str(p12), str(p13), str(p14), str(p15), str(p16), str(p17), str(p18))
        return self.run(command, **kwargs)

    def hptcreate(self, type="", entity="", nhp="", label="", val1="", val2="",
                  val3="", **kwargs):
        """APDL Command: HPTCREATE

        Defines a hard point.

        Parameters
        ----------
        type
            Type of entity on which the hard point will be created.

            LINE - Hard point will be created on a line.

            AREA - Hard point will be created within an area (not on the boundaries).

        entity
            Number of the line or area on which the hard point will be created.

        nhp
            Number assigned to the hard point.  Defaults to the lowest
            available hard point number.

        label
            If LABEL = COORD, VAL1, VAL2, and VAL3 are the respective global X,
            Y, and Z coordinates.  If LABEL = RATIO, VAL1 is the parameter
            value (this is available only for lines).  Valid parameter values
            are between 0 and 1.  VAL2 and VAL3 are ignored.

        val1
            If LABEL = RATIO, ratio value for line.  If LABEL = COORD, global X
            coordinate value.

        val2
            If LABEL = COORD, global Y coordinate value.

        val3
            If LABEL = COORD, global Z coordinate value.

        Notes
        -----
        The ability to enter a parameter value provides a simple way of
        positioning hard points on lines.  For example, to place a hard point
        halfway along a line, one can simply specify a VAL1 value of 0.5.

        For models imported through the DEFAULT IGES filter, you can place hard
        points on models only by specifying coordinates (you can't place a hard
        point using interactive picking).

        If you issue any commands that update the geometry of an entity, such
        as Boolean or simplification commands, any hard points associated with
        that entity are deleted.  Therefore, you should add any hard points
        after completing the solid model.  If you delete an entity that has
        associated hard points, those hard points are either

        Deleted along with the entity (if the hard point is not associated with
        any other entities).

        Detached from the deleted entity (if the hard point is associated with
        additional entities).

        When archiving your model (CDWRITE), hardpoint information cannot be
        written to the IGES file. The Jobname.cdb file can be written with the
        CDWRITE,DB option.

        Hard points are only applicable for area and volume meshing, not for
        beams.
        """
        command = "HPTCREATE,%s,%s,%s,%s,%s,%s,%s" % (str(type), str(entity), str(nhp), str(label), str(val1), str(val2), str(val3))
        return self.run(command, **kwargs)

    def smcons(self, **kwargs):
        """APDL Command: SMCONS

        Specifies "Constraints on the solid model" as the subsequent status
        topic.

        Notes
        -----
        This is a status [STAT] topic command. Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "SMCONS," % ()
        return self.run(command, **kwargs)

    def tref(self, tref="", **kwargs):
        """APDL Command: TREF

        Defines the reference temperature for the thermal strain calculations.

        Parameters
        ----------
        tref
            Reference temperature for thermal expansion.

        Notes
        -----
        Defines the reference temperature for the thermal strain calculations
        in structural analyses and explicit dynamic analyses.  Thermal strains
        are given by : α *(T-TREF), where α is the coefficient of thermal
        expansion (for more on this see the Mechanical APDL Theory Reference).
        Input the strain via ALPX, ALPY, ALPZ (the secant or mean coefficient
        value), or CTEX, CTEY, CTEZ (the instantaneous coefficient value), or
        the thermal strain value (THSX, THSY, THSZ). T is the element
        temperature. If α is temperature-dependent, TREF should be in the range
        of temperatures you define using the MPTEMP command.

        Reference temperatures may also be input per material by specifying a
        value on the MP material property command:

        MP,REFT,MAT,C0.

        Only a constant (non-temperature-dependent) value is valid. The value
        input on the TREF command applies to all materials not having a
        specified material property definition.

        To convert temperature-dependent secant coefficients of thermal
        expansion (SCTE) data (properties ALPX, ALPY, ALPZ) from the definition
        temperature to the reference temperature defined via a TREF (or
        MP,REFT) command, issue the MPAMOD command.

        This command is also valid in PREP7.
        """
        command = "TREF,%s" % (str(tref))
        return self.run(command, **kwargs)

    def cbdof(self, fname1="", ext1="", fname2="", ext2="", kpos="", clab="",
              kshs="", tolout="", tolhgt="", tolthk="", **kwargs):
        """APDL Command: CBDOF

        Activates cut-boundary interpolation (for submodeling).

        Parameters
        ----------
        fname1
            File name and directory path (248 characters maximum, including
            directory) from which to read boundary node data. If no specified
            directory path exists, the path defaults to your working directory
            and you can use all 248 characters for the file name.

        ext1
            Filename extension (eight-character maximum).

        --
            Unused field.

        fname2
            File name and directory path (248 characters maximum, including
            directory) to which cut-boundary D commands are written. If no
            specified directory path exists, the path defaults to your working
            directory and you can use all 248 characters for the file name.

        ext2
            Filename extension (eight-character maximum).

        --
            Unused field.

        kpos
            Position on Fname2 to write block of D commands:

            0 - Beginning of file (overwrite existing file).

            1 - End of file (append to existing file).

        clab
            Label (eight characters maximum, including the colon) for this
            block of D commands on Fname2.  his label is appended to the colon
            (:).  Defaults to CBn, where n is the cumulative iteration number
            for the data set currently in the database.  For imaginary data
            (see KIMG on the *SET command), Clab defaults to CIn.

        kshs
            Shell-to-solid submodeling key:

            0 - Solid-to-solid or shell-to-shell submodel.

            1 - Shell-to-solid submodel.

        tolout
            Extrapolation tolerance about elements, based on a fraction of the
            element dimension. Submodel nodes outside the element by more than
            TOLOUT are not accepted as candidates for DOF extrapolation.
            Defaults to 0.5 (50 percent).

        tolhgt
            Height tolerance above or below shell elements, in units of length.
            Used only for shell-to-shell submodeling (KSHS = 0). Submodel nodes
            off the element surface by more than TOLHGT are not accepted as
            candidates for degree-of-freedom interpolation or extrapolation.
            Defaults to 0.0001 times the maximum element dimension.

        tolthk
            Height tolerance above or below shell elements, based on a fraction
            of the shell element thickness. Used only for shell-to-solid
            submodeling (KSHS = 1). Submodel nodes off the element surface by
            more than TOLTHK are not accepted as candidates for DOF
            interpolation or extrapolation. Defaults to 0.1 times the average
            shell thickness.

        Notes
        -----
        File Fname1 should contain a node list for which boundary conditions
        are to be interpolated (NWRITE).  File Fname2 is created to contain
        interpolated boundary conditions written as a block of D commands.

        Boundary conditions are written for the active degree-of-freedom set
        for the element from which interpolation is performed. Interpolation
        occurs on the selected set of elements.  The block of D commands begins
        with an identifying colon label and ends with a /EOF command.  The
        colon label is of the form :Clab (described above).

        Interpolation from multiple results sets can be performed by looping
        through the results file in a user-defined macro.  Additional blocks
        can be appended to Fname2 by using KPOS and unique colon labels.  To
        read the block of commands, issue the /INPUT command with the
        appropriate colon label.

        If the model has coincident (or very close) nodes, the CBDOF must be
        applied to each part of the model separately to ensure that the mapping
        of the nodes is correct.  For example, if nodes belonging to two
        adjacent parts linked by springs are coincident, the operation should
        be performed on each part of the model separately.

        Resume the coarse model database at the beginning of the cut-boundary
        procedure. The database should have been saved after the first coarse
        model solution, as the number of nodes in the database and the results
        file must match, and internal nodes are sometimes created during the
        solution.

        Caution:: : Relaxing the TOLHGT or TOLTHK tolerances to allow submodel
        nodes to be “found” can produce poor submodel results.
        """
        command = "CBDOF,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(fname1), str(ext1), str(fname2), str(ext2), str(kpos), str(clab), str(kshs), str(tolout), str(tolhgt), str(tolthk))
        return self.run(command, **kwargs)

    def nsll(self, type="", nkey="", **kwargs):
        """APDL Command: NSLL

        Selects those nodes associated with the selected lines.

        Parameters
        ----------
        type
            Label identifying the type of node select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        nkey
            Specifies whether only interior line nodes are to be selected:

            0 - Select only nodes interior to selected lines.

            1 - Select all nodes (interior to line and at keypoints) associated with the
                selected lines.

        Notes
        -----
        Valid only if the nodes were generated by a line meshing operation
        [LMESH, AMESH, VMESH] on a solid model that contains the associated
        lines.

        This command is valid in any processor.
        """
        command = "NSLL,%s,%s" % (str(type), str(nkey))
        return self.run(command, **kwargs)

    def cs(self, kcn="", kcs="", norig="", nxax="", nxypl="", par1="", par2="",
           **kwargs):
        """APDL Command: CS

        Defines a local coordinate system by three node locations.

        Parameters
        ----------
        kcn
            Arbitrary reference number assigned to this coordinate system.
            Must be greater than 10.  A coordinate system previously defined
            with this number will be redefined.

        kcs
            Coordinate system type:

            0 or CART - Cartesian

            1 or CYLIN - Cylindrical (circular or elliptical)

            2 or SPHE - Spherical (or spheroidal)

            3 or TORO - Toroidal

        norig
            Node defining the origin of this coordinate system.  If NORIG = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).

        nxax
            Node defining the positive x-axis orientation of this coordinate
            system.

        nxypl
            Node defining the x-y plane (with NORIG and NXAX) in the first or
            second quadrant of this coordinate system.

        par1
            Used for elliptical, spheroidal, or toroidal systems.  If KCS = 1
            or 2, PAR1 is the ratio of the ellipse Y-axis radius to X-axis
            radius (defaults to 1.0 (circle)).  If KCS  = 3, PAR1 is the major
            radius of the torus.

        par2
            Used for spheroidal systems.  If KCS = 2, PAR2 = ratio of ellipse
            Z-axis radius to X-axis radius (defaults to 1.0 (circle)).

        Notes
        -----
        Defines and activates a local right-handed coordinate system by
        specifying three existing nodes: to locate the origin, to locate the
        positive x-axis, and to define the positive x-y plane.  This local
        system becomes the active coordinate system.  See the CLOCAL, CSKP,
        CSWPLA, and LOCAL commands for alternate definitions.  Local coordinate
        systems may be displayed with the /PSYMB command.

        This command is valid in any processor.
        """
        command = "CS,%s,%s,%s,%s,%s,%s,%s" % (str(kcn), str(kcs), str(norig), str(nxax), str(nxypl), str(par1), str(par2))
        return self.run(command, **kwargs)

    # def else(self, **kwargs):
    #     """APDL Command: *ELSE

    #     Separates the final if-then-else block.

    #     Notes
    #     -----
    #     Optional final block separator within an if-then-else construct. See
    #     the *IF for details.  If a batch input stream hits an end-of-file
    #     during a false *IF  condition, the ANSYS run will not terminate
    #     normally. You will need to terminate it externally (use either the
    #     Linux “kill” function or the Windows task manager). The *ELSE command
    #     must appear on the same file as the *IF  command, and all five
    #     characters must be input.

    #     This command is valid in any processor.
    #     """
    #     command = "*ELSE," % ()
    #     return self.run(command, **kwargs)

    def nladaptive(self, component="", action="", criterion="", option="",
                   val1="", val2="", val3="", **kwargs):
        """APDL Command: NLADAPTIVE

        Defines the criteria under which the mesh is refined or modified during
        a nonlinear solution.

        Parameters
        ----------
        component
            Specifies the element component upon which this command should act:

            ALL  - All selected components, or all selected elements if no component is selected
                   (default).

            Name - Component name.

        action
            The action to perform on the selected component(s):

            ADD  - Add a criterion to the database.

            LIST  - List the criteria defined for the specified component(s).

            DELETE  - Delete the criteria defined for the specified component(s).

            ON - Enable the defined criteria for the specified component(s) and specify how
                 frequently and when to check them (via ON,,,VAL1,VAL2,VAL3):

            VAL1 -- Checking frequency. If > 0, check criteria at every VAL1 substeps. If < 0, check criteria at each of the VAL1 points (approximately equally spaced) between VAL2 and VAL3. (Default = -1.) - VAL2 -- Checking start time, where VAL2 < VAL3. (Default is the start time of
                              the load step.)

            VAL3 -- Checking end time, where VAL3 > VAL2. (Default is the end time of the load step.)  - OFF

        criterion
            The type of criterion to apply to the selected component(s):

            CONTACT  - Contact-based. (Valid only for Action = ADD, Action = LIST, or Action =
                       DELETE.)

            ENERGY  - Energy-based. (Valid only for Action = ADD, Action = LIST, or Action = DELETE.)

            BOX  - A position-based criterion, defined by a box. (Valid only for Action = ADD,
                   Action = LIST, or Action = DELETE.)

            MESH  - A mesh-quality-based criterion. (Valid only for Action = LIST, or Action =
                    DELETE.)

            ALL  - All criteria and options. (Valid only for Action = LIST or Action = DELETE.
                   Option and all subsequent arguments are ignored.)

        option
            Criterion option to apply to the selected component(s):

            NUMELEM  - For target elements only, define the minimum number of contact elements to
                       contact with each target element. If this criterion is
                       not satisfied, the program refines the contact elements
                       and the associated solid elements. For this option, VAL1
                       must be a positive integer. (Valid only for Action =
                       ADD, Action = LIST, or Action = DELETE. )

            MEAN  - Check the strain energy of any element that is part of the defined component
                    for the condition Ee ≥ c1 * Etotal / NUME (where c1 = VAL1,
                    Etotal is the total strain energy of the component, and
                    NUME is the number of elements of the component). If this
                    criterion is satisfied at an element, the program refines
                    the element. For this option, VAL1 must be non-negative and
                    defaults to 1. (Valid only for Action = ADD, Action = LIST,
                    or Action = DELETE.)

            XYZRANGE  - Define the location box in which all elements within are to be split or
                        refined. Up to six values following the Option argument
                        (representing the x1, x2, y1, y2, z1, and z2
                        coordinates) are allowed. An unspecified coordinate is
                        not checked. (Valid only for Action = ADD, Action =
                        LIST, or Action = DELETE.)

            SKEWNESS - Mesh-quality control threshold for element SOLID285. Valid values (VAL1) are
                       0.0 through 1.0. Default = 0.9. (Valid only for Action =
                       ADD, Action = LIST, or Action = DELETE.)

            WEAR - This option is valid only for contact elements having surface wear specified
                   (TB,WEAR). Define VAL1 as a critical ratio of magnitude of
                   wear to the average depth of the solid element underlying
                   the contact element. Once this critical ratio is reached for
                   any element, the program morphs the mesh to improve the
                   quality of the elements. VAL1 must be a positive integer.
                   (Valid only for Action = ADD, Action = LIST, or Action =
                   DELETE.) The WEAR criterion cannot be combined with any
                   other criterion.

            ALL  - All options. (Valid only for Action = LIST or Action = DELETE. All subsequent
                   arguments are ignored.)

        Notes
        -----
        If a specified component (Component) is an assembly, the defined
        criterion applies to all element components included in the assembly.

        All components must be defined and selected before the first solve
        (SOLVE), although their nonlinear adaptivity criteria can be modified
        from load step to load step, and upon restart. For nonlinear adaptivity
        to work properly, ensure that all components are selected before each
        solve.

        After using this command to define a new criterion, the new criterion
        becomes active and is checked one time during each load step, roughly
        in mid-loading (unless this behavior is changed via Action = ON).

        When a criterion is defined, it overwrites a previously defined
        criterion (if one exists) through the same component, or through the
        component assembly that includes the specified component.

        During solution, the same criteria defined for an element through
        different components are combined, and the tightest criteria and action
        control (Action,ON,,,VAL1) are used. If an ON action is defined by a
        positive VAL1 value through one component and a negative VAL1 value
        through another, the program uses the positive value.

        For Action = ON, if VAL2 (start time) and/or VAL3 (end time) are
        unspecified or invalid, the program uses the start and/or end time
        (respectively) of the load step. If VAL1 < 0, the program checks VAL1
        points between VAL2 and VAL3. The time interval between each check
        points is determined by (VAL3 - VAL2) / (VAL1 + 1), with the first
        check point as close to VAL2 + (VAL3 - VAL2) / (VAL1 + 1) as possible.
        Fewer check points can be used if the number of substeps during
        solution is insufficient (as the program can only check at the end of a
        substep).

        Option = SKEWNESS applies to linear tetrahedral element SOLID285 only.
        When the skewness of a SOLID285 element is >= the defined value, the
        element is used as the core (seed) element of the remeshed region(s).
        If this criterion is used together with any other criteria for the same
        component, the other criteria defined for the component are ignored.
        The most desirable skewness value is 0, applicable when the element is
        a standard tetrahedral element; the highest value is 1, applicable when
        the element becomes flat with zero volume. For more information about
        skewness and remeshing, see Mesh Nonlinear Adaptivity in the Advanced
        Analysis Guide.

        For more granular control of the source mesh geometry, see NLMESH.
        """
        command = "NLADAPTIVE,%s,%s,%s,%s,%s,%s,%s" % (str(component), str(action), str(criterion), str(option), str(val1), str(val2), str(val3))
        return self.run(command, **kwargs)

    def atran(self, kcnto="", na1="", na2="", ninc="", kinc="", noelem="",
              imove="", **kwargs):
        """APDL Command: ATRAN

        Transfers a pattern of areas to another coordinate system.

        Parameters
        ----------
        kcnto
            Reference number of coordinate system where the pattern is to be
            transferred.  Transfer occurs from the active coordinate system.
            The coordinate system type and parameters of KCNTO must be the same
            as the active system.

        na1, na2, ninc
            Transfer area pattern beginning with NA1 to NA2 (defaults to NA1)
            in steps of NINC (defaults to 1).  If NA1 = ALL, NA2 and NINC are
            ignored and the pattern is all selected areas [ASEL].  If NA1 = P,
            graphical picking is enabled and all remaining arguments are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NA1 (NA2 and NINC are ignored).

        kinc
            Keypoint increment between sets.  If zero, the lowest available
            keypoint numbers are assigned [NUMSTR].

        noelem
            Specifies whether elements and nodes are also to be generated:

            0 - Generate nodes and elements associated with the original areas, if they exist.

            1 - Do not generate nodes and elements.

        imove
            Specifies whether to redefine the existing areas:

            0 - Generate additional areas.

            1 - Move original areas to new position retaining the same keypoint numbers (KINC
                and NOELEM are ignored).  Valid only if the old areas are no
                longer needed at their original positions.  Corresponding
                meshed items are also moved if not needed at their original
                position.

        Notes
        -----
        Transfers a pattern of areas (and their corresponding lines, keypoints
        and mesh) from one coordinate system to another (see analogous node
        TRANSFER command).  The MAT, TYPE, REAL, and ESYS attributes are based
        upon the areas in the pattern and not upon the current settings.
        Coordinate systems may be translated and rotated relative to each
        other.  Initial pattern may be generated in any coordinate system.
        However, solid modeling in a toroidal coordinate system is not
        recommended.  Coordinate and slope values are interpreted in the active
        coordinate system and are transferred directly.  Areas are generated as
        described in the AGEN command.
        """
        command = "ATRAN,%s,%s,%s,%s,%s,%s,%s" % (str(kcnto), str(na1), str(na2), str(ninc), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def cycspec(self, label="", node="", item="", comp="", **kwargs):
        """APDL Command: CYCSPEC

        Defines the set of result items for a subsequent CYCCALC command in
        postprocessing a cyclic harmonic mode-superposition analysis.

        Parameters
        ----------
        label
            One of the following labels:

            ADD - Adds a new specification to the set (default). The maximum number of
                  specifications that can be defined is 50.

            LIST - Lists the current set of specifications. Node, Item, Comp are ignored.

            ERASE - Erases the current set of specifications. Node, Item, Comp are ignored.

            DELETE - Deletes an existing specification. Item, Comp are ignored.

        node
            The node at which to evaluate the results. If Node is a nodal
            component, then all nodes in the component are included. All
            sectors containing this node (or set of nodes) are evaluated.

        item
            Specifies the type of values to evaluate:

            U - Displacement

            S - Stress

            EPEL - Elastic strain

        comp
            Specifies the specific component of displacement, stress, or strain
            to evaluate:

            X,Y,Z - Direct components

            XY,YZ,XZ - Shear components (stress and strain only)

            1,2,3 - Principal values (stress and strain only)

            EQV - Equivalent value (stress and strain only)

            SUM - Vector sum (displacement only)

            NORM - L2 norm for the set of nodes (displacement only)

        Notes
        -----
        Up to 50 specifications can be defined for use in a subsequent CYCCALC
        command. If more than 50 specifications are desired, erase the table
        after the CYCCALC operation and add new specifications and repeat the
        CYCCALC command. All the specified nodes, items, and components are
        evaluated for all sectors and the maximum amplitude value output. For
        combined stresses and strains (Comp = 1,2,3 or EQV) or displacement
        vector sum (Comp = SUM), a 360 degree phase sweep is performed at each
        location to determine the maximum.

        Additional POST1 controls are used to refine the specification. For
        component values, components are in the RSYS direction. For shell
        elements, the results are at the SHELL location. For EPEL,EQV, the
        results are based on the EFFNU value on the AVPRIN command. The
        controls active when the CYCCALC command is issued determine the result
        values. If results at another SHELL location are desired, issue the new
        SHELL command and then re-issue the CYCCALC command.

        If a single node is input, the Item/Comp value at that location in each
        sector is output. If a node component is given, then the maximum
        Item/Comp value within the set of nodes of each sector is output, one
        value for each sector (the node of the maximum may vary from sector to
        sector). For stress and strain items, only corner nodes are valid.

        For the displacement norm option (Item = U, Comp = NORM), the L2 norm
        computed from all the nodes in the component is output, one per sector.
        """
        command = "CYCSPEC,%s,%s,%s,%s" % (str(label), str(node), str(item), str(comp))
        return self.run(command, **kwargs)

    def adams(self, nmodes="", kstress="", kshell="", **kwargs):
        """APDL Command: ADAMS

        Performs solutions and writes flexible body information to a modal
        neutral file (Jobname.MNF) for use in an ADAMS analysis.

        Parameters
        ----------
        nmodes
            Number of normal modes to be written to Jobname.MNF file (no
            default).

        kstress
            Specifies whether to write stress or strain results:

            0 - Do not write stress or strain results (default).

            1 - Write stress results.

            2 - Write strain results.

            3 - Write both stress and strain results.

        kshell
            Shell element output location. This option is valid only for shell
            elements.

            0, 1 - Shell top surface (default).

            2 - Shell middle surface.

            3 - Shell bottom surface.

        Notes
        -----
        ADAMS invokes a predefined ANSYS macro that solves a series of analyses
        and then writes the modal neutral file, Jobname.MNF. This file can be
        imported into the ADAMS program in order to perform a rigid body
        dynamics simulation. For detailed information on how to use the ADAMS
        command macro to create a modal neutral file, see Rigid Body Dynamics
        and the ANSYS-ADAMS Interface in the Substructuring Analysis Guide.

        Before running the ADAMS command macro, you must specify the units with
        the /UNITS command. The interface points should be the only selected
        nodes when the command macro is initiated. (Interface points are nodes
        where constraints may be applied in ADAMS.) Only selected elements will
        be considered in the calculations.

        By default, stress and strain data is transferred to the ADAMS program
        for all nodes, as specified by the KSTRESS value.  If you want to
        transfer stress/strain data for only a subset of nodes, select the
        desired subset and create a node component named "STRESS" before
        running the ADAMS command macro.  For example, you may want to select
        exterior nodes for the purpose of visualization in the ADAMS program.

        The default filename for the modal neutral file is Jobname.MNF. In
        interactive (GUI) mode, you can specify a filename other than
        Jobname.MNF. In batch mode, there is no option to change the filename,
        and the modal neutral file is always written to Jobname.MNF.
        """
        command = "ADAMS,%s,%s,%s" % (str(nmodes), str(kstress), str(kshell))
        return self.run(command, **kwargs)

    def write(self, fname="", **kwargs):
        """APDL Command: WRITE

        Writes the radiation matrix file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        Notes
        -----
        Writes radiation matrix file (File.SUB) for input to the substructure
        thermal "use" pass.  Subsequent WRITE operations to the same file
        overwrite the file.
        """
        command = "WRITE,%s" % (str(fname))
        return self.run(command, **kwargs)

    def mpdata(self, lab="", mat="", sloc="", c1="", c2="", c3="", c4="",
               c5="", c6="", **kwargs):
        """APDL Command: MPDATA

        Defines property data to be associated with the temperature table.

        Parameters
        ----------
        lab
            Valid property label.  Applicable labels are listed under "Material
            Properties" in the input table for each element type in the Element
            Reference.  See Linear Material Properties in the Mechanical APDL
            Material Reference for more complete property label definitions:

            ALPD - Mass matrix multiplier for damping.

            ALPX - Secant coefficients of thermal expansion (also ALPY, ALPZ).  (See also MPAMOD
                   command for adjustment to reference temperature).

            BETD - Stiffness matrix multiplier for damping.

            BETX - Coefficient of diffusion expansion (also BETY, BETZ)

            C - Specific heat.

            CREF - Reference concentration (may not be temperature dependent)

            CSAT - Saturated concentration

            CTEX - Instantaneous coefficients of thermal expansion (also CTEY, CTEZ).

            DENS - Mass density.

            DMPR - Constant material damping coefficient.

            DXX - Diffusivity coefficients (also DYY, DZZ)

            EMIS - Emissivity.

            ENTH - Enthalpy.

            EX - Elastic moduli (also EY, EZ).

            GXY - Shear moduli (also GYZ, GXZ).

            HF - Convection or film coefficient.

            KXX - Thermal conductivities (also KYY, KZZ).

            LSST - Dielectric loss tangent.

            MGXX - Magnetic coercive forces (also MGYY, MGZZ).

            MU - Coefficient of friction.

            MURX - Magnetic relative permeabilities (also MURY, MURZ).

            NUXY - Minor Poisson's ratios (also NUYZ, NUXZ).

            PERX - Electric relative permittivities (also PERY, PERZ).

            PRXY - Major Poisson's ratios (also PRYZ, PRXZ).

            QRATE - Heat generation rate.

            REFT - Reference temperature (may not be temperature dependent).

            RH - Hall Coefficient.

            RSVX - Electrical resistivities (also RSVY, RSVZ).

            SBKX - Seebeck coefficients (also SBKY, SBKZ).

            SONC - Sonic velocity.

            THSX - Thermal strain (also THSY, THSZ).

            VISC - Viscosity.

        mat
            Material reference number to be associated with the elements
            (defaults to 1 if you specify zero or no material number).

        sloc
            Starting location in table for generating data.  For example, if
            SLOC = 1, data input in the C1 field is the first constant in the
            table.  If SLOC = 7, data input in the C1 field is the seventh
            constant in the table, etc.  Defaults to the last location filled +
            1.

        c1, c2, c3, . . . , c6
            Property data values assigned to six locations starting with SLOC.
            If a value is already in this location, it is redefined.  A blank
            (or zero) value for C1 resets the previous value in SLOC to zero.
            A value of zero can only be assigned by C1.  Blank (or zero) values
            for C2 to C6 leave the corresponding previous values unchanged.

        Notes
        -----
        Defines a table of property data to be associated with the temperature
        table.  Repeat MPDATA command for additional values (100 maximum).
        Temperatures must be defined first [MPTEMP].  Also stores assembled
        property function table (temperature and data) in virtual space.

        This command is also valid in SOLUTION.

        Without Emag enabled, the MUR_ and MG__ properties are not allowed.  In
        ANSYS Professional, all structural and thermal properties are allowed
        except ALPD, BETD, and MU.  In ANSYS Emag, only the RSV_, PER_, MUR_,
        and MG__ properties are allowed. Only products that include ANSYS Emag
        can use the LSST property. The SBK_ property is only available in ANSYS
        Multiphysics and ANSYS PrepPost.
        """
        command = "MPDATA,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(lab), str(mat), str(sloc), str(c1), str(c2), str(c3), str(c4), str(c5), str(c6))
        return self.run(command, **kwargs)

    def mfrc(self, freq="", maxfiles="", **kwargs):
        """APDL Command: MFRC

        Controls file writing for multiframe restarts for the ANSYS Multi-field
        solver.

        Parameters
        ----------
        freq
            Frequency at which the .Xnnn files are written.

            0 - Do not write any .Xnnn files for this simulation

            LAST - Write the .Xnnn files for the last multifield time step (default).

            N - If N is a positive number, write the .Xnnn file every Nth multifield time step.

        maxfiles
            Maximum number of .Xnnn files to save for a multifield analysis.

            0 - Do not overwrite existing .Xnnn files (default). The total maximum number of
                .Xnnn files for one run is 999. If this number is reached
                before the analysis is complete, the analysis will continue,
                but will no longer write .Xnnn files.

            N - The maximum number of .Xnnn file to keep for this multifield simulation. When
                this number of .Rnnn have been written, ANSYS will overwrite
                the first .Xnnn file of the subsequent multifield time step.

        Notes
        -----
        This command sets up the restart parameters for a multiframe restart,
        allowing you to restart an analysis from any multifield time step for
        which there is a .Rnnn file. You can perform a multiframe restart only
        for nonlinear static and full transient structural, thermal and
        thermal- structural (see RESCONTROL for details).

        If you have many multifield time steps, and are writing .Xnnn files
        frequently, use MAXFILES to limit the number of .Xnnn files saved,
        since these files can fill up your disk quickly.

        For a CFX analysis, you must also configure the MFOUTPUT and MFRSTART
        settings to ensure consistent time points for postprocessing and
        restart simulation.

        For MFX simulation, the RESCONTROL command will be ignored.

        Default Behavior

        In nonlinear static and full transient analyses, the default behavior
        is multiframe restart. (MFRC,LAST). By default, the .Rnnn file is
        written at the last multifield time step . An .Rnnn file and
        corresponding load set of .ldhi files is also written at the multifield
        time step prior to the abort point of the run if an abort file was
        used, or if the job terminated because of a failure to converge or some
        other solution error. No information at the aborted multifield time
        step is saved in either the .Rnnn file or the .ldhi file.

        This command cannot be issued after restarting a multifield analysis.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFRC,%s,%s" % (str(freq), str(maxfiles))
        return self.run(command, **kwargs)

    def mmass(self, option="", zpa="", **kwargs):
        """APDL Command: MMASS

        Specifies the missing mass response calculation.

        Parameters
        ----------
        option
            Flag to activate or deactivate missing mass response calculation.

            0 (OFF or NO) - Deactivate (default).

            1 (ON or YES) - Activate.

        zpa
            Zero Period Acceleration Value. If a scale factor FACT is defined
            on the SVTYP command, it is applied to this value.

        Notes
        -----
        The missing mass calculation is valid only for single point excitation
        response spectrum analysis (SPOPT, SPRS) and for multiple point
        response spectrum analysis (SPOPT, MPRS) performed with base excitation
        using acceleration response spectrum loading. Missing mass is supported
        in a spectrum analysis only when the preceding modal analysis is
        performed with the Block Lanczos, PCG Lanczos, Supernode, or Subspace
        eigensolver (Method =LANB, LANPCG, SNODE, or SUBSP on the MODOPT
        command).

        The velocity solution is not available (Label = VELO on the combination
        command: SRSS, CQC...) when the missing mass calculation is activated.

        The missing mass calculation is not supported when the spectrum
        analysis is based on a linear perturbation modal analysis performed
        after a nonlinear base analysis.

        The missing mass is not supported when superelements are present.

        To take into account the contribution of the truncated modes, the
        residual vector (RESVEC) can be used in place of the missing mass
        response. This is of particular interest if the velocity solution is
        requested or if a nonlinear prestress is included in the analysis
        (linear perturbation), or if a superelement is present, since the
        missing mass cannot be used in these cases.

        In a multiple point response spectrum analysis (SPOPT,MPRS), the MMASS
        command must precede the participation factor calculation command
        (PFACT).

        This command is also valid in PREP7.
        """
        command = "MMASS,%s,%s" % (str(option), str(zpa))
        return self.run(command, **kwargs)

    def trpdel(self, ntrp1="", ntrp2="", trpinc="", **kwargs):
        """APDL Command: TRPDEL

        Deletes particle flow or charged particle trace points.

        Parameters
        ----------
        ntrp1, ntrp2, trpinc
            Delete points from NTRP1 to NTRP2 (defaults to NTRP1) in steps of
            TRPINC (defaults to 1).  If NTRP1 = ALL, NTRP2 and TRPINC are
            ignored and all trace points are deleted.  If NTRP1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).

        Notes
        -----
        Deletes particle flow or charged particle trace points defined with the
        TRPOIN command.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "TRPDEL,%s,%s,%s" % (str(ntrp1), str(ntrp2), str(trpinc))
        return self.run(command, **kwargs)

    def estif(self, kmult="", **kwargs):
        """APDL Command: ESTIF

        Specifies the matrix multiplier for deactivated elements.

        Parameters
        ----------
        kmult
            Stiffness matrix multiplier for deactivated elements (defaults to
            1.0E-6).

        Notes
        -----
        Specifies the stiffness matrix multiplier for elements deactivated with
        the EKILL command (birth and death).

        This command is also valid in PREP7.
        """
        command = "ESTIF,%s" % (str(kmult))
        return self.run(command, **kwargs)

    def wsprings(self, **kwargs):
        """APDL Command: WSPRINGS

        Creates weak springs on corner nodes of a bounding box of the currently
        selected elements.

        Notes
        -----
        WSPRINGS invokes a predefined ANSYS macro that is used during the
        import of loads from the ADAMS program into the ANSYS program. WSPRINGS
        creates weak springs on the corner nodes of the bounding box of the
        currently selected elements. The six nodes of the bounding box are
        attached to ground using COMBIN14 elements. The stiffness is chosen as
        a small number and can be changed by changing the real constants of the
        COMBIN14 elements. This command works only for models that have a
        geometric extension in two or three dimensions. One dimensional
        problems (pure beam in one axis) are not supported.

        For more information on how WSPRINGS is used during the transfer of
        loads from the ADAMS program to ANSYS, see Import Loads into ANSYS in
        the Substructuring Analysis Guide.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "WSPRINGS," % ()
        return self.run(command, **kwargs)

    def fsnode(self, node="", nev="", nlod="", **kwargs):
        """APDL Command: FSNODE

        Calculates and stores the stress components at a node for fatigue.

        Parameters
        ----------
        node
            Node number for which stress components are stored.

        nev
            Event number to be associated with these stresses (defaults to 1).

        nlod
            Loading number to be associated with these stresses (defaults to
            1).

        Notes
        -----
        Calculates and stores the total stress components at a specified node
        for fatigue.  Stresses are stored according to the event number and
        loading number specified.  The location is associated with that
        previously defined for this node [FL] or else it is automatically
        defined.  Stresses are stored as six total components (SX through SYZ).
        Temperature and current time are also stored along with the total
        stress components.  Calculations are made from the stresses currently
        in the database (last SET or LCASE command).  Stresses stored are in
        global Cartesian coordinates, regardless of the active results
        coordinate system [RSYS].  The FSLIST command may be used to list
        stresses.  The FS command can be used to modify stored stresses.
        """
        command = "FSNODE,%s,%s,%s" % (str(node), str(nev), str(nlod))
        return self.run(command, **kwargs)

    def edclist(self, num="", **kwargs):
        """APDL Command: EDCLIST

        Lists contact entity specifications in an explicit dynamics analysis.

        Parameters
        ----------
        num
            Number identifying contact entity to be listed. Use NUM = ALL to
            list all contact entities (ALL is the default).

        Notes
        -----
        Lists contact entity specifications previously defined with the EDCGEN
        command. The listing will include any contact parameters defined using
        the EDCMORE command.

        This command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDCLIST,%s" % (str(num))
        return self.run(command, **kwargs)

    def noerase(self, **kwargs):
        """APDL Command: /NOERASE

        Prevents the screen erase between displays.

        Notes
        -----
        Preventing the normal screen erase between requested displays allows
        you to overlay multiple views.

        Clearing the screen with the ERASE command (Utility Menu> PlotCtrls>
        Erase Options> Erase screen) active simply clears the display area.
        Subsequent replots will provide the cumulative plots previously
        generated by the /NOERASE command.

        For 3-D devices, you can issue /DV3D,DELS to suppress repeated screen
        overlays and generate clear contour plots.

        Use the /ERASE command to reactivate automatic screen erase.

        For 3-D devices (/SHOW,3D), the model in all active windows will be the
        same, even if you issue a different display command (NPLOT, EPLOT,
        etc.) for each active window.  Use the Multi-Plot command (GPLOT) to
        display different entities, in different windows, on 3-D devices.

        This command is valid in any processor.
        """
        command = "/NOERASE," % ()
        return self.run(command, **kwargs)

    def spopt(self, sptype="", nmode="", elcalc="", modereusekey="", **kwargs):
        """APDL Command: SPOPT

        Selects the spectrum type and other spectrum options.

        Parameters
        ----------
        sptype
            Spectrum type:

            SPRS - Single point excitation response spectrum (default).  See also the SVTYP
                   command.

            MPRS - Multiple point excitation response spectrum.

            DDAM - Dynamic design analysis method.

            PSD - Power spectral density.

        nmode
            Use the first NMODE modes from the modal analysis.  Defaults to all
            extracted modes, as specified by the MODOPT and BUCOPT commands.
            NMODE cannot be larger than 10000.

        elcalc
            Element results calculation key (for Sptype = PSD only):

            NO - Do not calculate element results and reaction forces (default).

            YES - Calculate element results and reaction forces, as well as the nodal degree of
                  freedom solution.

        modereusekey
            Key for existing MODE file reuse when running multiple spectrum
            analyses:

            NO - No spectrum analysis has been performed yet (default).

            YES - This is not the first spectrum analysis.  The MODE file will be reused and the
                  necessary files will be cleaned up for the new spectrum
                  analysis.

        Notes
        -----
        Valid only for a spectrum analysis (ANTYPE,SPECTR).  This operation
        must be preceded by a modal solution (ANTYPE,MODAL) with the
        appropriate files available.  Both the spectrum analysis and the
        preceding modal analysis must be performed under the same ANSYS version
        number.

        If used in SOLUTION, this command is valid only within the first load
        step.

        This command is also valid in PREP7.

        Only Sptype = SPRS is allowed in ANSYS Professional.
        """
        command = "SPOPT,%s,%s,%s,%s" % (str(sptype), str(nmode), str(elcalc), str(modereusekey))
        return self.run(command, **kwargs)

    def vdrag(self, na1="", na2="", na3="", na4="", na5="", na6="", nlp1="",
              nlp2="", nlp3="", nlp4="", nlp5="", nlp6="", **kwargs):
        """APDL Command: VDRAG

        Generates volumes by dragging an area pattern along a path.

        Parameters
        ----------
        na1, na2, na3, . . . , na6
            List of areas in the pattern to be dragged (6 maximum if using
            keyboard entry).  If NA1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  If
            NA1 = ALL, all selected areas will be swept along the path.  A
            component name may also be substituted for NA1.

        nlp1, nlp2, nlp3, . . . , nlp6
            List of lines defining the path along which the pattern is to  be
            dragged (6 maximum if using keyboard entry).  Must be a continuous
            set of lines.  To be continuous, adjacent lines must share the
            connecting keypoint (the end keypoint of one line must also be
            first keypoint of the next line).

        Notes
        -----
        Generates volumes (and their corresponding keypoints, lines, and areas)
        by sweeping a given area pattern along a characteristic drag path.  If
        the drag path consists of multiple lines, the drag direction is
        determined by the sequence in which the path lines are input (NLP1,
        NLP2, etc.).  If the drag path is a single line (NLP1), the drag
        direction is from the keypoint on the drag line that is closest to the
        first keypoint of the given area pattern to the other end of the drag
        line.

        The magnitude of the vector between the keypoints of the given pattern
        and the first path keypoint remains constant for all generated keypoint
        patterns and the path keypoints.  The direction of the vector relative
        to the path slope also remains constant so that patterns may be swept
        around curves.  Lines are generated with the same shapes as the given
        pattern and the path lines.

        Keypoint, line, area, and volume numbers are automatically assigned
        (beginning with the lowest available values [NUMSTR]).  Adjacent lines
        use a common keypoint, adjacent areas use a common line, and adjacent
        volumes use a common area.  For best results, the entities to be
        dragged should be orthogonal to the start of the drag path.  Drag
        operations that produce an error message may create some of the desired
        entities prior to terminating.

        If element attributes have been associated with the input area via the
        AATT command, the opposite area generated by the VDRAG operation will
        also have those attributes (i.e., the element attributes from the input
        area are copied to the opposite area).  Note that only the area
        opposite the input area will have the same attributes as the input
        area; the areas adjacent to the input area will not.

        If the input areas are meshed or belong to a meshed volume, the area(s)
        can be extruded to a 3-D mesh.  Note that the NDIV argument of the
        ESIZE command should be set before extruding the meshed areas.
        Alternatively, mesh divisions can be specified directly on the drag
        line(s) (LESIZE).  See the Modeling and Meshing Guide for more
        information.

        You can use the VDRAG command to generate 3-D interface element meshes
        for elements INTER194 and INTER195. When generating interface element
        meshes using VDRAG, you must specify the line divisions to generate one
        interface element directly on the drag line using the LESIZE command.
        The source area to be extruded becomes the bottom surface of the
        interface element. Interface elements must be extruded in what will
        become the element's local x direction, that is, bottom to top.
        """
        command = "VDRAG,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(na1), str(na2), str(na3), str(na4), str(na5), str(na6), str(nlp1), str(nlp2), str(nlp3), str(nlp4), str(nlp5), str(nlp6))
        return self.run(command, **kwargs)

    def dlist(self, node1="", node2="", ninc="", **kwargs):
        """APDL Command: DLIST

        Lists DOF constraints.

        Parameters
        ----------
        node1, node2, ninc
            List constraints for nodes NODE1 to NODE2 (defaults to NODE1) in
            steps of NINC (defaults to 1).  If ALL (default), NODE2 and NINC
            are ignored and constraints for all selected nodes [NSEL] are
            listed.  If NODE1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  A
            component name may also be substituted for NODE1(NODE2 and NINC are
            ignored).

        Notes
        -----
        Listing applies to the selected nodes [NSEL] and the selected degree of
        freedom labels [DOFSEL].

        This command is valid in any processor.
        """
        command = "DLIST,%s,%s,%s" % (str(node1), str(node2), str(ninc))
        return self.run(command, **kwargs)

    def vtype(self, nohid="", nzone="", **kwargs):
        """APDL Command: VTYPE

        Specifies the viewing procedure used to determine the form factors for
        the Radiation Matrix method.

        Parameters
        ----------
        nohid
            Type of viewing procedure:

            0 - Hidden procedure.

            1 - Non-hidden (faster, but less general) procedure.

        nzone
            Number of sampling zones for the hidden procedure (100 maximum for
            3-D, 1000 maximum for 2-D).  Defaults to 20 for 3-D, 200 for 2-D.
            Number of points is 2*NZONE for 2-D and 2*NZONE*(NZONE+1) for 3-D.
        """
        command = "VTYPE,%s,%s" % (str(nohid), str(nzone))
        return self.run(command, **kwargs)

    def edcontact(self, sfsi="", rwpn="", ipck="", shtk="", peno="", stcc="",
                  orie="", cspc="", penchk="", **kwargs):
        """APDL Command: EDCONTACT

        Specifies contact surface controls for an explicit dynamics analysis.

        Parameters
        ----------
        sfsi
            Scale factor for sliding interface penalties. Defaults to 0.1.

        rwpn
            Scale factor for rigid wall penalties (defaults to 0). If RWPN = 0,
            rigid bodies interacting with rigid walls are not considered. If
            RWPN>0, rigid bodies interact with fixed rigid walls. A value of
            1.0 should be optimal; however, this may be problem dependent.

        ipck
            Initial contact surface penetration checking option:

            1 - No checking.

            2 - Full check of initial penetration is performed (default).

        shtk
            Shell thickness contact option for surface-to-surface and nodes-to-
            surface contact (see Notes below):

            0 - Thickness is not considered (default).

            1 - Thickness is considered, except in rigid bodies.

            2 - Thickness is considered, including rigid bodies.

        peno
            Penalty stiffness option (options 4 and 5 are useful for metal
            forming calculations):

            1 - Minimum of master segment and slave node (default).

            2 - Use master segment stiffness.

            3 - Use slave node value.

            4 - Use area or mass weighted slave node value.

            5 - Use slave node value inversely proportional to shell thickness. (This may
                require special scaling and is not generally recommended.)

        stcc
            Shell thickness change option for single surface contact:

            1 - Shell thickness changes are not considered (default).

            2 - Shell thickness changes are included.

        orie
            Option for automatic reorientation of contact surface segments
            during initialization:

            1 - Activate for automated (part ID) input only (default).

            2 - Activate for manual (nodal component) and automated (part ID) input.

            3 - Do not activate.

        cspc
            Contact surface penetration check multiplier, used if small
            penetration checking is on (PENCHK = 1 or 2). Defaults to 4.

        penchk
            Small penetration check, used only for contact types STS, NTS,
            OSTS, TNTS, and TSTS. If the contact surface node penetrates more
            than the target thickness times CSPC, the penetration is ignored
            and the contacting node is set free. The target thickness is the
            element thickness for shell elements, or 1/20 of the shortest
            diagonal for solid elements.

            0 - Penetration checking is off (default).

            1 - Penetration checking is on.

            2 - Penetration checking is on, but shortest diagonal is used.

        Notes
        -----
        The thickness offsets are always included in single surface, automatic
        surface-to-surface, and automatic nodes-to-surface contact. The shell
        thickness change option must be used [EDSHELL,,,1] and a nonzero value
        must be specified for SHTK before the shell thickness changes can be
        included in the surface-to-surface contact type. Additionally, STCC
        must be set to 2 if thickness changes are to be included in the single
        surface contact algorithms.

        To reset the contact options to default values, issue the EDCONTACT
        command with no fields specified.

        This command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDCONTACT,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(sfsi), str(rwpn), str(ipck), str(shtk), str(peno), str(stcc), str(orie), str(cspc), str(penchk))
        return self.run(command, **kwargs)

    def cmmod(self, cname="", keyword="", value="", **kwargs):
        """APDL Command: CMMOD

        Modifies the specification of a component.

        Parameters
        ----------
        cname
            Name of the existing component or assembly to be modified.

        keyword
            The label identifying the type of value to be modified.

        value
            If Keyword is NAME, then the value is the alphanumeric label to be
            applied. See the CM command for naming convention details. If a
            component named Value already exists, the command will be ignored
            and an error message will be generated.

        Notes
        -----
        The naming conventions for components, as specified in the CM command,
        apply for CMMOD (32 characters, “ALL”, “STAT” and “DEFA” are not
        allowed, etc.). However, if you choose a component name that is already
        designated for another component, an error message will be issued and
        the command will be ignored.

        This command is valid in any processor.
        """
        command = "CMMOD,%s,%s,%s" % (str(cname), str(keyword), str(value))
        return self.run(command, **kwargs)

    def unpause(self, **kwargs):
        """APDL Command: UNPAUSE

        Restores use of a temporarily released product license.

        Notes
        -----
        The UNPAUSE command restores use of a temporarily released (paused)
        product license. The command is valid only after a previously issued
        PAUSE command.

        When use of the product license is paused via the PAUSE command, no
        other operation (other than SAVE or /EXIT) is possible until you issue
        the UNPAUSE command.

        For more information, see the documentation for the PAUSE command and
        the ANSYS, Inc. Licensing Guide.
        """
        command = "UNPAUSE," % ()
        return self.run(command, **kwargs)

    def cyl5(self, xedge1="", yedge1="", xedge2="", yedge2="", depth="",
             **kwargs):
        """APDL Command: CYL5

        Creates a circular area or cylindrical volume by end points.

        Parameters
        ----------
        xedge1, yedge1
            Working plane X and Y coordinates of one end of the circle or
            cylinder face.

        xedge2, yedge2
            Working plane X and Y coordinates of the other end of the circle or
            cylinder face.

        depth
            The perpendicular distance (either positive or negative based on
            the working plane Z direction) from the working plane representing
            the depth of the cylinder.  If DEPTH = 0 (default), a circular area
            is created on the working plane.

        Notes
        -----
        Defines a circular area anywhere on the working plane or a cylindrical
        volume with one face anywhere on the working plane by specifying
        diameter end points.  For a solid cylinder of 360°, the top and bottom
        faces will be circular (each area defined with four lines) and they
        will be connected with two surface areas (each spanning 180°).  See the
        CYL4, PCIRC, and CYLIND commands for alternate ways to create circles
        and cylinders.
        """
        command = "CYL5,%s,%s,%s,%s,%s" % (str(xedge1), str(yedge1), str(xedge2), str(yedge2), str(depth))
        return self.run(command, **kwargs)

    def fmagsum(self, cnam1="", cnam2="", cnam3="", cnam4="", cnam5="",
                cnam6="", cnam7="", cnam8="", cnam9="", **kwargs):
        """APDL Command: FMAGSUM

        Summarizes electromagnetic force calculations on element components.

        Parameters
        ----------
        cnam1, cnam2, cnam3, . . . , cnam9
            Names of existing element components for which Maxwell or virtual
            work boundary conditions were applied in the preprocessor.  Must be
            enclosed in single quotes (e.g., `Cnam1') when the command is
            manually typed in.

        Notes
        -----
        FMAGSUM invokes an ANSYS macro that summarizes the Maxwell and virtual
        work forces.  The element components must have had appropriate Maxwell
        or virtual work boundary conditions established in the preprocessor
        prior to solution in order to retrieve forces (see FMAGBC, SF, BF
        commands). The forces are also stored on a per-element basis for the
        adjacent air layer surrounding the components in the element table
        [ETABLE].  Maxwell forces are stored as items FMX_X, FMX_Y, and FMX_Z,
        and virtual work forces are stored as items FVW_X, FVW_Y, and FVW_Z.
        Use the PLETAB and PRETAB commands to plot and list the element table
        items.

         If using elements PLANE121, SOLID122, SOLID123, PLANE233, SOLID236,
        and SOLID237, use EMFT to summarize electromagnetic force and torque.

        FMAGSUM can also be used to summarize time-average forces from a 2-D
        harmonic analysis.
        """
        command = "FMAGSUM,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(cnam1), str(cnam2), str(cnam3), str(cnam4), str(cnam5), str(cnam6), str(cnam7), str(cnam8), str(cnam9))
        return self.run(command, **kwargs)

    def ui(self, func="", type="", format="", screen="", color="", krev="",
           orient="", compress="", quality="", **kwargs):
        """APDL Command: /UI

        Activates specified GUI dialog boxes.

        Parameters
        ----------
        func
            Label identifying the dialog box to be activated:

            HELP - Activates the online help system. Valid only in non-UI graphics mode
                   (/MENU,GRPH).

            VIEW - Activates the Pan, Zoom, Rotate dialog box

            WPSE - Activates the Working Plane Settings dialog box.

            WPVI - Activates the Offset Working Plane dialog box.

            RESULT - Activates the Query Picking Menu for reviewing results.

            QUERY - Activates the Query Picked Entities (preprocess) dialog box.

            COPY - Activates the Hard Copy dialog box.

            ANNO - Activates the 2D Annotation dialog box.

            AN3D - Activates the 3D Annotation dialog box.

            SELECT - Activates the Select Entities dialog box.

            NSEL - Activates a picking menu to select nodes.

            ESEL - Activates a picking menu to select elements.

            KSEL - Activates a picking menu to select keypoints.

            LSEL - Activates a picking menu to select lines.

            ASEL - Activates a picking menu to select areas.

            VSEL - Activates a picking menu to select volumes.

            REFRESH - Refreshes the graphics window (non-UI mode only).

            COLL - Controls the collapse of the ANSYS Main Menu when a FINISH command is issued.
                   See Type below for a discussion of the arguments.

        type
            Label identifying the type of select operation.  Valid only for the
            following Func labels; NSEL, ESEL, KSEL, LSEL, ASEL, and VSEL:

            S - Select a new set.

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        Notes
        -----
        Allows you to activate specified GUI dialog boxes directly in either
        GUI or non-GUI mode.
        """
        command = "/UI,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(func), str(type), str(format), str(screen), str(color), str(krev), str(orient), str(compress), str(quality))
        return self.run(command, **kwargs)

    def ktran(self, kcnto="", np1="", np2="", ninc="", kinc="", noelem="",
              imove="", **kwargs):
        """APDL Command: KTRAN

        Transfers a pattern of keypoints to another coordinate system.

        Parameters
        ----------
        kcnto
            Reference number of coordinate system where the pattern is to be
            transferred.  Transfer occurs from the active coordinate system.

        np1, np2, ninc
            Transfer keypoints from pattern beginning with NP1 to NP2 (defaults
            to NP1) in steps of NINC (defaults to 1).  If NP1 = ALL, NP2 and
            NINC are ignored and pattern is all selected keypoints [KSEL].  If
            NP1 = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI).  A component name may
            also be substituted for NP1 (NP2 and NINC are ignored).

        kinc
            Keypoint increment between sets.  If zero, the lowest available
            keypoint numbers are assigned [NUMSTR].

        noelem
            Specifies whether nodes and elements are also to be generated:

            0 - Generate nodes and point elements associated with the original keypoints, if
                they exist.

            1 - Do not generate nodes and elements.

        imove
            Specifies whether keypoints will be moved or newly defined:

            0 - Generate additional keypoints.

            1 - Move original keypoints to new position retaining the same keypoint numbers
                (KINC and NOELEM are ignored).  Valid only if the old keypoints
                are no longer needed at their original positions.
                Corresponding meshed items are also moved if not needed at
                their original position.

        Notes
        -----
        Transfers a pattern of keypoints (and corresponding mesh) from one
        coordinate system to another (see analogous node transfer command,
        TRANSFER).  The MAT, TYPE, REAL, and ESYS attributes are based upon the
        keypoints in the pattern and not upon the current settings.  Coordinate
        systems may be translated and rotated relative to each other.  Initial
        pattern may be generated in any coordinate system.  Coordinate values
        are interpreted in the active coordinate system and are transferred
        directly.  Solid modeling in a toroidal coordinate system is not
        recommended.
        """
        command = "KTRAN,%s,%s,%s,%s,%s,%s,%s" % (str(kcnto), str(np1), str(np2), str(ninc), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def keyopt(self, itype="", knum="", value="", **kwargs):
        """APDL Command: KEYOPT

        Sets element key options.

        Parameters
        ----------
        itype
            Element type number as defined on the ET command. The label GCN is
            also valid input for general contact elements (see Notes).

        knum
            Number of the KEYOPT to be defined (KEYOPT(KNUM)).

        value
            Value of this KEYOPT.

        Notes
        -----
        Alternative to inputting KEYOPT values on ET command.  Must be used if
        KEYOPT(7) or greater values are to be input. ITYPE must first be
        defined with the ET command.

        Specify ITYPE = GCN to set element key options for all contact elements
        types used in any existing general contact definitions (that is,
        contact elements having a real constant set number = 0).
        """
        command = "KEYOPT,%s,%s,%s" % (str(itype), str(knum), str(value))
        return self.run(command, **kwargs)

    def hemiopt(self, hres="", **kwargs):
        """APDL Command: HEMIOPT

        Specifies options for Hemicube view factor calculation.

        Parameters
        ----------
        hres
            Hemicube resolution.  Increase value to increase the accuracy of
            the view factor calculation.  Defaults to 10.
        """
        command = "HEMIOPT,%s" % (str(hres))
        return self.run(command, **kwargs)

    def rmflvec(self, **kwargs):
        """APDL Command: RMFLVEC

        Writes eigenvectors of fluid nodes to a file for use in damping
        parameter extraction.

        Notes
        -----
        RMFLVEC extracts the modal information from the modal results file for
        all nodes specified in a node component called 'FLUN'. This component
        should include all nodes which are located at the fluid-structural
        interface. Mode shapes, element normal orientation, and a scaling
        factor are computed and stored in a file Jobname.EFL. For damping
        parameter extraction, use the DMPEXT command macro. See Introduction
        for more information on thin film analyses.

        FLUID136 and FLUID138 are used to model the fluid interface. Both the
        structural and fluid element types must be active. The fluid interface
        nodes must be grouped into a component 'FLUN'. A results file of the
        last modal analysis must be available.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMFLVEC," % ()
        return self.run(command, **kwargs)

    def asel(self, type="", item="", comp="", vmin="", vmax="", vinc="",
             kswp="", **kwargs):
        """APDL Command: ASEL

        Selects a subset of areas.

        Parameters
        ----------
        type
            Label identifying the type of select:

            S - Select a new set (default)

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

            ALL - Restore the full set.

            NONE - Unselect the full set.

            INVE - Invert the current set (selected becomes unselected and vice versa).

            STAT - Display the current select status.

        Notes
        -----
        Selects a subset of areas. For example, to select those areas with area
        numbers 1 through 7, use ASEL,S,AREA,,1,7.  The selected subset is then
        used when the ALL label is entered (or implied) on other commands, such
        as ALIST,ALL.  Only data identified by area number are selected.  Data
        are flagged as selected and unselected; no data are actually deleted
        from the database.

        In a cyclic symmetry analysis, area hot spots can be modified.
        Consequently, the result of an area selection may be different before
        and after the CYCLIC command.

        If Item = ACCA, the command selects only those areas that were created
        by concatenation.  The KSWP field is processed, but the Comp, VMIN,
        VMAX, and VINC fields are ignored.

        This command is valid in any processor.

        For Selects based on non-integer numbers (coordinates, results, etc.),
        items that are within the range VMIN-Toler and VMAX+Toler are selected.
        The default tolerance Toler is based on the relative values of VMIN and
        VMAX as follows:

        If VMIN = VMAX, Toler = 0.005 x VMIN.

        If VMIN = VMAX = 0.0, Toler = 1.0E-6.

         If VMAX ≠ VMIN, Toler = 1.0E-8 x (VMAX-VMIN).

        Use the SELTOL command to override this default and specify Toler
        explicitly.

        Table: 127:: : ASEL - Valid Item and Component Labels
        """
        command = "ASEL,%s,%s,%s,%s,%s,%s,%s" % (str(type), str(item), str(comp), str(vmin), str(vmax), str(vinc), str(kswp))
        return self.run(command, **kwargs)

    def mfrelax(self, lab="", value="", option="", **kwargs):
        """APDL Command: MFRELAX

        Sets relaxation values for an ANSYS Multi-field solver analysis.

        Parameters
        ----------
        lab
            Valid labels:

        value
            Relaxation value. Defaults to 0.75 for all labels.

        option
            Valid options are:

            RELX  - Uses relaxation method for load transfer (default).

            LINT  - Uses a linear interpolation for loaf transfer.

        Notes
        -----
        MFRELAX sets relaxation values for the load transfer variables at a
        surface or volume interface. Option = RELX will usually give you a more
        stable and smooth load transfer and is suitable for strongly coupled
        problems (such as FSI problems). Option = LINT is suitable for weakly
        coupled problems because it will transfer the full load in fewer
        stagger iterations.

        See the MFFR and MFITER commands for more information on relaxation in
        the ANSYS Multi-field solver.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFRELAX,%s,%s,%s" % (str(lab), str(value), str(option))
        return self.run(command, **kwargs)

    def dcvswp(self, option="", elem="", cnum="", vmax="", vinc1="", vinc2="",
               gap="", **kwargs):
        """APDL Command: DCVSWP

        Performs a DC voltage sweep on a ROM element.

        Parameters
        ----------
        option
            Sweep option:

            GV - Perform voltage sweep up to given voltage Vmax.

        elem
            Element number of the ROM element for the ROM use pass analysis.

        cnum
            Number of sweep conductor.

        vmax
            Maximum voltage. For the PI option, this voltage should be below
            the pull-in voltage value.

        vinc1
            Voltage increment for Vmax (default = Vmax/20).

        vinc2
            Voltage increment for pull-in voltage (default = 1).

        gap
            Gap elements option:

            0 - Create gap elements (COMBIN40) (default).

        Notes
        -----
        Vinc1 is used to ramp the sweep conductor voltage from 0 to Vmax. Vinc2
        is used to increase the sweep conductor voltage from Vmax to the pull-
        in value if the PI sweep option is used.

        Because ramping the voltage may lead to the unstable region of an
        electromechanical system, DCVSWP might not converge when the sweep
        conductor voltage approaches the pull-in value. To avoid non-converged
        solutions, you should use the gap option to create a set of spring-gap
        elements (COMBIN40). By default, DCVSWP creates two spring-gap elements
        with opposite orientations for each active modal displacement DOF of
        the ROM element. The gap size is set to the maximum absolute values of
        the deflection range for the corresponding mode, as calculated by
        RMMSELECT or modified  using the RMMRANGE command. The spring constants
        are set to 1.E5 for all the COMBIN40 elements. Along with the spring-
        gap elements, DCVSWP creates a set of constraint equations relating the
        ROM element modal displacements DOF (EMF) and the displacement DOF (UX)
        of the gap elements. Constraining the modal displacements using the
        spring-gap elements allows DCVSWP to converge in the pull-in range. The
        DCVSWP macro has a limit of 900 equilibrium iterations. If this limit
        is not sufficient to reach convergence, try the advanced techniques
        given in Overcoming Convergence Problems in the Structural Analysis
        Guide. For more information on gap elements, see Using Gap Elements
        with ROM144 in the Coupled-Field Analysis Guide.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "DCVSWP,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(elem), str(cnum), str(vmax), str(vinc1), str(vinc2), str(gap))
        return self.run(command, **kwargs)

    def qrdopt(self, reusekey="", symmeth="", cmccoutkey="", **kwargs):
        """APDL Command: QRDOPT

        Specifies additional QRDAMP modal analysis options.

        Parameters
        ----------
        reusekey
            Reuse key for method=QRDAMP specified in MODOPT command.

            ON - Reuse the symmetric eigensolution from the previous load steps or from the
                 previous solution.

            OFF - Do not reuse (calculates symmetric eigensolution at current load step). This is
                  the default.

        --, --
            Unused fields.

        symmeth
            Mode-extraction method to be used for the symmetric eigenvalue
            problem.

            LANB - Block Lanczos (default for shared-memory parallel processing).

            SUBSP - Subspace algorithm (default for distributed-memory parallel processing).

        cmccoutkey
            Complex Modal Contribution Coefficients (CMCC) output key. See
            Calculate the Complex Mode Contribution Coefficients (CMCC) in the
            Structural Analysis Guide for details and usage.

            ON - Output the CMCC to the text file Jobname.CMCC.

            OFF - Do not output the CMCC. This is the default.

        Notes
        -----
        If the filename.modesym file exists in the working directory and
        ReuseKey = ON, filename.modesym will be reused. If filename.modesym
        does not exist in the working directory, the symmetric eigensolution
        will be calculated.

        When ReuseKey=ON, both the new modal analysis (filename.modesym usage)
        and the preceding modal analysis (filename.modesym generation) must be
        performed using the same product version number.

        The mode-extraction method changes depending on the type of parallelism
        involved. For performance reasons, the subspace method is used with
        distributed-memory parallel processing (Distributed ANSYS) runs, while
        the Block Lanczos method is used with shared-memory parallel processing
        runs.
        """
        command = "QRDOPT,%s,%s,%s" % (str(reusekey), str(symmeth), str(cmccoutkey))
        return self.run(command, **kwargs)

    def abs(self, ir="", ia="", name="", facta="", **kwargs):
        """APDL Command: ABS

        Forms the absolute value of a variable.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        ia
            Reference number of the variable to be operated on.

        --, --
            Unused fields.

        name
            Thirty-two character name for identifying the variable on the
            printout and displays.  Embedded blanks are compressed upon output.

        --, --
            Unused fields.

        facta
            Scaling factor (positive or negative) applied to variable IA
            (defaults to 1.0).

        Notes
        -----
        The new variable is calculated as:

        IR = | FACTA x IA |

        For a complex number (a + ib), the absolute value is the magnitude,
        where the IA values are obtained from:

        See POST26 - Data Operations in the Mechanical APDL Theory Reference
        for details.
        """
        command = "ABS,%s,%s,%s,%s" % (str(ir), str(ia), str(name), str(facta))
        return self.run(command, **kwargs)

    def rigid(self, dof1="", dof2="", dof3="", dof4="", dof5="", dof6="",
              **kwargs):
        """APDL Command: RIGID

        Specifies known rigid body modes (if any) of the model.

        Parameters
        ----------
        dof1, dof2, dof3, . . . , dof6
            Up to six global Cartesian directions of the rigid modes.  For a
            completely free 2-D model, use ALL or UX, UY, ROTZ.   For a
            completely free 3-D model, use ALL or UX, UY, UZ, ROTX, ROTY, ROTZ.
            For a constrained model, use UX, UY, UZ, ROTX, ROTY, or ROTZ, as
            appropriate, to specify each and every unconstrained direction
            which exists in the model (not specifying every direction may cause
            difficulties in extracting the modes).

        Notes
        -----
        Specifies known rigid body modes (if any) of the model.  This command
        applies only to a component mode synthesis (CMS) analysis (see the
        CMSOPT command).  Any rigid body modes specified must be permitted by
        the applied displacement constraints (i.e., do not specify a rigid body
        mode in a constrained direction).  Reissue the command to redefine the
        specification.  If used in SOLUTION, this command is valid only within
        the first load step.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RIGID,%s,%s,%s,%s,%s,%s" % (str(dof1), str(dof2), str(dof3), str(dof4), str(dof5), str(dof6))
        return self.run(command, **kwargs)

    def svtyp(self, ksv="", fact="", keyinterp="", **kwargs):
        """APDL Command: SVTYP

        Defines the type of single-point response spectrum.

        Parameters
        ----------
        ksv
            Response spectrum type:

            0 - Seismic velocity response spectrum loading (SV values interpreted as velocities
                with units of length/time).

            1 - Force response spectrum loading (SV values interpreted as force amplitude
                multipliers).

            2 - Seismic acceleration response spectrum loading (SV values interpreted as
                accelerations with units of length/time2).

            3 - Seismic displacement response spectrum loading (SV values interpreted as
                displacements with units of length).

            4 - PSD loading (SV values interpreted as acceleration2/(cycles/time), such as
                (in/sec2)2/Hz (not g2/Hz)).  (Not recommended)

        fact
            Scale factor applied to spectrum values (defaults to 1.0).  Values
            are scaled when the solution is initiated [SOLVE].  Database values
            remain the same.

        keyinterp
            Key to activate or deactivate the linear interpolation between
            input response spectrum points and input response spectrum curves:

            0 (OFF or NO) - Deactivate linear and use logarithmic interpolation. This value is the default.

            1 (ON or YES) - Activate linear interpolation.

        Notes
        -----
        Defines the type of single-point response spectrum [SPOPT].  The
        seismic excitation direction is defined with the SED command.

        This command is also valid in PREP7.
        """
        command = "SVTYP,%s,%s,%s" % (str(ksv), str(fact), str(keyinterp))
        return self.run(command, **kwargs)

    def n(self, node="", x="", y="", z="", thxy="", thyz="", thzx="",
          **kwargs):
        """APDL Command: N

        Defines a node.

        Parameters
        ----------
        node
            Node number to be assigned.  A previously defined node of the same
            number will be redefined.  Defaults to the maximum node number used
            +1.

        x, y, z
            Node location in the active coordinate system (R, θ, Z for
            cylindrical, R, θ, Φ for spherical or toroidal).  If X = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).

        thxy
            First rotation about nodal Z (positive X toward Y).

        thyz
            Second rotation about nodal X (positive Y toward Z).

        thzx
            Third rotation about nodal Y (positive Z toward X).

        Notes
        -----
        Defines a node in the active coordinate system [CSYS].  The nodal
        coordinate system is parallel to the global Cartesian system unless
        rotated.  Rotation angles are in degrees and redefine any previous
        rotation angles.  See the NMODIF, NANG, NROTAT, and NORA commands for
        other rotation options.
        """
        command = "N,%s,%s,%s,%s,%s,%s,%s" % (str(node), str(x), str(y), str(z), str(thxy), str(thyz), str(thzx))
        return self.run(command, **kwargs)

    def axlab(self, axis="", lab="", **kwargs):
        """APDL Command: /AXLAB

        Labels the X and Y axes on graph displays.

        Parameters
        ----------
        axis
            Axis specifier:

            X - Apply label to X axis.

            Y - Apply label to Y axis.

        lab
            Axis label (user defined text up to 30 characters long).  Leave
            blank to reestablish the default for Axis axis.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "/AXLAB,%s,%s" % (str(axis), str(lab))
        return self.run(command, **kwargs)

    def ssbt(self, bt11="", bt22="", bt12="", t="", **kwargs):
        """APDL Command: SSBT

        Specifies preintegrated bending thermal effects for shell sections.

        Parameters
        ----------
        bt11, bt22, bt12
            Bending thermal effects component [BT].

        t
            Temperature.

        Notes
        -----
        The behavior of shell elements is governed by the generalized-
        stress/generalized-strain relationship of the form:

        The SSBT command, one of several preintegrated shell section commands,
        specifies the bending thermal effects quantity (submatrix [BT] data)
        for a preintegrated shell section. The section data defined is
        associated with the section most recently defined (via the SECTYPE
        command).

        The [BT] quantity represents bending stress resultants caused by a unit
        raise in temperature on a fully constrained model. For a layered
        composite shell, it is usually necessary to specify both the [BT] and
        [MT] quantities (by issuing the SSBT and SSMT commands, respectively).

        Unspecified values default to zero.

        Related commands are SSPA, SSPB, SSPD, SSPE, SSMT, and SSPM.

        If you are using the SHELL181 or SHELL281 element's Membrane option
        (KEYOPT(1) = 1), it is not necessary to issue this command.

        For complete information, see Using Preintegrated General Shell
        Sections.
        """
        command = "SSBT,%s,%s,%s,%s" % (str(bt11), str(bt22), str(bt12), str(t))
        return self.run(command, **kwargs)

    def icscale(self, wn="", factor="", **kwargs):
        """APDL Command: /ICSCALE

        Scales the icon size for elements supported in the circuit builder.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        factor
            Factor applied to the default icon size (defaults to 1).

        Notes
        -----
        Scaling the icon size can provide better visualization of the circuit
        components when using the Circuit Builder (an interactive builder
        available in the ANSYS GUI).

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "/ICSCALE,%s,%s" % (str(wn), str(factor))
        return self.run(command, **kwargs)

    def kuse(self, key="", **kwargs):
        """APDL Command: KUSE

        Specifies whether or not to reuse the factorized matrix.

        Parameters
        ----------
        key
            Reuse key:

            0  - Program decides whether or not to reuse the previous factorized stiffness
                 matrix.

            1  - Force the previous factorized stiffness matrix to be reused.  Used mainly in a
                 restart.  Forcing reuse of the matrix is a nonstandard use of
                 the program, and should be done with caution.  For instance,
                 using this option and changing the number of elements, or the
                 number or type of degrees of freedom, may cause an abort.

            -1  - All element matrices are reformed and are used to reform a new factorized
                  stiffness matrix.

        Notes
        -----
        Overrides the program logic to determine whether or not to reuse the
        previous factorized stiffness matrix for each substep of this load
        step.  Applies only to static or full transient analyses and to full
        harmonic analyses if the frequency is not changed for continuing
        loadsteps. For full harmonic analyses, only KEY = 1 or KEY = 0 is
        valid.

        This command is also valid in PREP7.
        """
        command = "KUSE,%s" % (str(key))
        return self.run(command, **kwargs)

    def cskp(self, kcn="", kcs="", porig="", pxaxs="", pxypl="", par1="",
             par2="", **kwargs):
        """APDL Command: CSKP

        Defines a local coordinate system by three keypoint locations.

        Parameters
        ----------
        kcn
            Arbitrary reference number assigned to this coordinate system.
            Must be greater than 10.  A coordinate system previously defined
            with this number will be redefined.

        kcs
            Coordinate system type:

            0 or CART - Cartesian

            1 or CYLIN - Cylindrical (circular or elliptical)

            2 or SPHE - Spherical (or spheroidal)

            3 or TORO - Toroidal

        porig
            Keypoint defining the origin of this coordinate system.  If PORIG =
            P, graphical picking is enabled and all remaining command fields
            are ignored (valid only in the GUI).

        pxaxs
            Keypoint defining the positive x-axis orientation of this
            coordinate system.

        pxypl
            Keypoint defining the x-y plane (with PORIG and PXAXS) in the first
            or second quadrant of this coordinate system.

        par1
            Used for elliptical, spheroidal, or toroidal systems.  If KCS = 1
            or 2, PAR1 is the ratio of the ellipse Y-axis radius to X-axis
            radius (defaults to 1.0 (circle)).  If KCS = 3, PAR1 is the major
            radius of the torus.

        par2
            Used for spheroidal systems.  If KCS = 2, PAR2 = ratio of ellipse
            Z-axis radius to X-axis radius (defaults to 1.0 (circle)).

        Notes
        -----
        Defines and activates a local right-handed coordinate system by
        specifying three existing keypoints: to locate the origin, to locate
        the positive x-axis, and to define the positive x-y plane.  This local
        system becomes the active coordinate system.  See the CLOCAL, CS,
        CSWPLA, and LOCAL commands for alternate definitions.  Local coordinate
        systems may be displayed with the /PSYMB command.

        This command is valid in any processor.
        """
        command = "CSKP,%s,%s,%s,%s,%s,%s,%s" % (str(kcn), str(kcs), str(porig), str(pxaxs), str(pxypl), str(par1), str(par2))
        return self.run(command, **kwargs)

    def bsm2(self, val1="", val2="", t="", **kwargs):
        """APDL Command: BSM2

        Specifies the bending curvature and moment relationship in plane XY for
        beam sections.

        Parameters
        ----------
        val1
            Curvature component (κ2).

        val2
            Bending moment component (M2).

        t
            Temperature.

        Notes
        -----
        The behavior of beam elements is governed by the generalized-
        stress/generalized-strain relationship of the form:

        The BSM2 command, one of several nonlinear general beam section
        commands, specifies the bending curvature and moment relationship for
        plane XY of a beam section. The section data defined is associated with
        the section most recently defined (via the SECTYPE command).

        Unspecified values default to zero.

        Related commands are BSAX, BSM1, BSTQ, BSS1, BSS2, BSMD, and BSTE.

        For complete information, see Using Nonlinear General Beam Sections.
        """
        command = "BSM2,%s,%s,%s" % (str(val1), str(val2), str(t))
        return self.run(command, **kwargs)

    def torqsum(self, cnam1="", cnam2="", cnam3="", cnam4="", cnam5="",
                cnam6="", cnam7="", cnam8="", cnam9="", **kwargs):
        """APDL Command: TORQSUM

        Summarizes electromagnetic torque calculations on element components.

        Parameters
        ----------
        cnam1, cnam2, cnam3, . . . , cnam9
            Names of existing element components for which Maxwell or virtual
            work boundary conditions were applied in the preprocessor.  Must be
            enclosed in single quotes (e.g., 'CNAM1') when the command typed in
            the command input box.

        Notes
        -----
        TORQSUM invokes an ANSYS macro that summarizes the Maxwell and virtual
        work torque values.  The element components must have had appropriate
        Maxwell or virtual work boundary conditions established in the
        preprocessor prior to solution in order to retrieve torques (see the
        FMAGBC command).  The torque values are stored on a per-element basis
        for the adjacent air layer elements surrounding the components and are
        retrieved and summed by the macro.  For a harmonic analysis, the
        calculated torque represents a time-average value.

        TORQSUM is valid only for 2-D planar analysis.
        """
        command = "TORQSUM,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(cnam1), str(cnam2), str(cnam3), str(cnam4), str(cnam5), str(cnam6), str(cnam7), str(cnam8), str(cnam9))
        return self.run(command, **kwargs)

    def plcrack(self, loc="", num="", **kwargs):
        """APDL Command: PLCRACK

        Displays cracking and crushing locations in SOLID65 elements.

        Parameters
        ----------
        loc
            Location at which symbols are to be displayed:

            0 - Plot symbols at integration points (default).

            1 - Plot symbol at element centroids (averaged).

        num
            Crack to be displayed:

            0 - Plot all cracks (default).

            1 - Plot only the first crack.

            2 - Plot only the second crack.

            3 - Plot only the third crack.

        Notes
        -----
        PLCRACK displays circles at locations of cracking or crushing in
        concrete elements.  Cracking is shown with a circle outline in the
        plane of the crack, and crushing is shown with an octahedron outline.
        If the crack has opened and then closed, the circle outline will have
        an X through it.  Each integration point can crack in up to three
        different planes.  The first crack at an integration point is shown
        with a red circle outline, the second crack with a green outline, and
        the third crack with a blue outline.

        Symbols shown at the element centroid (LOC = 1) are based on the status
        of all of the element's integration points.  If any integration point
        in the element has crushed, the crushed (octahedron) symbol is shown at
        the centroid.  If any integration point has cracked or cracked and
        closed, the cracked symbol is shown at the element centroid.  If at
        least five integration points have cracked and closed, the cracked and
        closed symbol is shown at the element centroid.  Finally, if more than
        one integration point has cracked, the circle outline at the element
        centroid shows the average orientation of all cracked planes for that
        element.

        Portions of this command are not supported by PowerGraphics
        [/GRAPHICS,POWER].
        """
        command = "PLCRACK,%s,%s" % (str(loc), str(num))
        return self.run(command, **kwargs)

    def ksymm(self, ncomp="", np1="", np2="", ninc="", kinc="", noelem="",
              imove="", **kwargs):
        """APDL Command: KSYMM

        Generates a reflected set of keypoints.

        Parameters
        ----------
        ncomp
            Symmetry key:

            X - X (or R) symmetry (default).

            Y - Y (or θ) symmetry.

            Z - Z (or Φ) symmetry.

        np1, np2, ninc
            Reflect keypoints from pattern beginning with NP1 to NP2 (defaults
            to NP1) in steps of NINC (defaults to 1).  If NP1 = ALL, NP2 and
            NINC are ignored and pattern is all selected keypoints [KSEL].  If
            Ncomp = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI).  A component name may
            also be substituted for NP1 (NP2 and NINC are ignored).

        kinc
            Keypoint increment between sets.  If zero, the lowest available
            keypoint numbers are assigned [NUMSTR].

        noelem
            Specifies whether nodes and elements are also to be generated:

            0 - Generate nodes and point elements associated with the original keypoints, if
                they exist.

            1 - Do not generate nodes and elements.

        imove
            Specifies whether keypoints will be moved or newly defined:

            0 - Generate additional keypoints.

            1 - Move original keypoints to new position retaining the same keypoint numbers
                (KINC and NOELEM are ignored).  Valid only if the old keypoints
                are no longer needed at their original positions.
                Corresponding meshed items are also moved if not needed at
                their original position.

        Notes
        -----
        Generates a reflected set of keypoints (and corresponding mesh) from a
        given keypoint pattern by a symmetry reflection (see analogous node
        symmetry command, NSYM).  The MAT, TYPE, REAL, and ESYS attributes are
        based upon the keypoints in the pattern and not upon the current
        settings.  Reflection is done in the active coordinate system by
        changing a particular coordinate sign.  Keypoints in the pattern may
        have been generated in any coordinate system.  However, solid modeling
        in a toroidal coordinate system is not recommended.
        """
        command = "KSYMM,%s,%s,%s,%s,%s,%s,%s" % (str(ncomp), str(np1), str(np2), str(ninc), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def cmdele(self, name="", **kwargs):
        """APDL Command: CMDELE

        Deletes a component or assembly definition.

        Parameters
        ----------
        name
            Name of the component or assembly whose definition is to be
            removed.

        Notes
        -----
        Entities contained in the component, or the components within the
        assembly, are unaffected.  Only the grouping relationships are deleted.
        Assemblies are automatically updated to reflect deletion of their
        components or subassemblies, but they are not automatically deleted
        when all their components or subassemblies are deleted.

        This command is valid in any processor.
        """
        command = "CMDELE,%s" % (str(name))
        return self.run(command, **kwargs)

    def emodif(self, iel="", stloc="", i1="", i2="", i3="", i4="", i5="",
               i6="", i7="", i8="", **kwargs):
        """APDL Command: EMODIF

        Modifies a previously defined element.

        Parameters
        ----------
        iel
            Modify nodes and/or attributes for element number IEL.  If ALL,
            modify all selected elements [ESEL].  If IEL = P, graphical picking
            is enabled and all remaining command fields are ignored (valid only
            in the GUI). A component name may also be substituted for IEL.

        stloc
            Starting location (n) of first node to be modified or the attribute
            label.

        i1, i2, i3, . . . , i8
            Replace the previous node numbers assigned to this element with
            these corresponding values. A (blank) retains the previous value
            (except in the I1 field, which resets the STLOC node number to
            zero).

        Notes
        -----
        The nodes and/or attributes (MAT, TYPE, REAL, ESYS, and SECNUM values)
        of an existing element may be changed with this command.
        """
        command = "EMODIF,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(iel), str(stloc), str(i1), str(i2), str(i3), str(i4), str(i5), str(i6), str(i7), str(i8))
        return self.run(command, **kwargs)

    def susel(self, type="", name1="", name2="", name3="", name4="", name5="",
              name6="", name7="", name8="", **kwargs):
        """APDL Command: SUSEL

        Selects a subset of surfaces

        Parameters
        ----------
        type
            Label identifying the type of select:

            S - Selects a new set (default).

            R - Reselects a set from the current set.

            A - Additionally selects a set and extends the current set.

            U - Unselects a set from the current set.

            ALL - Also selects all surfaces.

            NONE - Unselects all surfaces.

        name1, name2, name3, . . . , name8
            Eight character surface names

        Notes
        -----
        The selected set of surfaces is used in the following operations:
        SUMAP, SUDEL, SUCALC, SUEVAL, and SUVECT.
        """
        command = "SUSEL,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(type), str(name1), str(name2), str(name3), str(name4), str(name5), str(name6), str(name7), str(name8))
        return self.run(command, **kwargs)

    def oczone(self, zonetype="", zonename="", compnameint="", compnameext="",
               **kwargs):
        """APDL Command: OCZONE

        Specifies the type of ocean zone data to follow.

        Parameters
        ----------
        zonetype
            The type of ocean zone data to be input following this command:

            COMP - Define by a component.

            ZLOC - Define by Z levels.

            PIP - Associate an internal pipe or pipes with an external pipe.

        zonename
            The ocean zone name. If no name is specified, the program assigns
            one.

        compnameint
            For Zonetype = COMP, the required name of a component.

        compnameext
            For Zonetype = PIP, the required name of an external pipe
            component.

        Notes
        -----
        The OCZONE command specifies the type of ocean zone data to follow
        (component, Z-level, or internal pipes associated with an external
        pipe). An ocean zone is a local space where you can override global
        ocean-loading parameters.

        Names specified for ZoneName, CompNameInt, and CompNameExt can consist
        of up to 32 alphanumeric characters. The name cannot contain
        punctuation, special characters, or spaces.

        For Zonetype = COMP, the zone is defined by a component. Only the
        elements in the component are affected by the local parameters. A
        partial component can be defined as the zone via the Z input on the
        OCTABLE command.

        For Zonetype = ZLOC, the zone is defined by Z levels. Structural
        elements (such as BEAM188, BEAM189, PIPE288, PIPE289, and LINK180) in
        the Z levels are included in the zone.

        For Zonetype = PIP, the zone is prepared for a special configuration of
        pipes. It associates an internal pipe or pipes with an external pipe to
        remove the hydrodynamic effect on the internal pipe. Only hydrostatic
        pressure is applied on the internal pipe.

        This command is also valid in PREP7.

        Figure: 6:: : Ocean Zone Types (Specified via ZoneType)

        Issue this command before defining your ocean load data (OCDATA or
        OCTABLE). Define components before defining a component-type or a pipe-
        type zone (OCZONE,COMP or OCZONE,PIP, respectively).
        """
        command = "OCZONE,%s,%s,%s,%s" % (str(zonetype), str(zonename), str(compnameint), str(compnameext))
        return self.run(command, **kwargs)

    def usrelem(self, nnodes="", ndim="", keyshape="", nreal="", nsavevars="",
                nrsltvar="", keyansmat="", nintpnts="", kestress="", keysym="",
                **kwargs):
        """APDL Command: USRELEM

        Specifies the characteristics of the user-defined element USER300.

        Parameters
        ----------
        nnodes
            The number of nodes.

        ndim
            The number of dimensions (of nodal coordinates). Valid values are 2
            or 3.

        keyshape
            One of the following element shape options:

            ANYSHAPE - Any shape (that is, no specified shape). This value is the default. (The ANSYS
                       MeshTool is unavailable.)

            POINT - Point.

            LINE - Straight line.

            TRIAN - Triangle.

            QUAD - Quadrilateral. This shape can be degenerated to a triangle.

            TET - Tetrahedron.

            BRICK - Brick. This shape can be degenerated to a wedge, pyramid, or tetrahedron.

        nreal
            The number of real constants.

        nsavevars
            The number of saved variables.

        nrsltvar
            The number of variables saved in results files.

        keyansmat
            Key for element formulation control:

            0 - Create your own material codes within the element formulation. In this case,
                the real constants are available to input material properties.
                You can also input linear material properties via MP and MPDATA
                commands .

            1 - Use ANSYS standard material routines or the USERMAT subroutine to form
                structural material data. ANSYS material properties must be
                input in the standard way (as you would for non-user-defined
                elements). This value is invalid when KeyShape = ANYSHAPE.

        nintpnts
            The maximum number of integration points (used when KEYANSMAT = 1).

        kestress
            Key for the element stress state (used when KEYANSMAT = 1):

            0 - Plane stress elements.

            1 - Axisymmetric elements.

            2 - Plane strain elements.

            3 - 3-D solid elements.

            4 - 3-D solid-shell elements.

            5 - Generalized plane strain elements.

            6 - Beam elements.

            7 - Link/truss elements.

            8 - 3-D shell elements.

            9 - Axisymmetric shell elements.

        keysym
            Key for specifying whether element stiffness matrices are symmetric
            or unsymmetric:

            0 - Symmetric.

            1 - Unsymmetric.

        Notes
        -----
        The USRELEM command specifies the characteristics of the user-defined
        element USER300.

        Although you can intersperse other commands as necessary for your
        analysis, issue the USRELEM command as part of the following general
        sequence of commands:

        Issue the ET command for element USER300, followed by the related TYPE
        command.

        Issue both the USRELEM and USRDOF commands (in either order).

        Define your element using USER300.

        The number of real constants (NREAL) can refer to geometry quantities,
        material quantities, or any parameters for element formulation.

        ANSYS saves variables in the .esav file to preserve element data when
        you specify a positive NSAVEVARS value. When KEYANSMAT = 0, all
        variables of both material and kinematic formulation are saved. When
        KEYANSMAT = 1, only the variables for kinematic formulation (such as
        deformation gradient tensor) are saved; in this case, the material
        routine saves all necessary material data automatically.

        Element data saved in results files (NRSLTVAR) are accessible only as
        nonsummable miscellaneous data.  ANSYS saves stress and total strain
        data for structural elements in the .rst file automatically (as it does
        for equivalent variables such as thermal gradient and thermal flux in
        thermal elements); therefore, NRSLTVAR does not need to include stress
        and total strain data.

        To learn more about creating user-defined elements, see Creating a New
        Element in the Programmer's Reference.
        """
        command = "USRELEM,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nnodes), str(ndim), str(keyshape), str(nreal), str(nsavevars), str(nrsltvar), str(keyansmat), str(nintpnts), str(kestress), str(keysym))
        return self.run(command, **kwargs)

    def sallow(self, strs1="", strs2="", strs3="", strs4="", strs5="",
               strs6="", **kwargs):
        """APDL Command: SALLOW

        Defines the allowable stress table for safety factor calculations.

        Parameters
        ----------
        strs1, strs2, strs3, . . . , strs6
            Input up to six allowable stresses corresponding to the temperature
            points [TALLOW].

        Notes
        -----
        Defines the allowable stress table for safety factor calculations
        [SFACT,SFCALC].  Use the STAT command to list current allowable stress
        table.  Repeat SALLOW to zero table and redefine points (6 maximum).

        Safety factor calculations are not supported by PowerGraphics. Both the
        SALLOW and TALLOW commands must be used with the Full Model Graphics
        display method active.
        """
        command = "SALLOW,%s,%s,%s,%s,%s,%s" % (str(strs1), str(strs2), str(strs3), str(strs4), str(strs5), str(strs6))
        return self.run(command, **kwargs)

    def edpc(self, min="", max="", inc="", **kwargs):
        """APDL Command: EDPC

        Selects and plots explicit dynamic contact entities.

        Parameters
        ----------
        min
             Minimum contact entity number to be selected and plotted (default
            = 1).

        max
            Maximum contact entity number to be selected and plotted (default =
            MIN).

        inc
            Contact entity number increment (default = 1).

        Notes
        -----
        EDPC invokes an ANSYS macro which selects and plots explicit dynamic
        contact entities. The plot will consist of nodes or elements, depending
        on the method (node components or parts) that was used to define the
        contact surfaces (see the EDCGEN command). For single surface contact
        definitions, all external surfaces within the model are plotted.

        Note:: : EDPC changes the selected set of nodes and elements. After
        plotting contact entities, you must reselect all nodes and elements
        (NSEL and ESEL) required for subsequent operations, such as SOLVE

        Use the EDCLIST command to list the contact entity numbers for all
        defined contact.

        This command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDPC,%s,%s,%s" % (str(min), str(max), str(inc))
        return self.run(command, **kwargs)

    def pscontrol(self, option="", key="", **kwargs):
        """APDL Command: PSCONTROL

        Enables or disables shared-memory parallel operations.

        Parameters
        ----------
        option
            Specify the operations for which you intend to enable/disable
            parallel behavior:

            ALL  - Enable/disable parallel for all areas (default).

            PREP  - Enable/disable parallel during preprocessing (/PREP7).

            SOLU  - Enable/disable parallel during solution (/SOLU).

            FORM  - Enable/disable parallel during element matrix generation.

            SOLV  - Enable/disable parallel during equation solver.

            RESU - Enable/disable parallel during element results calculation.

            POST  - Enable/disable parallel during postprocessing (/POST1 and /POST26).

            STAT - List parallel operations that are enabled/disabled.

        key
             Option control key. Used for all Option values except STAT.

            ON  - Enable parallel operation.

            OFF  - Disable parallel operation.

        Notes
        -----
        Use this command in shared-memory parallel operations.

        This command is useful when you encounter minor discrepancies in a
        nonlinear solution when using different numbers of processors. A
        parallel operation applied to the element matrix generation can produce
        a different nonlinear solution with a different number of processors.
        Although the nonlinear solution converges to the same nonlinear
        tolerance, the minor discrepancy created may not be desirable for
        consistency.

        Enabling/disabling parallel behavior for the solution (Option = SOLU)
        supersedes the activation/deactivation of parallel behavior for element
        matrix generation (FORM), equation solver (SOLV), and element results
        calculation (RESU).

        The SOLV option supports only the sparse direct and PCG solvers
        (EQSLV,SPARSE or PCG). No other solvers are supported.

        This command applies only to shared-memory architecture. It does not
        apply to the Distributed ANSYS product.
        """
        command = "PSCONTROL,%s,%s" % (str(option), str(key))
        return self.run(command, **kwargs)

    def gtype(self, wn="", label="", key="", **kwargs):
        """APDL Command: /GTYPE

        Controls the entities that the GPLOT command displays.

        Parameters
        ----------
        wn
            Window number (or ALL) to which this command applies (defaults to
            1)

        label
            This represents the type of entity to display:

            NODE - Nodes

            ELEM - Elements

            KEYP - Keypoints

            LINE - Lines

            AREA - Areas

            VOLU - Volumes

            GRPH - Graph displays

        key
            Switch:

            0 - Turns the entity type off.

            1 - Turns the entity type on.

        Notes
        -----
        The /GTYPE command controls which entities the GPLOT command displays.
        NODE, ELEM, KEYP, LINE, AREA, and VOLU are on by default.  When ELEM is
        activated, you can control the type of element displayed via the /GCMD
        command (which also controls the type of graph display).  When the GRPH
        entity type is activated, all other entity types are deactivated.
        Conversely, when any of the NODE, ELEM, KEYP, LINE, AREA, and VOLU
        entity types are active, the GRPH entity type is deactivated.

        The /GTYPE command gives you several options for multi-window layout:

        One window

        Two windows (left and right or top and bottom of the screen)

        Three windows (two at the top and one at the bottom of the screen, or
        one top and two bottom windows

        Four windows (two at the top and two at the bottom)



        Once you choose a window layout, you can choose one of the following:
        multiple plots, replotting, or no redisplay.

        This command is valid in any processor.
        """
        command = "/GTYPE,%s,%s,%s" % (str(wn), str(label), str(key))
        return self.run(command, **kwargs)

    def nstore(self, tinc="", **kwargs):
        """APDL Command: NSTORE

        Defines which time points are to be stored.

        Parameters
        ----------
        tinc
            Store data associated with every TINC time (or frequency) point(s),
            within the previously defined range of TMIN to TMAX [TIMERANGE].
            (Defaults to 1)

        Notes
        -----
        Defines which time (or frequency) points within the range are to be
        stored.
        """
        command = "NSTORE,%s" % (str(tinc))
        return self.run(command, **kwargs)

    def cycfiles(self, fnamerst="", extrst="", fnamerfrq="", extrfrq="",
                 **kwargs):
        """APDL Command: CYCFILES

        Specifies the data files where results are to be found for a cyclic
        symmetry mode-superposition harmonic analysis.

        Parameters
        ----------
        fnamerst
            The file name and directory path of the results file from the
            cyclic modal solution. Defaults to Jobname.

        extrst
            File name extension for FnameRst. Defaults to rst.

        fnamerfrq
            The file name and directory path of the results file from the
            cyclic mode-superposition harmonic solution. Defaults to the value
            of the FnameRst argument.

        extrfrq
            File name extension for FnameRfrq. Defaults to rfrq.
        """
        command = "CYCFILES,%s,%s,%s,%s" % (str(fnamerst), str(extrst), str(fnamerfrq), str(extrfrq))
        return self.run(command, **kwargs)

    def kscale(self, kinc="", np1="", np2="", ninc="", rx="", ry="", rz="",
               **kwargs):
        """APDL Command: KSCALE

        Generates a scaled pattern of keypoints from a given keypoint pattern.

        Parameters
        ----------
        kinc
            Do this scaling operation one time, incrementing all keypoints in
            the given pattern by KINC.  If KINC = 0, keypoints will be
            redefined at the scaled locations.

        np1, np2, ninc
            Scale keypoints from pattern beginning with NP1 to NP2 (defaults to
            NP1) in steps of NINC (defaults to 1).  If NP1 = ALL, NP2 and NINC
            are ignored and pattern is all selected keypoints [KSEL].  If NP1 =
            P, graphical picking is enabled and all remaining command fields
            are ignored (valid only in the GUI).  A component name may also be
            substituted for NP1 (NP2 and NINC are ignored).

        rx, ry, rz
            Scale factor ratios.  Scaling is relative to the origin of the
            active coordinate system (RR, Rθ, RZ for cylindrical, RR, Rθ, RΦ
            for spherical).  If > 1.0, pattern is enlarged.  If < 1.0, pattern
            is reduced.  Ratios each default to 1.0.

        Notes
        -----
        Generates a scaled pattern of keypoints from a given keypoint pattern.
        Scaling is done in the active coordinate system (see analogous node
        scaling [NSCALE]).  Solid modeling in a toroidal coordinate system is
        not recommended.
        """
        command = "KSCALE,%s,%s,%s,%s,%s,%s,%s" % (str(kinc), str(np1), str(np2), str(ninc), str(rx), str(ry), str(rz))
        return self.run(command, **kwargs)

    def smsurf(self, **kwargs):
        """APDL Command: SMSURF

        Specifies "Surface loads on the solid model" as the subsequent status
        topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "SMSURF," % ()
        return self.run(command, **kwargs)

    def plmc(self, lstep="", sbstep="", timfrq="", kimg="", hibeg="", hiend="",
             **kwargs):
        """APDL Command: PLMC

        Plots the modal coordinates from a mode-superposition solution.

        Parameters
        ----------
        lstep, sbstep
            Plot the solution identified as load step LSTEP and substep SBSTEP

        timfrq
            As an alternative to LSTEP and SBSTEP, plot the solution at the
            time value TIMFRQ (for ANTYPE,TRANS) or frequency value TIMFRQ (for
            ANTYPE,HARMIC). LSTEP and SBSTEP should be left blank.

        kimg
            If 0 (or blank), plot the real solution. If 1, plot the imaginary
            solution. Only valid for ANTYPE,HARMIC.

        hibeg, hiend
            For cyclic symmetry solutions, plot the solutions in the harmonic
            index solution range HIbeg to HIend. Defaults to all harmonic
            indices (all modes).

        Notes
        -----
        PLMC plots a histogram of the modal coordinates (the response
        amplitudes applied to each mode shape) at a certain time point
        (transient analyses) or frequency point (harmonic analyses). The
        absolute values of the modal coordinates are plotted. Use /XRANGE to
        plot only modes in a certain range, if desired.

        For transient analyses, the Jobname.RDSP file must be available. For
        harmonic analyses, the Jobname.RFRQ must be available. No SET command
        is required and no expansion pass is required.

        For a cyclic harmonic mode-superposition analysis, use the CYCFILES
        command to identify the Jobname.RFRQ and modal Jobname.RST file. You
        may limit the plot to display only those modes in a certain harmonic
        index range. The modes having the same harmonic index are each plotted
        in a unique color. If there are less than 10 harmonic indices, they are
        identified in the graphics legend.

        This is a graphical representation of the optional Jobname.MCF text
        file. (see the TRNOPT and HROPT commands). For more information on
        modal coordinates, see Mode-Superposition Method in the Mechanical APDL
        Theory Reference.
        """
        command = "PLMC,%s,%s,%s,%s,%s,%s" % (str(lstep), str(sbstep), str(timfrq), str(kimg), str(hibeg), str(hiend))
        return self.run(command, **kwargs)

    def create(self, fname="", ext="", **kwargs):
        """APDL Command: *CREATE

        Opens (creates) a macro file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        See the *USE command for a discussion of macros.  All commands
        following the *CREATE command, up to the *END command, are written to
        the specified file without being executed.  An existing file of the
        same name, if any, will be overwritten.  Parameter values are not
        substituted for parameter names in the commands when the commands are
        written to the file.  Use *CFWRITE to create a file if this is desired.
        The resulting macro may be executed with a *USE command (which also
        allows parameters to be passed into the macro) or a /INPUT command
        (which does not allow parameters to be passed in).  Several macros may
        be stacked into a library file [*ULIB]. You cannot use *CREATE within a
        DO loop.

        This command is valid in any processor.
        """
        command = "*CREATE,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def clocal(self, kcn="", kcs="", xl="", yl="", zl="", thxy="", thyz="",
               thzx="", par1="", par2="", **kwargs):
        """APDL Command: CLOCAL

        Defines a local coordinate system relative to the active coordinate
        system.

        Parameters
        ----------
        kcn
            Arbitrary reference number assigned to this coordinate system.
            Must be greater than 10.  A coordinate system previously defined
            with this number will be redefined.

        kcs
            Coordinate system type:

            0 or CART - Cartesian

            1 or CYLIN - Cylindrical (circular or elliptical)

            2 or SPHE - Spherical (or spheroidal)

            3 or TORO - Toroidal

        xl, yl, zl
            Location (in the active coordinate system) of the origin of the new
            coordinate system (R, θ, Z for cylindrical, R, θ,Φ for spherical or
            toroidal).

        thxy
            First rotation about local Z (positive X toward Y).

        thyz
            Second rotation about local X (positive Y toward Z).

        thzx
            Third rotation about local Y (positive Z toward X).

        par1
            Used for elliptical, spheroidal, or toroidal systems.  If KCS = 1
            or 2, PAR1 is the ratio of the ellipse Y-axis radius to X-axis
            radius (defaults to 1.0 (circle)).  If KCS = 3, PAR1 is the major
            radius of the torus.

        par2
            Used for spheroidal systems.  If KCS = 2, PAR2 = ratio of ellipse
            Z-axis radius to X-axis radius (defaults to 1.0 (circle)).

        Notes
        -----
        Defines and activates a local coordinate system by origin location and
        orientation angles relative to the active coordinate system.  This
        local system becomes the active coordinate system, and is automatically
        aligned with the active system (i.e., x is radial if a cylindrical
        system is active, etc.).  Nonzero rotation angles (degrees) are
        relative to this automatic rotation.  See the CS, CSKP, CSWPLA, and
        LOCAL commands for alternate definitions.  Local coordinate systems may
        be displayed with the /PSYMB command.

        This command is valid in any processor.
        """
        command = "CLOCAL,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(kcn), str(kcs), str(xl), str(yl), str(zl), str(thxy), str(thyz), str(thzx), str(par1), str(par2))
        return self.run(command, **kwargs)

    def pmgtran(self, fname="", freq="", fcnam1="", fcnam2="", pcnam1="",
                pcnam2="", ecnam1="", ccnam1="", **kwargs):
        """APDL Command: PMGTRAN

        Summarizes electromagnetic results from a transient analysis.

        Parameters
        ----------
        fname
            File name (8 characters maximum) to which tabular data and plot
            files will be written.  Must be enclosed in single quotes when the
            command is manually typed in.  Defaults to MG_TRNS.  The data file
            extension is .OUT and the plot file extension is .PLT.

        freq
            Frequency of solution output.  Defaults to 1.  Every FREQth
            solution on the results file is output.

        fcnam1, fcnam2
            Names of element components for force calculation.  Must be
            enclosed in single quotes when the command is manually typed in.

        pcnam1, pcnam2
            Names of element components for power loss calculation.  Must be
            enclosed in single quotes when the command is manually typed in.

        ecnam1, ccnam1
            Names of element components for energy and total current
            calculations, respectively.  Must be enclosed in single quotes when
            the command is manually typed in.

        Notes
        -----
        PMGTRAN invokes an ANSYS macro which calculates and summarizes
        electromagnetic results from a transient analysis.  The results are
        summarized by element components and listed on the screen as well as
        written to a file (Fname.OUT).  Also, graph plots of results as a
        function of time are created and written to a file (Fname.PLT) for use
        in the DISPLAY program.

        Two components may be selected for the summary of electromagnetic
        forces (see FMAGSUM), two for power loss, and one each for stored
        energy (see SENERGY) and total current (see CURR2D).  See the
        referenced commands for other restrictions.

        PMGTRAN is restricted to MKSA units.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "PMGTRAN,%s,%s,%s,%s,%s,%s,%s,%s" % (str(fname), str(freq), str(fcnam1), str(fcnam2), str(pcnam1), str(pcnam2), str(ecnam1), str(ccnam1))
        return self.run(command, **kwargs)

    def sexp(self, labr="", lab1="", lab2="", exp1="", exp2="", **kwargs):
        """APDL Command: SEXP

        Forms an element table item by exponentiating and multiplying.

        Parameters
        ----------
        labr
            Label assigned to results.  If same as existing label, the existing
            values will be overwritten by these results.

        lab1
            First labeled result item in operation.

        lab2
            Second labeled result item in operation (may be blank).

        exp1
            Exponent applied to Lab1.

        exp2
            Exponent applied to Lab2.

        Notes
        -----
        Forms a labeled result item (see ETABLE command) for the selected
        elements by exponentiating and multiplying two existing labeled result
        items according to the operation:

        LabR = (|Lab1|EXP1) x (|Lab2|EXP2)

        Roots, reciprocals, and divides may also be done with this command.
        """
        command = "SEXP,%s,%s,%s,%s,%s" % (str(labr), str(lab1), str(lab2), str(exp1), str(exp2))
        return self.run(command, **kwargs)

    def center(self, node="", node1="", node2="", node3="", radius="",
               **kwargs):
        """APDL Command: CENTER

        Defines a node at the center of curvature of 2 or 3 nodes.

        Parameters
        ----------
        node
            Number to be assigned to the node generated at the center of
            curvature.

        node1, node2, node3
            Three nodes used to calculated the center of curvature, as
            described under RADIUS.

        radius
            Used to control the interpretation of NODE1, NODE2 and NODE3:

            0 - NODE1, NODE2 and NODE3 lie on a circular arc.  The program will calculate the
                center of curvature (and radius) (default).

            ≠0 - NODE1 and NODE2 are the endpoints of an arc, and RADIUS is the radius of
                 curvature.  The program will locate the center of curvature on
                 the NODE3 side of the NODE1-NODE2 line if RADIUS > 0, and
                 opposite to NODE3 if RADIUS < 0.
        """
        command = "CENTER,%s,%s,%s,%s,%s" % (str(node), str(node1), str(node2), str(node3), str(radius))
        return self.run(command, **kwargs)

    def quad(self, node1="", nintr="", node2="", nfill="", nstrt="", ninc="",
             pkfac="", **kwargs):
        """APDL Command: QUAD

        Generates a quadratic line of nodes from three nodes.

        Parameters
        ----------
        node1
            Begin fill-in from this node location.  If NODE1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).

        nintr
            Intermediate or guiding node.  Quadratic curve will pass through
            this location.  NINTR may have any node number and any location.
            If the quadratic line also generates a node with number NINTR, the
            generated location overrides the previous NINTR location.

        node2
            End quadratic fill-in at this node location.

        nfill
            Fill-in NFILL nodes between NODE1 and NODE2 (defaults to
            |NODE2-NODE1|-1).  NFILL must be positive.

        nstrt
            Node number assigned to first filled-in node (defaults to NODE1 +
            NINC).

        ninc
            Add this increment to each of the remaining filled-in node numbers
            (may be positive or negative).  Defaults to (NODE2-NODE1)/(NFILL +
            1), i.e., linear interpolation.

        pkfac
            Peak location factor.  If PKFAC=0.5, the peak of the quadratic
            shape occurs at the NINTR location.  If 0.0 < PKFAC < 0.5, the peak
            occurs to the NODE2 side of the NINTR location.  If 0.5 < PKFAC <
            1.0, the peak occurs to the NODE1 side of the NINTR location.
            Defaults to 0.5.

        Notes
        -----
        Generates a quadratic line of nodes (in the active coordinate system)
        from three nodes.  The three nodes determine the plane of the curve and
        may have been defined in any coordinate system.  Any number of nodes
        may be filled-in and any node number sequence may be assigned.

        The quadratic line feature uses three nodes (NODE1,NINTR,NODE2) to
        determine the plane of the curve.  The curve passes through the three
        points, beginning from NODE1, through the intermediate (or guiding)
        point NINTR, and toward NODE2.

        Generated nodes are also quadratically spaced.  If the guiding node
        number is within the set being generated, it will be relocated
        according to the quadratic spacing.

        The peak location factor is used to determine how the quadratic fits
        through the three points.  Various nodal progressions can be obtained
        by different combinations of PKFAC and the guiding node location.  If
        the guiding node is at mid-length between NODE1 and NODE2, 0.293:
        PKFAC< 0.707 will ensure that all generated nodes fall within the
        NODE1,NODE2 bounds.  In the limit, as PKFAC approaches 0.0, the peak
        approaches the line through NODE1 and NINTR at an infinite distance
        from NODE1.  The QUAD command generates quadratic lines of nodes, which
        in turn may be used as a base line for generating irregular surfaces of
        nodes (by repeating [*REPEAT], generating [NGEN, NSCALE], etc.).
        Irregular surfaces may also be generated with the meshing commands.
        """
        command = "QUAD,%s,%s,%s,%s,%s,%s,%s" % (str(node1), str(nintr), str(node2), str(nfill), str(nstrt), str(ninc), str(pkfac))
        return self.run(command, **kwargs)

    def slashclog(self, fname="", ext="", **kwargs):
        """APDL Command: /CLOG

        Copies the session log file to a named file.

        Parameters
        ----------
        fname
            File name and directory path to which the log file is to be copied
            (248 characters maximum, including directory). If you do not
            specify a directory path, it will default to your working directory
            and you can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        This command is valid in any processor, but only during an interactive
        run.
        """
        command = "/CLOG,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def nlgeom(self, key="", **kwargs):
        """APDL Command: NLGEOM

        Includes large-deflection effects in a static or full transient
        analysis.

        Parameters
        ----------
        key
            Large-deflection key:

            OFF - Ignores large-deflection effects (that is, a small-deflection analysis is
                  specified). This option is the default.

            ON - Includes large-deflection (large rotation) effects or large strain effects,
                 according to the element type.

        Notes
        -----
        Large-deflection effects are categorized as either large deflection (or
        large rotation) or large strain, depending on the element type. These
        are listed (if available) under Special Features in the input data
        table for each element in the Element Reference. When large deflection
        effects are included (NLGEOM,ON), stress stiffening effects are also
        included automatically.

        If used during the solution (/SOLU), this command is valid only within
        the first load step.

        In a large-deflection analysis, pressure loads behave differently than
        other load types. For more information, see Load Direction in a Large-
        Deflection Analysis.

        The gyroscopic matrix (that occurs due to rotational angular velocity)
        does not support large-deflection effects. The theoretical formulations
        for the gyroscopic matrix support small deflection (linear formulation)
        only.

        When large-deflection effects are included in a substructure or CMS
        transient analysis use pass, the OUTRES command ignores DSUBres = ALL.

        This command is also valid in PREP7.

        In ANSYS Professional NLT, large deflection effects should not be
        turned on if 2-D solid (PLANEn) or 3-D solid (SOLIDn) elements are
        defined. ANSYS Professional NLS supports NLGEOM,ON for plane and solid
        elements.
        """
        command = "NLGEOM,%s" % (str(key))
        return self.run(command, **kwargs)

    def cgomga(self, cgomx="", cgomy="", cgomz="", **kwargs):
        """APDL Command: CGOMGA

        Specifies the rotational velocity of the global origin.

        Parameters
        ----------
        cgomx, cgomy, cgomz
            Rotational velocity of the global origin about the acceleration
            system X, Y, and Z axes.

        Notes
        -----
        Specifies the rotational velocity of the global origin about each of
        the acceleration coordinate system axes.  The location of the
        acceleration coordinate system is defined with the CGLOC command.
        Rotational velocities may be defined in analysis types ANTYPE,STATIC,
        HARMIC (full or mode-superposition), TRANS (full or mode-
        superposition), and SUBSTR.  See Acceleration Effect in the Mechanical
        APDL Theory Reference for details.  Units are radians/time.  Related
        commands are ACEL, CGLOC, DCGOMG,   DOMEGA, and OMEGA.

        See Analysis Tools in the Mechanical APDL Theory Reference for more
        information.

        The CGOMGA command supports tabular boundary conditions (%TABNAME_X%,
        %TABNAME_Y%, and %TABNAME_Z%) for CGOMGA_X, CGOMGA_Y, and CGOMGA_Z
        input values (*DIM) for full transient and harmonic analyses.

        This command is also valid in PREP7.
        """
        command = "CGOMGA,%s,%s,%s" % (str(cgomx), str(cgomy), str(cgomz))
        return self.run(command, **kwargs)

    def se(self, file="", toler="", **kwargs):
        """APDL Command: SE

        Defines a superelement.

        Parameters
        ----------
        file
            The name (case sensitive) of the file containing the original
            superelement matrix created by the generation pass (Sename.SUB).
            The default is the current Jobname.

        --, --
            Unused fields.

        toler
            Tolerance used to determine if use pass nodes are noncoincident
            with master nodes having the same node numbers.  Defaults to
            0.0001.  Use pass nodes will always be replaced by master nodes of
            the same node number.  However, if a use pass node is more than
            TOLER away from the corresponding master node, a warning is
            generated.

        Notes
        -----
        Defines a superelement by reading in the superelement matrices and
        master nodes from the superelement matrix file.  The matrix file
        (File.SUB) must be available from the substructure generation pass.
        The proper element type (MATRIX50) must be active [TYPE] for this
        command.  A scratch file called File.SORD showing the superelement
        names and their corresponding element numbers is also written.
        """
        command = "SE,%s,%s" % (str(file), str(toler))
        return self.run(command, **kwargs)

    def sfact(self, type="", **kwargs):
        """APDL Command: SFACT

        Allows safety factor or margin of safety calculations to be made.

        Parameters
        ----------
        type
            Type of calculation:

            0 - No nodal safety factor or margin of safety calculations.

            1 - Calculate and store safety factors in place of nodal stresses.

            2 - Calculate and store margins of safety in place of nodal stresses.

        Notes
        -----
        Allows safety factor (SF) or margin of safety (MS) calculations to be
        made for the average nodal stresses according to:

        SF = SALLOW/|Stress|

        MS = (SALLOW/|Stress|) -- 1.0

        Calculations are done during the display, select, or sort operation (in
        the active coordinate system [RSYS]) with results stored in place of
        the nodal stresses.  Use the PRNSOL or PLNSOL command to display the
        results.

        Note:: : The results are meaningful only for the stress (SIG1, SIGE,
        etc.) upon which SALLOW is based.  Nodal temperatures used are those
        automatically stored for the node.  Related commands are SFCALC,
        SALLOW, TALLOW.
        """
        command = "SFACT,%s" % (str(type))
        return self.run(command, **kwargs)

    def mmf(self, **kwargs):
        """APDL Command: MMF

        Calculates the magnetomotive force along a path.

        Notes
        -----
        MMF invokes an ANSYS macro which calculates the magnetomotive force
        (mmf) along a predefined path [PATH].  It  is valid for both 2-D and
        3-D magnetic field analyses.  The calculated mmf value is stored in the
        parameter MMF.

        A closed path [PATH], passing through the magnetic circuit for which
        mmf is to be calculated, must be defined before this command is issued.
        A counterclockwise ordering of points on the PPATH command will yield
        the correct sign on the mmf.  The mmf is based on Ampere's Law.  The
        macro makes use of calculated values of field intensity (H), and uses
        path operations for the calculations.  All path items are cleared upon
        completion.  The MMF macro sets the "ACCURATE" mapping method and "MAT"
        discontinuity option of the PMAP command.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MMF," % ()
        return self.run(command, **kwargs)

    def enddo(self, **kwargs):
        """APDL Command: *ENDDO

        Ends a do-loop and starts the looping action.

        Notes
        -----
        One *ENDDO  is required for each nested do-loop. The *ENDDO command
        must appear on the same file as the  *DO command, and all six
        characters must be input.

        This command is valid in any processor.
        """
        command = "*ENDDO," % ()
        return self.run(command, **kwargs)

    def numcmp(self, label="", **kwargs):
        """APDL Command: NUMCMP

        Compresses the numbering of defined items.

        Parameters
        ----------
        label
            Items to be compressed:

            NODE - Node numbers

            ELEM - Element numbers

            KP - Keypoint numbers

            LINE - Line numbers

            AREA - Area numbers

            VOLU - Volume numbers

            MAT - Material numbers

            TYPE - Element type numbers

            REAL - Real constant numbers

            CP - Coupled set numbers

            SECN - Section numbers

            CE - Constraint equation numbers

            ALL - All item numbers

        Notes
        -----
        The NUMCMP command effectively compresses out unused item numbers by
        renumbering all the items, beginning with one and continuing throughout
        the model.  The renumbering order follows the initial item numbering
        order (that is, compression lowers the maximum number by "sliding"
        numbers down to take advantage of unused or skipped numbers).  All
        defined items are renumbered, regardless of whether or not they are
        actually used or selected.  Applicable related items are also checked
        for renumbering as described for the merge operation (NUMMRG).

        Compressing material numbers (NUMCMP,ALL or NUMCMP,MAT) does not update
        the material number referenced by either of the following:

        A temperature-dependent convection or surface-to-surface radiation load
        (SF, SFE, SFL, SFA)

        Real constants for multi-material elements (such as SOLID65)

         Compression is usually not required unless memory space is limited and
        there are large gaps in the numbering sequence.
        """
        command = "NUMCMP,%s" % (str(label))
        return self.run(command, **kwargs)

    def add(self, ir="", ia="", ib="", ic="", name="", facta="", factb="",
            factc="", **kwargs):
        """APDL Command: ADD

        Adds (sums) variables.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        ia, ib, ic
            Reference numbers of the three variables to be operated on.  If
            only two variables, leave IC blank.  If only one, leave IB and IC
            blank.

        name
            Thirty-two character name for identifying the variable on the
            printout and displays.  Embedded blanks are compressed upon output.

        --, --
            Unused fields.

        facta, factb, factc
            Scaling factors (positive or negative) applied to the corresponding
            variables (default to 1.0).

        Notes
        -----
        Adds variables (up to three at once) according to the operation:

        IR = (FACTA x IA) + (FACTB x IB) + (FACTC x IC)
        """
        command = "ADD,%s,%s,%s,%s,%s,%s,%s,%s" % (str(ir), str(ia), str(ib), str(ic), str(name), str(facta), str(factb), str(factc))
        return self.run(command, **kwargs)

    def gcolumn(self, curve="", string="", **kwargs):
        """APDL Command: /GCOLUMN

        Allows the user to apply a label to a specified curve.

        Parameters
        ----------
        curve
            Curve number on which label will be applied (integer value between
            1 and 10).

        string
            Name or designation that will be applied to the curve (8 characters
            max).

        Notes
        -----
        This command is used for an array parameter plot (a plot created by the
        *VPLOT command).  Normally the label for curve 1 is "COL 1", the label
        for curve 2 is "COL 2" and so on; the column number is the field
        containing the dependent variables for that particular curve. Issuing
        /GCOLUMN,CURVE, with no string value specified resets the label to the
        original value.
        """
        command = "/GCOLUMN,%s,%s" % (str(curve), str(string))
        return self.run(command, **kwargs)

    def jsol(self, nvar="", elem="", item="", comp="", name="", **kwargs):
        """APDL Command: JSOL

        Specifies result items to be stored for the joint element.

        Parameters
        ----------
        nvar
            Arbitrary reference number or name assigned to this variable.
            Variable numbers can be 2 to NV (NUMVAR) while the name can be an
            eight-byte character string. Overwrites any existing results for
            this variable.

        elem
            Element number for which to store results.

        item
            Label identifying the item.  Valid item labels are shown in
            Table 202: JSOL - Valid Item and Component Labels below.

        comp
            Component of the Item (if required).  Valid component labels are
            shown in Table 202: JSOL - Valid Item and Component Labels below.

        name
            Thirty-two character name identifying the item on printouts and
            displays.  Defaults to a label formed by concatenating the first
            four characters of the Item and Comp labels.

        Notes
        -----
        This command is valid for the MPC184 joint elements. The values stored
        are for the free or unconstrained degrees of freedom of a joint
        element. Relative reaction forces and moments are available only if
        stiffness, damping, or friction is associated with the joint element.

        Table: 202:: : JSOL - Valid Item and Component Labels


        """
        command = "JSOL,%s,%s,%s,%s,%s" % (str(nvar), str(elem), str(item), str(comp), str(name))
        return self.run(command, **kwargs)

    def emore(self, q="", r="", s="", t="", u="", v="", w="", x="", **kwargs):
        """APDL Command: EMORE

        Adds more nodes to the just-defined element.

        Parameters
        ----------
        q, r, s, t, u, v, w, x
            Numbers of nodes typically assigned to ninth (node Q) through
            sixteenth (node X) nodal positions, if any. If Q = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).

        Notes
        -----
        Repeat EMORE command for up to 4 additional nodes (20 maximum). Nodes
        are added after the last nonzero node of the element.  Node numbers
        defined with this command may be zeroes.
        """
        command = "EMORE,%s,%s,%s,%s,%s,%s,%s,%s" % (str(q), str(r), str(s), str(t), str(u), str(v), str(w), str(x))
        return self.run(command, **kwargs)

    def pmacro(self, **kwargs):
        """APDL Command: /PMACRO

        Specifies that macro contents be written to the session log file.

        Notes
        -----
        This command forces the contents of a macro or other input file to be
        written to Jobname.LOG.  It is valid only within a macro or input file,
        and should be placed at the top of the file.  /PMACRO should be
        included in any macro or input file that calls GUI functions.
        """
        command = "/PMACRO," % ()
        return self.run(command, **kwargs)

    def fk(self, kpoi="", lab="", value="", value2="", **kwargs):
        """APDL Command: FK

        Defines force loads at keypoints.

        Parameters
        ----------
        kpoi
            Keypoint at which force is to be specified.  If ALL, apply to all
            selected keypoints [KSEL].  If KPOI = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for KPOI.

        lab
            Valid force label.  Structural labels:  FX, FY, or FZ (forces); MX,
            MY, or MZ (moments).  Thermal labels:  HEAT, HBOT, HE2, HE3, . . .,
            HTOP (heat flow).  Fluid labels:  FLOW (fluid flow).  Electric
            labels:  AMPS (current flow), CHRG (electric charge).  Magnetic
            labels:  FLUX (magnetic flux);  CSGX, CSGY, or CSGZ (magnetic
            current segments). Diffusion labels: RATE (diffusion flow rate).

        value
            Force value or table name reference for specifying tabular boundary
            conditions.  To specify a table, enclose the table name in percent
            signs (%), e.g., FK, KPOI, HEAT,%tabname%).  Use the *DIM command
            to define a table.

        value2
            Second force value (if any).  If the analysis type and the force
            allow a complex input, VALUE (above) is the real component and
            VALUE2 is the imaginary component.

        Notes
        -----
        Forces may be transferred from keypoints to nodes with the FTRAN or
        SBCTRAN commands.  See the F command for a description of force loads.

        Tabular boundary conditions (VALUE = %tabname%) are available only for
        the following labels: Fluid (FLOW), Electric (AMPS), Structural force
        (FX, FY, FZ, MX, MY, MZ), and Thermal (HEAT, HBOT, HE2, HE3, . . .,
        HTOP).

        This command is also valid in PREP7.
        """
        command = "FK,%s,%s,%s,%s" % (str(kpoi), str(lab), str(value), str(value2))
        return self.run(command, **kwargs)

    def rsopt(self, opt="", filename="", ext="", dir="", **kwargs):
        """APDL Command: RSOPT

        Creates or loads the radiosity mapping data file for SURF251 or SURF252
        element types.

        Parameters
        ----------
        opt
            File option:

            SAVE - Write the radiosity mapping data to a file. (Default)

            LOAD - Read in the specified mapping data file.

        fname
            File name for radiosity mapping data file. Defaults to Jobname.

        ext
            Filename extension for radiosity mapping data file (default =
            .rsm).

        dir
            Directory path for radiosity mapping data file. If you do not
            specify a directory path, it will default to your working
            directory.

        Notes
        -----
        Use this command to manually create or load a radiosity mapping data
        file. This command is useful if you want to create the mapping data
        file without issuing SAVE or CDWRITE, or if you want to specify that
        the file be located in a directory other than your working directory.
        Also use this command to manually load an existing mapping data file
        during a restart.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RSOPT,%s,%s,%s,%s" % (str(opt), str(filename), str(ext), str(dir))
        return self.run(command, **kwargs)

    def pnum(self, label="", key="", **kwargs):
        """APDL Command: /PNUM

        Controls entity numbering/coloring on plots.

        Parameters
        ----------
        label
            Type of numbering/coloring:

            NODE - Node numbers on node and element plots.

            ELEM - Element numbers and colors on element plots.

            SEC - Section numbers and colors on element and solid model plots (see "Notes").

            MAT - Material set numbers and colors on element and solid model plots  (see
                  "Notes").

            TYPE - Element type reference numbers and colors on element and solid model plots (see
                   "Notes").

            REAL - Real constant set numbers and colors on element and solid model plots (see
                   "Notes").

            ESYS - Element coordinate system numbers on element and solid model plots (see
                   "Notes").

            PART - Element part numbers and colors on element plots (applicable to ANSYS LS-DYNA
                   only).

            LOC - Location numbers/colors of the element in matrix assembly order on element
                  plots.

            Note:LOC and ELEM numbers will be the same unless the model has been reordered. - KP

            Keypoint numbers on solid model plots. - LINE

            Line numbers on solid model plots (both numbers and colors on line plots). - AREA

            Area numbers on solid model plots (both numbers and colors on area plots). - VOLU

            Volume numbers on solid model plots (both numbers and colors on volume plots). - SVAL

            Stress (or any contour) values on postprocessing plots, and surface load values and colors on model plots (when surface load symbols are on [/PSF]).  For tabular boundary conditions, the table-evaluated values will be displayed on node, element, or contour displays in POST1 when load symbols (/PBF, /PSF, /PBC) are on and TABNAM is OFF. - TABNAM

            Table names for tabular boundary conditions.  If this label is turned on, the table name appears next to the appropriate symbol, arrow, face outline, or contour as dictated by the /PSF, /PBC, and /PBF commands. - STAT

            Shows current settings for /PNUM. - DEFA

        key
            Switch:

            0 - Turns OFF numbers/colors for specified label.

            1 - Turns ON numbers/colors for specified label.

        Notes
        -----
        This command specifies entity numbering and coloring for subsequent
        plots.

        The MAT, TYPE, REAL, and ESYS labels activate both the numbering and
        coloring of the corresponding attributes for  EPLOT, KPLOT, LPLOT,
        APLOT, and VPLOT. The ELEM, MAT, TYPE, REAL, ESYS, PART (ANSYS LS-DYNA
        only), and LOC labels are mutually exclusive, i.e., only one can be
        specified at a time. Also, turning on a LINE, AREA, or VOLU label will
        turn off the MAT, TYPE, REAL, and PART labels.

        PowerGraphics [/GRAPHICS,POWER] displays for/PNUM can be problematic.
        /PNUM,ELEM will display erratically depending on other display command
        specifications, while /PNUM,LOC and /PNUM,ESYS are not supported.

        Element and volume numbers are not visible for 3-D elements and volumes
        when Z-buffering is turned on (/TYPE,,[6,7, or 8]).

        Use /PSTATUS or /PNUM,STAT to show settings. Use /PNUM,DEFA to reset
        all specifications back to default. Use the /NUMBER command to control
        whether numbers and colors are displayed together.

        This command is valid in any processor
        """
        command = "/PNUM,%s,%s" % (str(label), str(key))
        return self.run(command, **kwargs)

    def rmsave(self, fname="", ext="", **kwargs):
        """APDL Command: RMSAVE

        Saves ROM data to file.

        Parameters
        ----------
        fname
            Name and directory path of the ROM database file. Default to
            Jobname.

        ext
            Extension of the ROM database file. Default to .rom.

        --
            Unused field.

        Notes
        -----
        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMSAVE,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def xfdata(self, enrichmentid="", elemnum="", nodenum="", phi="",
               **kwargs):
        """APDL Command: XFDATA

        Defines a crack in the model by specifying nodal level set values

        Parameters
        ----------
        enrichmentid
            Name of the enrichment specified via the associated XFENRICH
            command.

        lsm (or blank)
            Specify LSM to indicate that level set values (PHI and optional
            PSI) are specified.

        elemnum
            Element number.

        nodenum
            Node number associated with the specified element ELNUM.

        phi
            Signed normal distance of the node from the crack.

        Notes
        -----
        Issue the XFDATA command multiple times as needed to specify nodal
        level set values for all nodes of an element.

        This command is valid in PREP7 (/PREP7) only.
        """
        command = "XFDATA,%s,%s,%s,%s" % (str(enrichmentid), str(elemnum), str(nodenum), str(phi))
        return self.run(command, **kwargs)

    def prrfor(self, lab="", **kwargs):
        """APDL Command: PRRFOR

        Prints the constrained node reaction solution. Used with the FORCE
        command.

        Parameters
        ----------
        lab
            Nodal reaction load type.  If blank, use the first ten of all
            available labels. Valid labels are:

        Notes
        -----
        PRRFOR has the same functionality as the PRRSOL command; use PRRFOR
        instead of PRRSOL when a FORCE command has been issued.

        In a non-spectrum analysis, if either contact or pretension elements
        exist in the model, PRRFOR uses the PRRSOL command internally and the
        FORCE setting is ignored.

        Because modal displacements cannot be used to calculate contact element
        nodal forces,: those forces are not included in the spectrum and PSD
        analyses reaction solution. As a consequence, the: PRRFOR: command is
        not supported when constraints on contact element pilot nodes are
        present.
        """
        command = "PRRFOR,%s" % (str(lab))
        return self.run(command, **kwargs)

    def slashfdele(self, ident="", stat="", **kwargs):
        """APDL Command: /FDELE

        Deletes a binary file after it is used.

        Parameters
        ----------
        ident
            ANSYS file name identifier.  Valid identifiers are:  EMAT, ESAV,
            FULL, SUB, MODE, DSUB, USUB, OSAV, and SELD.  See the Basic
            Analysis Guide for file descriptions.

        stat
            Keep or delete key:

            KEEP - Keep this file.

            DELE - Delete (or do not write, if not necessary) this file.

        Notes
        -----
        Deletes as soon as possible (or prevents writing) a binary file created
        by the ANSYS program to save space.

        Caution:: : Deleting files that are necessary for the next substep,
        load step, or analysis will prevent continuation of the run.

        This command is valid only at the Begin Level.
        """
        command = "/FDELE,%s,%s" % (str(ident), str(stat))
        return self.run(command, **kwargs)

    def solu(self, nvar="", item="", comp="", name="", **kwargs):
        """APDL Command: SOLU

        Specifies solution summary data per substep to be stored.

        Parameters
        ----------
        nvar
            Arbitrary reference number assigned to this variable (2 to NV
            [NUMVAR]).

        item
            Label identifying the item.  Valid item labels are shown in the
            table below.  Some items may also require a component label.

        comp
            Component of the item (if required).  Valid component labels are
            shown in the table below.  None are currently required.

        name
            Thirty-two character name identifying the item on printouts and
            displays.  Defaults to an eight character label formed by
            concatenating the first four characters of the Item and Comp
            labels.

        Notes
        -----
        See also the PRITER command of POST1 to display some of these items
        directly.  Valid for a static or full transient analysis. All other
        analyses have zeros for the data. Valid item and component labels for
        solution summary values are:
        """
        command = "SOLU,%s,%s,%s,%s" % (str(nvar), str(item), str(comp), str(name))
        return self.run(command, **kwargs)

    def emft(self, **kwargs):
        """APDL Command: EMFT

        Summarizes electromagnetic forces and torques.

        Notes
        -----
        Use this command to summarize electromagnetic force and torque in both
        static electric and magnetic problems. To use this command, select the
        nodes in the region of interest and make sure that all elements are
        selected. If RSYS = 0, the force is reported in the global Cartesian
        coordinate system. If RSYS ≠ 0, force is reported in the specified
        coordinate system. However, for torque, if RSYS ≠ 0, this command will
        account for the shift and rotation as specified by RSYS, but will
        report only the Cartesian components.

        Forces are stored as items _FXSUM, _FYSUM, _FZSUM, and _FSSUM. Torque
        is stored as items _TXSUM, _TYSUM, _TZSUM, and _TSSUM.

        This command is valid only with PLANE121, SOLID122, SOLID123, PLANE233,
        SOLID236 and SOLID237 elements. For any other elements, you must use
        FMAGSUM.
        """
        command = "EMFT," % ()
        return self.run(command, **kwargs)

    def selist(self, sename="", kopt="", kint="", **kwargs):
        """APDL Command: SELIST

        Lists the contents of a superelement matrix file.

        Parameters
        ----------
        sename
            The name (case-sensitive) of the superelement matrix file created
            by the substructure generation pass (Sename.SUB).   Defaults to the
            current Jobname.  If a number, it is the element number of the
            superelement as used in the use pass.

        kopt
            List key:

            0 - List summary data only.

            1 - List contents, except load vectors and matrices.

            2 - List contents, except matrices.

            3 - List full contents.  Be aware that the listing may be extensive.

        kint
            Integer printout format key:

            OFF - Default.

            ON - Long format for large integers.

        Notes
        -----
        This command is valid in any processor.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "SELIST,%s,%s,%s" % (str(sename), str(kopt), str(kint))
        return self.run(command, **kwargs)

    def knode(self, npt="", node="", **kwargs):
        """APDL Command: KNODE

        Defines a keypoint at an existing node location.

        Parameters
        ----------
        npt
            Arbitrary reference number for keypoint.  If zero, the lowest
            available number is assigned [NUMSTR].

        node
            Node number defining global X, Y, Z keypoint location.  If NODE =
            P, graphical picking is enabled and all remaining command fields
            are ignored (valid only in the GUI).  A component name may also be
            substituted for NODE.
        """
        command = "KNODE,%s,%s" % (str(npt), str(node))
        return self.run(command, **kwargs)

    def ndist(self, nd1="", nd2="", **kwargs):
        """APDL Command: NDIST

        Calculates and lists the distance between two nodes.

        Parameters
        ----------
        nd1
            First node in distance calculation.  If ND1 = P, graphical picking
            is enabled and all remaining command fields are ignored (valid only
            in the GUI).

        nd2
            Second node in distance calculation.

        Notes
        -----
        NDIST lists the distance between nodes ND1 and ND2, as well as the
        current coordinate system offsets from ND1 to ND2, where the X, Y, and
        Z locations of ND1 are subtracted from the X, Y, and Z locations of ND2
        (respectively) to determine the offsets.  NDIST is valid in any
        coordinate system except toroidal [CSYS,3].

        NDIST returns a variable, called "_RETURN," which contains the distance
        value. You can use this value for various purposes, such as the
        calculation of distributed loads. In interactive mode, you can access
        this command by using the Model Query Picker (Utility Menu> List>
        Picked Entities), where you can also access automatic annotation
        functions and display the value on your model.

        This command is valid in any processor.
        """
        command = "NDIST,%s,%s" % (str(nd1), str(nd2))
        return self.run(command, **kwargs)

    def smax(self, labr="", lab1="", lab2="", fact1="", fact2="", **kwargs):
        """APDL Command: SMAX

        Forms an element table item from the maximum of two other items.

        Parameters
        ----------
        labr
            Label assigned to results.  If same as existing label, the existing
            values will be overwritten by these results.

        lab1
            First labeled result item in operation.

        lab2
            Second labeled result item in operation (may be blank).

        fact1
            Scale factor applied to Lab1. A (blank) or '0' entry defaults to
            1.0.

        fact2
            Scale factor applied to Lab2. A (blank) or '0' entry defaults to
            1.0.

        Notes
        -----
        Forms a labeled result item (see ETABLE command) for the selected
        elements by comparing two existing labeled result items according to
        the operation:

        LabR = (FACT1 x Lab1) cmx (FACT2 x Lab2)

        where "cmx" means "compare and save maximum."  If absolute values are
        requested [SABS,1], the absolute values of Lab1 and Lab2 are used.
        """
        command = "SMAX,%s,%s,%s,%s,%s" % (str(labr), str(lab1), str(lab2), str(fact1), str(fact2))
        return self.run(command, **kwargs)

    def emf(self, **kwargs):
        """APDL Command: EMF

        Calculates the electromotive force (emf), or voltage drop along a
        predefined path.

        Notes
        -----
        EMF invokes an ANSYS macro which calculates the electromotive force
        (emf), or voltage drop along a predefined path (specified with the PATH
        command). It is valid for both 2-D and 3-D electric field analysis or
        high-frequency electromagnetic field analysis. The calculated emf value
        is stored in the parameter EMF.

        You must define a line path (via the PATH command) before issuing the
        EMF command macro. The macro uses calculated values of the electric
        field (EF), and uses path operations for the calculations. All path
        items are cleared when the macro finishes executing.

        The EMF macro sets the "ACCURATE" mapping method and "MAT"
        discontinuity option on the PMAP command. The ANSYS program retains
        these settings after executing the macro.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EMF," % ()
        return self.run(command, **kwargs)

    def igesin(self, fname="", ext="", **kwargs):
        """APDL Command: IGESIN

        Transfers IGES data from a file into ANSYS.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Reads a file containing IGES data and transfers it into the ANSYS
        database.  The file transferred is the IGES Version 5.1, ASCII format
        file.  IGES (Initial Graphics Exchange Specification) is a neutral
        format developed by the U.S. Dept. of Commerce, National Institute of
        Standards and Technology.  There is no output transfer file written
        since the transferred data is read directly into the ANSYS database.

        You can import multiple files into a single database, but you must use
        the same import option (set with the IOPTN command) for each file.

        The IOPTN command sets the parameters for reading the file.  Files read
        via the SMOOTH method (the only available method) use the standard
        database.
        """
        command = "IGESIN,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def mater(self, **kwargs):
        """APDL Command: MATER

        Specifies "Material properties" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "MATER," % ()
        return self.run(command, **kwargs)

    def cfopen(self, fname="", ext="", loc="", **kwargs):
        """APDL Command: *CFOPEN

        Opens a "command" file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        loc
            Determines whether existing file will be overwritten or appended:

            The existing file will be overwritten. - The file will be appended to the existing file.

        Notes
        -----
        Data processed with the *VWRITE command will also be written to this
        file if the file is open when the *VWRITE command is issued.

        This command is valid in any processor.
        """
        command = "*CFOPEN,%s,%s,%s" % (str(fname), str(ext), str(loc))
        return self.run(command, **kwargs)

    def pldisp(self, kund="", **kwargs):
        """APDL Command: PLDISP

        Displays the displaced structure.

        Parameters
        ----------
        kund
            Undisplaced shape key:

            0 - Display only displaced structure.

            1 - Overlay displaced display with similar undisplaced display (appearance is
                system-dependent).

            2 - Same as 1 except overlay with undisplaced edge display (appearance is system-
                dependent).

        Notes
        -----
        Displays the displaced structure for the selected elements.

        For information on true scale plots, refer to the description of the
        /DSCALE command [/DSCALE,,1.0].
        """
        command = "PLDISP,%s" % (str(kund))
        return self.run(command, **kwargs)

    def chkmsh(self, comp="", **kwargs):
        """APDL Command: CHKMSH

        Checks area and volume entities for previous meshes.

        Parameters
        ----------
        comp
            Name of component containing areas or volumes.

        Notes
        -----
        CHKMSH invokes a predefined ANSYS macro that checks areas and volumes
        to find out if they were previously meshed.  This macro name will
        appear in the log file (Jobname.LOG) prior to area and volume meshing
        operations initiated through the GUI.  This command is not intended to
        be typed in directly in an ANSYS session (although it can be included
        in an input file for use with the /INPUT command).
        """
        command = "CHKMSH,%s" % (str(comp))
        return self.run(command, **kwargs)

    def edasmp(self, option="", _asmid="", part1="", part2="", part3="",
               part4="", part5="", part6="", part7="", part8="", part9="",
               part10="", part11="", part12="", part13="", part14="",
               part15="", part16="", **kwargs):
        """APDL Command: EDASMP

        Creates a part assembly to be used in an explicit dynamic analysis.

        Parameters
        ----------
        option
            Label identifying the part assembly option to be performed.

            ADD - Adds a part assembly (default).

            DELETE - Deletes a part assembly.

            LIST - Lists each part assembly number, and the part numbers that make up each part
                   assembly.

        asmid
             User defined part assembly ID number. The part assembly number
            cannot be the same as any currently defined part ID number.

        part1, part2, part3, . . . , part16
            Part numbers to be included in the assembly (up to 16 different
            parts).

        Notes
        -----
        Several ANSYS LS-DYNA commands (such as EDCGEN, EDPVEL, and EDIS) refer
        to assembly ID numbers. If you intend to use assembly ID numbers with
        these commands, you must first define the assembly ID numbers using
        EDASMP.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDASMP,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(_asmid), str(part1), str(part2), str(part3), str(part4), str(part5), str(part6), str(part7), str(part8), str(part9), str(part10), str(part11), str(part12), str(part13), str(part14), str(part15), str(part16))
        return self.run(command, **kwargs)

    def vput(self, par="", ir="", tstrt="", kcplx="", name="", **kwargs):
        """APDL Command: VPUT

        Moves an array parameter vector into a variable.

        Parameters
        ----------
        par
            Array parameter vector in the operation.

        ir
            Arbitrary reference number assigned to this variable (1 to NV
            [NUMVAR]).  Overwrites any existing results for this variable.

        tstrt
            Time (or frequency) corresponding to start of IR data.  If between
            values, the nearer value is used.

        kcplx
            Complex number key:

            0 - Use the real part of the IR data.

            1 - Use the imaginary part of the IR data.

        name
            Thirty-two character name identifying the item on printouts and
            displays. Defaults to the label formed by concatenating VPUT with
            the reference number IR.

        Notes
        -----
        At least one variable should be defined (NSOL, ESOL, RFORCE, etc.)
        before using this command.  The starting array element number must be
        defined.  For example, VPUT,A(1),2 moves array parameter A to variable
        2 starting at time 0.0.  Looping continues from array element A(1) with
        the index number incremented by one until the variable is filled.
        Unfilled variable locations are assigned a zero value.  The number of
        loops may be controlled with the *VLEN command (except that loop
        skipping (NINC) is not allowed).  For multi-dimensioned array
        parameters, only the first (row) subscript is incremented.
        """
        command = "VPUT,%s,%s,%s,%s,%s" % (str(par), str(ir), str(tstrt), str(kcplx), str(name))
        return self.run(command, **kwargs)

    def int1(self, ir="", iy="", ix="", name="", facta="", factb="", const="",
             **kwargs):
        """APDL Command: INT1

        Integrates a variable.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.  Table values represent integrated
            sum of IY to current table position of IX.

        iy, ix
            Integrate variable IY with respect to IX.

        --
            Unused field.

        name
            Thirty-two character name for identifying the variable on the
            printout and displays.  Embedded blanks are compressed upon output.

        --, --
            Unused fields.

        facta, factb
            Scaling factors (positive or negative) applied to the corresponding
            variables (default to 1.0).

        const
            Initial value.

        Notes
        -----
        Integrates variables according to the operation:

        IR = ∫ (FACTA x IY) d(FACTB x IX) + CONST
        """
        command = "INT1,%s,%s,%s,%s,%s,%s,%s" % (str(ir), str(iy), str(ix), str(name), str(facta), str(factb), str(const))
        return self.run(command, **kwargs)

    def kscon(self, npt="", delr="", kctip="", nthet="", rrat="", **kwargs):
        """APDL Command: KSCON

        Specifies a keypoint about which an area mesh will be skewed.

        Parameters
        ----------
        npt
            Keypoint number at concentration.  If NPT = ALL, use all selected
            keypoints.  If remaining fields are blank, remove concentration
            from this keypoint (if unmeshed).  If NPT = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for NPT.

        delr
            Radius of first row of elements about keypoint.

        kctip
            Crack tip singularity key:

            0 - Do not skew midside nodes, if any, within the element.

            1 - Skew midside nodes of the first row of elements to the 1/4 point for crack tip
                singularity.

        nthet
            Number of elements in circumferential direction (defaults to
            approximately one per 45° (or one per 30°, if KCTIP = 1)).

        rrat
            Ratio of 2nd row element size to DELR (defaults to 0.75, or 0.5 if
            KCTIP = 1).

        Notes
        -----
        Defines a concentration keypoint about which an area mesh will be
        skewed. Useful for modeling stress concentrations and crack tips.
        During meshing, elements are initially generated circumferentially
        about, and radially away, from the keypoint. Lines attached to the
        keypoint are given appropriate divisions and spacing ratios. Only one
        concentration keypoint per unmeshed area is allowed.  Use KSCON,STAT to
        list current status of concentration keypoints. The KSCON command does
        not support 3-D modeling.

        This command is also valid for rezoning.
        """
        command = "KSCON,%s,%s,%s,%s,%s" % (str(npt), str(delr), str(kctip), str(nthet), str(rrat))
        return self.run(command, **kwargs)

    def rmmlist(self, **kwargs):
        """APDL Command: RMMLIST

        Lists all mode specifications for the ROM method.

        Notes
        -----
        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMMLIST," % ()
        return self.run(command, **kwargs)

    def pspec(self, pcolor="", kfill="", kbordr="", **kwargs):
        """APDL Command: /PSPEC

        Creates annotation polygon attributes (GUI).

        Parameters
        ----------
        pcolor
            Polygon color (0  PCOLOR   15):

            0 - Black.

            1 - Red-Magenta.

            2 - Magenta.

            3 - Blue-Magenta.

            4 - Blue.

            5 - Cyan-Blue.

            6 - Cyan.

            7 - Green-Cyan.

            8 - Green.

            9 - Yellow-Green.

            10 - Yellow.

            11 - Orange.

            12 - Red.

            13 - Dark Gray.

            14 - Light Gray.

            15 - White.

        kfill
            Polygon fill key:

            0 - Hollow polygon.

            1 - Filled polygon.

        kbordr
            Polygon border key:

            0 - No border.

            1 - Border.

        Notes
        -----
        Creates annotation polygon attributes to control certain
        characteristics of the polygons created via the /POLYGON, /PMORE,
        /PCIRCLE and /PWEDGE commands.  This is a command generated by the
        Graphical User Interface (GUI) and will appear in the log file
        (Jobname.LOG) if annotation is used.  This command is not intended to
        be typed in directly in an ANSYS session (although it can be included
        in an input file for batch input or for use with the /INPUT command).

        This command is valid in any processor.
        """
        command = "/PSPEC,%s,%s,%s" % (str(pcolor), str(kfill), str(kbordr))
        return self.run(command, **kwargs)

    def gline(self, wn="", style="", **kwargs):
        """APDL Command: /GLINE

        Specifies the element outline style.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        style
            Outline key:

             0  - Solid element outlines (default)

             1  - Dashed element outlines

            -1  - No element outlines

        Notes
        -----
        Determines the element outline style.  Often used when node numbers are
        displayed to prevent element lines from overwriting node numbers.

        Unless you are using an OpenGL or Starbase driver, the dashed element
        outline option (/GLINE,WN,1) is not available in the following
        situations:

        Z-buffered displays (/TYPE,WN,6).

        Capped Z-buffered displays (/TYPE,WN,7).

        Qslice Z-buffered displays (/TYPE,WN,8).

        This command is valid in any processor.
        """
        command = "/GLINE,%s,%s" % (str(wn), str(style))
        return self.run(command, **kwargs)

    def nprint(self, n="", **kwargs):
        """APDL Command: NPRINT

        Defines which time points stored are to be listed.

        Parameters
        ----------
        n
            List data associated with every N time (or frequency) point(s),
            beginning with the first point stored (defaults to 1).

        Notes
        -----
        Defines which time (or frequency) points within the range stored are to
        be listed.
        """
        command = "NPRINT,%s" % (str(n))
        return self.run(command, **kwargs)

    def nsla(self, type="", nkey="", **kwargs):
        """APDL Command: NSLA

        Selects those nodes associated with the selected areas.

        Parameters
        ----------
        type
            Label identifying the type of node select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        nkey
            Specifies whether only interior area nodes are to be selected:

            0 - Select only nodes interior to selected areas.

            1 - Select all nodes (interior to area, interior to lines, and at keypoints)
                associated with the selected areas.

        Notes
        -----
        Valid only if the nodes were generated by an area meshing operation
        [AMESH, VMESH] on a solid model that contains the selected areas.

        This command is valid in any processor.
        """
        command = "NSLA,%s,%s" % (str(type), str(nkey))
        return self.run(command, **kwargs)

    def addam(self, af="", aa="", ab="", ac="", ad="", amin="", **kwargs):
        """APDL Command: ADDAM

        Specifies the acceleration spectrum computation constants for the
        analysis of shock resistance of shipboard structures.

        Parameters
        ----------
        af
            Direction-dependent acceleration coefficient for elastic or
            elastic-plastic analysis option (default = 0).

        aa, ab, ac, ad
            Coefficients for the DDAM acceleration spectrum equations. Default
            for these coefficients is zero.

        amin
            The minimum acceleration value in inch/sec2.  It defaults to 2316
            inch/sec2 which equals 6g, where g is acceleration due to gravity
            (g = 386 inch/sec2).

        Notes
        -----
        This command specifies acceleration coefficients to analyze shock
        resistance of shipboard equipment.  These coefficients are used to
        compute mode coefficients according to the equations given in Dynamic
        Design Analysis Method in the Mechanical APDL Theory Reference.  The
        form of these equations is based on the Naval NRL Dynamic Design
        Analysis Method.  This command, along with the VDDAM and SED commands,
        is used with the spectrum (ANTYPE,SPECTR) analysis as a special purpose
        alternative to the SV, FREQ, and SVTYP commands.  The mass and length
        units of the model must be in pounds and inches, respectively.

        DDASPEC may alternatively be used to calculate spectrum coefficients.

        This command is also valid in PREP7.
        """
        command = "ADDAM,%s,%s,%s,%s,%s,%s" % (str(af), str(aa), str(ab), str(ac), str(ad), str(amin))
        return self.run(command, **kwargs)

    def quit(self, **kwargs):
        """APDL Command: /QUIT

        Exits a processor.

        Notes
        -----
        This is an alternative to the FINISH command.  If any cleanup or file
        writing is normally done by the FINISH command, it is bypassed if the
        /QUIT command is used instead.  A new processor may be entered after
        this command.  See the /EXIT command to terminate the run.

        This command is valid in any processor.  This command is not valid at
        the Begin level.
        """
        command = "/QUIT," % ()
        return self.run(command, **kwargs)

    def esol(self, nvar="", elem="", node="", item="", comp="", name="",
             **kwargs):
        """APDL Command: ESOL

        Specifies element data to be stored from the results file.

        Parameters
        ----------
        nvar
            Arbitrary reference number assigned to this variable (2 to NV
            [NUMVAR]). Overwrites any existing results for this variable.

        elem
            Element for which data are to be stored. If ELEM = P, graphical
            picking is enabled (valid only in the GUI).

        node
            Node number on this element for which data are to be stored. If
            blank, store the average element value (except for FMAG values,
            which are summed instead of averaged). If NODE = P, graphical
            picking is enabled (valid only in the GUI).

        item
            Label identifying the item. General item labels are shown in
            Table 134: ESOL - General Item and Component Labels below. Some
            items also require a component label.

        comp
            Component of the item (if required). General component labels are
            shown in Table 134: ESOL - General Item and Component Labels below.
            If Comp is a sequence number (n), the NODE field will be ignored.

        name
            Thirty-two character name for identifying the item on the printout
            and displays.  Defaults to a label formed by concatenating the
            first four characters of the Item and Comp labels.

        Notes
        -----
        See Table: 134:: ESOL - General Item and Component Labels for a list of
        valid item and component labels for element (except line element)
        results.

        The ESOL command defines element results data to be stored from a
        results file (FILE). Not all items are valid for all elements. To see
        the available items for a given element, refer to the input and output
        summary tables in the documentation for that element.

        Two methods of data access are available via the ESOL command. You can
        access some simply by using a generic label (component name method),
        while others require a label and number (sequence number method).

        Use the component name method to access general element data (that is,
        element data generally available to most element types or groups of
        element types).

        The sequence number method is required for data that is not averaged
        (such as pressures at nodes and temperatures at integration points), or
        data that is not easily described in a generic fashion (such as all
        derived data for structural line elements and contact elements, all
        derived data for thermal line elements, and layer data for layered
        elements).

        Element results are in the element coordinate system, except for
        layered elements where results are in the layer coordinate system.
        Element forces and moments are in the nodal coordinate system. Results
        are obtainable for an element at a specified node. Further location
        specifications can be made for some elements via the SHELL, LAYERP26,
        and FORCE commands.

        Table: 134:: : ESOL - General Item and Component Labels

        For more information on the meaning of contact status and its possible
        values, see Reviewing Results in POST1 in the Contact Technology Guide.
        """
        command = "ESOL,%s,%s,%s,%s,%s,%s" % (str(nvar), str(elem), str(node), str(item), str(comp), str(name))
        return self.run(command, **kwargs)

    def edcnstr(self, option="", ctype="", comp1="", comp2="", val1="",
                **kwargs):
        """APDL Command: EDCNSTR

        Defines various types of constraints for an explicit dynamic analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed.

            ADD - Define a constraint (default).

            DELE - Delete the constraint specified by Ctype, Comp1, and Comp2. If Ctype = ALL, all
                   constraints are deleted.

            LIST - List all of the constraints previously defined by the EDCNSTR command.

        ctype
            Constraint type. The command format will vary, depending on the
            Ctype value.

            ENS - Extra node set added to an existing rigid body.

            NRB - Nodal rigid body.

            STS - Tie between a shell edge and solid elements.

            RIVET - Massless rivet between two noncoincident nodes.

        Notes
        -----
        The EDCNSTR command allows you to define several types of constraints
        in an explicit dynamic analysis. A brief description of each constraint
        type is given below. See Constraints and Initial Conditions in the
        ANSYS LS-DYNA User's Guide for more information.

        Extra Node Set Added to a Rigid Body (Ctype = ENS)

        The ability to add extra nodes to an existing rigid body has many
        potential applications, including placing nodes where joints will be
        attached between rigid bodies, defining nodes where point loads will be
        applied, and defining a lumped mass at a specific location. The extra
        nodes specified by Comp2 may be located anywhere in the model and may
        have coordinates outside those of the original rigid body specified by
        Comp1.

        Nodal Rigid Body (Ctype = NRB)

        Unlike typical rigid bodies that are defined with the EDMP command,
        nodal rigid bodies defined with the EDCNSTR command are not associated
        with a part number. This can be advantageous for modeling rigid
        (welded) joints in a model. For a rigid joint, portions of different
        flexible components (having different MAT IDs) act together as a rigid
        body. It is difficult to define this type of rigid body with a unique
        MAT ID (and corresponding part number). However, the rigid joint can be
        easily defined using a nodal rigid body.

        Shell Edge to Solid Tie (Ctype = STS)

        The STS option ties regions of solid elements to regions of shell
        elements. A single shell node may be tied to up to nine brick element
        nodes that define a “fiber” vector. Solid element nodes constrained in
        this way remain linear throughout the analysis but can move relative to
        each other in the fiber direction.

        Rivet between Two Nodes (Ctype = RIVET)

        The RIVET option defines a massless rigid constraint between two nodes,
        similar to spotwelds defined with the EDWELD command. Unlike a
        spotweld, however, rivets contain nodes that are noncoincident, and
        failure cannot be specified. When a rivet is defined, the distance
        between the nodes is kept constant throughout any motion that occurs
        during a simulation. Nodes connected by a rivet cannot be part of any
        other constraints specified in the model.

        The EDCNSTR command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDCNSTR,%s,%s,%s,%s,%s" % (str(option), str(ctype), str(comp1), str(comp2), str(val1))
        return self.run(command, **kwargs)

    def slist(self, sfirst="", sl_ast="", sinc="", details="", type="",
              **kwargs):
        """APDL Command: SLIST

        Summarizes the section properties for all defined sections in the
        current session.

        Parameters
        ----------
        sfirst
            First section ID to be summarized. Defaults to first available
            section in the database.

        slast
            Last section ID to be summarized. Defaults to last available
            section in the database.

        sinc
            Increment of the section ID; defaults to 1.

        details
            Determines the content of the summarized information for beams and
            shells.

            BRIEF - For beams, lists only the section integrated properties (such as Area, Iyy, and
                    Iyz). This option is the default.

            FULL - For beams, lists the section integrated properties, as well as the section
                   nodal coordinates, section cell connectivity information,
                   and section cell integration point coordinates. For shells,
                   the section stiffness (membrane, bending, membrane-bending
                   coupling and transverse shear) are printed.

            The shell section stiffness listed considers elastic behavior of materials at reference temperature only. The elements that use the section data may alter the transverse shear stiffness based on slenderness considerations (in addition to the shear correction factors shown).  - Section stiffness terms listed via the FULL option do not include section
                              offsets. The ANSYS program considers section
                              offsets during the solution phase of the
                              analysis.

            GROUP - If a section calls other sections, this option lists those sections too.

        type
            The section type. Valid arguments are ALL (the default) and the
            types available on the SECTYPE command.

        Notes
        -----
        By default, the command lists information concerning all sections;
        however, you can limit the output to only beam or pretension sections
        via the Type key. Also, by default when ocean loading is present, the
        command lists the beam section properties used by ocean loading.

        Following is example output from the SLIST,,,,BRIEF command for a
        rectangular beam section subtype (SECTYPE,,BEAM,RECT):
        """
        command = "SLIST,%s,%s,%s,%s,%s" % (str(sfirst), str(sl_ast), str(sinc), str(details), str(type))
        return self.run(command, **kwargs)

    def pdinqr(self, rpar="", name="", type="", val="", **kwargs):
        """APDL Command: PDINQR

        Evaluates statistical characteristics of a random input variable.

        Parameters
        ----------
        rpar
            Name of scalar ANSYS parameter into which the characteristic value
            is stored.

        name
            Parameter name. The parameter must have been previously defined as
            a random input variable using the PDVAR command.

        type
            Keyword for the type of information you need to retrieve.

            MEAN - Mean value of the random input variable specified in Name.

            STDV - Standard deviation of the random input variable

            PDF - Probability density function of the random input variable specified in Name at
                  a given value specified by VAL.

            CDF - Cumulative distribution function of the random input variable specified in Name
                  at a given value specified by VAL.

            INV - Inverse cumulative distribution function of the random input variable specified
                  in Name at a given probability specified by VAL.

        val
            Value needed for Type = PDF, CDF, or INV. For Type = PDF and Type =
            CDF, this is the value of the random input variable at which the
            probabilistic density or cumulative distribution function should be
            evaluated. For Type = INV, VAL indicates the probability at which
            you want the inverse cumulative distribution function evaluated.

        Notes
        -----
        Evaluates statistical characteristics of a random input variable. The
        result is stored in the ANSYS parameter Rpar.
        """
        command = "PDINQR,%s,%s,%s,%s" % (str(rpar), str(name), str(type), str(val))
        return self.run(command, **kwargs)

    def asol(self, lab="", opt="", **kwargs):
        """APDL Command: ASOL

        Specifies the output type of an acoustic scattering analysis.

        Parameters
        ----------
        lab
            Acoustic solver specification (no default):

            SCAT - Set acoustic solver to the scattered field formulation.

        opt
            Option identifying an acoustic solver status:

            OFF - Deactivate the specified acoustic solver (default).

            ON - Activate the specified acoustic solver.

        Notes
        -----
        Use the ASOL command to activate the specified acoustic solution
        process.

        The scattered option (Lab = SCAT) sets the acoustic solver to the
        scattered-pressure field formulation.

        Issue the AWAVE command to define the incident pressure pinc. If the
        AWAVE command is defined with Opt2 = INT, the acoustic solver is set to
        the scattered field formulation regardless of the ASOL command issued.
        """
        command = "ASOL,%s,%s" % (str(lab), str(opt))
        return self.run(command, **kwargs)

    def trlcy(self, lab="", tlevel="", n1="", n2="", ninc="", **kwargs):
        """APDL Command: /TRLCY

        Specifies the level of translucency.

        Parameters
        ----------
        lab
            Apply translucency level to the items specified by the following
            labels:

            ELEM - Elements.  Use N1, N2, NINC fields for element numbers.

            AREA - Solid model areas.  Use N1, N2, NINC fields for area numbers.

            VOLU - Solid model volumes.  Use N1, N2, NINC fields for volume numbers.

            ISURF - Isosurfaces (surfaces of constant stress, etc., value).  Translucency varies
                    with result value, to a maximum of the specified
                    translucency level.

            CM - Component group.  Use N1 for component name, ignore N2 and NINC.

            CURVE - Filled areas under curves of line graphs.  Use N1, N2, NINC fields for curve
                    numbers.

            ZCAP - If /TYPE,WN,ZCAP is the current display type, then /TRLCY,ZCAP,TLEVEL will
                   display the model in window WN with the portion of the model
                   in front of the section plane displayed at the translucency
                   level TLEVEL.

            ON, OFF - Sets the specified translucency display on or off. All other fields are
                      ignored.

        tlevel
            Translucency level:  0.0 (opaque) to 1.0 (transparent).

        n1, n2, ninc
            Used only with labels as noted above.  Apply translucency level to
            Lab items numbered N1 to N2 (defaults to N1) in steps of NINC
            (defaults to 1).  If N1 is blank or ALL, apply specified
            translucency level to entire selected range.  If Lab is CM, use
            component name for N1 and ignore N2 and NINC. A value of N1 = P
            allows you to graphically pick elements, areas, and volumes. You
            can then assign translucency levels to the entities via the picker.
            The Lab and TLEVEL fields are ignored when translucency is applied
            by picking.

        Notes
        -----
        Specifies the level of translucency for various items.  Issue
        /TRLCY,DEFA to reset the default (0) translucency levels.  This command
        is valid only on selected 2-D and 3-D graphics devices; see  in the
        Basic Analysis Guide for more information on applying translucency.

        For 2-D devices, ANSYS displays only the visible faces of the items
        being displayed.  The information behind the facing planes is not
        displayed.  Issuing the /SHRINK command will force the hardware to
        display information behind the translucent items.

        This command is valid in any processor.
        """
        command = "/TRLCY,%s,%s,%s,%s,%s" % (str(lab), str(tlevel), str(n1), str(n2), str(ninc))
        return self.run(command, **kwargs)

    def pdexe(self, slab="", mrun="", nfail="", fopt="", fname="", **kwargs):
        """APDL Command: PDEXE

        Executes the probabilistic analysis.

        Parameters
        ----------
        slab
            Solution label. This is the name given to the files containing the
            results of different probabilistic analyses performed with a
            particular probabilistic model. Different solutions using different
            probabilistic methods or method options are stored in separate
            solution sets identified with this solution label. If the solution
            label is blank, ANSYS automatically assigns Slab = "SOLUnn", where
            nn is the current two-digit number of the probabilistic analysis
            (PDS allows a maximum of 10 solution sets identified by 10 solution
            labels); for example, the first analysis is SOLU01, the second is
            SOLU02, and so on up to SOLU10). This field cannot contain blanks.
            Maximum length of this field is 32 characters; if the field
            contains more than 32 characters, it will be truncated to 32
            characters.

        mrun
            Keyword for the processing of the simulation loops

            SER - Executes the simulation loops of the probabilistic analysis using a single
                  machine; serial processing (default).

            PAR - Executes the simulation loops of the probabilistic analysis in parallel using
                  the ANSYS parallel-processing tool. See Probabilistic Design
                  in the Advanced Analysis Guide.

        nfail
            This parameter sets the number of loops that are allowed to fail
            before the execution of the probabilistic analysis is terminated.
            For example, if geometric parameters are used as random variables
            then for some simulations (loops) the loop will fail because
            meshing was not successful. This might happen infrequently which
            might be acceptable. However, if the probabilistic problem is
            incorrectly defined then loops could fail frequently or even in
            every loop. You can define an upper limit for the number of failed
            loops that will be tolerated before the probabilistic analysis will
            be terminated. If you use NFAIL = 0 (default) then failed loops are
            not tolerated and the probabilistic analysis will terminate the
            first time a loop fails. NFAIL is used only if MRUN = PAR.

        fopt
            Keyword for the file option. This determines if a copy of the
            sample file should be saved or not.

            DEL - The sample file will be deleted (default).

            COPY - A copy of the sample file will be saved as the file name specified with the
                   Fname option.

        fname
            Name of the copy of the sample file. The directory for storing the
            sample file is always the current working directory. The file
            extension is always .csmp. This option is ignored for FOPT = DEL.

        Notes
        -----
        Runs the probabilistic analysis. The results of the probabilistic
        analysis are identified with the solution label specified here. This
        solution label is used for the postprocessing of the results. The
        maximum number of probabilistic analyses that can be executed, stored,
        and post-processed based on the same deterministic and probabilistic
        model in one session with the PDS is 10. However, it is not counted as
        a separate probabilistic analysis if the same solution label is used
        multiple times in order to append to or overwrite previous results.

        The probabilistic results are stored in result files in ASCII format.

        If you specify a solution label that has already been used, the results
        will be appended at the end of the results file.

        After the PDEXE command has been issued, you can no longer change the
        probabilistic model using probabilistic preprocessing commands; doing
        so would invalidate the probabilistic analysis results and potentially
        corrupt the probabilistic database. Also, you are not allowed to change
        the probabilistic analysis file using a PDANL command after the first
        PDEXE has been executed.

        If you need to change the probabilistic model (analysis file, random
        input variables, etc.) after the PDEXE command has been issued, you
        should use the PDCLR, POST command to clear the probabilistic results.
        We recommend that you first save the results using the PDSAVE command.

        By default, ANSYS creates a sample file (called Jobname.samp)
        containing all values of all random input parameters; unless you
        specify otherwise, this file is deleted after the analysis is finished.
        With the FOPT and Fname options you can determine if and where a copy
        of that file should be stored for later use in another analysis.
        """
        command = "PDEXE,%s,%s,%s,%s,%s" % (str(slab), str(mrun), str(nfail), str(fopt), str(fname))
        return self.run(command, **kwargs)

    def mshpattern(self, key="", **kwargs):
        """APDL Command: MSHPATTERN

        Specifies pattern to be used for mapped triangle meshing.

        Parameters
        ----------
        key
            Key indicating triangle pattern to be used (the figures below
            illustrate the pattern that will be used for each value of KEY):

            0 - Let ANSYS choose the pattern (the default).  ANSYS maximizes the minimum angle
                of the triangular-shaped elements that are created.

            1 - Unidirectional split at node I.

            2 - Unidirectional split at node J.

        Notes
        -----
        "Mapped triangle meshing" refers to the ANSYS program's ability to take
        a map-meshable area and mesh it with triangular elements, based on the
        value of MSHPATTERN,KEY. This type of meshing is particularly useful
        for analyses that involve the meshing of rigid contact elements.

        The MSHPATTERN command is valid only when you have specified that ANSYS
        use triangle-shaped elements [MSHAPE,1,2D] (or you are meshing with an
        element that supports only triangles), and you have also specified
        mapped meshing [MSHKEY,1] to mesh an area.

        For details about mapped meshing with triangles, see the Modeling and
        Meshing Guide.
        """
        command = "MSHPATTERN,%s" % (str(key))
        return self.run(command, **kwargs)

    def dmove(self, node1="", node2="", ninc="", **kwargs):
        """APDL Command: DMOVE

        Digitizes nodes on surfaces and along intersections.

        Parameters
        ----------
        node1, node2, ninc
            Digitize nodes NODE1through NODE2 in steps of NINC.  NODE2 defaults
            to NODE1 and NINC defaults to 1.

        Notes
        -----
        Digitizes nodes on undefined surfaces, warped surfaces, and along
        intersection lines.  Two orthogonal views showing the nodes on a plane
        in each view are required.  No surfaces need be specified.  Two
        coordinates are determined from the second view and the other
        coordinate is retained from the first view.  Use the DIG command to
        first define nodes in one view (as determined from the DSET command).
        Then reset the view and use this command to move the nodes to the
        proper location.
        """
        command = "DMOVE,%s,%s,%s" % (str(node1), str(node2), str(ninc))
        return self.run(command, **kwargs)

    def ldele(self, nl1="", nl2="", ninc="", kswp="", **kwargs):
        """APDL Command: LDELE

        Deletes unmeshed lines.

        Parameters
        ----------
        nl1, nl2, ninc
            Delete lines from NL1 to NL2 (defaults to NL1) in steps of NINC
            (defaults to 1).  If NL1 = ALL, NL2 and NINC are ignored and all
            selected lines [LSEL] are deleted.  If NL1 = P, graphical picking
            is enabled and all remaining command fields are ignored (valid only
            in the GUI).  A component name may also be substituted for NL1 (NL2
            and NINC are ignored).

        kswp
            Specifies whether keypoints are also to be deleted:

            0 - Delete lines only.

            1 - Delete lines, as well as keypoints attached to lines but not attached to other
                lines.

        Notes
        -----
        A line attached to an area cannot be deleted unless the area is first
        deleted.
        """
        command = "LDELE,%s,%s,%s,%s" % (str(nl1), str(nl2), str(ninc), str(kswp))
        return self.run(command, **kwargs)

    def waves(self, wopt="", oldmax="", oldrms="", **kwargs):
        """APDL Command: WAVES

        Initiates reordering.

        Parameters
        ----------
        wopt
            Option for comparison:

            MAX - Use maximum wavefront value for comparison (default).

            RMS - Use RMS wavefront value for comparison.

        oldmax, oldrms
            Maximum and RMS wavefront values of model to be used in place of
            the old values.  OLDRMS defaults to OLDMAX  (and vice versa).  If
            neither is specified, each defaults to its calculated old value.

        Notes
        -----
        Initiates the element reordering based upon the previously defined
        starting wave lists (if any).  Reordering affects only the element
        order for the solution phase and not the element numbers (input
        referring to element numbers, such as element pressures, is unaffected
        by reordering).

        Note:: : The new order is retained only if new the new maximum or RMS
        wavefront values are lower than the old values, as described below.
        See the WSORT command for another reordering procedure.  The resulting
        element ordering can be shown by listing the wavefront history
        [WFRONT,1] or by displaying elements with their element location
        numbers [/PNUM].

        The WAVES reordering procedure is based upon a list of nodes defining
        where the element reordering is to start (either input on the WSTART
        command, or automatically determined if not input).  If a list is
        input, additional starting wave lists may be defined to allow the user
        to block or guide the wave.  An input starting list usually consists of
        one node for a line element model, a line of nodes for an area element
        model, or a plane of nodes for a volume element model.  Elements are
        ordered from the first starting wave list in a direction that attempts
        to minimize the wavefront.  Nodes are deleted and added to the total
        wave list set as reordering progresses through the model.  Elements
        attached to nodes on succeeding starting lists, if any, are ignored at
        this time, thereby temporarily blocking that path.  Whenever no more
        elements can be reordered, the procedure is repeated starting from the
        nodes defined on the second starting list (if any).  The same node
        number should not appear on more than one list.  If no starting list is
        input, a starting node is automatically selected from an element
        weighting procedure (see Element Reordering in the Mechanical APDL
        Theory Reference).

        Reordering may be made from the previously reordered model or from the
        initial model (by issuing the SAVE command before reordering and then
        restoring that model back to PREP7 with the RESUME command after
        reordering).  The WFRONT command is useful for calculating and printing
        the current wavefront statistics at any time without causing any
        reordering of the elements.  If a model is to be used for both a
        thermal and a structural analysis, the reordered statistics should be
        based upon the structural model (because of the higher number of
        degrees of freedom per node).

        The reordering procedure treats separate portions of the model (i.e.,
        not connected by elements) as discontinuous.  Reordering automatically
        continues across a discontinuity as best as possible.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "WAVES,%s,%s,%s" % (str(wopt), str(oldmax), str(oldrms))
        return self.run(command, **kwargs)

    def vup(self, wn="", label="", **kwargs):
        """APDL Command: /VUP

        Specifies the global Cartesian coordinate system reference orientation.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        label
            Orientation:

            Y  - Y vertical upward, X horizontal to the right, Z out from the screen (default).

            -Y  - Y vertical downward, X horizontal to the left, Z out from the screen.

            X  - X vertical upward, Y horizontal to the left, Z out from the screen.

            -X  - X vertical downward, Y horizontal to the right, Z out from the screen.

            Z  - Z vertical upward, Y horizontal to the right, X out from the screen.  With this
                 choice, you should use a view other than the /VIEW default of
                 (0,0,1).

            -Z  - Z vertical downward, Y horizontal to the left, X out from the screen.  With
                  this choice, you should use a view other than the /VIEW
                  default of (0,0,1).

        Notes
        -----
        Specifies the global Cartesian coordinate system reference orientation.
        The /VIEW and /ANGLE commands may be used to reorient the view and are
        relative to this reference orientation.  All coordinate systems are
        right-handed.

        This command is valid in any processor.
        """
        command = "/VUP,%s,%s" % (str(wn), str(label))
        return self.run(command, **kwargs)

    def anmres(self, delay="", min="", max="", inc="", autocntrky="", freq="",
               ext="", **kwargs):
        """APDL Command: ANMRES

        Performs animation of results over multiple results files in an
        explicit dynamic structural analysis or fluid flow analysis with
        remeshing.

        Parameters
        ----------
        delay
            Time delay during animation (default = 0.5 seconds).

        min
            Minimum results file number to animate. Default = 1 (for
            Jobname.RS01).

        max
            Maximum results file number to animate. Defaults to the highest
            numbered results file, Jobname.RSnn.

        inc
            Increment between results file numbers. Default = 1.

        autocntrky
            Automatic contour scaling option.

            0 - No auto-scaling (default).

            1 - Auto-scaling on.

        freq
             Results frequency key.

            0 or 1 - Animate every results set in each Jobname.EXT file (default).

            2 - Animate every other results set in each Jobname.EXT file.

            n - Animate every nth results set in each Jobname.EXT file.

        ext
            Extension of result files

            'rfl' - Animate Jobname.rflnn

            'rs' - Animate Jobname.rsnn. Default = 'rs'.

        Notes
        -----
        ANMRES invokes an ANSYS macro that performs animation across multiple
        results files (Jobname.EXT, Jobname.EXT, etc.) produced by an explicit
        dynamic structural analysis or fluid flow analysis with remeshing.
        Multiple results files typically occur when adaptive meshing is used in
        an explicit dynamic structural analysis or fluid flow analysis with
        remeshing. Each results file must have more than one set of results.
        ANMRES cannot be used for multiple results files that are caused by
        file splitting.

        ANMRES animates results from files having the currently specified
        jobname (Jobname.EXT - Jobname.EXT).  To change the current jobname,
        use  the /FILNAME command. The animation is based on the last plot
        command (e.g., PLDISP).

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "ANMRES,%s,%s,%s,%s,%s,%s,%s" % (str(delay), str(min), str(max), str(inc), str(autocntrky), str(freq), str(ext))
        return self.run(command, **kwargs)

    def dmpoption(self, filetype="", combine="", **kwargs):
        """APDL Command: DMPOPTION

        Specifies distributed memory parallel (Distributed ANSYS) file
        combination options.

        Parameters
        ----------
        filetype
            Type of solution file to combine after a distributed memory
            parallel solution. There is no default; if (blank), the command is
            ignored.

            RST - Results files (.RST, .RTH, .RMG, .RSTP)

            EMAT - Element matrix files (.EMAT).

            ESAV - Element saved data files (.ESAVE)

            MODE - Modal results files (.MODE)

            MLV - Modal load vector file (.MLV)

            IST - Initial state file (.IST)

            FULL - Full matrix file (.FULL)

            RFRQ - Reduced complex displacement file (.RFRQ)

            RDSP - Reduced displacement file (.RDSP)

        combine
            Option to combine solution files.

            Yes - Combine solution files (default).

            No - Do not combine solution files.

        Notes
        -----
        The DMPOPTION command controls how solution files are written during a
        distributed memory parallel (Distributed ANSYS) solution. This command
        is most useful for controlling how results files (.RST,.RTH, etc.) are
        written.

        In a distributed memory parallel solution, a local results file is
        written by each process (JobnameN.ext, where N is the process number).
        By default, the program automatically combines the local results files
        (for example, JobnameN.RST) upon leaving the SOLUTION processor (for
        example, upon the FINISH command) into a single global results file
        (Jobname.RST) which can be used in ANSYS postprocessing. To reduce the
        amount of communication and I/O performed by this operation, you can
        issue the command DMPOPTION,RST,NO to bypass this step of combining the
        local results files; the local files will remain on the local disks in
        the current working directory. You can then use the RESCOMBINE command
        macro in the POST1 general postprocessor (/POST1) to read all results
        into the database for postprocessing.

        The RESCOMBINE command macro is intended for use with POST1. If you
        want to postprocess distributed parallel solution results using the
        POST26 time-history postprocessor (/POST26), it is recommended that you
        combine your local results files into one global results file
        (DMPOPTION,RST,YES or COMBINE).

        Local .EMAT, .ESAV, .MODE, .MLV, .IST, .RFRQ, .RDSP, and .FULL files
        are also written (when applicable) by each process in a distributed
        memory parallel solution. If these files are not needed for a
        downstream solution or operation, you can issue the command
        DMPOPTION,FileType,NO for each file type to bypass the file combination
        step and thereby improve performance. You should not bypass the file
        combination step if a downstream PSD analysis or modal expansion pass
        will be performed.

        If DMPOPTION,MODE,NO or DMPOPTION,RST,NO is specified in a modal
        analysis, element results cannot be written to the combined mode file
        (Jobname.MODE). In this case, if Distributed ANSYS is used in a
        downstream harmonic or transient analysis that uses the mode-
        superposition method, the MSUPkey on the MXPAND command can retain its
        value. However, if shared memory parallel processing is used in the
        downstream harmonic or transient analysis, the MSUPkey is effectively
        set to NO.

        The DMPOPTION command can be changed between load steps; however, doing
        so will not affect which set of solution files are combined. Only the
        last values of FileType and Combine upon leaving the solution processor
        will be used to determine whether the solution files are combined. For
        example, given a two load step solution and FileType = RST, setting
        Combine = NO for the first load step and YES for the second load step
        will cause all sets on the local results files to be combined. If the
        opposite is true (Combine = YES for the first load step and NO for the
        second load step), no results will be combined.

        After using DMPOPTION to suppress file combination, you may find it
        necessary to combine the local files for a specific FileType for use in
        a subsequent analysis. In this case, use the COMBINE command to combine
        local solution files into a single, global file.
        """
        command = "DMPOPTION,%s,%s" % (str(filetype), str(combine))
        return self.run(command, **kwargs)

    def eshape(self, scale="", key="", **kwargs):
        """APDL Command: /ESHAPE

        Displays elements with shapes determined from the real constants or
        section definition.

        Parameters
        ----------
        scale
            Scaling factor:

            0 - Use simple display of line and area elements. This value is the default.

            1 - Use real constants or section definition to form a solid shape display of the
                applicable elements.

            FAC - Multiply certain real constants, such as thickness, by FAC (where FAC > 0.01)
                  and use them to form a solid shape display of elements.

        key
            Current shell thickness key:

            0 - Use current thickness in the displaced solid shape display of shell elements
                (valid for SHELL181, SHELL208, SHELL209, and SHELL281). This
                value is the default.

            1 - Use initial thickness in the displaced solid shape display of shell elements.

        Notes
        -----
        The /ESHAPE command allows beams, shells, current sources, and certain
        special-purpose elements to be displayed as solids with the shape
        determined from the real constants or section types. Elements are
        displayed via the EPLOT command. No checks for valid or complete input
        are made for the display.

        Following are details about using this command with various element
        types:

        SOLID65 elements are displayed with internal lines that represent rebar
        sizes and orientations (requires vector mode [/DEVICE] with a basic
        type of display [/TYPE,,BASIC]). The rebar with the largest volume
        ratio in each element plots as a red line, the next largest as green,
        and the smallest as blue.

        COMBIN14, COMBIN39, and MASS21 are displayed with a graphics icon, with
        the offset determined by the real constants and KEYOPT settings.

        BEAM188, BEAM189, PIPE288, PIPE289 and ELBOW290 are displayed as solids
        with the shape determined via the section-definition commands (SECTYPE
        and SECDATA). The arbitrary section option (Subtype = ASEC) has no
        definite shape and appears as a thin rectangle to show orientation. The
        elements are displayed with internal lines representing the cross-
        section mesh.

        SOLID272 and SOLID273 are displayed as solids with the shape determined
        via the section-definition commands (SECTYPE and SECDATA).  The 2-D
        master plane is revolved around the prescribed axis of symmetry.

        Contour plots are available for these elements in postprocessing for
        PowerGraphics only (/GRAPHICS,POWER). To view 3-D deformed shapes for
        the elements, issue OUTRES,MISC or OUTRES,ALL for static or transient
        analyses. To view 3-D mode shapes for a modal or eigenvalue buckling
        analysis, expand the modes with element results calculation ON (Elcalc
        = YES for MXPAND).

        SOURC36, CIRCU124, and TRANS126 elements always plot using /ESHAPE when
        PowerGraphics is activated (/GRAPHICS,POWER).

        In most cases, /ESHAPE renders a thickness representation of your
        shell, plane and layered elements more readily in PowerGraphics
        (/GRAPHICS,POWER). This type of representation employs PowerGraphics to
        generate the enhanced representation, and will often provide no
        enhancement in Full Graphics (/GRAPHICS,FULL). This is especially true
        for POST1 results displays, where /ESHAPE is not supported for most
        element types with FULL graphics.

        When PowerGraphics is active, /ESHAPE may degrade the image if adjacent
        elements have overlapping material, such as shell elements which are
        not co-planar. Additionally, if adjacent elements have different
        thicknesses, the polygons depicting the connectivity between the
        “thicker” and “thinner” elements along the shared element edges may not
        always be displayed.

        For POST1 results displays (such as PLNSOL), the following limitations
        apply:

        Rotational displacements for beam elements are used to create a more
        realistic displacement display. When /ESHAPE is active, displacement
        plots (via PLNSOL,U,X and PLDISP, for example) may disagree with your
        PRNSOL listings. This discrepancy will become more noticeable when the
        SCALE value is not equal to one.

        When shell elements are not co-planar, the resulting PLNSOL display
        with /ESHAPE will actually be a PLESOL display as the non-coincident
        pseudo-nodes are not averaged. Additionally, /ESHAPE should not be used
        with coincident elements because the plot may incorrectly average the
        displacements of the coincident elements.

        When nodes are initially coincident and PowerGraphics is active,
        duplicate polygons are eliminated to conserve display time and disk
        space. The command may degrade the image if initially coincident nodes
        have different displacements. The tolerance for determining coincidence
        is 1E-9 times the model’s bounding box diagonal.

        If you want to view solution results (PLNSOL, etc.) on layered elements
        (such as SHELL181, SOLSH190, SOLID185 Layered Solid, SOLID186 Layered
        Solid, SHELL208, SHELL209, SHELL281, and ELBOW290), set KEYOPT(8) = 1
        for the layer elements so that the data for all layers is stored in the
        results file.

        You can plot the through-thickness temperatures of elements SHELL131
        and SHELL132 regardless of the thermal DOFs in use by issuing the
        PLNSOL,TEMP command (with PowerGraphics and /ESHAPE active).

        The /ESHAPE,1 and /ESHAPE,FAC commands are incompatible with the
        /CYCEXPAND command used in cyclic symmetry analyses.

        This command is valid in any processor.
        """
        command = "/ESHAPE,%s,%s" % (str(scale), str(key))
        return self.run(command, **kwargs)

    def golist(self, **kwargs):
        """APDL Command: /GOLIST

        Reactivates the suppressed data input listing.

        Notes
        -----
        Reactivates printout of the data input listing suppressed with /NOLIST.

        This command is valid in any processor, but only within a batch run
        [/BATCH].
        """
        command = "/GOLIST," % ()
        return self.run(command, **kwargs)

    def pasave(self, lab="", fname="", ext="", **kwargs):
        """APDL Command: PASAVE

        Saves selected paths to an external file.

        Parameters
        ----------
        lab
            Write operation:

            S - Saves only selected paths.

            ALL - Saves all paths (default).

            Pname - Saves the named path (from the PSEL command).

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Saves the paths selected with the PSEL command to an external file
        (Jobname.path by default).  Previous paths on this file, if any, will
        be overwritten.  The path file may be read with the PARESU command.

        This command is valid in POST1.
        """
        command = "PASAVE,%s,%s,%s" % (str(lab), str(fname), str(ext))
        return self.run(command, **kwargs)

    def mpcopy(self, matf="", matt="", **kwargs):
        """APDL Command: MPCOPY

        Copies linear material model data from one material reference number to
        another.

        Parameters
        ----------
        --
            Unused field

        matf
            Material reference number from where material property data will be
            copied.

        matt
            Material reference number to where material property data will be
            copied.

        Notes
        -----
        The MPCOPY command copies linear material properties only, which are
        all properties defined through the MP command. If you copy a model that
        includes both linear and yield behavior constants (for example, a BKIN
        model), the MPCOPY and TBCOPY, ALL commands are used together to copy
        the entire model.  All input data associated with the model is copied,
        that is, all data defined through the MP and TB commands.

        Also, if you copy a material model using the Material Model Interface
        (Edit> Copy), both the commands MPCOPY and TBCOPY, ALL are issued,
        regardless of whether the model includes linear constants only, or if
        it includes a combination of linear and yield behavior constants.

        This command is also valid in SOLUTION.
        """
        command = "MPCOPY,%s,%s" % (str(matf), str(matt))
        return self.run(command, **kwargs)

    def etype(self, **kwargs):
        """APDL Command: ETYPE

        Specifies "Element types" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command. Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "ETYPE," % ()
        return self.run(command, **kwargs)

    def tbfield(self, type="", value="", **kwargs):
        """APDL Command: TBFIELD

        Defines values of field variables for material data tables.

        Parameters
        ----------
        type
            Type of field variable:

            FREQ - A frequency is to be specified in Value

            TEMP - A temperature is to be specified in Value

            TIME - A time is to be specified in Value

            NPRES - A normal pressure is to be specified in Value

            SLDA - A total sliding distance (algebraic) is to be specified in Value

            SLDI - A total sliding distance (absolute) is to be specified in Value

            SLRV - A sliding velocity is to be specified in Value

            CYCLE - A healing cycle number is to be specified in Value

            UFXX - User-defined field variable (UF01,UF02, ..., UF09)

        value
            The field value to be referenced (use this command multiple times
            to enter values of different field variables).

        Notes
        -----
        Define your data tables as field-variable-dependent (via the
        appropriate TB command shown below), then issue the TBFIELD command to
        define the field values.

        Define data values in ascending order for all field quantities. If a
        field value is to be held constant, define it only once; subsequent
        definitions are ignored.

        There is no limit on the number of values you can specify. The
        specified field value remains active until the next TBFIELD command is
        input.

        After you have defined the field value(s), define your data for the
        data tables (TBDATA).

        See Understanding Field Variables in the Material Reference for more
        information about the interpolation scheme used for field-dependent
        material properties.

        See Full Harmonic Analysis in the Structural Analysis Guide for more
        information about using TBFIELD with TB,ELASTIC or TB,SDAMP.

        The TBFIELD command supports the following material models (TB,Lab
        commands):

        The TEMP value specified on this command corresponds to the average
        temperature on the contact surface for contact elements CONTA171,
        CONTA172, CONTA173, CONTA174, CONTA175, CONTA176, and CONTA177. For
        contact element CONTA178, the TEMP value corresponds to the average
        temperature of the nodes.

        The TIME value specified on this command corresponds to the analysis
        time specified on the TIME command.

        The algebraic sliding distance (SLDA) specified on this command is the
        total sliding distance (the algebraic sum) as reported in the element
        output definitions table for the contact elements (for example, TASS
        and TASR output items for CONTA174).

        The absolute sliding distance (SLDI) specified on this command is the
        total accumulated sliding distance (the absolute sum) as reported in
        the element output definitions table for the contact elements (for
        example, AASS and AASR output items for CONTA174).

        When used with TB,FRIC, field variables defined by TBFIELD are only
        available for isotropic friction (TBOPT = ISO) and orthotropic friction
        (TBOPT = ORTHO); they are not available for user-defined friction
        (TBOPT = USER).

        See Contact Friction in the Material Reference for more information
        about using TBFIELD with TB,FRIC.
        """
        command = "TBFIELD,%s,%s" % (str(type), str(value))
        return self.run(command, **kwargs)

    def mftol(self, key="", value="", toler="", **kwargs):
        """APDL Command: MFTOL

        Activates or deactivates normal distance checking for surface mapping
        in an ANSYS Multi-field solver analysis.

        Parameters
        ----------
        key
            Normal distance key

            ON - Activates normal distance checking.

            OFF - Deactivates normal distance checking (default).

        value
            The normal distance tolerance for surface mapping.  Defaults to
            1.0e-6. If Toler = REL, Value is dimensionless. If Toler = ABS,
            Value has the dimensions of length.

        toler
            Tolerance definition key

            REL - Activates relative gap tolerance, which is independent of units (default).

            ABS - Activates absolute gap tolerance.

        Notes
        -----
        For a dissimilar mesh interface, the nodes of one mesh are mapped to
        the local coordinates of an element in the other mesh. When normal
        distance checking is activated, the mapping tool checks the normal
        distance from the node to the nearest element. The node is considered
        improperly mapped if the normal distance exceeds the tolerance value.
        The mapping tool creates a component to graphically display the
        improperly mapped nodes. See Mapping Diagnostics in the Coupled-Field
        Analysis Guide for more information.

        When using relative gap tolerance (Toler = REL), the normal distance
        tolerance is derived from the product of the relative tolerance Value
        and the largest dimension of the Cartesian bounding box for a specific
        interface. Therefore, each interface will have a different normal
        distance tolerance , even though MFTOL is a global command.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFTOL,%s,%s,%s" % (str(key), str(value), str(toler))
        return self.run(command, **kwargs)

    def light(self, wn="", num="", int="", xv="", yv="", zv="", refl="",
              **kwargs):
        """APDL Command: /LIGHT

        Specifies the light direction for the display window.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        num
            Ambient or directional light key:

            0 - Ambient light (default).

            1 - Directional light.

        int
            Light intensity factor (defaults to 0.3 for ambient, 1.0 for
            directional). This option is valid only for 3-D devices).

        xv, yv, zv
            Light direction (valid only for NUM = 1).  The directional light
            source is parallel to the line from point XV, YV, ZV to the origin,
            in the global Cartesian system origin.  Defaults to the viewing
            direction [/VIEW].

        refl
            Light reflectance factor (valid only for NUM = 1 and 3-D devices).

        Notes
        -----
        Defines the light direction for the window.  Use this command only with
        3-D graphics devices or 2-D devices when Z-buffering is used [/TYPE,,(6
        or 7)].  The ambient light has no direction, only an intensity.  You
        can position the directional light source  by defining a point (in the
        global Cartesian coordinate system) representing a point along the
        light directional line.  This point, and the global Cartesian
        coordinate system origin, define the line along which the light is
        positioned looking toward the origin.  You can use any point along the
        light line; for example, both (1.,1.,1.) and (2.,2.,2.) give the same
        light effect.  For 3-D graphics devices only, the directional light
        source also has intensity and reflectance factors.

        By choosing the highest intensity ambient light for 3-D graphics
        devices (via the command /LIGHT,WN,0,1), you can nullify color shading
        and other effects of directional lighting.

        This command is valid in any processor.
        """
        command = "/LIGHT,%s,%s,%s,%s,%s,%s,%s" % (str(wn), str(num), str(int), str(xv), str(yv), str(zv), str(refl))
        return self.run(command, **kwargs)

    def gssol(self, nvar="", item="", comp="", name="", **kwargs):
        """APDL Command: GSSOL

        Specifies which results to store from the results file when using
        generalized plane strain.

        Parameters
        ----------
        nvar
            Arbitrary reference number or name assigned to this variable.
            Variable numbers can be 2 to NV (NUMVAR) while the name can be an
            eight byte character string. Overwrites any existing results for
            this variable.

        item
            Label identifying item to be stored.

            LENGTH - Change of fiber length at the ending point.

            ROT - Rotation of the ending plane during deformation.

            F - Reaction force at the ending point in the fiber direction.

            M - Reaction moment applied on the ending plane.

        comp
            Component of the item, if Item = ROT or M.

            X - The rotation angle or reaction moment of the ending plane about X.

            Y - The rotation angle or reaction moment of the ending plane about Y.

        name
            Thirty-two character name identifying the item on the printout and
            display. Defaults to the label formed by concatenating the first
            four characters of the Item and Comp labels.

        Notes
        -----
        This command stores the results (new position of the ending plane after
        deformation) for generalized plane strain. All outputs are in the
        global Cartesian coordinate system. For more information about the
        generalized plane strain feature, see Generalized Plane Strain Option
        of Current-Technology Solid Elements in the Element Reference.
        """
        command = "GSSOL,%s,%s,%s,%s" % (str(nvar), str(item), str(comp), str(name))
        return self.run(command, **kwargs)

    def inquire(self, strarray="", func="", **kwargs):
        """APDL Command: /INQUIRE

        Returns system information to a parameter.

        Parameters
        ----------
        strarray
            Name of the "string array" parameter that will hold the returned
            values.  String array parameters are similar to character arrays,
            but each array element can be as long as 128 characters. If the
            string parameter does not exist, it will be created.

        Notes
        -----
        The /INQUIRE command is valid in any processor.
        """
        command = "/INQUIRE,%s,%s" % (str(strarray), str(func))
        return self.run(command, **kwargs)

    def focus(self, wn="", xf="", yf="", zf="", ktrans="", **kwargs):
        """APDL Command: /FOCUS

        Specifies the focus point (center of the window).

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        xf, yf, zf
            Location of the object to be at the focus point (center of the
            window) in the global Cartesian coordinate system.  If XF = AUTO,
            allow automatic location calculation.  If XF = USER, use focus
            location of last display (useful when last display had auto focus).

        ktrans
            Translate key:

            0 - Interpret numerical XF, YF, ZF values as described above.

            1 - Interpret XF, YF, ZF values as multiples of half-screens to translate from the
                current position in the screen coordinate system.  Example: XF
                of 2.4 translates the display approximately 2.4 half-screens to
                the left in the screen X (horizontal) direction.

            2 - Interpret XF, YF, ZF values as multiples of half-screens to translate from the
                current position in the global Cartesian coordinate system.
                Example: XF of 1.5 translates the display approximately 1.5
                half-screens in the global Cartesian X direction of the model.

        Notes
        -----
        Specifies the location on (or off) the model which is to be located at
        the focus point (center of the window).  For section and capped
        displays, the cutting plane is also assumed to pass through this
        location (unless the working plane is used via /CPLANE).  See also
        /AUTO and /USER commands.

        This command is valid in any processor.
        """
        command = "/FOCUS,%s,%s,%s,%s,%s" % (str(wn), str(xf), str(yf), str(zf), str(ktrans))
        return self.run(command, **kwargs)

    def cecheck(self, itemlab="", tolerance="", dof="", **kwargs):
        """APDL Command: CECHECK

        Check constraint equations and couplings for rigid body motions.

        Parameters
        ----------
        itemlab
            Item indicating what is to be checked:

            CE - Check constraint equations only

            CP - Check couplings only

            ALL - Check both CE and CP

        tolerance
            Allowed amount of out-of-balance for any constraint equation or
            coupled set. The default value of 1.0e-6 is usually good.

        dof
            Specifies which DOF is to be checked. Default is RIGID, the usual
            option. Other choices are individual DOF such as UX, ROTZ, etc. or
            THERM. The THERM option will check the constraint equations or
            coupled sets for free thermal expansions, whereas the individual
            DOFs check under rigid body motions. ALL is RIGID and THERM.

        Notes
        -----
        This command imposes a rigid body motion on the nodes attached to the
        constraint equation or coupled set and makes sure that no internal
        forces are generated for such rigid body motions. Generation of
        internal forces by rigid body motions usually indicates an error in the
        equation specification (possibly due to nodal coordinate rotations).
        The THERM option does a similar check to see that no internal forces
        are created by the equations if the body does a free thermal expansion
        (this check assumes a single isotropic coefficient of expansion).
        """
        command = "CECHECK,%s,%s,%s" % (str(itemlab), str(tolerance), str(dof))
        return self.run(command, **kwargs)

    def l2tan(self, nl1="", nl2="", **kwargs):
        """APDL Command: L2TAN

        Generates a line tangent to two lines.

        Parameters
        ----------
        nl1
            Number of the first line generated line is tangent to.  If
            negative, assume P1 (see below) is the second keypoint of the line
            instead of the first.  If NL1 = P, graphical picking is enabled and
            all remaining command fields are ignored (valid only in the GUI).

        nl2
            Number of the second line generated line is tangent to.  If
            negative, assume P3 is the second keypoint of the line instead of
            the first.

        Notes
        -----
        Generates a line (P2-P3) tangent at point P2 to line NL1 (P1-P2) and
        tangent at point P3 to line NL2 (P3-P4).
        """
        command = "L2TAN,%s,%s" % (str(nl1), str(nl2))
        return self.run(command, **kwargs)

    def dcum(self, oper="", rfact="", ifact="", tb_ase="", **kwargs):
        """APDL Command: DCUM

        Specifies that DOF constraint values are to be accumulated.

        Parameters
        ----------
        oper
            Accumulation key:

            REPL - Subsequent values replace the previous values (default).

            ADD - Subsequent values are added to the previous values.

            IGNO - Subsequent values are ignored.

        rfact
            Scale factor for the real component.  Zero (or blank) defaults to
            1.0.  Use a small number for a zero scale factor.

        ifact
            Scale factor for the imaginary component.  Zero (or blank) defaults
            to 1.0.  Use a small number for a zero scale factor.

        tbase
            Base temperature for temperature difference.  Used only with
            temperature degree of freedom.  Scale factor is applied to the
            temperature difference (T-TBASE) and then added to TBASE.  T is the
            current temperature.

        Notes
        -----
        Allows repeated degree of freedom constraint values (displacement,
        temperature, etc.)  to be replaced, added, or ignored.  Operations
        apply to the selected nodes [NSEL] and the selected degree of freedom
        labels [DOFSEL]. This command also operates on velocity and
        acceleration loads applied in a structural analysis.

        The operations occur when the next degree of freedom constraints are
        defined.  For example, issuing the command D,1,UX,.025 after a previous
        D,1,UX,.020 causes the new value of the displacement on node 1 in the
        x-direction to be 0.045 with the add operation, 0.025 with the replace
        operation, or 0.020 with the ignore operation.  Scale factors are also
        available to multiply the next value before the add or replace
        operation.  A scale factor of 2.0 with the previous "add" example
        results in a displacement of 0.070.  Scale factors are applied even if
        no previous values exist.  Issue DCUM,STAT to show the current label,
        operation, and scale factors.  Solid model boundary conditions are not
        affected by this command, but boundary conditions on the FE model are
        affected.

        Note:: : FE boundary conditions may still be overwritten by existing
        solid model boundary conditions if a subsequent boundary condition
        transfer occurs.

        DCUM does not work for tabular boundary conditions.

        This command is also valid in PREP7.
        """
        command = "DCUM,%s,%s,%s,%s" % (str(oper), str(rfact), str(ifact), str(tb_ase))
        return self.run(command, **kwargs)

    def display(self, **kwargs):
        """APDL Command: DISPLAY

        Specifies "Display settings" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "DISPLAY," % ()
        return self.run(command, **kwargs)

    def cmwrite(self, fname="", ext="", fmat="", **kwargs):
        """APDL Command: CMWRITE

        Writes node and element components and assemblies to a file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        fmat
            Format of the output file (defaults to BLOCKED).

            BLOCKED - Blocked format. This format allows faster reading of the file.

            UNBLOCKED - Unblocked format.
        """
        command = "CMWRITE,%s,%s,%s" % (str(fname), str(ext), str(fmat))
        return self.run(command, **kwargs)

    def nlist(self, node1="", node2="", ninc="", lcoord="", sort1="", sort2="",
              sort3="", kinternal="", **kwargs):
        """APDL Command: NLIST

        Lists nodes.

        Parameters
        ----------
        node1, node2, ninc
            List nodes from NODE1 to NODE2 (defaults to NODE1) in steps of NINC
            (defaults to 1).  If NODE1 = ALL (default), NODE2 and NINC are
            ignored and all selected nodes [NSEL] are listed.  If NODE1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NODE1 (NODE2 and NINC are ignored).

        lcoord
            Coordinate listing key:

            (blank) - List all nodal information

            COORD - Suppress all but the XYZ coordinates (shown to a higher degree of accuracy than
                    when displayed with all information).

        sort1
            First item on which to sort.  Valid item names are NODE, X, Y, Z,
            THXY, THYZ, THXZ

        sort2, sort3
            Second and third items on which to sort.  Valid item names are the
            same as for SORT1.

        kinternal
            Internal nodes listing key:

            (blank) - List only external nodes.

            INTERNAL - List all nodes, including internal nodes.

        Notes
        -----
        Lists nodes in the active display coordinate system [DSYS].  Nodal
        coordinate rotation angles are also listed (relative to the global
        Cartesian coordinate system).

        Node listing can be in a sorted order (ascending).  SORT2, for example,
        will be carried out on nodes having equal values of SORT1.

        This command is valid in any processor.
        """
        command = "NLIST,%s,%s,%s,%s,%s,%s,%s,%s" % (str(node1), str(node2), str(ninc), str(lcoord), str(sort1), str(sort2), str(sort3), str(kinternal))
        return self.run(command, **kwargs)

    def trpoin(self, x="", y="", z="", vx="", vy="", vz="", chrg="", m_ass="",
               **kwargs):
        """APDL Command: TRPOIN

        Defines a point through which a particle flow or charged particle trace
        will travel.

        Parameters
        ----------
        x, y, z
            Coordinate location of the trace point (in the active coordinate
            system).  If X = P, graphical picking is enabled and all remaining
            command fields are ignored (valid only in the GUI).

        vx, vy, vz
            Particle velocities in the X, Y and Z directions (in the active
            coordinate system).

        chrg
            Particle charge.

        mass
            Particle mass.

        Notes
        -----
        Defines a point through which a particle flow or charged particle trace
        [PLTRAC] will travel.  Multiple points (50 maximum) may be defined
        which will result in multiple flow traces.  Use TRPLIS to list the
        currently defined trace points and TRPDEL to delete trace points.

        The VX, VY, VZ, CHRG, and MASS arguments only apply to charged
        particles.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "TRPOIN,%s,%s,%s,%s,%s,%s,%s,%s" % (str(x), str(y), str(z), str(vx), str(vy), str(vz), str(chrg), str(m_ass))
        return self.run(command, **kwargs)

    def edcadapt(self, freq="", tol="", opt="", maxlvl="", btime="", dtime="",
                 lcid="", adpsize="", adp_ass="", ireflg="", adpene="",
                 adpth="", maxel="", **kwargs):
        """APDL Command: EDCADAPT

        Specifies adaptive meshing controls for an explicit dynamic analysis.

        Parameters
        ----------
        freq
            Time interval between adaptive mesh refinements (default = 0.0).
            Use FREQ = STAT to list the current adaptive meshing control
            settings.

        tol
            Adaptive angle tolerance (in degrees) for which adaptive meshing
            will occur (default = 1e31). If the relative angle change between
            elements exceeds the specified tolerance value, the elements will
            be refined.

        opt
            Adaptivity option:

            1 - Angle change (in degrees) of elements is based on original mesh configuration
                (default).

            2 - Angle change (in degrees) of elements is incrementally based on previously
                refined mesh.

        maxlvl
            Maximum number of mesh refinement levels (default = 3). This
            parameter controls the number of times an element can be remeshed.
            Values of 1, 2, 3, 4, etc. allow a maximum of 1, 4, 16, 64, etc.
            elements, respectively, to be created for each original element.

        btime
            Birth time to begin adaptive meshing (default = 0.0).

        dtime
            Death time to end adaptive meshing (default = 1e31).

        lcid
            Data curve number (previously defined on the EDCURVE command)
            identifying the interval of remeshing (no default). The abscissa of
            the data curve is time, and the ordinate is the varied adaptive
            time interval. If LCID is nonzero, the adaptive frequency (FREQ) is
            replaced by this load curve. Note that a nonzero FREQ value is
            still required to initiate the first adaptive loop.

        adpsize
            Minimum element size to be adapted based on element edge length
            (default = 0.0).

        adpass
            One or two pass adaptivity option.

            0 - Two pass adaptivity (default).

            1 - One pass adaptivity.

        ireflg
            Uniform refinement level flag (no default). Values of 1, 2, 3, etc.
            allow 4, 16, 64, etc. elements, respectively, to be created
            uniformly for each original element.

        adpene
            Adaptive mesh flag for starting adaptivity when approaching
            (positive ADPENE value) or penetrating (negative ADPENE value) the
            tooling surface (default = 0.0).

        adpth
            Absolute shell thickness level below which adaptivity should begin.
            This option works only if the adaptive angle tolerance (TOL) is
            nonzero. If thickness based adaptive remeshing is desired without
            angle change, set TOL to a large angle. The default is ADPTH = 0.0,
            which means this option is not used.

        maxel
            Maximum number of elements at which adaptivity will be terminated
            (no default). Adaptivity is stopped if this number of elements is
            exceeded.

        Notes
        -----
        The EDCADAPT command globally sets the control options for all part IDs
        that are to be adaptively meshed (see the EDADAPT command). Because
        FREQ defaults to zero, you must input a nonzero value in this field in
        order to activate adaptive meshing. You must also specify a reasonable
        value for TOL since the default adaptive angle tolerance (1e31) will
        not allow adaptive meshing to occur.

        The EDCADAPT command is not supported in an explicit dynamic full
        restart analysis (EDSTART,3).

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDCADAPT,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(freq), str(tol), str(opt), str(maxlvl), str(btime), str(dtime), str(lcid), str(adpsize), str(adp_ass), str(ireflg), str(adpene), str(adpth), str(maxel))
        return self.run(command, **kwargs)

    def pcross(self, labxr="", labyr="", labzr="", labx1="", laby1="",
               labz1="", labx2="", laby2="", labz2="", **kwargs):
        """APDL Command: PCROSS

        Calculates the cross product of two path vectors along the current
        path.

        Parameters
        ----------
        labxr
            Label assigned to X-component of resultant vector.

        labyr
            Label assigned to Y-component of resultant vector.

        labzr
            Label assigned to Z-component of resultant vector.

        labx1
            X-component of first vector label (labeled path item).

        laby1
            Y-component of first vector label.

        labz1
            Z-component of first vector label.

        labx2
            X-component of second vector label (labeled path item).

        laby2
            Y-component of second vector label.

        labz2
            Z-component of second vector label.
        """
        command = "PCROSS,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(labxr), str(labyr), str(labzr), str(labx1), str(laby1), str(labz1), str(labx2), str(laby2), str(labz2))
        return self.run(command, **kwargs)

    def lsbw(self, nl="", sepo="", keep="", **kwargs):
        """APDL Command: LSBW

        Subtracts the intersection of the working plane from lines (divides
        lines).

        Parameters
        ----------
        nl
            Line (or lines, if picking is used) to be subtracted from.  If NL =
            ALL, use all selected lines.  If NL = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be input for NL.

        sepo
            Behavior of the created boundary.

            (blank) - The resulting lines will share keypoint(s) where they touch.

            SEPO - The resulting lines will have separate, but coincident keypoint(s).

        keep
            Specifies whether NL lines are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NL lines after LSBW operation (override BOPTN command settings).

            KEEP - Keep NL lines after LSBW operation (override BOPTN command settings).

        Notes
        -----
        Generates new lines by subtracting the intersection of the working
        plane from the NL lines.  The intersection will be a keypoint(s).  The
        working plane must not be in the same plane as the NL line(s).  If SEPO
        is blank, the NL line is divided and the resulting lines will be
        connected, sharing a common keypoint where they touch.  If SEPO is set
        to SEPO, NL is divided into two unconnected lines with separate
        keypoints.  See the Modeling and Meshing Guide for an illustration.
        See the BOPTN command for an explanation of the options available to
        Boolean operations.  Element attributes and solid model boundary
        conditions assigned to the original entities will not be transferred to
        the new entities generated.  Areas that completely contain the input
        lines will be updated if the lines are divided by this operation.
        """
        command = "LSBW,%s,%s,%s" % (str(nl), str(sepo), str(keep))
        return self.run(command, **kwargs)

    def oclist(self, datatype="", zonename="", **kwargs):
        """APDL Command: OCLIST

        Summarizes all currently defined ocean loads.

        Parameters
        ----------
        datatype
            Ocean data type to list. Valid values are BASIC, CURRENT, WAVE,
            ZONE, and ALL.

        zonename
            The name of an ocean zone to list. If no name is specified, all
            defined ocean zones are listed. Valid only when DataType = ZONE.

        Notes
        -----
        The OCLIST command summarizes the ocean properties for all defined
        ocean loads in the current session.

        When this command follows the SOLVE command, certain waves types also
        list the calculated wave length.

        This command is also valid in PREP7.
        """
        command = "OCLIST,%s,%s" % (str(datatype), str(zonename))
        return self.run(command, **kwargs)

    def fsum(self, lab="", item="", **kwargs):
        """APDL Command: FSUM

        Sums the nodal force and moment contributions of elements.

        Parameters
        ----------
        lab
            Coordinate system in which to perform summation.

            (blank) - Sum all nodal forces in global Cartesian coordinate system (default).

            RSYS - Sum all nodal forces in the currently active RSYS coordinate system.

        item
            Selected set of nodes.

            (blank) - Sum all nodal forces for all selected nodes (default), excluding contact
                      elements.

            CONT - Sum all nodal forces for contact nodes only.

            BOTH - Sum all nodal forces for all selected nodes, including contact elements.

        Notes
        -----
        Sums and prints, in each component direction for the total selected
        node set, the nodal force and moment contributions of the selected
        elements attached to the node set. Selecting a subset of nodes [NSEL]
        and then issuing this command will give the total force acting on that
        set of nodes (default), excluding surface-to-surface, node-to-surface,
        line-to-line, and line-to-surface contact elements (TARGE169, TARGE170,
        CONTA171, CONTA172, CONTA173, CONTA174, CONTA175, CONTA176, and
        CONTA177).

        Setting ITEM = CONT sums the nodal forces and moment contributions of
        the selected contact elements (CONTA171, CONTA172, CONTA173, CONTA174,
        CONTA175, CONTA176, and CONTA177). Setting ITEM = BOTH sums the nodal
        forces for all selected nodes, including contact elements.

        Nodal forces associated with surface loads are not included. The
        effects of nodal coupling and constraint equations are ignored. Moment
        summations are about the global origin unless another point is
        specified with the SPOINT command. This vector sum is printed in the
        global Cartesian system unless it is transformed [RSYS] and a point is
        specified with the SPOINT command. By default, the sum is done in
        global Cartesian, and the resulting vector is transformed to the
        requested system.

        The LAB = RSYS option transforms each of the nodal forces into the
        active coordinate system before summing and printing. The FORCE command
        can be used to specify which component (static, damping, inertia, or
        total) of the nodal load is to be used. This command output is included
        in the NFORCE command.

        The command should not be used with axisymmetric elements because it
        might calculate a moment where none exists. Consider, for example, the
        axial load on a pipe modeled with an axisymmetric shell element.  The
        reaction force on the end of the pipe is the total force (for the full
        360 degrees) at that location. The net moment about the centerline of
        the pipe would be zero, but the program would incorrectly calculate a
        moment at the end of the element as the force multiplied by the radius.

        The command is not valid for elements that operate solely within the
        nodal coordinate system with 1-D option activated and rotated nodes
        (NROTAT).
        """
        command = "FSUM,%s,%s" % (str(lab), str(item))
        return self.run(command, **kwargs)

    def lsscale(self, nl1="", nl2="", ninc="", rx="", ry="", rz="", kinc="",
                noelem="", imove="", **kwargs):
        """APDL Command: LSSCALE

        Generates a scaled set of lines from a pattern of lines.

        Parameters
        ----------
        nl1, nl2, ninc
            Set of lines (NL1 to NL2 in steps of NINC) that defines the pattern
            to be scaled.  NL2 defaults to NL1, NINC defaults to 1.  If NL1 =
            ALL, NL2 and NINC are ignored and the pattern is defined by all
            selected lines.  If NL1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  A
            component name may also be substituted for NL1 (NL2 and NINC are
            ignored).

        rx, ry, rz
            Scale factors to be applied to the X, Y, Z keypoint coordinates in
            active coordinate system (RR, Rθ, RZ for cylindrical; RR, Rθ, RΦ
            for spherical).  Note that the Rθ and RΦ scale factors are
            interpreted as angular offsets.  For example, for CSYS,1, RR, Rθ,
            RZ input of (1.5,10,3) would scale the specified keypoints 1.5
            times in the radial and 3 times in the Z direction, while adding an
            offset of 10 degrees to the keypoints.  Zero, blank, or negative
            scale factor values are assumed to be 1.0.  Zero or blank angular
            offsets have no effect.

        kinc
            Increment to be applied to keypoint numbers for generated set.  If
            zero, the lowest available keypoint numbers will be assigned
            [NUMSTR].

        noelem
            Specifies whether nodes and elements are also to be generated:

            0 - Nodes and line elements associated with the original lines will be generated
                (scaled) if they exist.

            1 - Nodes and line elements will not be generated.

        imove
            Specifies whether lines will be moved or newly defined:

            0 - Additional lines will be generated.

            1 - Original lines will be moved to new position (KINC and NOELEM are ignored).
                Use only if the old lines are no longer needed at their
                original positions.  Corresponding meshed items are also moved
                if not needed at their original position.

        Notes
        -----
        Generates a scaled set of lines (and their corresponding keypoints and
        mesh) from a pattern of lines.  The MAT, TYPE, REAL, and ESYS
        attributes are based on the lines in the pattern and not the current
        settings.  Scaling is done in the active coordinate system.  Lines in
        the pattern could have been generated in any coordinate system.
        """
        command = "LSSCALE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nl1), str(nl2), str(ninc), str(rx), str(ry), str(rz), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def mpwrite(self, fname="", ext="", mat="", **kwargs):
        """APDL Command: MPWRITE

        Writes linear material properties in the database to a file (if the LIB
        option is not specified) or writes both linear and nonlinear material
        properties (if LIB is specified) from the database to a file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including
            directory). If you do not specify the LIB option, the default
            directory is the current working directory. If you specify LIB and
            you have specified a material library directory (via the /MPLIB
            command), that directory is the default. Otherwise, the default is
            the current working directory. If you use the default for your
            directory, you can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        lib
            The only value allowed for this field is the string "LIB."

        mat
            Specifies the material to be written to the named material library
            file.  There is no default; you must either specify a material or
            omit the MAT argument.  Even if you specify a MAT value, the ANSYS
            program ignores it if the LIB argument is not specified.

        Notes
        -----
        Writes linear material properties currently in the database to a file.
        The file is rewound before and after writing.

        This command is also valid in SOLUTION.
        """
        command = "MPWRITE,%s,%s,%s" % (str(fname), str(ext), str(mat))
        return self.run(command, **kwargs)

    def bfk(self, kpoi="", lab="", val1="", val2="", val3="", ph_ase="",
            **kwargs):
        """APDL Command: BFK

        Defines a body force load at a keypoint.

        Parameters
        ----------
        kpoi
            Keypoint to which body load applies.  If ALL, apply to all selected
            keypoints [KSEL].  A component name may also be substituted for
            Kpoi.

        lab
            Valid body load label. Load labels are listed under "Body Loads" in
            the input table for each element type in the Element Reference.

        val1, val2, val3
            Value associated with the Lab item or a table name for specifying
            tabular boundary conditions.  Use only VAL1 for TEMP, FLUE, HGEN,
            MVDI and CHRGD.  For magnetics, use VAL1, VAL2, and VAL3 for the X,
            Y, and Z components of JS . For acoustics, if Lab = JS,  use VAL1
            for mass source in a harmonic analysis or mass source rate in a
            transient analysis, and ignoreVAL2 and VAL3. When specifying a
            table name, you must enclose the table name in percent signs (%),
            e.g., BFK,Kpoi,Lab,%tabname%.  Use the *DIM command to define a
            table.

        phase
            Phase angle in degrees associated with the JS label.

        Notes
        -----
        Defines a body force load (such as temperature in a structural
        analysis, heat generation rate in a thermal analysis, etc.) at a
        keypoint.  Body loads may be transferred from keypoints to nodes with
        the BFTRAN or SBCTRAN commands.  Interpolation will be used to apply
        loads to the nodes on the lines between keypoints.  All keypoints on a
        given area (or volume) must have the same BFK specification, with the
        same values, for the loads to be transferred to interior nodes in the
        area (or volume).  If only one keypoint on a line has a BFK
        specification, the other keypoint defaults to the value specified on
        the BFUNIF command.

        You can specify a table name only when using temperature (TEMP) and
        heat generation rate (HGEN) body load labels.

        Body loads specified by the BFK command can conflict with other
        specified body loads.  See Resolution of Conflicting Body Load
        Specifications in the Basic Analysis Guide for details.

        Graphical picking is available only via the listed menu paths.

        This command is also valid in PREP7.
        """
        command = "BFK,%s,%s,%s,%s,%s,%s" % (str(kpoi), str(lab), str(val1), str(val2), str(val3), str(ph_ase))
        return self.run(command, **kwargs)

    def bfklist(self, kpoi="", lab="", **kwargs):
        """APDL Command: BFKLIST

        Lists the body force loads at keypoints.

        Parameters
        ----------
        kpoi
            Keypoint at which body load is to be listed.  If ALL (or blank),
            list for all selected keypoints [KSEL].  If KPOI = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).  A component name may also be substituted
            for KPOI

        lab
            Valid body load label. If ALL, use all appropriate labels. Load
            labels are listed under "Body Loads" in the input table for each
            element type in the Element Reference. See the BFK command for
            labels.

        Notes
        -----
        Lists the body force loads for the specified keypoint and label.
        Keypoint body loads may be defined with the BFK command.

        This command is valid in any processor.
        """
        command = "BFKLIST,%s,%s" % (str(kpoi), str(lab))
        return self.run(command, **kwargs)

    def cdopt(self, option="", **kwargs):
        """APDL Command: CDOPT

        Specifies format to be used for archiving geometry.

        Parameters
        ----------
        option
            IGES

            IGES - Write solid model geometry information using IGES format (default).

            ANF - Write solid model geometry information using ANSYS Neutral File format.

            STAT - Print out the current format setting.

        Notes
        -----
        This command controls your solid model geometry format for CDWRITE
        operations. The ANF option affects only the COMB and SOLID options of
        the CDWRITE command. All other options remain unaffected.

        This option setting is saved in the database.
        """
        command = "CDOPT,%s" % (str(option))
        return self.run(command, **kwargs)

    def nslk(self, type="", **kwargs):
        """APDL Command: NSLK

        Selects those nodes associated with the selected keypoints.

        Parameters
        ----------
        type
            Label identifying the type of node select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        Notes
        -----
        Valid only if the nodes were generated by a keypoint meshing operation
        [KMESH, LMESH, AMESH, VMESH] on a solid model that contains the
        selected keypoints.

        This command is valid in any processor.
        """
        command = "NSLK,%s" % (str(type))
        return self.run(command, **kwargs)

    def mlist(self, node1="", node2="", ninc="", **kwargs):
        """APDL Command: MLIST

        Lists the MDOF of freedom.

        Parameters
        ----------
        node1, node2, ninc
            List master degrees of freedom from NODE1 to NODE2 (defaults
            toNODE1) in steps of NINC (defaults to 1).  If NODE1 = ALL
            (default), NODE2 and NINC are ignored and masters for all selected
            nodes [NSEL] are listed.  If NODE1 = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for NODE1
            (NODE2 and NINC are ignored).

        Notes
        -----
        Lists the master degrees of freedom.
        """
        command = "MLIST,%s,%s,%s" % (str(node1), str(node2), str(ninc))
        return self.run(command, **kwargs)

    def fjdele(self, elem="", lab="", **kwargs):
        """APDL Command: FJDELE

        Deletes forces (or moments) on the components of the relative motion of
        a joint element.

        Parameters
        ----------
        elem
            Element number, or ALL. (leaving this blank defaults to ALL)

        lab
            Valid labels are:

            FX - Force in local x direction.

            FY - Force in local y direction.

            FZ - Force in local z direction.

            MX - Moment about local x axis.

            MY - Moment about local y axis.

            MZ - Moment about local z axis.

            ALL, or (blank) - Delete all valid forces or moments.

        Notes
        -----
        Valid for MPC184 (joint options in KEYOPT(1)).

        See FJ for information on specifying forces (or moments).
        """
        command = "FJDELE,%s,%s" % (str(elem), str(lab))
        return self.run(command, **kwargs)

    def detab(self, elem="", lab="", v1="", v2="", v3="", v4="", v5="", v6="",
              **kwargs):
        """APDL Command: DETAB

        Modifies element table results in the database.

        Parameters
        ----------
        elem
            Element for which results are to be modified.  If ALL, modify all
            selected elements [ESEL] results.  If ELEM = P, graphical picking
            is enabled and all remaining command fields are ignored (valid only
            in the GUI).  A component name may also be substituted for ELEM.

        lab
            Label identifying results.  Valid labels are as defined with the
            ETABLE command.  Issue ETABLE,STAT to display labels and values.

        v1
            Value assigned to this element table result in the database.  If
            zero, a zero value will be assigned.  If blank, value remains
            unchanged.

        v2, v3, v4, . . . , v6
            Additional values (if any) assigned to consecutive element table
            columns.

        Notes
        -----
        Modifies element table [ETABLE] results in the database.  For example,
        DETAB,35,ABC,1000,2000,1000 assigns 1000, 2000, and 1000 to the first
        three table columns starting with label ABC for element 35.  Use the
        PRETAB command to list the current results.  After deleting a column of
        data using ETABLE,Lab,ERASE, the remaining columns of data are not
        shifted to compress the empty slot.  Therefore, the user must allocate
        null (blank) values for V1, V2...V6 for any ETABLE entries which have
        been deleted by issuing ETABLE,Lab,ERASE.  All data are stored in the
        solution coordinate system but will be displayed in the results
        coordinate system [RSYS].
        """
        command = "DETAB,%s,%s,%s,%s,%s,%s,%s,%s" % (str(elem), str(lab), str(v1), str(v2), str(v3), str(v4), str(v5), str(v6))
        return self.run(command, **kwargs)

    def dsym(self, lab="", normal="", kcn="", **kwargs):
        """APDL Command: DSYM

        Specifies symmetry or antisymmetry degree-of-freedom constraints on
        nodes.

        Parameters
        ----------
        lab
            Symmetry label:

            SYMM - Generate symmetry constraints as described below (default).

            ASYM - Generate antisymmetry constraints as described below.

        normal
            Surface orientation label to determine the constraint set (surface
            is assumed to be perpendicular to this coordinate direction in
            coordinate system KCN):

            X - Surface is normal to coordinate X direction (default).  Interpreted as R
                direction for non-Cartesian coordinate systems.

            Y - Surface is normal to coordinate Y direction.   θ direction for non-Cartesian
                coordinate systems.

            Z - Surface is normal to coordinate Z direction.   Φ direction for spherical or
                toroidal coordinate systems.

        kcn
            Reference number of global or local coordinate system used to
            define surface orientation.

        Notes
        -----
        Specifies symmetry or antisymmetry degree-of-freedom constraints on the
        selected nodes. The nodes are first automatically rotated (any
        previously defined rotations on these nodes are redefined) into
        coordinate system KCN, then zero-valued constraints are generated, as
        described below, on the selected degree-of-freedom set (limited to
        displacement, velocity, and magnetic degrees of freedom) [DOFSEL].
        Constraints are defined in the (rotated) nodal coordinate system, as
        usual. See the D and NROTAT commands for additional details about
        constraints and nodal rotations.

        This command is also valid in PREP7.

        Symmetry or antisymmetry constraint generations are based upon the
        valid degrees of freedom in the model, i.e., the degrees of freedom
        associated with the elements attached to the nodes.  The labels for
        degrees of freedom used in the generation depend on the Normal label.

        For displacement degrees of freedom, the constraints generated are:

        For velocity degrees of freedom, the constraints generated are:

        For magnetic degrees of freedom, the SYMM label generates flux normal
        conditions (flux flows normal to the surface).  Where no constraints
        are generated, the flux normal condition is "naturally" satisfied.  The
        ASYM label generates flux parallel conditions (flux flows parallel to
        the surface).
        """
        command = "DSYM,%s,%s,%s" % (str(lab), str(normal), str(kcn))
        return self.run(command, **kwargs)

    def abbsav(self, lab="", fname="", ext="", **kwargs):
        """APDL Command: ABBSAV

        Writes the current abbreviation set to a coded file.

        Parameters
        ----------
        lab
            Label that specifies the write operation:

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Existing abbreviations on this file, if any, will be overwritten.  The
        abbreviation file may be read with the ABBRES command.

        This command is valid in any processor.
        """
        command = "ABBSAV,%s,%s,%s" % (str(lab), str(fname), str(ext))
        return self.run(command, **kwargs)

    def nocolor(self, key="", **kwargs):
        """APDL Command: NOCOLOR

        Removes color from graphics displays.

        Parameters
        ----------
        key
            Color key:

            0 - Color the displays.

            1 - Do not color the displays.

            2 - Do not shade the displays.
        """
        command = "NOCOLOR,%s" % (str(key))
        return self.run(command, **kwargs)

    def rsys(self, kcn="", **kwargs):
        """APDL Command: RSYS

        Activates a coordinate system for printout or display of element and
        nodal results.

        Parameters
        ----------
        kcn
            The coordinate system to use for results output:

            0 - Global Cartesian coordinate system (default, except for spectrum analyses).

            1 - Global cylindrical coordinate system.

            2 - Global spherical coordinate system.

            > 10 - Any existing local coordinate system.

            SOLU - Solution coordinate systems. For element quantities, these are the element
                   coordinate system for each element.  For nodal quantities,
                   these are the nodal coordinate systems. If an element or
                   nodal coordinate system is not defined, ANSYS uses the
                   global Cartesian coordinate system. If you issue a LAYER,N
                   command (where N refers to a layer number), the results
                   appear in the layer coordinate system. (SOLU is the default
                   for spectrum analyses.)

            LSYS - Layer coordinate system. For layered shell and solid elements, the results
                   appear in their respective layer coordinate systems.  For a
                   specific layer of interest, issue a LAYER,N command (where N
                   refers to a layer number). If a model has both nonlayered
                   and layered elements, you can use RSYS,SOLU and RSYS,LSYS
                   simultaneously (with RSYS,SOLU applicable to nonlayered
                   elements and RSYS,LSYS applicable to layered elements).  To
                   reverse effects of the LSYS option, issue an RSYS,0 command.
                   LSYS is the default for spectrum analysis.

        Notes
        -----
        The RSYS command activates a coordinate system for printing or
        displaying element results data such as stresses and heat fluxes, and
        nodal results data such as degrees of freedom and reactions. ANSYS
        rotates the results data to the specified coordinate system during
        printout, display, or element table operations (such as PRNSOL, PRESOL,
        PLNSOL, and ETABLE). You can define coordinate systems with various
        ANSYS commands such as LOCAL, CS, CLOCAL, and CSKP.

        If you issue RSYS with KCN > 10 (indicating a local coordinate system),
        and the specified system is subsequently redefined, you must reissue
        RSYS for results to be rotated into the redefined system.

        Note:: : The default coordinate system for certain elements, notably
        shells, is not global Cartesian and is frequently not aligned at
        adjacent elements.

        The use of RSYS,SOLU with these elements can make nodal averaging of
        component element results, such as SX, SY, SZ, SXY, SYZ, and SXZ,
        invalid and is not recommended.

        The RSYS command has no effect on beam or pipe stresses, which ANSYS
        displays (via /ESHAPE,1 and PowerGraphics) in the element coordinate
        system.

        Element results such as stresses and heat fluxes are in the element
        coordinate systems when KCN = SOLU. Nodal requests for element results
        (for example, PRNSOL,S,COMP) average the element values at the common
        node; that is, the orientation of the node is not a factor in the
        output of element quantities.  For nearly all solid elements, the
        default element coordinate systems are parallel to the global Cartesian
        coordinate system. For shell elements and the remaining solid elements,
        the default element coordinate system can differ from element to
        element. For layered shell and layered solid elements, ANSYS initially
        selects the element coordinate system when KCN = SOLU; you can then
        select the layer coordinate system via the LAYER command.

        Nodal results such as degrees of freedom and reactions can be properly
        rotated only if the resulting component set is consistent with the
        degree-of-freedom set at the node. (The degree-of-freedom set at a node
        is determined by the elements attached to the node.) For example, if a
        node does not have a UZ degree of freedom during solution, then any Z
        component resulting from a rotation does not print or display in POST1.
        Therefore, results at nodes with a single degree-of-freedom (UY only,
        for example) should not be rotated; that is, they should be viewed only
        in the nodal coordinate system or a system parallel to the nodal
        system. (The global Cartesian system--the RSYS command default--may not
        be parallel to the nodal system.) Results at nodes with a 2-D degree-
        of-freedom set (UX and UY, for example) should not be rotated out of
        the 2-D plane.

        PowerGraphics

        For PowerGraphics, ANSYS plots PLVECT vector arrow displays (such
        temperature, velocity, and force) in the global Cartesian coordinate
        system (RSYS = 0). Subsequent operations revert to your original
        coordinate system.

        PGR File

        When you generate a .PGR file in SOLUTION, you can use the Results
        Viewer to display your stresses only in the coordinate system in which
        you write your .PGR file. To view stresses in other coordinate systems,
        load your results file into the Results Viewer and regenerate the data.

        Large Deflections

        If large deflection is active (NLGEOM,ON), ANSYS rotates the element
        component result directions by the amount of rigid body rotation.

        ANSYS displays the element component results in the initial global
        coordinate system for the following elements: SHELL181, SHELL281,
        ELBOW290, PLANE182, PLANE183, SOLID185, SOLID186, SOLID187, SOLID272,
        SOLID273, SOLID285, SOLSH190, SHELL208, and SHELL209. All other element
        result transformations are, therefore, also relative to the initial
        global system. Nodal degree-of-freedom results are based on the initial
        (and not the updated) geometry. For all other element types, component
        results displayed in the co-rotated coordinate system include the
        element rigid body rotation from the initial global coordinate system,
        and all other element result transformations are relative to the
        rotated global system.

        LS-DYNA

        You can use the RSYS command to rotate stress data for all explicit
        (ANSYS LS-DYNA) elements except BEAM161, COMBI165, and composite
        SHELL163 (KEYOPT(3) = 1). In models that contain these element types
        combined with other explicit elements, you must unselect the
        unsupported elements before issuing the RSYS command. The command does
        not support strain data for any explicit element types. If you request
        strain results for explicit elements when RSYS is not set to the global
        Cartesian coordinate system (KCN = 0), ANSYS ignores the printing or
        plotting command. (ANSYS always rotates displacements into the results
        coordinate system, independent of the explicit element type.)
        """
        command = "RSYS,%s" % (str(kcn))
        return self.run(command, **kwargs)

    def nrm(self, name="", normtype="", parr="", normalize="", **kwargs):
        """APDL Command: *NRM

        Computes the norm of the specified matrix or vector.

        Parameters
        ----------
        name
            Matrix or vector for which the norm will be computed. This can be a
            dense matrix (created by the *DMAT command), a sparse matrix
            (created by the *SMAT command) or a vector (created by the *VEC
            command)

        normtype
            Mathematical norm to use:

            L2 (Euclidian or SRSS) norm (default). - L1 (absolute sum) norm (vectors only).

        parr
            Parameter name that contains the result.

        normalize
            Normalization key; to be used only for vectors created by *VEC:

            Normalize the vector such that the norm is 1.0. - Do not normalize the vector (default).

        Notes
        -----
        The NRM2 option corresponds to the Euclidian or L2 norm and is
        applicable to either vectors or matrices. The NRM1 option corresponds
        to the L1 norm and is applicable to vectors only. The NRMINF option is
        the maximum norm and is applicable to either vectors or matrices.
        """
        command = "*NRM,%s,%s,%s,%s" % (str(name), str(normtype), str(parr), str(normalize))
        return self.run(command, **kwargs)

    def sfgrad(self, lab="", slkcn="", sldir="", slzer="", slope="", **kwargs):
        """APDL Command: SFGRAD

        Specifies a gradient (slope) for surface loads.

        Parameters
        ----------
        lab
            Valid surface load label.  Load labels are listed under "Surface
            Loads" in the input table for each element type in the Element
            Reference.

        slkcn
            Reference number of slope coordinate system (used with Sldir and
            SLZER to determine COORD).  Defaults to 0 (the global Cartesian
            coordinate system).

        sldir
            Slope direction in coordinate system SLKCN:

            X - Slope is along X direction (default).  Interpreted as R direction for non-
                Cartesian coordinate systems.

            Y - Slope is along Y direction.  Interpreted as  θ direction for non-Cartesian
                coordinate systems.

            Z - Slope is along Z direction.  Interpreted as Φ direction for spherical or
                toroidal coordinate systems.

        slzer
            Coordinate location (degrees for angular input) where slope
            contribution is zero (CVALUE = VALUE).  Allows the slope
            contribution to be shifted along the slope direction.  For angular
            input, SLZER should be between ±180° if the singularity [CSCIR]  is
            at 180° and should be between 0° and 360° if the singularity is at
            0°.

        slope
            Slope value (load per unit length or per degree).

        Notes
        -----
        Specifies a gradient (slope) for surface loads.  All surface loads
        issued with the SF, SFE, SFL, or SFA commands while this specification
        is active will have this gradient applied (for complex pressures, only
        the real component will be affected; for convections, only the bulk
        temperature will be affected).  The load value, CVALUE, calculated at
        each node is:

        CVALUE = VALUE + (SLOPE X (COORD-SLZER))

        where VALUE is the load value specified on the subsequent SF, SFE, SFL,
        or SFA commands and COORD is the coordinate value (in the Sldir
        direction of coordinate system SLKCN) of the node.  Only one SFGRAD
        specification may be active at a time (repeated use of this command
        replaces the previous specification with the new specification).  Issue
        SFGRAD (with blank fields) to remove the specification.  Issue
        SFGRAD,STAT to show the current command status.  The SFGRAD
        specification (if active) is removed when the LSREAD (if any) command
        is issued.

        SFGRAD does not work for tabular boundary conditions.

        This command is also valid in PREP7.
        """
        command = "SFGRAD,%s,%s,%s,%s,%s" % (str(lab), str(slkcn), str(sldir), str(slzer), str(slope))
        return self.run(command, **kwargs)

    def elseif(self, val1="", oper1="", val2="", conj="", val3="", oper2="",
               val4="", **kwargs):
        """APDL Command: *ELSEIF

        Separates an intermediate if-then-else block.

        Parameters
        ----------
        val1
            First numerical value (or parameter which evaluates to numerical
            value) in the conditional comparison operation. VAL1, VAL2, VAL3,
            and VAL4 can also be character strings (enclosed in quotes) or
            parameters for Oper = EQ and NE only.

        oper1
            Operation label. A tolerance of 1.0E-10 is used for comparisons
            between real numbers:

            Equal (for VAL1 = VAL2). - Not equal (for VAL1 ≠VAL2).

            Less than (for VAL1<VAL2). - Greater than (for VAL1>VAL2).

            Less than or equal (for VAL1 VAL2). - Greater than or equal (for VAL1 VAL2).

            Absolute values of VAL1 and VAL2 before < operation. - Absolute values of VAL1 and VAL2 before > operation.

        val2
            Second numerical value (or parameter which evaluates to numerical
            value) in the conditional comparison operation.

        conj
            (Optional) Connection between two logical clauses.

            True if both clauses (Oper1 and Oper2) are true.  - True if either clause is true.

        val3
            (Optional) Third numerical value (or parameter which evaluates to
            numerical value).

        oper2
            (Optional) Operation label.  This will have the same labels as
            Oper1, except it uses Val3 and Val4. A tolerance of 1.0E-10 is used
            for comparisons between real numbers.

        val4
            (Optional) Fourth numerical value (or parameter value which
            evaluates to a numerical value).

        Notes
        -----
        Optional intermediate block separator within an if-then-else construct.
        All seven characters of the command name (*ELSEIF) must be input. This
        command is similar to the *IF  command except that the Base field is
        not used. The *IF, *ELSEIF, *ELSE, and *ENDIF commands for each if-
        then-else construct must all be read from the same file (or keyboard).

        This command is valid in any processor.
        """
        command = "*ELSEIF,%s,%s,%s,%s,%s,%s,%s" % (str(val1), str(oper1), str(val2), str(conj), str(val3), str(oper2), str(val4))
        return self.run(command, **kwargs)

    def prsect(self, rho="", kbr="", **kwargs):
        """APDL Command: PRSECT

        Calculates and prints linearized stresses along a section path.

        Parameters
        ----------
        rho
            In-plane (X-Y) average radius of curvature of the inside and
            outside surfaces of an axisymmetric section.  If zero (or blank), a
            plane or 3-D structure is assumed.  If nonzero, an axisymmetric
            structure is assumed.  Use any large number (or -1) for an
            axisymmetric straight section.

        kbr
            Through-thickness bending stresses key for an axisymmetric analysis
            (RHO  ≠ 0):

            0 - Include the thickness-direction bending stresses.

            1 - Ignore the thickness-direction bending stresses.

            2 - Include the thickness-direction bending stress using the same formula as the Y
                (axial direction ) bending stress. Also use the same formula
                for the shear stress.

        Notes
        -----
        You may choose to linearize the stresses through a section and separate
        them into categories for various code calculations.  PRSECT calculates
        and reports linearized stresses along a section path.  The linearized
        stresses are also separated into membrane, bending, membrane plus
        bending, peak, and total stress categories.

        First, define your section path using the PATH and PPATH (with the NODE
        option) commands.  Your path must lie entirely within the selected set
        of elements (that is, there must be no element gaps along the path).
        PATH and PPATH are used only to retrieve the two end nodes.  The path
        data is not retained.  The section path is defined by the two end
        nodes, and by 47 intermediate points that are automatically determined
        by linear interpolation in the active display coordinate system [DSYS].
        The number and location of the intermediate points are not affected by
        the number of divisions set by PATH,,,,nDiv.

        Your  linearized component stress values are obtained by interpolating
        each element’s  average corner nodal values along the section path
        points within each path element.  PRSECT reports the linearized
        component and principal stresses for each stress category at the
        beginning, mid-length, and end of the section path.  PRPATH can be used
        to report the total stresses at the intermediate points.

        Section paths may be through any set of solid (2-D plane, 2-D
        axisymmetric or 3-D) elements.  However, section paths are usually
        defined to be through the thickness of the structure and normal to the
        inner and outer structure surfaces.  Section paths (in-plane only) may
        also be defined for shell element structures.  See the Mechanical APDL
        Theory Reference for details.

        If the RHO option is set to indicate the axisymmetric option (non-
        zero), PRSECT reports the linearized stresses in the section
        coordinates (SX – along the path, SY – normal to the path, and SZ –
        hoop direction).  If the RHO option is set to indicate the 2-D planar
        or 3-D option (zero or blank), PRSECT reports the linearized stresses
        in the active results coordinate system [RSYS].  If the RHO option is
        zero or blank and either RSYS, SOLU or RSYS, -1 are active, the
        linearized stresses are calculated and reported in the global Cartesian
        coordinate system.  It is recommended that linearized stress
        calculations be performed in a rectangular coordinate system.
        Principal stresses are recalculated from the component stresses and are
        invariant with the coordinate system as long as SX is in the same
        direction at all points along the defined path.  The PLSECT command
        displays the linearized stresses in the same coordinate system as
        reported by PRSECT.

        Stress components through the section are linearized by a line integral
        method and separated into constant membrane stresses, bending stresses
        varying linearly between end points, and peak stresses (defined as the
        difference between the actual (total) stress and the membrane plus
        bending combination).

        For nonaxisymmetric structures,  the bending stresses are calculated
        such that the neutral axis is at the midpoint of the path.
        Axisymmetric results include the effects of both the radius of
        revolution (automatically determined from the node locations) and the
        in-plane average radius of curvature of the section surfaces (user
        input).

        For axisymmetric cases, Mechanical APDL calculates the linearized
        bending stress in the through-thickness direction as the difference
        between the total outer fiber stress and the membrane stress if KBR =
        1. The calculation method may be conservative for locations with a
        highly nonlinear variation of stress in the through-thickness
        direction.  Alternatively, you can specify KBR = 2 to calculate the
        bending stress using the same method and formula as the Y (axial
        direction) bending stress. For more information, see the discussion of
        axisymmetric cases (specifically Equation: 17–40) in the Mechanical
        APDL Theory Reference.

        Portions of this command are not supported by PowerGraphics
        [/GRAPHICS,POWER].
        """
        command = "PRSECT,%s,%s" % (str(rho), str(kbr))
        return self.run(command, **kwargs)

    def spmwrite(self, method="", nmode="", inputs="", inputlabels="",
                 outputs="", outputlabels="", nic="", velacckey="",
                 fileformat="", **kwargs):
        """APDL Command: SPMWRITE

        Calculates the state-space matrices and writes them to the SPM file.

        Parameters
        ----------
        method
            Reduction method for the calculation of the state-space matrices.

            MODAL - Method based on modal analysis results from LANB, LANPCG, SNODE, or SUBSP
                    eigensolver (default).

        nmode
            Number of modes to be used. Defaults to all modes.

        inputs
            Definition of the inputs. Defaults to all load vectors on the MODE
            file.

        inputlabels
            Definition of the input labels. Defaults to the load vector numbers
            or input definition (node and degree of freedom array parameter),
            depending on the Inputs specification.

        outputs
            Definition of the outputs. Defaults to the inputs.

        outputlabels
            Definition of the output labels. Defaults to the output definition
            (node and degree of freedom) if used, else defaults to the
            InputLabels.

        nic
            Load vector on the MODE file used for the calculation of the
            initial conditions. Defaults to no initial condition.

        velacckey
            Output velocities and accelerations key.

            OFF - Output displacements only (default).

            ON - Output displacements, velocities and accelerations.

        fileformat
            The format of the SPM file.

            0 - Dense format.

            1 - Matrix Market Exchange format (non-zero terms only).

            2 - Simplorer SML format without reference (default).

            3 - Simplorer SML format with common reference.

            4 - Simplorer SML format with independent references.

        Notes
        -----
        The SPMWRITE generates the file Jobname.SPM containing the state-space
        matrices and other information.

        The following applies to the SML formats (FileFormat = 2, 3, and 4):

        For conservative systems where the outputs are equal to the inputs
        (Outputs is left blank):

        The labels for the inputs (InputLabels) are required.

        The Inputs must use the array parameter option so that the input
        degrees of freedom (DOFs) are known.

        For non-conservative systems where the outputs are not equal to the
        inputs:

        The labels for the outputs (OutputLabels) are required.

        The file formats with references (FileFormat = 3 and 4) do not apply.

        Velocity and acceleration results are not included in the state-space
        matrices calculation (VelAccKey = OFF)

        File format with common reference (FileFormat = 3) does not apply if
        the inputs are based on DOFs of a different nature.  All input DOFs
        must be either all rotational or all translational and not a mix of the
        two.

        A graphics file (Jobname_SPM.PNG) is generated. It contains an element
        plot of the model.

        For more details about the reduction method and the generation of the
        state-space matrices, see Reduced-Order Modeling for State-Space
        Matrices Export in the Mechanical APDL Theory Reference.

        For examples of the command usage, see State-Space Matrices Export.
        """
        command = "SPMWRITE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(method), str(nmode), str(inputs), str(inputlabels), str(outputs), str(outputlabels), str(nic), str(velacckey), str(fileformat))
        return self.run(command, **kwargs)

    def plgeom(self, item="", nodekey="", **kwargs):
        """APDL Command: PLGEOM

        Plots target and source geometries.

        Parameters
        ----------
        item
            Items to plot:

            BOTH - Plot both target and source geometries (default).

            TARGET - Plot only the target geometry.

            SOURCE - Plot only the source geometry.

        nodekey
            If the source data contains faces (that is, surface elements were
            created upon the READ command), set NODEkey = 1 to plot only the
            source nodes rather than both the nodes and the elements.

        Notes
        -----
        Target faces are displayed in gray and source points in yellow. If the
        source data contains faces (that is, surface elements were created upon
        the READ command), the source faces are also displayed in blue (unless
        NODEkey = 1), and both surfaces are made translucent.
        """
        command = "PLGEOM,%s,%s" % (str(item), str(nodekey))
        return self.run(command, **kwargs)

    def adele(self, na1="", na2="", ninc="", kswp="", **kwargs):
        """APDL Command: ADELE

        Deletes unmeshed areas.

        Parameters
        ----------
        na1, na2, ninc
            Delete areas from NA1 to NA2 (defaults to NA1) in steps of NINC
            (defaults to 1).  If NA1 = ALL, NA2 and NINC are ignored and all
            selected areas [ASEL] are deleted.  If NA1 = P, graphical picking
            is enabled and all remaining arguments are ignored (valid only in
            the GUI).  A component name may also be substituted for NA1 (NA2
            and NINC are ignored).

        kswp
            Specifies whether keypoints and lines are also to be deleted:

            0 - Delete areas only (default).

            1 - Delete areas, as well as keypoints and lines attached to specified areas but
                not shared by other areas.

        Notes
        -----
        An area attached to a volume cannot be deleted unless the volume is
        first deleted.
        """
        command = "ADELE,%s,%s,%s,%s" % (str(na1), str(na2), str(ninc), str(kswp))
        return self.run(command, **kwargs)

    def lsymbol(self, x="", y="", symang="", symtyp="", symsiz="", keybmp="",
                **kwargs):
        """APDL Command: /LSYMBOL

        Creates annotation symbols (GUI).

        Parameters
        ----------
        x
            X location for symbol (-1.0 < X < 2.0).

        y
            Y location for symbol (-1.0 < Y < 1.0).

        symang
            Symbol orientation angle.

        symtyp
            Symbol type:

            1 - Arrow.

            2 - Tee.

            3 - Circle.

            4 - Triangle.

            5 - Star.

        symsiz
            Symbol size multiplier (0.1 to 20.0).  Defaults to 1.0.

        keybmp
            If KEYBMP = 1, the annotation is a bitmap. SYMTYP will then be a
            number from 1-99, indicating the bitmap type (see notes), and X and
            Y will define the lower left corner of the bitmap. The SYMANG,
            SYMSIZarguments are ignored. If KEYBMP = 0, or blank, then the
            argument definitions above apply.

        Notes
        -----
        Defines annotation symbols to be written directly onto the display at a
        specified location.  This is a command generated by the GUI and will
        appear in the log file (Jobname.LOG) if annotation is used.  This
        command is not intended to be typed in directly in an ANSYS session
        (although it can be included in an input file for batch input or for
        use with the /INPUT command).

        All symbols are shown on subsequent displays unless the annotation is
        turned off or deleted.  Use the /LSPEC command to set the attributes of
        the symbol.

        The KEYBMP argument reads the symtype argument to determine which
        bitmap to insert. This bitmap is defined by an integer between 1 and
        99. Numbers 1 through 40 correspond to the standard texture values
        found in the /TXTRE  command, while numbers 51 through 99 correspond to
        user supplied bitmaps, as defined using the Filename option of the
        /TXTRE command. Numbers 51 through 57 are predefined (the logos, clamps
        and arrows available from the GUI) but can be overridden. Numbers 41
        through 50 are reserved.

        This command is valid in any processor.
        """
        command = "/LSYMBOL,%s,%s,%s,%s,%s,%s" % (str(x), str(y), str(symang), str(symtyp), str(symsiz), str(keybmp))
        return self.run(command, **kwargs)

    def bsax(self, val1="", val2="", t="", **kwargs):
        """APDL Command: BSAX

        Specifies the axial strain and axial force relationship for beam
        sections.

        Parameters
        ----------
        val1
            Axial strain component (ε).

        val2
            Axial force component (N).

        t
            Temperature.

        Notes
        -----
        The behavior of beam elements is governed by the generalized-
        stress/generalized-strain relationship of the form:

        The BSAX command, one of several nonlinear general beam section
        commands, specifies the relationship of axial strain and axial force
        for a beam section. The section data defined is associated with the
        section most recently defined (via the SECTYPE command).

        Unspecified values default to zero.

        Related commands are BSM1, BSM2, BSTQ, BSS1, BSS2, BSMD, and BSTE.

        For complete information, see Using Nonlinear General Beam Sections.
        """
        command = "BSAX,%s,%s,%s" % (str(val1), str(val2), str(t))
        return self.run(command, **kwargs)

    # def plot(self, nstrt="", nend="", ninc="", **kwargs):
    #     """APDL Command: PLOT

    #     Forms a display.

    #     Parameters
    #     ----------
    #     nstrt, nend, ninc
    #         Display plots sequentially from number NSTRT to NEND in steps of
    #         NINC. NSTRT defaults to the next plot.  NEND defaults to NSTRT.
    #         NINC defaults to 1.  If NSTRT = ALL, display all plots from the
    #         beginning of the file.  If NEND = ALL, display to the end of the
    #         file.

    #     Notes
    #     -----
    #     Output will be to the terminal or to a file, depending on the driver
    #     [/SHOWDISP].  The INTERLEAF and DUMP drivers produce an output file for
    #     each plot named INTLnn and DUMPnn, with nn sequentially ranging from 00
    #     to 99.  A blank line after the PLOT command causes the next plot to be
    #     formed.
    #     """
    #     command = "PLOT,%s,%s,%s" % (str(nstrt), str(nend), str(ninc))
    #     return self.run(command, **kwargs)

    def bfa(self, area="", lab="", val1="", val2="", val3="", val4="",
            **kwargs):
        """APDL Command: BFA

        Defines a body force load on an area.

        Parameters
        ----------
        area
            Area to which body load applies.  If ALL, apply to all selected
            areas [ASEL]. A component name may also be substituted for Area.

        lab
            Valid body load label. Load labels are listed under "Body Loads" in
            the input table for each element type in the Element Reference.

        val1, val2, val3
            Value associated with the Lab item or a table name for specifying
            tabular boundary conditions. Use only VAL1 for TEMP, FLUE, HGEN,
            CHRGD. For Lab = JS in magnetics, use VAL1, VAL2, and VAL3 for the
            X, Y, and Z components. For acoustics, if Lab = JS, use VAL1 for
            mass source in a harmonic analysis or mass source rate in a
            transient analysis, and ignore VAL2 and VAL3. For Lab = VLTG, VAL1
            is the voltage drop and VAL2 is the phase angle. If Lab = IMPD,
            VAL1 is the resistance and VAL2 is the reactance in ohms/square.
            When specifying a table name, you must enclose the table name in
            percent signs (%), e.g., BFA,Area,Lab,%tabname%. Use the *DIM
            command to define a table.

        val4
            If Lab = JS, VAL4 is the phase angle in degrees.

        Notes
        -----
        Defines a body force load (such as temperature in a structural
        analysis, heat generation rate in a thermal analysis, etc.) on an area.
        Body loads may be transferred from areas to area elements (or to nodes
        if area elements do not exist) with the BFTRAN or SBCTRAN commands.
        Body loads default to the value specified on the BFUNIF command, if it
        was previously specified.

        You can specify a table name only when using temperature (TEMP) and
        heat generation rate (HGEN) body load labels.

        Body loads specified by the BFA command can conflict with other
        specified body loads.  See Resolution of Conflicting Body Load
        Specifications in the Basic Analysis Guide for details.

        Graphical picking is available only via the listed menu paths.

        This command is also valid in PREP7.
        """
        command = "BFA,%s,%s,%s,%s,%s,%s" % (str(area), str(lab), str(val1), str(val2), str(val3), str(val4))
        return self.run(command, **kwargs)

    def lczero(self, **kwargs):
        """APDL Command: LCZERO

        Zeroes the results portion of the database.

        Notes
        -----
        Often used before the LCOPER command.  Same as LCOPER,ZERO.
        """
        command = "LCZERO," % ()
        return self.run(command, **kwargs)

    def lumpm(self, key="", **kwargs):
        """APDL Command: LUMPM

        Specifies a lumped mass matrix formulation.

        Parameters
        ----------
        key
            Formulation key:

            OFF - Use the element-dependent default mass matrix formulation (default).

            ON - Use a lumped mass approximation.

        Notes
        -----
        This command is also valid in PREP7.  If used in SOLUTION, this command
        is valid only within the first load step.
        """
        command = "LUMPM,%s" % (str(key))
        return self.run(command, **kwargs)

    def aremesh(self, lcomb="", angle="", **kwargs):
        """APDL Command: AREMESH

        Generates an area in which to create a new mesh for rezoning.

        Parameters
        ----------
        lcomb
            Specifies how to combine adjacent line segments:

             0 - Line segments combined by connecting ends to ends. This value is the default.

            -1 - No line segments combined.

        angle
            The maximum angle (in degrees) allowed for connecting two line
            segments together. The default value is 30. This value is valid
            only when LCOMB = 0.

        Notes
        -----
        Issue the AREMESH command after issuing a REMESH,START command and
        before issuing a REMESH,FINISH command.

        The AREMESH command cannot account for an open area (or “hole”) inside
        a completely enclosed region. Instead, try meshing around an open area
        by selecting two adjoining regions; for more information, see Hints for
        Remeshing Multiple Regions .
        """
        command = "AREMESH,%s,%s" % (str(lcomb), str(angle))
        return self.run(command, **kwargs)

    def pretab(self, lab1="", lab2="", lab3="", lab4="", lab5="", lab6="",
               lab7="", lab8="", lab9="", **kwargs):
        """APDL Command: PRETAB

        Prints the element table items.

        Parameters
        ----------
        lab1, lab2, lab3, . . . , lab9
            Print selected items.  Valid labels are (blank) or any label as
            specified with the ETABLE command.  Convenience labels may be used
            for Lab1 to select groups of labels (10 labels maximum):  GRP1 for
            first 10 stored items; GRP2 for items 11 to 20; GRP3 for items 21
            to 30; GRP4 for items 31 to 40; GRP5 for items 41 to 50.  Enter
            ETABLE,STAT command to list stored item order.  If all labels are
            blank, print first 10 stored items (GRP1).

        Notes
        -----
        Prints the items stored in the table defined with the ETABLE command.
        Item values will be listed for the selected elements in the sorted
        sequence [ESORT].  The FORCE command can be used to define which
        component of the nodal load is to be used (static,  damping, inertia,
        or total).

        Portions of this command are not supported by PowerGraphics
        [/GRAPHICS,POWER].
        """
        command = "PRETAB,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(lab1), str(lab2), str(lab3), str(lab4), str(lab5), str(lab6), str(lab7), str(lab8), str(lab9))
        return self.run(command, **kwargs)

    def cecyc(self, lowname="", highname="", nsector="", hindex="",
              tolerance="", kmove="", kpairs="", **kwargs):
        """APDL Command: CECYC

        Generates the constraint equations for a cyclic symmetry analysis

        Parameters
        ----------
        lowname
            Name of a component for the nodes on the low angle edge of the
            sector.  Enclosed in single quotes.

        highname
            Name of a component for the nodes on the high angle edge of the
            sector.  Enclosed in single quotes.

        nsector
            Number of sectors in the complete 360 degrees.

        hindex
            Harmonic index to be represented by this set of constraint
            equations.  If Hindex is -1, generate constraint equations for
            static cyclic symmetry.  If HIndex is -2, generate constraint
            equations for static cyclic asymmetry.

        tolerance
            A positive tolerance is an absolute tolerance (length units), and a
            negative tolerance is a tolerance relative to the local element
            size.

        kmove
            0

            0 - Nodes are not moved.

            1 - HIGHNAME component nodes are moved to match LOWNAME component nodes exactly.

        kpairs
            0

            0 - Do not print paired nodes

            1 - Print table of paired nodes

        Notes
        -----
        The analysis can be either modal cyclic symmetry or static cyclic
        symmetry.

        The pair of nodes for which constraint equations are written are
        rotated into CSYS,1.
        """
        command = "CECYC,%s,%s,%s,%s,%s,%s,%s" % (str(lowname), str(highname), str(nsector), str(hindex), str(tolerance), str(kmove), str(kpairs))
        return self.run(command, **kwargs)

    def title(self, title="", **kwargs):
        """APDL Command: /TITLE

        Defines a main title.

        Parameters
        ----------
        title
            Input up to 72 alphanumeric characters.  Parameter substitution may
            be forced within the title by enclosing the parameter name or
            parametric expression within percent (%) signs.

        Notes
        -----
        The title is carried through the printout and written on various files.
        The title written to a file is the title defined at that time.  Special
        characters may be used within the title text.  Subtitles may also be
        defined [/STITLE].

        This command is valid in any processor.
        """
        command = "/TITLE,%s" % (str(title))
        return self.run(command, **kwargs)

    def arotat(self, nl1="", nl2="", nl3="", nl4="", nl5="", nl6="", pax1="",
               pax2="", arc="", nseg="", **kwargs):
        """APDL Command: AROTAT

        Generates cylindrical areas by rotating a line pattern about an axis.

        Parameters
        ----------
        nl1, nl2, nl3, . . . , nl6
            List of lines in the pattern to be rotated (6 maximum if using
            keyboard entry of NL1 to NL6).  The lines must lie in the plane of
            the axis of rotation.  If NL1 = P, graphical picking is enabled and
            all remaining arguments are ignored (valid only in the GUI).  If
            NL1 = ALL, all selected lines will define the pattern to be
            rotated.  A component name may also be substituted for NL1.

        pax1, pax2
            Keypoints defining the axis about which the line pattern is to be
            rotated.

        arc
            Arc length (in degrees).  Positive follows right-hand rule about
            PAX1-PAX2 vector.  Defaults to 360°.

        nseg
            Number of areas (8 maximum) around circumference.  Defaults to
            minimum number required for 90° -maximum arcs, i.e., 4 for 360°, 3
            for 270°, etc.

        Notes
        -----
        Generates cylindrical areas (and their corresponding keypoints and
        lines) by rotating a line pattern (and its associated keypoint pattern)
        about an axis.  Keypoint patterns are generated at regular angular
        locations, based on a maximum spacing of 90°.  Line patterns are
        generated at the keypoint patterns.  Arc lines are also generated to
        connect the keypoints circumferentially.  Keypoint, line, and area
        numbers are automatically assigned, beginning with the lowest available
        values [NUMSTR].  Adjacent lines use a common keypoint.  Adjacent areas
        use a common line.
        """
        command = "AROTAT,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nl1), str(nl2), str(nl3), str(nl4), str(nl5), str(nl6), str(pax1), str(pax2), str(arc), str(nseg))
        return self.run(command, **kwargs)

    def kl(self, nl1="", ratio="", nk1="", **kwargs):
        """APDL Command: KL

        Generates a keypoint at a specified location on an existing line.

        Parameters
        ----------
        nl1
            Number of the line.  If negative, the direction of line (as
            interpreted for RATIO) is reversed.  If NL1 = P, graphical picking
            is enabled and all remaining command fields are ignored (valid only
            in the GUI).

        ratio
            Ratio of line length to locate keypoint.  Must be between 0.0 and
            1.0.  Defaults to 0.5 (divide the line in half).

        nk1
            Number to be assigned to keypoint generated at division location
            (defaults to lowest available keypoint number [NUMSTR]).
        """
        command = "KL,%s,%s,%s" % (str(nl1), str(ratio), str(nk1))
        return self.run(command, **kwargs)

    def gsbdata(self, labz="", valuez="", labx="", valuex="", laby="",
                valuey="", **kwargs):
        """APDL Command: GSBDATA

        Specifies the constraints or applies the load at the ending point for
        generalized plane strain option.

        Parameters
        ----------
        labz
            Constraint or load at the ending point in the fiber Z direction.

            F - Apply a force in the fiber direction (default).

            LFIBER - Define a length change in the fiber direction.

        valuez
            Value for LabZ. The default is zero.

        labx
            Constraint or load on rotation about X.

            MX - Supply a moment to cause the rotation of the ending plane about X (default).

            ROTX - Define a rotation angle (in radians) of the ending plane about X.

        valuex
            Value for LabX. The default is zero.

        laby
            Constraint or load on rotation about Y

            MY - Supply a moment to cause the rotation of the ending plane about Y (default).

            ROTY - Define a rotation angle (in radians) of the ending plane about Y.

        valuey
            Value for LabY. The default is zero.

        Notes
        -----
        All inputs are in the global Cartesian coordinate system. For more
        information about the generalized plane strain feature, see Generalized
        Plane Strain Option of Current-Technology Solid Elements in the Element
        Reference.

        This command is also valid in PREP7.
        """
        command = "GSBDATA,%s,%s,%s,%s,%s,%s" % (str(labz), str(valuez), str(labx), str(valuex), str(laby), str(valuey))
        return self.run(command, **kwargs)

    def etcontrol(self, eltech="", eldegene="", **kwargs):
        """APDL Command: ETCONTROL

        Control the element technologies used in element formulation (for
        applicable elements).

        Parameters
        ----------
        eltech
            Element technology control:

            SUGGESTION - The program offers a suggestion for the best element technology before solving.
                         If necessary, mixed u-P (KEYOPT(6)) is also included
                         and reset. This behavior is the default.

            SET - The program informs you of the best settings and resets any applicable KEYOPT
                  settings automatically. This action overrides any previous
                  manual settings.

            OFF - Deactivates automatic selection of element technology. No suggestions are
                  issued, and no automatic resetting occurs.

        eldegene
            Element degenerated shape control:

            ON - If element shapes are degenerated, the degenerated shape function is employed
                 and enhanced strain, simplified enhanced strain, and B-bar
                 formulations are turned off (default).

            OFF - If element shapes are degenerated, regular shape functions are still used, and
                  the specified element technologies (e.g., enhanced strain,
                  B-bar, uniform reduced integration) are still used.

        Notes
        -----
        The command default is ETCONTROL,SUGGESTION,ON.

        This command is valid for elements SHELL181, PLANE182, PLANE183,
        SOLID185, SOLID186, SOLID187, BEAM188, BEAM189, SHELL208, SHELL209,
        PLANE223, SOLID226, SOLID227, REINF264, SOLID272, SOLID273, SHELL281,
        SOLID285, PIPE288, PIPE289, ELBOW290.

        For more information, see Automatic Selection of Element Technologies
        and Formulations in the Element Reference.
        """
        command = "ETCONTROL,%s,%s" % (str(eltech), str(eldegene))
        return self.run(command, **kwargs)

    def edcurve(self, option="", lcid="", par1="", par2="", **kwargs):
        """APDL Command: EDCURVE

        Specifies data curves for an explicit dynamic analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed.

            ADD - Define a data curve (default). If Option = ADD, Par1 and Par2 must be
                  previously defined array parameters.

            DELE - Delete the specified data curve (LCID). If LCID is blank, all data curves are
                   deleted. Par1 and Par2 are ignored for this option.

            LIST - List defined data curve (LCID). If LCID is blank, all data curves are listed.
                   Par1 and Par2 are ignored for this option.

            PLOT - Plot defined data curve (LCID). If Option = PLOT, LCID must be previously
                   defined with an EDCURVE command. Otherwise a warning message
                   will report that LCID has not been defined. Par1 and Par2
                   are ignored for this option.

        lcid
            Data curve ID number (no default). Must be a positive integer.

        par1
            Name of user-defined array parameter that contains the abscissa
            values of the curve data (e.g., time, effective plastic strain,
            effective strain rate, displacement, etc.).

        par2
            Name of user-defined array parameter that contains the ordinate
            values of the curve data (e.g., damping coefficients, initial yield
            stress, elastic modulus, force, etc.) corresponding to the abscissa
            values in Par1.

        Notes
        -----
        EDCURVE can be used to define material data curves (e.g., stress-
        strain) and load data curves (force-deflection) associated with
        material models in an explicit dynamics analysis. Material data
        specified by this command is typically required to define a particular
        material behavior (e.g., TB,HONEY), and the LCID number is used as
        input on the TBDATA command.

        EDCURVE can also be used to define load curves that represent time
        dependent loads (force, displacement, velocity, etc.). Par1 must
        contain the time values, and Par2 must contain the corresponding load
        values. The LCID number assigned to the load curve can be used as input
        on the EDLOAD command.

        Note:: : You cannot update a previously defined data curve by changing
        the array parameters that were input as Par1 and Par2. The data curve
        definition is written to the database at the time EDCURVE is issued.
        Therefore, subsequent changes to the array parameters that were used as
        input on EDCURVE will not affect the load curve definition. If you need
        to change the load curve definition, you must delete the load curve
        (EDCURVE,DELE,LCID) and define it again.

        LCID identifies the data curve. If the value input for LCID is the same
        as the ID number for a data curve previously defined by EDCURVE, the
        previous data will be overwritten. Use EDCURVE,LIST and EDCURVE,PLOT to
        check existing data curves.

        A starting array element number must be specified for Par1 and Par2.
        The input for these fields must be a single column array parameter, or
        a specific column from a multi-column array parameter. When using the
        GUI with multi-column parameters, you must specify the parameter name
        and starting position for Par1 and Par2 by typing the EDCURVE command
        in the Input Window. This is because only the parameter name is
        available through the dialog box, which pulls in the first position of
        a single-column array parameter.

        If you need to change a curve definition in an explicit dynamic small
        restart analysis, issue EDSTART,2 first (to specify the restart), then
        issue the EDCURVE command. The revised curve must contain the same
        number of points as the curve it replaces. This limitation does not
        apply to a full restart analysis (EDSTART,3).

        This command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDCURVE,%s,%s,%s,%s" % (str(option), str(lcid), str(par1), str(par2))
        return self.run(command, **kwargs)

    def cplist(self, nset1="", nset2="", ninc="", nsel="", **kwargs):
        """APDL Command: CPLIST

        Lists the coupled degree of freedom sets.

        Parameters
        ----------
        nset1, nset2, ninc
            List coupled sets from NSET1 to NSET2 (defaults to NSET1) in steps
            of NINC (defaults to 1).  If NSET1 = ALL (default), NSET2 and NINC
            are ignored and all coupled sets are listed.

        nsel
            Node selection control:

            ANY - List coupled set if any of the selected nodes are in the set (default).

            ALL - List coupled set only if all of the selected nodes are in the set.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "CPLIST,%s,%s,%s,%s" % (str(nset1), str(nset2), str(ninc), str(nsel))
        return self.run(command, **kwargs)

    def emsym(self, nsect="", **kwargs):
        """APDL Command: EMSYM

        Specifies circular symmetry for electromagnetic sources.

        Parameters
        ----------
        nsect
            The number of circular symmetry sections (defaults to 1).

        Notes
        -----
        Specifies the number of times to repeat electromagnetic sources for
        circular symmetry. Applies to SOURC36 elements and to coupled-field
        elements with electric current conduction results in the database.
        Sources are assumed to be equally spaced over 360° about the global
        Cartesian Z axis.

        This command is also valid in SOLUTION.
        """
        command = "EMSYM,%s" % (str(nsect))
        return self.run(command, **kwargs)

    def tbdele(self, lab="", mat1="", mat2="", inc="", **kwargs):
        """APDL Command: TBDELE

        Deletes previously defined material data tables.

        Parameters
        ----------
        lab
            Data table label. (See the TB command for valid labels.)  If ALL,
            delete all data tables.

        mat1, mat2, inc
            Delete tables for materials MAT1 to (MAT2 defaults to MAT1) in
            steps of INC (defaults to 1).  If MAT1= ALL, ignore MAT2 and INC
            and delete data tables for all materials.

        Notes
        -----
        This command is also valid in SOLUTION.
        """
        command = "TBDELE,%s,%s,%s,%s" % (str(lab), str(mat1), str(mat2), str(inc))
        return self.run(command, **kwargs)

    def kesize(self, npt="", size="", fact1="", fact2="", **kwargs):
        """APDL Command: KESIZE

        Specifies the edge lengths of the elements nearest a keypoint.

        Parameters
        ----------
        npt
            Number of the keypoint whose lines will be adjusted.  If ALL, use
            all selected keypoints [KSEL].  If NPT = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).

        size
            Size of elements along lines nearest keypoint NPT (overrides any
            other specified size).  If SIZE is zero (or blank), use FACT1 or
            FACT2.

        fact1
            Scale factor applied to a previously defined SIZE.  Not used if
            SIZE is input.

        fact2
            Scale factor applied to the minimum element division at keypoint
            NPT for any attached line.  This feature is useful with adaptive
            mesh refinement.  Not used if SIZE or FACT1 is input.

        Notes
        -----
        Affects only the line divisions adjacent to the keypoint on lines not
        previously assigned divisions by other line commands [LESIZE, etc.].
        The remaining line divisions are determined from the division nearest
        the keypoint at the other end of the line (specified by another KESIZE
        command or the ESIZE command).  Divisions are transferred to the lines
        during the mesh operation.  If smart element sizing is being used
        [SMRTSIZE], KESIZE specifications may be overridden (i.e., a smaller
        element size may be used) to accommodate curvature and small features.

        This command is valid in any processor. The command is also valid for
        rezoning.
        """
        command = "KESIZE,%s,%s,%s,%s" % (str(npt), str(size), str(fact1), str(fact2))
        return self.run(command, **kwargs)

    def pddmcs(self, nsim="", _astop="", accmean="", accstdev="", check="",
               seed="", **kwargs):
        """APDL Command: PDDMCS

        Specifies options for Monte Carlo Simulations using direct sampling.

        Parameters
        ----------
        nsim
            Number of simulation loops of the analysis.

        --
            Unused field.

        astop
            Autostop option label.

            AUTO - Enable Autostop. When Autostop is used, the PDS feature continues the
                   simulation loops until the convergence criteria for the mean
                   value and the standard deviation have been met or until the
                   number of simulations NSIM are complete, whichever comes
                   first. The convergence criteria (mean value and standard
                   deviations of all random output parameters) are specified by
                   the ACCMEAN and ACCSTDEV parameters. The criteria are met if
                   the mean value and the standard deviations converge within
                   the accuracy specified in the ACCMEAN and ACCSTDEV options.
                   The convergence check is done every i-th loop, where i is
                   specified in the CHECK parameter.

            ALL - Disable Autostop option. All Monte Carlo Simulations as specified by NSIM are
                  performed (default).

        accmean
            Accuracy of the mean values of all random output parameters that
            must be met for the Autostop option. Default is 0.01 (1%). ACCMEAN
            is ignored for Astop = ALL. The convergence of the mean values is
            met if for all random output parameters y the equation holds:

        accstdev
            Accuracy of the standard deviations of all random output parameters
            that must be met for the Autostop option. The default is 0.02 (2%).
            ACCSTDEV is ignored for Astop = ALL. The convergence for the
            standard deviations is met if for all random output parameters y
            the equation holds:

        check
            Sets how often conditions for convergence are checked for Autostop.
            The PDS checks if the convergence criteria are met every i-th loop,
            where i is given by the CHECK parameter. The default value is 10.
            It is not recommended to use CHECK = 1, because it could cause
            Autostop to terminate the simulations prematurely. The mean values
            and standard deviation might not show large differences between
            consecutive simulation loops but might still have a visible
            "global" trend if viewed over several simulations. This behavior
            indicates that convergence has not really been achieved. If you set
            CHECK = 1 (or another small number), then Autostop is not able to
            detect such a global trend. CHECK is ignored for Astop = ALL.

        seed
            Seed value label. Random number generators require a seed value
            that is used to calculate the next random number. After each random
            number generation finishes, the seed value is updated and is used
            again to calculate the next random number. ANSYS initializes the
            seed value with the system time when the ANSYS session started.

            CONT - Continues updating using the derived seed value (default).

            TIME - Initializes the seed value with the system time. You can use this if you want
                   the seed value set to a specific value for one analysis and
                   then you want to continue with a "random" seed in the next
                   analysis. It is not recommended to "randomize" the seed
                   value with the Seed = TIME option for multiple analyses. If
                   the Monte Carlo simulations requested with this command will
                   be appended to previously existing simulations, then the
                   Seed option is ignored and Seed = CONT is used.

            INIT - Initializes the seed value using 123457 (a typical recommendation). This option
                   leads to identical random numbers for all random input
                   variables when the exact analysis will be repeated, making
                   it useful for benchmarking and validation purposes (where
                   identical random numbers are desired). If the Monte Carlo
                   simulations requested with this command will be appended to
                   previously existing simulations, then the Seed option is
                   ignored and Seed = CONT is used.

            Value - Uses the specified (positive) value for the initialization of the seed value.
                    This option has the same effect as Seed = INIT, except you
                    can chose an arbitrary (positive) number for the
                    initialization. If the Monte Carlo simulations requested
                    with this command will be appended to previously existing
                    simulations, then the Seed option is ignored and Seed =
                    CONT is used.

        Notes
        -----
        Defines the number of simulations, the specification of the Autostop
        option, how frequently the Autostop option is checked and the seed
        value for random number generation. If the Autostop option is enabled,
        then the number of simulations given for NSIM can be regarded as the
        maximum number of simulations to be performed. The Autostop option may
        terminate the simulations before NSIM simulations are done if the
        convergence criteria are met.
        """
        command = "PDDMCS,%s,%s,%s,%s,%s,%s" % (str(nsim), str(_astop), str(accmean), str(accstdev), str(check), str(seed))
        return self.run(command, **kwargs)

    def ascres(self, opt="", **kwargs):
        """APDL Command: ASCRES

        Specifies the output type for an acoustic scattering analysis.

        Parameters
        ----------
        opt
            Output option:

            TOTAL - Output the total pressure field (default).

            SCAT - Output the scattered pressure field.

        Notes
        -----
        Use the ASCRES command to specify the output type for an acoustic
        scattering analysis.

        The scattered option (Opt = SCAT) provides a scattered pressure output,
        psc, required for calculating target strength (TS).

        The default behavior (Opt = TOTAL) provides a sum of the incident and
        scattering fields, ptotal = pinc + psc.

        Issue the AWAVE command to define the incident pressure pinc. If the
        AWAVE command is defined with Opt2 = INT, only the total pressure field
        is output regardless of the ASCRES,Opt command.
        """
        command = "ASCRES,%s" % (str(opt))
        return self.run(command, **kwargs)

    def nldpost(self, label="", key="", fileid="", prefix="", **kwargs):
        """APDL Command: NLDPOST

        Gets element component information from nonlinear diagnostic files.

        Parameters
        ----------
        label
            Specifies the type of command operation:

            EFLG - Element flag for nonlinear diagnostics.

            NRRE - Newton-Raphson residuals.

        key
            Specifies the command action:

            STAT - List information about the diagnostic files (Jobname.ndxxx or Jobname.nrxxx) in
                   the current directory.

            For Label = EFLG, the listing gives a summary that associates the loadstep, substep, time, equilibrium iteration number, cumulative iteration number, and the number of elements that fail each criteria with a specific file ID (Jobname.ndxxx). Use the list to create element components (via the CM option) based on the cumulative iteration number. - For Label = NRRE, the listing provides a summary that associates the loadstep,
                              substep, time, equilibrium iteration number, and
                              cumulative iteration number with a specific file
                              ID (Jobname.nrxxx).  Use the list to identify the
                              respective file ID for creating Newton-Raphson
                              residual contour plots (PLNSOL,NRRE,…,FileID).

            DEL - Delete Jobname.ndxxx or Jobname.nrxxx files in the working directory, if any
                  exist.

            CM - Create components for elements that violate criteria. This value is valid only
                 when Label = EFLG.

        fileid
            Valid only when Label = EFLG and Key = CM, this value specifies
            file IDs:

            IDnum - The file ID number. Creates the element components from the diagnostic files
                    corresponding to the specified file ID number in the
                    working directory.

            ALL - Creates element components from all available diagnostic files residing in the
                  working directory. This value is the default if you do not
                  specify an IDnum value.

        prefix
            Sets the prefix name for components. Specify up to 21 alphanumeric
            characters.

        Notes
        -----
        Based on the nonlinear diagnostic results (created via the NLDIAG,EFLG
        command), the NLDPOST command creates element components with
        predefined names.

        The following table lists the diagnostic criteria and component names
        (with specified prefix and without). Here xxx corresponds to the file
        ID (FileID) of Jobname.ndxxx or Jobname.nrxxx.

        If you have trouble viewing specific element components, see Viewing
        Hidden Element Components in the Basic Analysis Guide.

        For more information, see Performing Nonlinear Diagnostics.
        """
        command = "NLDPOST,%s,%s,%s,%s" % (str(label), str(key), str(fileid), str(prefix))
        return self.run(command, **kwargs)

    def mfcmmand(self, fnumb="", fname="", ext="", **kwargs):
        """APDL Command: MFCMMAND

        Captures field solution options in a command file.

        Parameters
        ----------
        fnumb
            Field number specified by the MFELEM command.

        fname
            Command file name specified for the field number. Defaults to field
            "FNUMB".

        ext
            Extension for Fname. Defaults to .cmd.

        Notes
        -----
        All relevant solution option commands for the specified field are
        written to a file with the extension .cmd. Refer to the commands in the
        following tables in the Command Reference: Analysis Options, Nonlinear
        Options, Dynamic Options, and Load Step Options.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFCMMAND,%s,%s,%s" % (str(fnumb), str(fname), str(ext))
        return self.run(command, **kwargs)

    def psdwav(self, tblno="", vx="", vy="", vz="", **kwargs):
        """APDL Command: PSDWAV

        Defines a wave propagation excitation in a PSD analysis.

        Parameters
        ----------
        tblno
            Input PSD table number defined with PSDVAL command.

        vx
            Global Cartesian X-velocity of traveling wave.

        vy
            Global Cartesian Y-velocity of traveling wave.

        vz
            Global Cartesian Z-velocity of traveling wave.

        Notes
        -----
        Defines a traveling wave in a PSD analysis. This command is not
        available for a pressure PSD analysis.

        This command is also valid in PREP7.
        """
        command = "PSDWAV,%s,%s,%s,%s" % (str(tblno), str(vx), str(vy), str(vz))
        return self.run(command, **kwargs)

    def rstmac(self, file1="", lstep1="", sbstep1="", file2="", lstep2="",
               sbstep2="", tolern="", maclim="", cname="", keyprint="",
               unvscale="", keym_ass="", **kwargs):
        """APDL Command: RSTMAC

        Calculates modal assurance criterion (MAC) and matches nodal solutions
        from two results files or from one results file and one universal
        format file.

        Parameters
        ----------
        file1
            File name (32 characters maximum) corresponding to the first
            results file (.rst or .rstp file). If the file name does not
            contain the extension, it defaults to .rst.

        lstep1
            Load step number of the results to be read in File1.

            N  - Reads load step N. Defaults to 1.

        sbstep1
            Substep number of the results to be read in File1.

            N  - Reads substep N.

            All  - Reads all substeps. This value is the default.

        file2
            File name (32 characters maximum) corresponding to the second file
            (.rst, .rstp, or .unv file). If the file name does not contain the
            extension, it defaults to .rst.

        lstep2
            Load step number of the results to be read in File2.

            N  - Reads load step N. Defaults to 1.

        sbstep2
            Substep number of the results to be read in File2.

            N  - Reads substep N.

            All  - Reads all substeps. This value is the default.

        tolern
            Tolerance for nodes matching. If TolerN = -1, the nodes on File2
            are mapped into the selected elements of File1. If TolerN is
            positive, the selected nodes of File1 are matched to the nodes of
            File2. The default value is 0.01.

        maclim
            Smallest acceptable MAC value. Must be  0 and  1. The default value
            is 0.90.

        cname
            Name of the component from the first file (File1). The component
            must be based on nodes. If unspecified, all nodes are matched and
            used for MAC calculations. If a component name is specified, only
            nodes included in the specified component are used. Not applicable
            to node mapping (TolerN=-1).

        keyprint
            Printout options:

            0  - Printout matched solutions table. This value is the default.

            1  - Printout matched solutions table and full MAC table.

            2  - Printout matched solutions table, full MAC table and matched nodes table.

        unvscale
            Scaling of the nodal coordinates when File2 is a universal format
            file (.unv).

            Blank or 0  - No scaling (default).

            Non-zero value  - Scaling factor applied to the nodal coordinates.

        keymass
            Key to include the mass matrix diagonal in the calculations.

            ON  - Include the mass matrix diagonal. This is the default.

            OFF  - Do not include the mass matrix diagonal.

        Notes
        -----
        The RSTMAC command allows the comparison of the solutions from either:

        Two different results files

        One result file and one universal format file

        The modal assurance criterion (MAC) is used.

        The meshes read on File1 and File2 may be different. If TolerN>0, the
        nodes are matched. This is the default. If TolerN = -1, the nodes are
        mapped and the solutions are interpolated from File1.

        Units and coordinate systems must be the same for both models. When a
        universal format file is used, the nodal coordinates can be scaled
        using UNVscale.

        The corresponding database file (.db) for File1 must be resumed before
        running the command only if a component (Cname) is used or if the nodes
        are mapped (TolerN = -1).

        Results may be real or complex; however, if results from File1 have a
        different type from results in File2, only the real parts of the
        solutions are taken into account in MAC calculations. The analysis type
        can be arbitrary.

        Only structural degrees of freedom are considered. Degrees of freedom
        can vary between File1 and File2, but at least one common degree of
        freedom must exist.

        When node mapping and solution interpolation is performed (TolerN=-1),
        File1 must correspond to a model meshed in solid and/or shell elements.
        Other types of elements can be present but the node mapping is not
        performed for those elements. Interpolation is performed on UX, UY, and
        UZ degrees of freedom.

        The solutions read on the results files are not all written to the
        database, therefore, subsequent plotting or printing of solutions is
        not possible.  A SET command must be issued after the RSTMAC command to
        post-process each solution.

        RSTMAC comparison on cyclic symmetry analysis works only if the number
        of sectors on File1 and File2 are the same. Also comparison cannot be
        made between cyclic symmetry results and full 360 degree model results
        (File1 – cyclic solution, File2 – full 360 degree model solution).
        Comparing cyclic symmetry solutions written on selected set of node
        (OUTRES) is not supported.

        The modal assurance criterion values can be retrieved as parameters
        using the *GET command (Entity = RSTMAC).

        For more information and an example, see Comparing Nodal Solutions From
        Two Models (RSTMAC) in the Basic Analysis Guide.
        """
        command = "RSTMAC,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(file1), str(lstep1), str(sbstep1), str(file2), str(lstep2), str(sbstep2), str(tolern), str(maclim), str(cname), str(keyprint), str(unvscale), str(keym_ass))
        return self.run(command, **kwargs)

    def ksum(self, **kwargs):
        """APDL Command: KSUM

        Calculates and prints geometry statistics of the selected keypoints.

        Notes
        -----
        Calculates and prints geometry statistics (centroid location, moments
        of inertia, etc.) associated with the selected keypoints.  Geometry
        items are reported in the global Cartesian coordinate system.  A unit
        density is assumed, irrespective of any material associations [KATT,
        MAT].  Items calculated by KSUM and later retrieved by a *GET or *VGET
        command are valid only if the model is not modified after the KSUM
        command is issued.
        """
        command = "KSUM," % ()
        return self.run(command, **kwargs)

    def ndsurf(self, snode="", telem="", dimn="", **kwargs):
        """APDL Command: NDSURF

        Generates surface elements overlaid on the edge of existing elements
        and assigns the extra node as the closest fluid element node.

        Parameters
        ----------
        snode
            Component name for the surface nodes of the solid elements.

        telem
            Component name for the target fluid elements.

        dimn
            Model dimensionality:

            2 - 2-D model.

            3 - 3-D model.

        Notes
        -----
        This command macro is used to generate surface effect elements (SURF151
        or SURF152) overlaid on the surface of existing plane or solid elements
        and, based on proximity, to determine and assign the extra node
        (FLUID116) for each surface element. The active element type must be
        SURF151 or SURF152 with appropriate settings for KEYOPT(4), KEYOPT(5),
        KEYOPT(6), and KEYOPT(8).

        The surface nodes of the plane or solid elements must be grouped into a
        node component and the fluid elements must be grouped into an element
        component and named using the CM command.  The names must be enclosed
        in single quotes (e.g., 'NOD') when the NDSURF command is manually
        typed in.

        When using the GUI method, node and element components are created
        through the picking dialog boxes associated with this command.

        The macro is applicable for the SURF151, SURF152, and FLUID116 element
        types.
        """
        command = "NDSURF,%s,%s,%s" % (str(snode), str(telem), str(dimn))
        return self.run(command, **kwargs)

    def ddele(self, node="", lab="", nend="", ninc="", rkey="", **kwargs):
        """APDL Command: DDELE

        Deletes degree-of-freedom constraints.

        Parameters
        ----------
        node
            Node for which constraint is to be deleted.  If ALL, NEND and NINC
            are ignored and constraints for all selected nodes [NSEL] are
            deleted.  If NODE = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  A
            component name may also be substituted for NODE.

        lab
            Valid degree of freedom label.  If ALL, use all selected labels
            [DOFSEL].  Structural labels:  UX, UY, or UZ (displacements); ROTX,
            ROTY, or ROTZ (rotations); WARP (warping).  Thermal labels: TEMP,
            TBOT, TE2, TE3, . . ., TTOP (temperature).  Acoustic labels:  PRES
            (pressure); UX, UY, or UZ (displacements for FSI coupled elements).
            Electric label:  VOLT (voltage).  Magnetic labels:  MAG (scalar
            magnetic potential); AX, AY, or AZ (vector magnetic potentials).
            Diffusion label: CONC (concentration).

        nend, ninc
            Delete constraints from NODE to NEND (defaults to NODE) in steps of
            NINC (defaults to 1).

        rkey
            Ramping key:

            OFF  - Loads are step-removed (default).

            ON or FORCE  - Forces on the specified degrees of freedom (Lab) are ramped during the next
                           load step. The forces are ramped from the reaction
                           forces of the previous load step, regardless of
                           whether or not a constraint was present. If the
                           specified node(s) and degree(s) of freedom has a
                           force value currently defined, the force is ramped
                           from the reaction force value to the currently
                           applied force value. If no force is currently
                           applied, the force is ramped from the reaction force
                           value to zero.

        Notes
        -----
        Deleting a constraint is not the same as setting it to zero (which
        "fixes" the degree of freedom to a zero value).  Deleting a constraint
        has the same effect as deactivating, releasing, or setting the
        constraint "free."  The node and the degree of freedom label must be
        selected [NSEL, DOFSEL].

        This command is also valid in PREP7.
        """
        command = "DDELE,%s,%s,%s,%s,%s" % (str(node), str(lab), str(nend), str(ninc), str(rkey))
        return self.run(command, **kwargs)

    def nolist(self, **kwargs):
        """APDL Command: /NOLIST

        Suppresses the data input listing.

        Notes
        -----
        Printout is suppressed until a /GOLIST command is read or the end of
        the listing is encountered.

        This command is valid in any processor, but only within a batch run
        [/BATCH].
        """
        command = "/NOLIST," % ()
        return self.run(command, **kwargs)

    def thexpand(self, key="", **kwargs):
        """APDL Command: THEXPAND

        Enables or disables thermal loading

        Parameters
        ----------
        key
            Activation key:

            ON  - Thermal loading is included in the load vector (default).

            OFF - Thermal loading is not included in the load vector.

        Notes
        -----
        Temperatures applied in the analysis are used by default to evaluate
        material properties and contribute to the load vector if the
        temperature does not equal the reference temperature and a coefficient
        of thermal expansion is specified.

        Use THEXPAND,OFF to evaluate the material properties but not contribute
        to the load vector. This capability is particularly useful when
        performing a harmonic analysis where you do not want to include
        harmonically varying thermal loads. It is also useful in a modal
        analysis when computing a modal load vector but excluding the thermal
        load.

        This command is valid for all analysis types except linear perturbation
        modal and linear perturbation harmonic analyses. For these two linear
        perturbation analysis types, the program internally sets THEXPAND,OFF,
        and it cannot be set to ON by using this command (THEXPAND,ON is
        ignored).
        """
        command = "THEXPAND,%s" % (str(key))
        return self.run(command, **kwargs)

    def plf2d(self, ncont="", olay="", anum="", win="", **kwargs):
        """APDL Command: PLF2D

        Generates a contour line plot of equipotentials.

        Parameters
        ----------
        ncont
            Number of contour lines to display.  Issue in multiples of 9 (i.e.,
            9, 18, 27, etc.).  Default is 27 contour lines.

        olay
            Overlay:

            0 - Overlay edge outlines by material number.

            1 - Overlay edge outlines by real constant number.

        anum
            Highest material or real constant attribute number.  Command will
            cycle through ANUM element display overlays.  Defaults to 10.

        win
            Window number to which command applies.  Defaults to 1.

        Notes
        -----
        PLF2D invokes an ANSYS macro which plots equipotentials of the degree
        of freedom AZ.  These equipotential lines are parallel to flux lines
        and thus give a good representation of flux patterns.  In the
        axisymmetric case, the display is actually r*AZ where "r" is the node
        radius.  The macro overlays (OLAY) edge outlines by material number or
        real constant number (ANUM) and allows user control over the number of
        contour lines to display (NCONT).

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "PLF2D,%s,%s,%s,%s" % (str(ncont), str(olay), str(anum), str(win))
        return self.run(command, **kwargs)

    def nsle(self, type="", nodetype="", num="", **kwargs):
        """APDL Command: NSLE

        Selects those nodes attached to the selected elements.

        Parameters
        ----------
        type
            Label identifying the type of node select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        nodetype
            Label identifying type of nodes to consider when selecting:

            ALL - Select all nodes of the selected elements (default).

            ACTIVE - Select only the active nodes. An active node is a node that contributes DOFs to
                     the model.

            INACTIVE - Select only inactive  nodes (such as orientation or radiation).

            CORNER - Select only corner nodes.

            MID - Select only midside nodes.

            POS - Select nodes in position Num.

            FACE - Select nodes on face Num.

        num
            Position or face number for NodeType = POS or FACE.

        Notes
        -----
        NSLE selects NodeType nodes attached to the currently-selected set of
        elements. Only nodes on elements in the currently-selected element set
        can be selected.

        Note:: : When using degenerate hexahedral elements, NSLE, U,CORNER and
        NSLE,S,MID will not select the same set of nodes because some nodes
        appear as both corner and midside nodes.

        This command is valid in any processor.
        """
        command = "NSLE,%s,%s,%s" % (str(type), str(nodetype), str(num))
        return self.run(command, **kwargs)

    def dflab(self, dof="", displab="", forcelab="", **kwargs):
        """APDL Command: /DFLAB

        Changes degree-of-freedom labels for user custom elements.

        Parameters
        ----------
        dof
            Number between 1 and 32 indicating which degree of freedom is to
            have its labels changed. For a list of these quantities, see the
            degree-of-freedom table in the echprm.inc file. The first few
            quantities follow:

        displab
            New label (four-character maximum) for the displacement label. The
            prior label is no longer valid.

        forcelab
            New label (four-character maximum) for the force label for this
            degree of freedom. The prior label is no longer valid.

        Notes
        -----
        The /DFLAB command is rarely used. Use it if you are writing a custom
        element and want to use degrees of freedom that are not part of the
        standard element set.
        """
        command = "/DFLAB,%s,%s,%s" % (str(dof), str(displab), str(forcelab))
        return self.run(command, **kwargs)

    def sspa(self, a11="", a21="", a31="", a22="", a32="", a33="", t="",
             **kwargs):
        """APDL Command: SSPA

        Specifies a preintegrated membrane stiffness for shell sections.

        Parameters
        ----------
        a11, a21, a31, a22, a32, a33
            Membrane stiffness component (symmetric lower part of submatrix
            [A]).

        t
            Temperature.

        Notes
        -----
        The behavior of shell elements is governed by the generalized-
        stress/generalized-strain relationship of the form:

        The SSPA command, one of several preintegrated shell section commands,
        specifies the membrane stiffness quantity (submatrix [A]) for a
        preintegrated shell section. The section data defined is associated
        with the section most recently defined (via the SECTYPE command).

        Unspecified values default to zero.

        Related commands are SSPB, SSPD, SSPE, SSMT, SSBT, and SSPM.

        For complete information, see Using Preintegrated General Shell
        Sections.
        """
        command = "SSPA,%s,%s,%s,%s,%s,%s,%s" % (str(a11), str(a21), str(a31), str(a22), str(a32), str(a33), str(t))
        return self.run(command, **kwargs)

    def mshape(self, key="", dimension="", **kwargs):
        """APDL Command: MSHAPE

        For elements that support multiple shapes, specifies the element shape
        to be used for meshing.

        Parameters
        ----------
        key
            Key indicating the element shape to be used:

            0 - Mesh with quadrilateral-shaped elements when Dimension = 2-D mesh with
                hexahedral-shaped elements when Dimension = 3-D.

            1 - Mesh with triangle-shaped elements when Dimension = 2-D mesh with tetrahedral-
                shaped elements when Dimension = 3-D.

        dimension
            Specifies the dimension of the model to be meshed:

            2D - 2-D model (area mesh).

            3D - 3-D model (volume mesh).

        Notes
        -----
        If no value is specified for Dimension the value of KEY determines the
        element shape that will be used for both 2-D and 3-D meshing.  In other
        words, if you specify MSHAPE,0, quadrilateral-shaped and hexahedral-
        shaped elements will be used.  If you specify MSHAPE,1, triangle-shaped
        and tetrahedral-shaped elements will be used.

        The MSHAPE, MSHKEY, and MSHMID commands replace the functionality that
        was provided by the ESHAPE command in ANSYS 5.3 and earlier releases.

        This command is also valid for rezoning.
        """
        command = "MSHAPE,%s,%s" % (str(key), str(dimension))
        return self.run(command, **kwargs)

    def emagerr(self, **kwargs):
        """APDL Command: EMAGERR

        Calculates the relative error in an electrostatic or electromagnetic
        field analysis.

        Notes
        -----
        The relative error is an approximation of the mesh discretization error
        associated with a solution. It is based on the discrepancy between the
        unaveraged, element-nodal field values and the averaged, nodal field
        values. The calculation is valid within a material boundary and does
        not consider the error in continuity of fields across dissimilar
        materials.

        For electrostatics, the field values evaluated are the electric field
        strength (EFSUM) and the electric flux density (DSUM). A relative error
        norm of each is calculated on a per-element basis and stored in the
        element table [ETABLE] with the labels EF_ERR and D_ERR. Normalized
        error values EFN_ERR and DN_ERR are also calculated and stored in the
        element table. Corresponding quantities for electromagnetics are H_ERR,
        B_ERR, HN_ERR, and BN_ERR, which are calculated from the magnetic field
        intensity (HSUM) and the magnetic flux density (BSUM).  The normalized
        error value is the relative error norm value divided by the peak
        element-nodal field value for the currently selected elements.

        Use the PLETAB and PRETAB commands to plot and list the error norms and
        normalized error values.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EMAGERR," % ()
        return self.run(command, **kwargs)

    def iclist(self, node1="", node2="", ninc="", lab="", **kwargs):
        """APDL Command: ICLIST

        Lists the initial conditions.

        Parameters
        ----------
        node1, node2, ninc
            List initial conditions for nodes NODE1 to NODE2 (defaults to
            NODE1) in steps of NINC (defaults to 1).  If NODE1 = ALL (default),
            NODE2 and NINC are ignored and initial conditions for all selected
            nodes [NSEL] are listed.  If NODE1 = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may be substituted for NODE1 (NODE2 and
            NINC are ignored).

        lab
            Velocity key:

            DISP - Specification is for first order degree of freedom value (displacements,
                   temperature, etc.) (default).

            VELO - Specification is for second order degree of freedom value (velocities).

        Notes
        -----
        Lists the initial conditions specified by the IC command.  Listing
        applies to all the selected nodes [NSEL] and DOF labels.  ICLIST is not
        the same as the DLIST command.  All the initial conditions including
        the default conditions are listed for the selected nodes.

        This command is valid in any processor.
        """
        command = "ICLIST,%s,%s,%s,%s" % (str(node1), str(node2), str(ninc), str(lab))
        return self.run(command, **kwargs)

    def plesol(self, item="", comp="", kund="", fact="", **kwargs):
        """APDL Command: PLESOL

        Displays the solution results as discontinuous element contours.

        Parameters
        ----------
        item
            Label identifying the item.  Valid item labels are shown in
            Table 219: PLESOL - Valid Item and Component Labels for Element
            Results below.  Some items also require a component label.

        comp
            Component of the item (if required).  Valid component labels are
            shown in Table 219: PLESOL - Valid Item and Component Labels for
            Element Results below.

        kund
            Undisplaced shape key:

            0 - Do not overlay undeformed structure display

            1 - Overlay displaced contour plot with undeformed display (appearance is system-
                dependent)

            2 - Overlay displaced contour plot  with undeformed edge display (appearance is
                system-dependent)

        fact
            Scale factor for 2-D display of contact items (defaults to 1). A
            negative scaling factor may be used to invert the display.

        Notes
        -----
        Displays the solution results as element contours discontinuous across
        element boundaries for the selected elements.  For example, PLESOL,S,X
        displays the X component of stress S (that is, the SX stress
        component).  Various element results depend on the calculation method
        and the selected results location (AVPRIN, RSYS, and ESEL).  Contours
        are determined by linear interpolation within each element, unaffected
        by the surrounding elements (i.e., no nodal averaging is performed).
        The discontinuity between contours of adjacent elements is an
        indication of the gradient across elements.  Component results are
        displayed in the active results coordinate system [RSYS] (default is
        the global Cartesian).  See the ETABLE and PLETAB commands for
        displaying items not available through this command (such as line
        element results).

        For PowerGraphics displays [/GRAPHICS,POWER], results are plotted only
        for the model exterior surface.  The items marked with [1] in Table:
        219:: PLESOL - Valid Item and Component Labels for Element Results are
        not supported by PowerGraphics.

        Table: 219:: : PLESOL - Valid Item and Component Labels for Element
        Results
        """
        command = "PLESOL,%s,%s,%s,%s" % (str(item), str(comp), str(kund), str(fact))
        return self.run(command, **kwargs)

    def fesurf(self, **kwargs):
        """APDL Command: FESURF

        Specifies "Surface loads on elements" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "FESURF," % ()
        return self.run(command, **kwargs)

    def btol(self, ptol="", **kwargs):
        """APDL Command: BTOL

        Specifies the Boolean operation tolerances.

        Parameters
        ----------
        ptol
            Point coincidence tolerance.  Points within this distance to each
            other will be assumed to be coincident during Boolean operations.
            Loosening the tolerance will increase the run time and storage
            requirements, but will allow more Boolean intersections to succeed.
            Defaults to 0.10E-4.

        Notes
        -----
        Use BTOL,DEFA to reset the setting to its default value.  Use BTOL,STAT
        to list the status of the present setting.
        """
        command = "BTOL,%s" % (str(ptol))
        return self.run(command, **kwargs)

    def pri2(self, p51x="", z1="", z2="", **kwargs):
        """APDL Command: PRI2

        Creates a polygonal area or a prism volume by vertices (GUI).

        Notes
        -----
        Creates a polygonal area or a prism volume using the vertices as input.
        This is a command generated by the Graphical User Interface (GUI) and
        will appear in the log file (Jobname.LOG) if graphical picking is used.
        This command is not intended to be typed in directly in an ANSYS
        session (although it can be included in an input file for batch input
        or for use with the /INPUT command).

        For polygons, the PRI2 command will appear in the log file as
        PRI2,P51X,0.0,0.0 preceded by FITEM commands that define the vertices
        (in global Cartesian coordinates).  For prisms, the PRI2 command will
        appear in the log file as PRI2,P51X preceded by FITEM commands that
        define the vertices and the Z-end of the prism.

        See the RPOLY, POLY, RPRISM, PRISM, and RPR4 commands for other ways to
        create polygons and prisms.
        """
        command = "PRI2,%s,%s,%s" % (str(p51x), str(z1), str(z2))
        return self.run(command, **kwargs)

    def vsba(self, nv="", na="", sepo="", keepv="", keepa="", **kwargs):
        """APDL Command: VSBA

        Subtracts areas from volumes.

        Parameters
        ----------
        nv
            Volume (or volumes, if picking is used) to be subtracted from.  If
            ALL, use all selected volumes.  If P, graphical picking is enabled
            (valid only in the GUI) and remaining fields are ignored.  A
            component name may also be substituted for NV.

        na
            Area (or areas, if picking is used) to subtract.  If ALL, use all
            selected areas.  A component name may also be substituted for NA.

        sepo
            Behavior of the touching boundary:

            (blank) - The resulting volumes will share area(s) where they touch.

            SEPO - The resulting volumes will have separate, but coincident area(s) where they
                   touch.

        keepv
            Specifies whether NV volumes are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NV volumes after VSBA operation (override BOPTN command settings).

            KEEP - Keep NV volumes after VSBA operation (override BOPTN command settings).

        keepa
            Specifies whether NA areas are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NA areas after VSBA operation (override BOPTN command settings).

            KEEP - Keep NA areas after VSBA operation (override BOPTN command settings).

        Notes
        -----
        Generates new volumes by subtracting the regions common to both the
        volumes and areas (the intersection) from the NV volumes.  The
        intersection will be an area(s).  If SEPO is blank, the volume is
        divided at the area and the resulting volumes will be connected,
        sharing a common area where they touch.  If SEPO is set to SEPO, the
        volume is divided into two unconnected volumes with separate areas
        where they touch.  See the Modeling and Meshing Guide for an
        illustration.  See the BOPTN command for an explanation of the options
        available to Boolean operations.  Element attributes and solid model
        boundary conditions assigned to the original entities will not be
        transferred to the new entities generated.
        """
        command = "VSBA,%s,%s,%s,%s,%s" % (str(nv), str(na), str(sepo), str(keepv), str(keepa))
        return self.run(command, **kwargs)

    def vplot(self, nv1="", nv2="", ninc="", degen="", scale="", **kwargs):
        """APDL Command: VPLOT

        Displays the selected volumes.

        Parameters
        ----------
        nv1, nv2, ninc
            Display volumes from NV1 to NV2 (defaults to NV1) in steps of NINC
            (defaults to 1).  If NV1 = ALL (default), NV2 and NINC are ignored
            and all selected volumes [VSEL] are displayed.

        degen
            Degeneracy marker:

            (blank) - No degeneracy marker is used (default).

            DEGE - A red star is placed on keypoints at degeneracies (see the Modeling and Meshing
                   Guide).  Not available if /FACET,WIRE is set.

        scale
            Scale factor for the size of the degeneracy-marker star.  The scale
            is the size in window space (-1 to 1 in both directions) (defaults
            to .075).

        Notes
        -----
        Displays selected volumes.  (Only volumes having areas within the
        selected area set [ASEL] will be plotted.)  With PowerGraphics on
        [/GRAPHICS,POWER], VPLOT will display only the currently selected
        areas. This command is also a utility command, valid anywhere.  The
        degree of tessellation used to plot the volumes is set through the
        /FACET command.
        """
        command = "VPLOT,%s,%s,%s,%s,%s" % (str(nv1), str(nv2), str(ninc), str(degen), str(scale))
        return self.run(command, **kwargs)

    def rmdir(self, dir="", **kwargs):
        """APDL Command: /RMDIR

        Removes (deletes) a directory.

        Parameters
        ----------
        dir
            The directory to remove. If no path is provided, it will be assumed
            to be in the current working directory. All files in the directory
            are also removed.

        Notes
        -----
        Removes a directory on the computer ANSYS is currently running on. No
        warning or prompt is given, so use with extreme caution.
        """
        command = "/RMDIR,%s" % (str(dir))
        return self.run(command, **kwargs)

    def jpeg(self, kywrd="", opt="", **kwargs):
        """APDL Command: JPEG

        Provides JPEG file export for ANSYS displays.

        Parameters
        ----------
        kywrd
            Specifies various JPEG file export options.

            QUAL - If Kywrd = QUAL, then OPT is an integer value defining the JPEG quality index
                   on an arbitrary scale ranging from 1 to 100. The default
                   value is 75.

            ORIENT - If Kywrd = ORIENT, then OPT will determine the orientation of the entire plot.
                     OPT can be either Horizontal (default) or Vertical.

            COLOR - If Kywrd = COLOR, then OPT will determine the color depth of the saved file.
                    OPT can be 0, 1, or 2, corresponding to Black and White,
                    Grayscale, and Color (default), respectively.

            TMOD - If Kywrd = TMOD, then OPT will determine the text method. OPT can be either 1
                   or 0, corresponding to bitmap text (default) or line stroke
                   text, respectively.

            DEFAULT - If Kywrd = DEFAULT, then all of the default values, for all of the Kywrd
                      parameters listed above, are active.

        opt
            OPT can have the following names or values, depending on the value
            for Kywrd (see above).

            1 to 100 - If Kywrd = QUAL, a value between 1 and 100 will determine the quality index of
                       the JPEG file.

            Horizontal, Vertical - If Kywrd = ORIENT, the terms Horizontal or Vertical determine the orientation
                              of the plot.

            0,1,2 - If Kywrd = COLOR, the numbers 0, 1, and 2 correspond to Black and White,
                    Grayscale and Color, respectively.

            1,0 - If Kywrd = TMOD, the values 1 and 0 determine whether bitmap (1) or stroke text
                  (0) fonts will be used
        """
        command = "JPEG,%s,%s" % (str(kywrd), str(opt))
        return self.run(command, **kwargs)

    def laylist(self, iel="", layr1="", layr2="", mplab1="", mplab2="",
                **kwargs):
        """APDL Command: LAYLIST

        Lists real constants material properties for layered elements.

        Parameters
        ----------
        iel
            Element number to be listed.  If ALL, list all selected elements
            [ESEL] of the appropriate type.  If blank and the current element
            type is a layered element type, list data from the current real
            constant table in the layered format.

        layr1, layr2
            Range of layer numbers to be listed.  If LAYR1 is greater than
            LAYR2, a reverse order list is produced.  LAYR1 defaults to 1.
            LAYR2 defaults to LAYR1 if LAYR1 is input or to the number of
            layers if LAYR1 is not input.

        mplab1, mplab2
            Material property labels (e.g., EX) to be listed along with the
            layer real constants.

        Notes
        -----
        Lists real constants and any two material properties for layered shell
        and solid elements.

        If matrix input is selected (KEYOPT(2) = 2 or 3), LAYR1, LAYR2, Mplab1,
        and Mplab2 are not used.

        This command is valid in any processor.
        """
        command = "LAYLIST,%s,%s,%s,%s,%s" % (str(iel), str(layr1), str(layr2), str(mplab1), str(mplab2))
        return self.run(command, **kwargs)

    def gp(self, node1="", node2="", lab="", stif="", gap="", damp="",
           **kwargs):
        """APDL Command: GP

        Defines a gap condition for transient analyses.

        Parameters
        ----------
        node1
            Node I of gap.  If NODE1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).

        node2
            Node J of gap (must be different from NODE1).  Non-grounded gap
            nodes must be defined as master degrees of freedom or be
            unconstrained, active DOF in a full analysis type.  Grounded gap
            nodes (those not defined as MDOF) need not appear elsewhere in the
            model.

        lab
            Direction of gap action in the nodal coordinate system (implied
            from the following force labels): FX, FY, FZ, MX, MY, MZ.

        stif
            Stiffness (Force/Length) of closed gap (may be positive or
            negative).

        gap
            Initial size of gap.  A zero (or positive) value assumes an
            initially open gap.  A negative value defines an interference
            condition.  For a rotational gap, GAP should be in radians.

        damp
            Damping coefficient (Force*Time/Length) of closed gap using pseudo
            velocity (Newmark finite difference expansion scheme).

        Notes
        -----
        Defines a gap condition for the mode superposition transient analysis
        (ANTYPE,TRANS with TRNOPT,MSUP). If used in SOLUTION, this command is
        valid only within the first load step. Gap conditions specified in
        subsequent load steps are ignored.

        Repeat GP command for additional gap conditions. Gaps are numbered
        sequentially as input.

        Note:: : Gaps may be renumbered by the program during the solution (see
        output listing)

        The mode-superposition transient analysis does not allow gap action
        with the standard gap elements. However, you can define gap conditions
        which are similar to gap elements; gap conditions can be specified
        between surfaces that are expected to contact (impact) each other
        during the transient. The gap condition simulates the basic gap action
        of the COMBIN40 element.

        The gap condition is treated as an explicit force (equal to the
        interference times contact stiffness) and affects only the load vector
        calculation and not the stiffness matrix. The interference is
        calculated from the displacement extrapolated from the previous time
        points.

        Gap conditions can only be defined between two master degree of freedom
        (DOF) nodes or between master DOF nodes and ground, as shown in the
        following figure.

        Master degrees of freedom are the unconstrained and active degrees of
        freedom. Gap nodes not defined as active degrees of freedom or attached
        to an element are assumed to be grounded. Grounded gap nodes do not
        need a spatial location, nor do they need to be located on an element.

        Gap conditions may be defined in parallel (across the same nodes), with
        varying gap and stiffness values, to simulate a nonlinear (piecewise)
        force-deflection curve.

        The gap direction is determined from the force label input on the GP
        command; i.e., FX defines a translational gap acting in the UX nodal
        degree of freedom direction, and MZ defines a rotational gap acting in
        the nodal ROTZ degree of freedom direction. The actual degree of
        freedom directions available for a particular node depends upon the
        degrees of freedom associated with the element types [ET] at that node.

        If the coordinate systems of the nodes connecting the gap are rotated
        relative to each other, the same degree of freedom may be in different
        directions. The gap, however, assumes only a one-dimensional action.
        Nodes I and J may be anywhere in space (preferably coincident).  No
        moment effects are included due to noncoincident nodes. That is, if the
        nodes are offset from the line of action, moment equilibrium may not be
        satisfied.

        The contact stiffness value represents the stiffness of the closed gap.
        Stiffness values are related to the integration time step size and
        should be physically reasonable. High stiffness will require a small
        integration time step; otherwise, due to the displacement
        extrapolation, the solution may go unstable. Negative stiffness values
        may be used with gaps in parallel to produce a decreasing force-
        deflection curve.

        The order of specifying the gap nodes is important; i.e., a gap
        condition connecting two nodes will act differently depending upon
        which node is specified first on the GP command.  For example, for Node
        1 at X = 0.0, Node 2 at X = 0.1, and the gap defined from Node 1 to 2,
        a displacement of Node 1 greater than Node 2 will cause the gap to
        close.  For the gap defined from Node 2 to 1, a displacement of Node 2
        greater than Node 1 will cause the gap to close (like a hook action).
        In general, the gap closes whenever the separation (defined as UJ - UI
        + GAP) is negative.  UJ is the displacement of node J, UI is the
        displacement of node I, and GAP is the input gap value.  The gap force
        output appears in the printout only for the time steps for which the
        gap is closed.  A negative spring force is always associated with a
        closed gap (even with the hook option).

        Some guidelines to define gap conditions are presented below:

        Use enough gap conditions to obtain a smooth contact stress
        distribution between the contacting surfaces.

        Define a reasonable gap stiffness. If the stiffness is too low, the
        contacting surfaces may overlap too much. If the stiffness is too high,
        a very small time step will be required during impact. A general
        recommendation is to specify a gap stiffness that is one or two orders
        of magnitude higher than the adjacent element stiffness. You can
        estimate the adjacent element stiffness using AE/L, where A is the
        contributing area around the gap condition, E is the elastic modulus of
        the softer material at the interface, and L is the depth of the first
        layer of elements at the interface.

        A mode-superposition transient using the nonlinear gap damping provided
        through the DAMP field runs faster than a full transient analysis using
        a gap element (COMBIN40).

        Use the GPLIST command to list gap conditions and the GPDELE command to
        delete gap conditions.

        This command is also valid in PREP7.
        """
        command = "GP,%s,%s,%s,%s,%s,%s" % (str(node1), str(node2), str(lab), str(stif), str(gap), str(damp))
        return self.run(command, **kwargs)

    def adapt(self, nsoln="", stargt="", ttargt="", facmn="", facmx="",
              kykps="", kymac="", **kwargs):
        """APDL Command: ADAPT

        Adaptively meshes and solves a model.

        Parameters
        ----------
        nsoln
            Number of solutions allowed (1 or more) (defaults to 5).

        stargt
            Target percentage for structural percent error in energy norm
            (SEPC) (defaults to 5).  If -1, no target value is used.

        ttargt
            Target percentage for thermal percent error in energy norm (TEPC)
            (defaults to 1).  If -1, no target value is used.

        facmn
            Minimum factor for the keypoint element size changes (defaults to
            0.25).

        facmx
            Maximum factor for the keypoint element size changes (defaults to
            2.0).

        kykps
            Specifies whether element size is to be modified at selected
            keypoints:

            0 - Modify element size regardless of selected keypoint set (default).

            1 - Modify element size only at selected keypoints.

        kymac
            Specifies which user-written auxiliary macro files are to be used:

            0 - Ignore user-written auxiliary macro files, if any (default).

            1 - Use user-written auxiliary macro files (if they exist) as follows:  Use
                ADAPTMSH.MAC instead of the default meshing command sequence.
                Use ADAPTSOL.MAC instead of the default solution command
                sequence (/SOLU ... SOLVE ... FINISH).

        Notes
        -----
        ADAPT invokes a predefined ANSYS macro for adaptive meshing and
        solution.  The macro causes repeated runs of the PREP7, SOLUTION, and
        POST1 phases of the ANSYS program with mesh density refinements based
        upon the percentage error in energy norm.  See the Advanced Analysis
        Guide for additional details.   After the adaptive meshing process is
        complete, the ADAPT macro automatically turns element shape checking on
        (SHPP,ON).

        A copy of the macro, called UADAPT.MAC, is available on the ANSYS
        distribution medium (system dependent), and may be copied and modified
        by the user to suit a particular need.  The modified file should be
        given a suitable name (cmd.MAC) and run as described above with the
        ADAPT command name replaced by your "cmd" name.

        This command is also valid at the Begin level.
        """
        command = "ADAPT,%s,%s,%s,%s,%s,%s,%s" % (str(nsoln), str(stargt), str(ttargt), str(facmn), str(facmx), str(kykps), str(kymac))
        return self.run(command, **kwargs)

    def lgwrite(self, fname="", ext="", kedit="", **kwargs):
        """APDL Command: LGWRITE

        Writes the database command log to a file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        kedit
            Flag to suppress nonessential commands:

            NONE - Do not suppress any commands (default).

            COMMENT - Write nonessential commands as comments (starting with !).

            REMOVE - Do not write nonessential commands or comments.

        Notes
        -----
        Writes the database command log to a named file.  The database command
        log contains all commands that were used to create the current
        database.  These commands are recorded in the database as they are
        issued, and saved in the database file (File.DB) whenever the database
        is saved.  The LGWRITE command extracts these commands from the
        database and writes them to a file.  Nonessential commands (for
        listing, graphics displays, help, etc.) can be excluded from the file
        by using the Kedit field.  The file resulting from LGWRITE can be used
        as command input to the program.  This command is most useful if the
        session log file (File.LOG), which is normally saved during an
        interactive session, has been lost or corrupted.

        This command is valid in any processor.
        """
        command = "LGWRITE,%s,%s,%s" % (str(fname), str(ext), str(kedit))
        return self.run(command, **kwargs)

    def ainv(self, na="", nv="", **kwargs):
        """APDL Command: AINV

        Finds the intersection of an area with a volume.

        Parameters
        ----------
        na
            Number of area to be intersected.  If P, graphical picking is
            enabled and all remaining arguments are ignored (valid only in the
            GUI).

        nv
            Number of volume to be intersected.

        Notes
        -----
        New areas will be generated where the areas intersect the volumes.  If
        the regions of intersection are only lines, new lines will be generated
        instead.  See the Modeling and Meshing Guide for an illustration.  See
        the BOPTN command for the options available to Boolean operations.
        Element attributes and solid model boundary conditions assigned to the
        original entities will not be transferred to the new entities
        generated.
        """
        command = "AINV,%s,%s" % (str(na), str(nv))
        return self.run(command, **kwargs)

    def lsum(self, **kwargs):
        """APDL Command: LSUM

        Calculates and prints geometry statistics of the selected lines.

        Notes
        -----
        Calculates and prints geometry statistics (length, centroid, moments of
        inertia, etc.) associated with the selected lines.  Geometry items are
        reported in the global Cartesian coordinate system.  A unit density is
        assumed, irrespective of any material associations [LATT, MAT].  Items
        calculated by LSUM and later retrieved by a *GET or *VGET command are
        valid only if the model is not modified after the LSUM command is
        issued.
        """
        command = "LSUM," % ()
        return self.run(command, **kwargs)

    def eextrude(self, action="", nelem="", space="", dist="", theta="",
                 tfact="", **kwargs):
        """APDL Command: EEXTRUDE

        Extrudes 2-D plane elements into 3-D solids.

        Parameters
        ----------
        action
            Specifies one of the following command behaviors:

            AUTO - Extrudes plane elements (PLANE182 and PLANE183) based on the KEYOPT(3) setting.
                   Complementary elements are also extruded. (See Notes for
                   more information.) This behavior is the default.

            PLANE - Extrudes elements in the global Z direction. KEYOPT(3) of the parent elements
                    is ignored.

            AXIS - Extrudes elements about the global Y axis. KEYOPT(3) of the parent elements is
                   ignored.

            TANGENT - Similar to Action = AXIS, except that target elements are extruded in the
                      global Z direction.

        nelem
            Number of elements to generate in the extruded direction. If you do
            not specify a number, the program calculates a number automatically
            based on the average element size and extrusion distance.

        space
            Spacing ratio. If positive, this value is the nominal ratio of the
            last division size to the first division size (if > 1.0, sizes
            increase, if < 1.0, sizes decrease). If negative, |SPACE| is the
            nominal ratio of the center division size to the end division size.
            The default value is 1.0 (uniform spacing).

        dist
            Distance to extrude in the global Z direction for the plane strain
            case (Action = PLANE). The default is 1.

        theta
            Ending angle (in degrees) to extrude about the global Y axis for
            the axisymmetric case (Action = AXIS). The beginning angle is
            always 0 degrees. The ending angle defaults to 360 degrees.

        tfact
            Factor for increasing the rigid target size. The size of the
            extruded rigid target elements is determined automatically based on
            the size of the contact elements. The default value is 0.2.

        Notes
        -----
        The EEXTRUDE command extrudes current-technology elements PLANE182 and
        PLANE183. Complementary elements TARGE169, CONTA171, CONTA172, and
        REINF263 will also extrude. Extrusion operates automatically on
        elements in the selected element set.

        For automatic PLANE182 and PLANE183 extrusion (Action = AUTO), based on
        the element behavior of the plane elements, the command performs as
        follows:

        Plane stress; the element is ignored.

        Axisymmetric; the element is extruded 360 degrees about the Y-axis.
        THETA is ignored.

        Plane strain (Z strain = 0.0); the element is extruded a unit distance
        in the global Z direction.

        Plane stress with thickness input; the element is extruded in the
        Z-direction as specified by the thickness input via a real constant.

        Generalized plane strain; the element is ignored.

        For an axisymmetric extrusion (Action = AUTO with KEYOPT(3) = 1, Action
        = AXIS, or Action = TANGENT), the command merges any nodes within the
        specified tolerance (SELTOL,TOLER) of the axis into a single node, then
        forms degenerate tetrahedrons, pyramids, or wedges. The default
        tolerance value is 1.0E-6.

        When issuing the EEXTRUDE command within the MAP2DTO3D environment
        using KEYOPT(3) = 3, mapping results do not provide the correct 3-D
        results state; therefore, KEYOPT(3) = 3 is suggested only as a tool for
        extruding the mesh itself as a geometric feature.

        For an axisymmetric extrusion, SHELL208 and SHELL209 will extrude.

        You can control shape-checking options via the SHPP command.

        The extrusion behavior of accompanying contact (CONTA171 and CONTA172)
        is determined by the plane element settings. Rigid target (TARGE169)
        elements are extruded in the global Z direction unless axisymmetric
        extrusion (Action = AXIS) is in effect.

        The following table shows each 2-D element capable of extrusion and its
        corresponding post-extrusion 3-D element:

        All element properties are also transferred consistently during
        extrusion. For example, a  2-D element is extruded to a  3-D element,
        and a mixed u-P 2-D element is extruded to a mixed u-P 3-D element.
        """
        command = "EEXTRUDE,%s,%s,%s,%s,%s,%s" % (str(action), str(nelem), str(space), str(dist), str(theta), str(tfact))
        return self.run(command, **kwargs)

    def rose(self, signif="", label="", td="", forcetype="", **kwargs):
        """APDL Command: ROSE

        Specifies the Rosenblueth mode combination method.

        Parameters
        ----------
        signif
            Combine only those modes whose significance level exceeds the
            SIGNIF threshold. For single point, multipoint, or DDAM response
            (SPOPT, SPRS, MPRS, or DDAM), the significance level of a mode is
            defined as the mode coefficient of the mode, divided by the maximum
            mode coefficient of all modes. Any mode whose significance level is
            less than SIGNIF is considered insignificant and does not
            contribute to the mode combinations. The higher the SIGNIF
            threshold, the fewer the number of modes combined. SIGNIF defaults
            to 0.001. If SIGNIF is specified as 0.0, it is taken as 0.0.

        label
            Label identifying the combined mode solution output.

            DISP - Displacement solution (default). Displacements, stresses, forces, etc., are
                   available.

            VELO - Velocity solution. Velocities, "stress velocities," "force velocities," etc.,
                   are available.

            ACEL - Acceleration solution. Accelerations, "stress accelerations," "force
                   accelerations," etc. are available.

        td
            Time duration for earthquake or shock spectrum. TD defaults to 10.

        forcetype
            Label identifying the forces to be combined:

            STATIC - Combine the modal static forces (default).

            TOTAL - Combine the modal static plus inertial forces.

        Notes
        -----
        For more information on spectrum analysis combination methods, see
        Combination of Modes

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "ROSE,%s,%s,%s,%s" % (str(signif), str(label), str(td), str(forcetype))
        return self.run(command, **kwargs)

    def arclen(self, key="", maxarc="", minarc="", **kwargs):
        """APDL Command: ARCLEN

        Activates the arc-length method.

        Parameters
        ----------
        key
            Arc-length key:

            OFF - Do not use the arc-length method (default).

            ON - Use the arc-length method.

        maxarc
            Maximum multiplier of the reference arc-length radius (default =
            25).

        minarc
            Minimum multiplier of the reference arc-length radius (default =
            1/1000).

        Notes
        -----
        Activates the arc-length method and sets the minimum and maximum
        multipliers for controlling the arc-length radius based on the initial
        arc-length radius.

        The initial arc-length radius, t0, is proportional (in absolute value)
        to the initial load factor. The initial load factor is given by:

        Initial Load Factor = TIME / NSBSTP

        where TIME is the time specified by the TIME command for the arc-length
        load step, and NSBSTP is the number of substeps specified by the NSUBST
        command.

        The factors MAXARC and MINARC are used to define the range for the arc-
        length radius to expand and shrink during the substep solution:

        In each substep, the arc-length radius is kept constant throughout the
        equilibrium iterations. After each converged substep, the arc-length
        radius for the next substep is modified depending on the convergence
        behavior. If the substep converges and the program heuristic predicts
        an easy convergence, the arc-length radius is enlarged. If the enlarged
        value is greater than tMAX, the arc-length radius is reset to tMAX. If
        the substep does not converge, bisection will take place until the arc-
        length radius is reduced to tMIN. If further nonconvergence is
        encountered, the solution terminates.

        The arc-length method predicts the next time increment (that is, load
        factor increment). Therefore, the AUTOTS and PRED commands are ignored
        when the arc-length method is used.

        The STABILIZE and LNSRCH commands are also ignored.

        The arc-length method cannot be used in a multiframe restart.

        For difficult problems, one suggestion is to increase the initial
        number of substeps (NSUBST), and to prevent the arc-length radius from
        increasing too rapidly (MAXARC = 1).

        ARCLEN cannot be used for any load step that has no applied load or
        displacement.

        The arc-length method does not support tabular loads. In order to use
        the arc-length method, you must replace tabular loads by other load
        types and then run the analysis again.
        """
        command = "ARCLEN,%s,%s,%s" % (str(key), str(maxarc), str(minarc))
        return self.run(command, **kwargs)

    def cmomega(self, cm_name="", omegax="", omegay="", omegaz="", x1="",
                y1="", z1="", x2="", y2="", z2="", **kwargs):
        """APDL Command: CMOMEGA

        Specifies the rotational velocity of an element component about a user-
        defined rotational axis.

        Parameters
        ----------
        cm_name
            The name of the element component.

        omegax, omegay, omegaz
            If the X2, Y2, Z2 fields are not defined, OMEGAX, OMEGAY, and
            OMEGAZ specify the components of the rotational velocity vector in
            the global Cartesian X, Y, Z directions.

        x1, y1, z1
            If the X2, Y2, Z2 fields are defined,X1, Y1, and Z1 define the
            coordinates of the beginning point of the rotational axis vector.
            Otherwise, X1, Y1, and Z1 are the coordinates of a point through
            which the rotational axis passes.

        x2, y2, z2
            The coordinates of the end point of the rotational axis vector.

        Notes
        -----
        Specifies the rotational velocity components OMEGAX, OMEGAY, and OMEGAZ
        of an element component CM_NAME about a user-defined rotational axis.
        The rotational axis can be defined either as a vector passing through a
        single point or a vector connecting two points.

        You can define rotational velocity and rotational axis for these
        analysis types:

        Static (ANTYPE,STATIC)

        Harmonic (ANTYPE,HARMIC) -- Full or modal superposition

        Transient (ANTYPE,TRANS)  -- Full or modal superposition

        Substructuring (ANTYPE,SUBSTR)

        Modal (ANTYPE,MODAL)

        Rotational velocities are combined with the element mass matrices to
        form a body force load vector term. Units are radians/time. Related
        commands are ACEL, CGLOC, CGLOC,  CGOMGA, CMDOMEGA, DCGOMG, DOMEGA.

        See Analysis Tools in the Mechanical APDL Theory Reference for more
        information.

        You can use the CMOMEGA command in conjunction with either one of the
        following two groups of commands, but not with both groups
        simultaneously:

        Components for which you want to specify rotational loading must
        consist of elements only. The elements you use cannot be part of more
        than one component, and elements that share nodes cannot exist in
        different element components. You cannot apply the loading to an
        assembly of element components.

        If you have applied the Coriolis effect (CORIOLIS) using a stationary
        reference frame, the CMOMEGA command takes the gyroscopic damping
        matrix into account for the elements listed under “Stationary Reference
        Frame” in the notes section of the CORIOLIS command. ANSYS verifies
        that the rotation vector axis is parallel to the axis of the element;
        if not, the gyroscopic effect is not applied. If you issue a CMOMEGA
        command when the Coriolis or gyroscopic effect is present, a
        subsequently issued OMEGA command has no effect.

        The CMOMEGA command supports tabular boundary conditions (%TABNAME_X%,
        %TABNAME_Y%, and %TABNAME_Z%) for CMOMEGA_X, CMOMEGA_Y, and CMOMEGA_Z
        input values (*DIM) for full transient and harmonic analyses.

        In a mode-superposition harmonic or transient analysis, you must apply
        the load in the modal portion of the analysis. Mechanical APDL
        calculates a load vector and writes it to the MODE file, which you can
        apply via the LVSCALE command.
        """
        command = "CMOMEGA,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(cm_name), str(omegax), str(omegay), str(omegaz), str(x1), str(y1), str(z1), str(x2), str(y2), str(z2))
        return self.run(command, **kwargs)

    def time(self, time="", **kwargs):
        """APDL Command: TIME

        Sets the time for a load step.

        Parameters
        ----------
        time
            Time at the end of the load step.

        Notes
        -----
        Associates the boundary conditions at the end of the load step with a
        particular TIME value.

        TIME must be a positive, nonzero, monotonically increasing quantity
        that "tracks" the input history.  Units of time should be consistent
        with those used elsewhere (for properties, creep equations, etc.).

        Typically, for the first load step TIME defaults to 1. However, for the
        first load step of a mode-superposition transient analysis
        (ANTYPE,TRANS and TRNOPT,MSUP), the TIME command is ignored and a
        static solution is performed at TIME = 0.

        For a full transient analyses, the command's default behavior does not
        apply. You must specify a time for each load step and it must be
        greater than the time at the end of the prior load step.

        TIME does not apply to modal (ANTYPE,MODAL), harmonic (ANTYPE,HARMIC),
        or substructure (ANTYPE,SUBSTR) analyses.

        This command is also valid in PREP7.
        """
        command = "TIME,%s" % (str(time))
        return self.run(command, **kwargs)

    def ssln(self, fact="", size="", **kwargs):
        """APDL Command: SSLN

        Selects and displays small lines in the model.

        Parameters
        ----------
        fact
            Factor used to determine small lines.  FACT times the average line
            length in the model is used as the line length limit below which
            lines will be selected.

        size
            Line length limit for line selection.  Lines that have a length
            less than or equal to SIZE will be selected.  Used only if FACT is
            blank.

        Notes
        -----
        SSLN invokes a predefined ANSYS macro for selecting small lines in a
        model.  Lines that are smaller than or equal to the specified limit
        (FACT or SIZE) are selected and line numbers are displayed.  This
        command macro is useful for detecting very small lines in a model that
        may cause problems (i.e., poorly shaped elements or a meshing failure)
        during meshing.  All lines that are not "small" will be unselected and
        can be reselected with the LSEL command.
        """
        command = "SSLN,%s,%s" % (str(fact), str(size))
        return self.run(command, **kwargs)

    def fluread(self, fname="", ext="", kdim="", kout="", limit="", listopt="",
                **kwargs):
        """APDL Command: FLUREAD

        Reads one-way Fluent-to-Mechanical APDL coupling data via a .cgns file
        with one-side fast Fourier transformation complex pressure peak value.

        Parameters
        ----------
        --
            Reserved.

        fname
            File name and directory path of a one-way Fluent-to-Mechanical APDL
            coupling data file (248 characters maximum, including the
            characters needed for the directory path). An unspecified directory
            path defaults to the working directory; in this case, you can use
            all 248 characters for the file name. Defaults to jobname.

        ext
            File name extension of the one-way Fluent-to-Mechanical APDL
            coupling data file. Defaults to .cgns).

        kdim
            Interpolation data for mapping. A value of 0 (default) or 2 applies
            2-D interpolation (where interpolation occurs on a surface).

        kout
            Outside region results for mapping:

            0 - Use the value(s) of the nearest region point for points outside of the region.
                This behavior is the default.

            1 - Set results extrapolated outside of the region to zero.

        limit
            Number of nearby nodes considered for mapping interpolation.
            Minimum = 5. Default = 20.

        listopt
            Type of items picked:

            (blank) - No listing (default).

            SOURCE - List the node coordinates and complex pressure values on the Fluent source side
                     during the solution.

            TARGET - List the node coordinates and complex pressure values on the mapped Mechanical
                     APDL target side during the solution.

            BOTH - List the node coordinates and complex pressure values on both the Fluent source
                   side and the mapped Mechanical APDL target side during the
                   solution.

        Notes
        -----
        The FLUREAD command reads one-way Fluent-to-Mechanical APDL coupling
        data from a .cgns file. The Fluent one-side fast Fourier transformation
        (FFT) peak complex pressure values are mapped to the Mechanical APDL
        structure model during the acoustic-structural solution at each FFT
        frequency.

        The command can be used only for the model with the acoustic elements.

        To apply complex pressure to the structure model, define the SURF154
        surface element, then define the one-way coupling interface (SF,,FSIN)
        on the element.

        You can define the solving frequency range via the HARFRQ command. The
        solver selects the FFT frequencies between the beginning and ending
        frequencies. The number of substeps is determined by the number of FFT
        frequencies over the frequency range. The number of substeps defined
        via the NSUBST command is overwritten.

        For better mapping performance, consider the following:

        Calculations for out-of-bound points require much more processing time
        than do points that are within bounds.

        For each point in the structural destination mesh, the command searches
        all possible triangles in the Fluent source mesh to find the best
        triangle containing each point, then performs a linear interpolation
        inside this triangle. For faster and more accurate results, consider
        your interpolation method and search criteria carefully. (See LIMIT.)

        It is possible to apply one-way coupling excitation to multiple
        frequencies. The one-side FFT peak complex pressure values are
        necessary to do so.
        """
        command = "FLUREAD,%s,%s,%s,%s,%s,%s" % (str(fname), str(ext), str(kdim), str(kout), str(limit), str(listopt))
        return self.run(command, **kwargs)

    def mfmap(self, lab1="", lab2="", filename="", opt="", **kwargs):
        """APDL Command: MFMAP

        Calculates, saves, resumes, or deletes mapping data in an ANSYS Multi-
        field solver analysis.

        Parameters
        ----------
        lab1
            Operation label:

            CALC  - Calculate mapping data and keep it in memory (default).

            SAVE  - Calculate mapping data, keep it in memory, and save it to a file. (If
                    MFMAP,CALC or MFMAP,RESU have been issued, just save it to
                    a file.)

            RESU  - Resume the mapping from a file and keep it in memory.

            DELE  - Free the mapping memory.

        lab2
            Applicable mapping label:

            ALL  - Surface and volumetric mapping.

            SURF  - Surface mapping only.

            VOLU  - Volumetric mapping only.

        filename
            The file name for a mapping data file (filename.sur for surface
            mapping and filename.vol for volumetric mapping). Defaults to
            Jobname. Applies to the commands MFMAP,SAVE and MFMAP,RESU only.

        opt
            File format:

            BINA  - Binary file (default).

            ASCI  - ASCII file.

        Notes
        -----
        This command calculates, saves, resumes, or deletes mapping data. It
        defaults to calculating the mapping data. If MFMAP has not been
        previously issued, the mapping data will be automatically calculated
        during the solution process. On the other hand, the ANSYS Multi-field
        solver will use previously created mapping data. Resumed mapping files
        must have load transfer specifications that are consistent with those
        of the current MFSURFACE and MFVOLUME commands and the ANSYS database.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFMAP,%s,%s,%s,%s" % (str(lab1), str(lab2), str(filename), str(opt))
        return self.run(command, **kwargs)

    def cpintf(self, lab="", toler="", **kwargs):
        """APDL Command: CPINTF

        Defines coupled degrees of freedom at an interface.

        Parameters
        ----------
        lab
            Degree of freedom label for coupled nodes (in the nodal coordinate
            system). If ALL, use all appropriate labels except HDSP.  Valid
            labels are: Structural labels:  UX, UY, or UZ (displacements);
            ROTX, ROTY, or ROTZ (rotations, in radians), HDSP (hydrostatic
            pressure).  Thermal labels: TEMP, TBOT, TE2, TE3, . . ., TTOP
            (temperature).  Fluid labels:  PRES (pressure);  VX, VY, or VZ
            (velocities).  Electric labels:  VOLT (voltage);  EMF
            (electromotive force drop);  CURR (current).  Magnetic labels:  MAG
            (scalar magnetic potential); AX, AY, or AZ (vector magnetic
            potentials);  CURR (current). Diffusion label: CONC
            (concentration).

        toler
            Tolerance for coincidence (based on maximum coordinate difference
            in each global Cartesian direction for node locations and on angle
            differences for node orientations).  Defaults to 0.0001.   Only
            nodes within the tolerance are considered to be coincident for
            coupling.

        Notes
        -----
        Defines coupled degrees of freedom between coincident nodes (within a
        tolerance).  May be used, for example, to "button" together elements
        interfacing at a seam, where the seam consists of a series of node
        pairs.  One coupled set is generated for each selected degree of
        freedom for each pair of coincident nodes.  For more than two
        coincident nodes in a cluster, a coupled set is generated from the
        lowest numbered node to each of the other nodes in the cluster.
        Coupled sets are generated only within (and not between) clusters.  If
        fewer than all nodes are to be checked for coincidence, use the NSEL
        command to select nodes.  Coupled set reference numbers are incremented
        by one from the highest previous set number.  Use CPLIST to display the
        generated sets.  Only nodes having the same nodal coordinate system
        orientations ("coincident" within a tolerance) are included.  Use the
        CEINTF command to connect nodes by constraint equations instead of by
        coupling.  Use the EINTF command to connect nodes by line elements
        instead of by coupling.
        """
        command = "CPINTF,%s,%s" % (str(lab), str(toler))
        return self.run(command, **kwargs)

    def enorm(self, enum="", **kwargs):
        """APDL Command: ENORM

        Reorients shell element normals or line element node connectivity.

        Parameters
        ----------
        enum
            Element number having the normal direction that the reoriented
            elements are to match. If ENUM = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).

        Notes
        -----
        Reorients shell elements so that their outward normals are consistent
        with that of a specified element. ENORM can also be used to reorder
        nodal connectivity of line elements so that their nodal ordering is
        consistent with that of a specified element.

        For shell elements, the operation reorients the element by reversing
        and shifting the node connectivity pattern. For example, for a 4-node
        shell element, the nodes in positions I, J, K and L of the original
        element are placed in positions J, I, L and K of the reoriented
        element. All 3-D shell elements in the selected set are considered for
        reorientation, and no element is reoriented more than once during the
        operation. Only shell elements adjacent to the lateral (side) faces are
        considered.

        The command reorients the shell element normals on the same panel as
        the specified shell element. A panel is the geometry defined by a
        subset of shell elements bounded by free edges or T-junctions (anywhere
        three or more shell edges share common nodes).

        Reorientation progresses within the selected set until either of the
        following conditions is true:

        The edge of the model is reached.

        More than two elements (whether selected or unselected) are adjacent to
        a lateral face.

        In situations where unselected elements might undesirably cause case b
        to control, consider using ENSYM,0,,0,ALL instead of ENORM.  It is
        recommended that reoriented elements be displayed and graphically
        reviewed.

        You cannot use the ENORM command to change the normal direction of any
        element that has a body or surface load. We recommend that you apply
        all of your loads only after ensuring that the element normal
        directions are acceptable.

        Real constant values are not reoriented and may be invalidated by an
        element reversal.
        """
        command = "ENORM,%s" % (str(enum))
        return self.run(command, **kwargs)

    def delete(self, set="", nstart="", nend="", **kwargs):
        """APDL Command: DELETE

        Specifies sets in the results file to be deleted before postprocessing.

        Parameters
        ----------
        set
            Specifies that sets in the results file are to be deleted.

        nstart
            The first set in a results file to be deleted.

        nend
            The final set in a results file to be deleted. This field is used
            only if deleting more than one sequential sets.

        Notes
        -----
        DELETE is a specification command that flags sets in the results file
        for deletion. It should be followed by a COMPRESS command, the
        corresponding action command that deletes the specified sets.

        The DELETE command is valid only in the results file editing processor
        (ANSYS auxiliary processor AUX3).
        """
        command = "DELETE,%s,%s,%s" % (str(set), str(nstart), str(nend))
        return self.run(command, **kwargs)

    def atan(self, ir="", ia="", name="", facta="", **kwargs):
        """APDL Command: ATAN

        Forms the arctangent of a complex variable.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        ia
            Reference number of the complex variable to be operated on.

        --, --
            Unused fields.

        name
            Thirty-two character name for identifying the variable on the
            printout and displays.  Embedded blanks are compressed upon output.

        --, --
            Unused fields.

        facta
            Scaling factor (positive or negative) applied to variable IA
            (defaults to 1.0).  Usually FACTA should be set to 1.  FACTA may
            affect the position of the angle by a multiple of  π, resulting in
            a quadrant change.

        Notes
        -----
        Forms the arctangent of a complex variable according to the operation:

        IR = ATAN(FACTA X b/a)

        where a and b are the real and imaginary parts, respectively, of the
        complex variable IA (which is of the form a + ib).  The arctangent
        represents the phase angle (in radians), and is valid only for a
        harmonic analysis (ANTYPE,HARMIC).

        Since the scaling factor is applied uniformly to b/a, applying any
        positive or negative scaling factor will not affect the size of the
        phase angle, with the exception that a negative scaling factor will
        change the results quadrant by : π.  The magnitude of a complex number
        is still obtained through the ABS command.  See POST26 - Data
        Operations in the Mechanical APDL Theory Reference for details.
        """
        command = "ATAN,%s,%s,%s,%s" % (str(ir), str(ia), str(name), str(facta))
        return self.run(command, **kwargs)

    def etdele(self, ityp1="", ityp2="", inc="", **kwargs):
        """APDL Command: ETDELE

        Deletes element types.

        Parameters
        ----------
        ityp1, ityp2, inc
            Deletes element types from ITYP1 to ITYP2 (defaults to ITYP1) in
            steps of INC (defaults to 1). If ITYP1 = ALL, ITYP2 and INC are
            ignored and all element types are deleted.  Element types are
            defined with the ET command.
        """
        command = "ETDELE,%s,%s,%s" % (str(ityp1), str(ityp2), str(inc))
        return self.run(command, **kwargs)

    def lsengine(self, type="", enginename="", matrix="", option="", **kwargs):
        """APDL Command: *LSENGINE

        Creates a linear solver engine.

        Parameters
        ----------
        type
            Specifies the algorithm to be used:

            Boeing sparse solver (default if applied to sparse matrices). - MKL sparse linear solver (Intel Windows and Linux systems only).

            LAPACK dense matrix linear solver (default if applied to dense matrices). - Distributed sparse solver.

        enginename
            Name used to identify this engine. Must be specified.

        matrix
            Name of the matrix to solve.

        option
            Option to control the memory mode of the DSS solver (used only if
            Type = DSS):

            In-core memory mode. - Out-of-core memory mode.

        Notes
        -----
        This command creates a linear solver engine.

        The BCS, DSS, and DSP solvers can only be used with sparse matrices.
        For dense matrices, use the LAPACK solver.
        """
        command = "*LSENGINE,%s,%s,%s,%s" % (str(type), str(enginename), str(matrix), str(option))
        return self.run(command, **kwargs)

    def prcplx(self, key="", **kwargs):
        """APDL Command: PRCPLX

        Defines the output form for complex variables.

        Parameters
        ----------
        key
            Output form key:

            0 - Real and imaginary parts.

            1 - Amplitude and phase angle.  Stored real and imaginary data are converted to
                amplitude and phase angle upon output.  Data remain stored as
                real and imaginary parts.

        Notes
        -----
        Defines the output form for complex variables.  Used only with harmonic
        analyses (ANTYPE,HARMIC).

        All results data are stored in the form of real and imaginary
        components and converted to amplitude and/or phase angle as specified
        via the PRCPLX command. The conversion is not  valid for derived
        results (such as principal stress/strain, equivalent stress/strain and
        USUM).
        """
        command = "PRCPLX,%s" % (str(key))
        return self.run(command, **kwargs)

    def demorph(self, elem="", dimn="", rmshky="", **kwargs):
        """APDL Command: DEMORPH

        Move nodes in selected elements to conform to structural displacements.

        Parameters
        ----------
        elem
             Non-structural elements to which mesh movement (morph) applies.
            If ALL, apply morphing to all selected elements [ESEL]. If ELEM =
            P, graphical picking is enabled.  A component may be substituted
            for ELEM.

        dimn
            Problem dimensionality.  Use "2" for a 2-D problem and "3" for a
            3-D problem (no default).

        rmshky
            Remesh flag option:

            0 - Remesh the selected non-structural regions only if mesh morphing fails.

            1 - Remesh the selected non-structural regions and bypass mesh morphing.

            2 - Perform mesh morphing only and do not remesh.

        Notes
        -----
        The selected elements should include only non-structural regions
        adjacent to structural regions. The exterior nodes of the selected
        elements will usually be on the boundary of the region which will have
        node positions displaced. For DIMN = 2, elements must lie on a flat
        plane. The DEMORPH command requires a single domain grouping of
        elements be provided (multiple domains of elements are not permitted).
        Exterior nodes will be assumed fixed (no nodes will be morphed) unless
        they coincide with structural nodes having nonzero displacements.

        Nodes in the structural regions move in accordance with computed
        displacements. Displacements from a structural analysis must be in the
        database prior to issuing DEMORPH.

        By default (RMSHKY = 0), DEMORPH will remesh the selected non-
        structural regions entirely if a satisfactory morphed mesh cannot be
        provided.

        If boundary conditions and loads are applied directly to nodes and
        elements, the DEMORPH command requires that these be removed before
        remeshing can take place.

        Exercise care with initial conditions defined by the IC command. Before
        a structural analysis is performed for a sequentially coupled analysis,
        the DEMORPH command requires that initial conditions be removed from
        all null element type nodes in the non-structural regions. Use ICDELE
        to delete the initial conditions.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "DEMORPH,%s,%s,%s" % (str(elem), str(dimn), str(rmshky))
        return self.run(command, **kwargs)

    def rmxport(self, **kwargs):
        """APDL Command: RMXPORT

        Exports ROM model to external VHDL-AMS simulator.

        Notes
        -----
        Use this command to generate all files necessary to run the ROM
        analysis in an external VHDL-AMS Simulator.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.

        VHDL files: Initial.vhd, S_ams_ijk.vhd, Cxxx_ams_ijk.vhd,
        transducer.vhd.
        """
        command = "RMXPORT," % ()
        return self.run(command, **kwargs)

    def sadd(self, labr="", lab1="", lab2="", fact1="", fact2="", const="",
             **kwargs):
        """APDL Command: SADD

        Forms an element table item by adding two existing items.

        Parameters
        ----------
        labr
            Label assigned to results.  If same as existing label, the existing
            values will be overwritten by these results.

        lab1
            First labeled result item in operation.

        lab2
            Second labeled result item in operation (may be blank).

        fact1
            Scale factor applied to Lab1. A (blank) or '0' entry defaults to
            1.0.

        fact2
            Scale factor applied to Lab2. A (blank) or '0' entry defaults to
            1.0.

        const
            Constant value.

        Notes
        -----
        Forms a labeled result (see ETABLE command) for the selected elements
        by adding two existing labeled result items according to the operation:

        LabR = (FACT1 x Lab1) + (FACT2 x Lab2) + CONST

        May also be used to scale results for a single labeled result item.  If
        absolute values are requested [SABS,1], absolute values of Lab1 and
        Lab2 are used.
        """
        command = "SADD,%s,%s,%s,%s,%s,%s" % (str(labr), str(lab1), str(lab2), str(fact1), str(fact2), str(const))
        return self.run(command, **kwargs)

    def rmodif(self, nset="", stloc="", v1="", v2="", v3="", v4="", v5="",
               v6="", **kwargs):
        """APDL Command: RMODIF

        Modifies real constant sets.

        Parameters
        ----------
        nset
            Number of existing real constant set to be modified.

        stloc
            Starting location in table for modifying data.  For example, if
            STLOC = 1, data input in the V1 field is the first constant in the
            set.  If STLOC = 7, data input in the V1 field is the seventh
            constant in the set, etc.  Must be greater than zero.

        v1
            New value assigned to constant in location STLOC.  If zero (or
            blank), a zero value will be assigned.

        v2, v3, v4, . . . , v6
            New values assigned to constants in the next five locations.  If
            blank, the value remains unchanged.

        Notes
        -----
        Allows modifying (or adding) real constants to an existing set [R] at
        any location.

        Specify NSET = GCN to define/modify real constants for real constant
        sets that were previously assigned by the GCDEF command (that is, real
        constants used in general contact interactions).

        This command is also valid in SOLUTION. For important information about
        using this command within the solution phase, see What Are Nonstandard
        Uses? in the Advanced Analysis Guide.
        """
        command = "RMODIF,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nset), str(stloc), str(v1), str(v2), str(v3), str(v4), str(v5), str(v6))
        return self.run(command, **kwargs)

    def eof(self, **kwargs):
        """APDL Command: /EOF

        Exits the file being read.

        Notes
        -----
        Causes an end-of-file exit when encountered on a switched file (see
        /INPUT, *USE, etc.). Commands are then read continuing from the file
        that contained the file switching command (or from the terminal if the
        switch was made from the terminal). Use the /EXIT command to terminate
        an ANSYS run. This command cannot be used in a do-loop or if-then-else
        construct.

        This command is valid in any processor.
        """
        command = "/EOF," % ()
        return self.run(command, **kwargs)

    def mflist(self, option="", value="", **kwargs):
        """APDL Command: MFLIST

        Lists the settings for an ANSYS Multi-field solver analysis.

        Parameters
        ----------
        option
            ALL

            ALL - Lists all ANSYS Multi-field solver analysis options.

            SOLU - Lists all solution-related ANSYS Multi-field solver options.

            FIELD - Lists all ANSYS Multi-field solver options related to the specified field
                    number.

            SINT - Lists all surface interface information for the specified surface interface
                   number.

            VINT - Lists all volumetric interface information for the specified volumetric
                   interface number.

        value
            Use only for Option = FIELD, SINT, or VINT.

        Notes
        -----
        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFLIST,%s,%s" % (str(option), str(value))
        return self.run(command, **kwargs)

    def edele(self, iel1="", iel2="", inc="", **kwargs):
        """APDL Command: EDELE

        Deletes selected elements from the model.

        Parameters
        ----------
        iel1, iel2, inc
            Delete elements from IEL1 to IEL2 (defaults to IEL1) in steps of
            INC (defaults to 1). If IEL1 = ALL, IEL2 and INC are ignored and
            all selected elements [ESEL] are deleted. If IEL1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI). A component name may also be substituted
            for IEL1 (IEL2 and INC are ignored).

        Notes
        -----
        Deleted elements are replaced by null or "blank" elements. Null
        elements are used only for retaining the element numbers so that the
        element numbering sequence for the rest of the model is not changed by
        deleting elements. Null elements may be removed (although this is not
        necessary) with the NUMCMP command. If related element data (pressures,
        etc.) are also to be deleted, delete that data before deleting the
        elements. EDELE is for unattached elements only. You can use the xCLEAR
        family of commands to remove any attached elements from the database.
        """
        command = "EDELE,%s,%s,%s" % (str(iel1), str(iel2), str(inc))
        return self.run(command, **kwargs)

    def wait(self, dtime="", **kwargs):
        """APDL Command: /WAIT

        Causes a delay before the reading of the next command.

        Parameters
        ----------
        dtime
            Time delay (in seconds). Maximum time delay is 59 seconds.

        Notes
        -----
        The command following the /WAIT will not be processed until the
        specified wait time increment has elapsed.  Useful when reading from a
        prepared input file to cause a pause, for example, after a display
        command so that the display can be reviewed for a period of time.
        Another "wait" feature is available via the *ASK command.

        This command is valid in any processor.
        """
        command = "/WAIT,%s" % (str(dtime))
        return self.run(command, **kwargs)

    def l(self, p1="", p2="", ndiv="", space="", xv1="", yv1="", zv1="",
          xv2="", yv2="", zv2="", **kwargs):
        """APDL Command: L

        Defines a line between two keypoints.

        Parameters
        ----------
        p1
            Keypoint at the beginning of line.  If P1 = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).

        p2
            Keypoint at the end of line.

        ndiv
            Number of element divisions within this line.  Normally this field
            is not used; specifying divisions with LESIZE, etc. is recommended.

        space
            Spacing ratio.  Normally this field is not used, as specifying
            spacing ratios with the LESIZE command is recommended.  If
            positive, SPACE is the nominal ratio of the last division size (at
            P2) to the first division size (at P1).  If the ratio is greater
            than 1, the division sizes increase from P1 to P2, and if less than
            1, they decrease.  If SPACE is negative, then |SPACE| is the
            nominal ratio of the center division size to those at the ends.

        Returns
        -------
        result : int
            Returns the line number of the created line or None,
            if something went wrong.

        Notes
        -----
        Defines a line between two keypoints from P1 to P2.  The line shape may
        be generated as "straight" (in the active coordinate system) or curved.
        The line shape is invariant with coordinate system after it is
        generated.  Note that solid modeling in a toroidal coordinate system is
        not recommended.  A curved line is limited to 180°.  Lines may be
        redefined only if not yet attached to an area.
        """
        command = "L,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(p1), str(p2), str(ndiv), str(space), str(xv1), str(yv1), str(zv1), str(xv2), str(yv2), str(zv2))
        return self.run(command, **kwargs)

    def mfoutput(self, freq="", **kwargs):
        """APDL Command: MFOUTPUT

        Specifies results file output frequency for an ANSYS
        Multi-field solver analysis.

        Parameters
        ----------
        freq
            N

            N - Write solution every Nth (and the last) time
                 step. Defaults to 1, for every time step.

            -N - Writes up to -N equally spaced results (for multifield auto time stepping).

            NONE - Suppresses writing of results for all multifield time steps.

            ALL - Writes results for every multifield time step (default).

            LAST - Writes results for only the last multifield time step.

            %array% - Where %array% is the name of an n X 1 X 1
                      dimensional array parameter defining n key
                      times, the data for the specified solution
                      results item is written at those key times. Key
                      times in the array parameter must appear in
                      ascending order. Value must be greater than or
                      equal to the ending time values for the load
                      step.

            For restart runs (see MFRSTART command), either change the parameter values to fall between the beginning and ending time values of the load step, or erase the current settings and reissue the command with a new array parameter.  - For more information about defining array parameters, see the *DIM command
                              documentation.

        Notes
        -----
         A MFOUTPUT setting overrides any other output frequency setting
        (OUTRES). To select the solution items, use the OUTRES command.

        For the case of Freq = -n and Freq = %array%, the results at the time
        points which first time reaches or exceeds the targeting ouptupt time
        points will be written.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFOUTPUT,%s" % (str(freq))
        return self.run(command, **kwargs)

    def pdsave(self, fname="", ext="", **kwargs):
        """APDL Command: PDSAVE

        Writes the probabilistic model data to a file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Writes the probabilistic model data to a file. Saved data include
        probabilistic data only; the results of the probabilistic analyses are
        not stored in the file (rather, these are stored in separate result
        files).
        """
        command = "PDSAVE,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def secdata(self, val1="", val2="", val3="", val4="", val5="", val6="",
                val7="", val8="", val9="", val10="", val11="", val12="",
                **kwargs):
        """APDL Command: SECDATA

        Describes the geometry of a section.

        Parameters
        ----------
        val1, val2, val3, . . . , val12
            Values, such as thickness or the length of a side or the numbers of
            cells along the width, that describe the geometry of a section. The
            terms VAL1, VAL2, etc. are specialized for each type of cross-
            section.

        Notes
        -----
        The SECDATA command defines the data describing the geometry of a
        section. The command is divided into these section types: Beams, Links,
        Pipes, Axisymmetric, Taper, Shells, Pretension, Joints, Reinforcing,
        and Contact.

        The data input on the SECDATA command is interpreted based on the most
        recently issued SECTYPE command. The data required is determined by the
        section type and subtype, and is different for each one.

        Beam sections are referenced by BEAM188 and BEAM189 elements. Not all
        SECOFFSET location values are valid for each subtype.

        Type: BEAM, Subtype: RECT

        Type: BEAM, Subtype: QUAD

        Degeneration to triangle is permitted by specifying the same
        coordinates for cells along an edge.

        Type: BEAM, Subtype: CSOLID

        Type: BEAM, Subtype: CTUBE

        This subtype is similar to type PIPE. However, elements using PIPE
        account for internal or external pressures, whereas elements using
        CTUBE do not.

        Type: BEAM, Subtype: CHAN

        Type: BEAM, Subtype: I

        Type: BEAM, Subtype: Z

        Type: BEAM, Subtype: L

        If W2 is a negative value, the section will be flipped.

        Type: BEAM, Subtype: T

        If W2 is a negative value, the section will be flipped.

        Type: BEAM, Subtype: HATS
        """
        command = "SECDATA,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(val1), str(val2), str(val3), str(val4), str(val5), str(val6), str(val7), str(val8), str(val9), str(val10), str(val11), str(val12))
        return self.run(command, **kwargs)

    def vdele(self, nv1="", nv2="", ninc="", kswp="", **kwargs):
        """APDL Command: VDELE

        Deletes unmeshed volumes.

        Parameters
        ----------
        nv1, nv2, ninc
            Delete volumes from NV1 to NV2 (defaults to NV1) in steps of NINC
            (defaults to 1).  If NV1 = ALL, NV2 and NINC are ignored and all
            selected volumes [VSEL] are deleted.  If NV1 = P, graphical picking
            is enabled and all remaining command fields are ignored (valid only
            in the GUI).  A component name may also be substituted for NV1 (NV2
            and NINC are ignored).

        kswp
            Specifies whether keypoints, lines, and areas are also deleted:

            0 - Delete volumes only (default).

            1 - Delete volumes, as well as keypoints, lines, and areas attached to the
                specified volumes but not shared by other volumes.
        """
        command = "VDELE,%s,%s,%s,%s" % (str(nv1), str(nv2), str(ninc), str(kswp))
        return self.run(command, **kwargs)

    def slashdscale(self, wn="", dmult="", **kwargs):
        """APDL Command: /DSCALE

        Sets the displacement multiplier for displacement displays.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        dmult
            AUTO or 0

            AUTO or 0 - Scale displacements automatically so that maximum  displacement (vector
                        amplitude) displays as 5 percent of the maximum model
                        length, as measured in the global Cartesian X, Y, or Z
                        directions.

            1 - Do not scale displacements (i.e., scale displacements by 1.0, true to
                geometry).  Often used with large deflection results.

            FACTOR - Scale displacements by numerical value input for FACTOR.

            OFF - Remove displacement scaling (i.e., scale displacements by 0.0, no distortion).

            USER - Set DMULT to that used for last display (useful when last DMULT value was
                   automatically calculated).

        Notes
        -----
        If Multi-Plots are not being displayed, and the current device is a 3-D
        device [/SHOW,3D], then the displacement scale in all active windows
        will be the same, even if separate /DSCALE commands are issued for each
        active window. For efficiency, ANSYS 3-D graphics logic maintains a
        single data structure (segment), which contains only one displacement
        scale. The program displays the same segment (displacement scale) in
        all windows. Only the view settings will be different in each of the
        active windows.

        This command is valid in any processor.
        """
        command = "/DSCALE,%s,%s" % (str(wn), str(dmult))
        return self.run(command, **kwargs)

    def lcabs(self, lcno="", kabs="", **kwargs):
        """APDL Command: LCABS

        Specifies absolute values for load case operations.

        Parameters
        ----------
        lcno
            Load case pointer number.  If ALL, apply to all selected load cases
            [LCSEL].

        kabs
            Absolute value key:

            0 - Use algebraic values of load case LCNO in operations.

            1 - Use absolute values of load case LCNO in operations.

        Notes
        -----
        Causes absolute values to be used in the load case operations [LCASE or
        LCOPER].  Absolute values are taken prior to assigning a load case
        factor [LCFACT] and are applied only to defined load cases [LCDEF].
        """
        command = "LCABS,%s,%s" % (str(lcno), str(kabs))
        return self.run(command, **kwargs)

    def qsopt(self, opt="", **kwargs):
        """APDL Command: QSOPT

        Specifies quasi static radiation options.

        Parameters
        ----------
        opt
            Quasi static option:

            OFF - Do not run transient radiation problem to steady-state (default).

            ON - Run transient radiation problem to steady-state.

        Notes
        -----
        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "QSOPT,%s" % (str(opt))
        return self.run(command, **kwargs)

    def edout(self, option="", **kwargs):
        """APDL Command: EDOUT

        Specifies time-history output (ASCII format) for an explicit dynamics
        analysis.

        Parameters
        ----------
        option
            Output data option. Each option corresponds to a separate file that
            is written by the LS-DYNA solver. If Option = ALL, all files except
            NODOUT and ELOUT are written. Valid options are:

            GLSTAT - Global data (default).

            BNDOUT - Boundary condition forces and energy.

            RWFORC - Wall force.

            DEFORC - Discrete element data.

            MATSUM - Material energies data.

            NCFORC - Nodal interface forces.

            RCFORC - Resultant interface force data.

            DEFGEO - Deformed geometry data.

            SPCFORC - SPC reaction force data.

            SWFORC - Nodal constraint reaction force data (spotwelds and rivets).

            RBDOUT - Rigid body data.

            GCEOUT - Geometry contact entities.

            SLEOUT - Sliding interface energy.

            JNTFORC - Joint force data.

            NODOUT - Nodal data.

            ELOUT - Element data.

        Notes
        -----
        This command specifies output to be written during an explicit dynamics
        solution. The data corresponding to each Option is written to a
        separate ASCII file having the same name as the Option label. The data
        is written for the entire model at time intervals specified by the
        EDHTIME command. If no time interval is specified, output is written at
        1000 steps over the analysis. (See also the EDHIST command which
        specifies time-history output for a portion of the model.)  The data
        written to the MATSUM file is actually for each PART number (EDPART) at
        time intervals specified by the EDHTIME command, but the data is listed
        following the Mat no. in the file.

        For Option = NODOUT and ELOUT, you must specify a component; you must
        issue EDHIST before issuing EDOUT,NODOUT or EDOUT,ELOUT.

        Use EDOUT,LIST to list the current time-history output specifications.
        (The listing will include output requested with the EDHIST command.)
        Use EDOUT,DELE to delete all output specifications that have been
        defined with the EDOUT command.

        In order for the specified output files to be written, you must also
        request that explicit dynamics results be written to an LS-DYNA output
        file [EDWRITE,LSDYNA or EDWRITE,BOTH].

        In an explicit dynamic small restart analysis (EDSTART,2) or full
        restart analysis (EDSTART,3), the same ASCII files that were requested
        for the original analysis are written by default for the restart. You
        can request different files by issuing the appropriate EDOUT commands
        in the restart analysis.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDOUT,%s" % (str(option))
        return self.run(command, **kwargs)

    def aflist(self, **kwargs):
        """APDL Command: AFLIST

        Lists the current data in the database.

        Notes
        -----
        Lists the current data and specifications in the database.  If batch,
        lists all appropriate data.  If interactive, lists only summaries.
        """
        command = "AFLIST," % ()
        return self.run(command, **kwargs)

    def trtime(self, time="", spacing="", offset="", size="", length="",
               **kwargs):
        """APDL Command: TRTIME

        Defines the options used for the PLTRAC (particle flow or charged
        particle trace) command.

        Parameters
        ----------
        time
            Total Trace Time (seconds) (defaults to 0, which is the full flow
            trace).

        spacing
            Particle spacing in seconds (defaults to 0).

        offset
            Particle offset in seconds (defaults to 0).  It is used internally
            in the ANFLOW macro to produce an animation of particle flow in a
            flowing fluid or charged particle motion in an electric or magnetic
            field.

        size
            Particle size (defaults to 0, which is a line).

        length
            Particle length fraction (defaults to .1).

        Notes
        -----
        The TRTIME command varies the type of   PLTRAC display produced.
        Particle flow or charged particle traces follow a particle's path in
        the forward and backward direction of travel. The DOF selected
        determines the color of the particle trace.  SPACING defines the
        particle spacing in seconds from adjacent particles in the stream line.
        OFFSET defines the offset in seconds from the spacing set by the
        SPACING argument.

        LENGTH defines the particle length fraction.  The default value (.1),
        means the particle occupies 10% of the flow region, and the other 90%
        is a color-coded line.

        SIZE sets the radius of the particle. Use SPACING, OFFSET and LENGTH
        only when SIZE is nonzero (i.e., the particle is bigger than the line).

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "TRTIME,%s,%s,%s,%s,%s" % (str(time), str(spacing), str(offset), str(size), str(length))
        return self.run(command, **kwargs)

    def cbmx(self, row="", s_r__r_="", s_r__r_plus_1_="", s_r__r_plus_2_="",
             s_r__r_plus_3_="", s_r__r_plus_4_="", s_r__r_plus_5_="",
             s_r__r_plus_6_="", **kwargs):
        """APDL Command: CBMX

        Specifies preintegrated cross-section stiffness for composite beam
        sections.

        Parameters
        ----------
        row
            Row number of the matrix.

        s(r)(r), . . . , s(r)(r+6)
            Upper triangle of the cross-section stiffness matrix [S].

        Notes
        -----
        The behavior of beam elements is governed by the generalized-
        stress/generalized-strain relationship of the form:

        The CBMX command, one of several composite beam section commands,
        specifies the cross-section stiffness matrix (submatrix [S] data) for a
        composite beam section. The section data defined is associated with the
        section most recently defined (SECTYPE) at the specified temperature
        (CBTMP).

        Unspecified values default to zero.

        Related commands are CBTMP, CBTE, and CBMD.

        For complete information, see Using Preintegrated Composite Beam
        Sections.
        """
        command = "CBMX,%s,%s,%s,%s,%s,%s,%s,%s" % (str(row), str(s_r__r_), str(s_r__r_plus_1_), str(s_r__r_plus_2_), str(s_r__r_plus_3_), str(s_r__r_plus_4_), str(s_r__r_plus_5_), str(s_r__r_plus_6_))
        return self.run(command, **kwargs)

    def extopt(self, lab="", val1="", val2="", val3="", val4="", **kwargs):
        """APDL Command: EXTOPT

        Controls options relating to the generation of volume elements from
        area elements.

        Parameters
        ----------
        lab
            Label identifying the control option. The meanings of Val1, Val2,
            and Val3 will vary depending on Lab.

            ON - Sets carryover of the material attributes, real constant attributes, and
                 element coordinate system attributes of the pattern area
                 elements to the generated volume elements.  Sets the pattern
                 area mesh to clear when volume generations are done. Val1,
                 Val2, and Val3 are ignored.

            OFF - Removes all settings associated with this command. Val1, Val2, and Val3 are
                  ignored.

            STAT - Shows all settings associated with this command. Val1, Val2, Val3, and Val4 are
                   ignored.

            ATTR - Sets carryover of particular pattern area attributes (materials, real
                   constants, and element coordinate systems) of the pattern
                   area elements to the generated volume elements. (See 2.)
                   Val1 can be:

            0 - Sets volume elements to use current MAT command settings.

            1 - Sets volume elements to use material attributes of the pattern area elements.

            Val2 can be:  - 0

            Sets volume elements to use current REAL command settings. - 1

            Sets volume elements to use real constant attributes of the pattern area elements. - Val3 can be:

            0 - Sets volume elements to use current ESYS command settings.

            1 - Sets volume elements to use element coordinate system attributes of the pattern
                area elements.

            Val4 can be:  - 0

            Sets volume elements to use current SECNUM command settings. - 1

            Sets volume elements to use section attributes of the pattern area elements. -

            ESIZE - Val1 sets the number of element divisions in the direction of volume generation
                    or volume sweep. For VDRAG and VSWEEP, Val1 is overridden
                    by the LESIZE command NDIV setting. Val2 sets the spacing
                    ratio (bias) in the direction of volume generation or
                    volume sweep. If positive, Val2 is the nominal ratio of
                    last division size to first division size (if > 1.0, sizes
                    increase, if < 1.0, sizes decrease). If negative, Val2 is
                    the nominal ratio of center division(s) size to end
                    divisions size. Ratio defaults to 1.0 (uniform spacing).
                    Val3 and Val4 are ignored.

            ACLEAR - Sets clearing of pattern area mesh. (See 3.) Val1 can be:

            0 - Sets pattern area to remain meshed when volume generation is done.

            1 - Sets pattern area mesh to clear when volume generation is done. Val2, Val3 ,
                and Val4 are ignored.

            VSWE - Indicates that volume sweeping options will be set using Val1 and Val2.
                   Settings specified with EXTOPT,VSWE will be used the next
                   time the VSWEEP command is invoked. If Lab = VSWE, Val1
                   becomes a label. Val1 can be:

            AUTO - Indicates whether you will be prompted for the source and target used by VSWEEP
                   or if VSWE should automatically determine the source and
                   target. If Val1 = AUTO, Val2 is ON by default. VSWE will
                   automatically determine the source and target for VSWEEP.
                   You will be allowed to pick more than one volume for
                   sweeping. When Val2 = OFF, the user will be prompted for the
                   source and target for VSWEEP. You will only be allowed to
                   pick one volume for sweeping.

            TETS - Indicates whether VSWEEP will tet mesh non-sweepable volumes or leave them
                   unmeshed. If Val1 = TETS, Val2 is OFF by default. Non-
                   sweepable volumes will be left unmeshed. When Val2 = ON, the
                   non-sweepable volumes will be tet meshed if the assigned
                   element type supports tet shaped elements.

        val1, val2, val3, val4
            Additional input values as described under each option for Lab.

        Notes
        -----
        EXTOPT controls options relating to the generation of volume elements
        from pattern area elements using the VEXT, VROTAT, VOFFST, VDRAG, and
        VSWEEP commands.  (When using VSWEEP,  the pattern area is referred to
        as the source area.)

        Enables carryover of the attributes  of the pattern area elements to
        the generated volume elements when you are using VEXT, VROTAT, VOFFST,
        or VDRAG. (When using VSWEEP, since the volume already exists, use the
        VATT command to assign attributes before sweeping.)

        When you are using VEXT, VROTAT, VOFFST, or VDRAG, enables clearing of
        the pattern area mesh when volume generations are done. (When you are
        using VSWEEP, if selected, the area meshes on the pattern (source),
        target, and/or side areas clear when volume sweeping is done.)

        Neither EXTOPT,VSWE,AUTO nor EXTOPT,VSWE,TETS will be affected by
        EXTOPT,ON or EXTOPT, OFF.
        """
        command = "EXTOPT,%s,%s,%s,%s,%s" % (str(lab), str(val1), str(val2), str(val3), str(val4))
        return self.run(command, **kwargs)

    def genopt(self, **kwargs):
        """APDL Command: GENOPT

        Specifies "General options" as the subsequent status topic.

        Notes
        -----
        This is a status (STAT) topic command. Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "GENOPT," % ()
        return self.run(command, **kwargs)

    def inrtia(self, **kwargs):
        """APDL Command: INRTIA

        Specifies "Inertial loads" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "INRTIA," % ()
        return self.run(command, **kwargs)

    def pdot(self, labr="", labx1="", laby1="", labz1="", labx2="", laby2="",
             labz2="", **kwargs):
        """APDL Command: PDOT

        Calculates the dot product of two path vectors along the current path.

        Parameters
        ----------
        labr
            Label assigned to dot product result.

        labx1
            X-component of first vector label (labeled path item).

        laby1
            Y-component of first vector label (labeled path item).

        labz1
            Z-component of first vector label (labeled path item).

        labx2
            X-component of second vector label (labeled path item).

        laby2
            Y-component of second vector label (labeled path item).

        labz2
            Z-component of second vector label (labeled path item).
        """
        command = "PDOT,%s,%s,%s,%s,%s,%s,%s" % (str(labr), str(labx1), str(laby1), str(labz1), str(labx2), str(laby2), str(labz2))
        return self.run(command, **kwargs)

    def dflx(self, node="", bx="", by="", bz="", bx2="", by2="", bz2="",
             **kwargs):
        """APDL Command: DFLX

        Imposes a uniform magnetic flux B on an edge-element electromagnetic
        model.

        Parameters
        ----------
        node
            Nodes at which the edge-flux (AZ) constraints corresponding to the
            uniform magnetic flux are to be specified.  Valid options are ALL
            (default) or Component Name. If ALL, constraints are applied to all
            selected nodes (NSEL).

        bx, by, bz
            Real components of magnetic flux B.

        bx2, by2, bz2
            Imaginary components of magnetic flux B.

        Notes
        -----
        The DFLX command sets the constraints on the edge-flux (AZ) degrees of
        freedom to produce a uniform magnetic flux B in an edge-based
        electromagnetic analysis using elements SOLID236 and SOLID237. The
        command ignores the corner nodes of the elements (even if they were
        selected) and imposes the AZ-constraints on the mid-side nodes only.
        The AZ-constraints are imposed in the active Cartesian coordinate
        system. A non-Cartesian coordinate system will be ignored by the DFLX
        command.

        The edge-flux constraints at the mid-side nodes are derived from  the
        magnetic vector potential A, which is related to the imposed magnetic
        flux B as follows:

        where r is the position of the mid-side node.

        The DFLX command creates a component named _DFLX for the constrained
        midside nodes. You can use this component to delete the constraints
        imposed by the DFLX command.

        This command is also valid in PREP7.
        """
        command = "DFLX,%s,%s,%s,%s,%s,%s,%s" % (str(node), str(bx), str(by), str(bz), str(bx2), str(by2), str(bz2))
        return self.run(command, **kwargs)

    def ereinf(self, **kwargs):
        """APDL Command: EREINF

        Generates reinforcing elements from selected existing (base) elements.

        Notes
        -----
        The EREINF command generates reinforcing elements (REINF264 and
        REINF265) directly from selected base elements (that is, existing
        standard elements in your model). The command scans all selected base
        elements and generates (if necessary) a compatible reinforcing element
        type for each base element. (ANSYS allows a combination of different
        base element types.)

        Although predefining the reinforcing element type (ET) is not required,
        you must define the reinforcing element section type (SECTYPE);
        otherwise, ANSYS cannot generate the reinforcing element.

        The EREINF command does not create new nodes. The reinforcing elements
        and the base elements share the common nodes.

        Elements generated by this command are not associated with the solid
        model.

        After the EREINF command executes, you can issue ETLIST, ELIST, and
        EPLOT commands to verify the newly created reinforcing element types
        and elements.

        Reinforcing elements do not account for any subsequent modifications
        made to the base elements. ANSYS, Inc. recommends issuing the EREINF
        command only after the base elements are finalized. If you delete or
        modify base elements (via EDELE, EMODIF, ETCHG, EMID, EORIENT, NUMMRG,
        or NUMCMP commands, for example), remove all affected reinforcing
        elements and reissue the EREINF command to avoid inconsistencies.
        """
        command = "EREINF," % ()
        return self.run(command, **kwargs)

    def cpmerge(self, lab="", **kwargs):
        """APDL Command: CPMERGE

        Merges different couple sets with duplicate degrees of freedom into one
        couple set.

        Parameters
        ----------
        lab
            Degree of freedom label for coupled nodes (in the nodal coordinate
            system).  Valid labels are: Structural labels:  UX, UY, or UZ
            (displacements); ROTX, ROTY, or ROTZ (rotations) (in radians).
            Thermal labels: TEMP, TBOT, TE2, TE3, . . ., TTOP (temperature).
            Fluid labels:  PRES (pressure);  VX, VY, or VZ (velocities).
            Electric labels:  VOLT (voltage);  EMF (electromotive force drop);
            CURR (current).  Magnetic labels:  MAG (scalar magnetic potential);
            AX, AY, or AZ (vector magnetic potentials);  CURR (current).
            Diffusion label: CONC (concentration). Explicit analysis labels:
            UX, UY, or UZ (displacements).  The degree of freedom set is
            determined from all element types defined and the DOF command, if
            used.
        """
        command = "CPMERGE,%s" % (str(lab))
        return self.run(command, **kwargs)

    def egen(self, itime="", ninc="", iel1="", iel2="", ieinc="", minc="",
             tinc="", rinc="", cinc="", sinc="", dx="", dy="", dz="",
             **kwargs):
        """APDL Command: EGEN

        Generates elements from an existing pattern.

        Parameters
        ----------
        itime, ninc
            Do this generation operation a total of ITIMEs, incrementing all
            nodes in the given pattern by NINC each time after the first. ITIME
            must be >1 if generation is to occur. NINC may be positive, zero,
            or negative. If DX, DY, and/or DZ is specified, NINC should be set
            so any existing nodes (as on NGEN) are not overwritten.

        iel1, iel2, ieinc
            Generate elements from selected pattern beginning with IEL1 to IEL2
            (defaults to IEL1) in steps of IEINC (defaults to 1). If IEL1 is
            negative, IEL2 and IEINC are ignored and the last |IEL1| elements
            (in sequence backward from the maximum element number) are used as
            the pattern to be repeated.  If IEL1 = ALL, IEL2 and IEINC are
            ignored and use all selected elements [ESEL] as pattern to be
            repeated. If P1 = P, graphical picking is enabled and all remaining
            command fields are ignored (valid only in the GUI).  A component
            name may also be substituted for IEL1 (IEL2 and INC are ignored).

        minc
            Increment material number of all elements in the given pattern by
            MINC each time after the first.

        tinc
            Increment type number by TINC.

        rinc
            Increment real constant table number by RINC.

        cinc
            Increment element coordinate system number by CINC.

        sinc
            Increment section ID number by SINC.

        dx, dy, dz
            Define nodes that do not already exist but are needed by generated
            elements (as though the NGEN,ITIME,INC,NODE1,,,DX,DY,DZ were issued
            before EGEN). Zero is a valid value. If blank, DX, DY, and DZ are
            ignored.

        Notes
        -----
        A pattern may consist of any number of previously defined elements. The
        MAT, TYPE, REAL, ESYS, and SECNUM numbers of the new elements are based
        upon the elements in the pattern and not upon the current specification
        settings.

        You can use the EGEN command to generate interface elements (INTER192,
        INTER193, INTER194, and INTER195) directly. However, because interface
        elements require that the element connectivity be started from the
        bottom surface, you must make sure that you use the correct element
        node connectivity. See the element descriptions for INTER192, INTER193,
        INTER194, and INTER195 for the correct element node definition.
        """
        command = "EGEN,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(itime), str(ninc), str(iel1), str(iel2), str(ieinc), str(minc), str(tinc), str(rinc), str(cinc), str(sinc), str(dx), str(dy), str(dz))
        return self.run(command, **kwargs)

    def gpdele(self, gap1="", gap2="", ginc="", **kwargs):
        """APDL Command: GPDELE

        Deletes gap conditions.

        Parameters
        ----------
        gap1, gap2, ginc
            Delete gap conditions from GAP1 to GAP2 (defaults to GAP1) in steps
            of GINC  (defaults to 1).

        Notes
        -----
        Deletes gap conditions defined with the GP command.  Gap conditions
        following those deleted are automatically compressed and renumbered.
        If used in SOLUTION, this command is valid only within the first load
        step.

        This command is also valid in PREP7.
        """
        command = "GPDELE,%s,%s,%s" % (str(gap1), str(gap2), str(ginc))
        return self.run(command, **kwargs)

    def blc5(self, xcenter="", ycenter="", width="", height="", depth="",
             **kwargs):
        """APDL Command: BLC5

        Creates a rectangular area or block volume by center and corner points.

        Parameters
        ----------
        xcenter, ycenter
            Working plane X and Y coordinates of the center of the rectangle or
            block face.

        width
            The total distance on or parallel to the working plane X-axis
            defining the width of the rectangle or block face.

        height
            The total distance on or parallel to the working plane Y-axis
            defining the height of the rectangle or block face.

        depth
            The perpendicular distance (either positive or negative based on
            the working plane Z direction) from the working plane representing
            the depth of the block.  If DEPTH = 0 (default), a rectangular area
            is created on the working plane.

        Notes
        -----
        Defines a rectangular area anywhere on the working plane or a
        hexahedral volume with one face anywhere on the working plane by
        specifying the center and corner points.  A rectangle will be defined
        with four keypoints and four lines.  A volume will be defined with
        eight keypoints, twelve lines, and six areas, with the top and bottom
        faces parallel to the working plane.  See the BLC4, RECTNG, and BLOCK
        commands for alternate ways to create rectangles and blocks.
        """
        command = "BLC5,%s,%s,%s,%s,%s" % (str(xcenter), str(ycenter), str(width), str(height), str(depth))
        return self.run(command, **kwargs)

    def asum(self, lab="", **kwargs):
        """APDL Command: ASUM

        Calculates and prints geometry statistics of the selected areas.

        Parameters
        ----------
        lab
            Controls the degree of tessellation used in the calculation of area
            properties.  If LAB = DEFAULT, area calculations will use the
            degree of tessellation set through the /FACET command.  If LAB =
            FINE, area calculations are based on a finer tessellation.

        Notes
        -----
        Calculates and prints geometry statistics (area, centroid location,
        moments of inertia, volume, etc.) associated with the selected areas.
        ASUM should only be used on perfectly flat areas.

        Geometry items are reported in the global Cartesian coordinate system.
        A unit thickness is assumed unless the areas have a non-zero total
        thickness defined by real constant or section data.

        For layered areas, a unit density is always assumed. For single-layer
        areas, a unit density is assumed unless the areas have a valid material
        (density).

        The thickness and density are associated to the areas via the AATT
        command.

        Items calculated via ASUM and later retrieved via a *GET or *VGET
        command are valid only if the model is not modified after issuing the
        ASUM command.

        Setting a finer degree of tessellation will provide area calculations
        with greater accuracy, especially for thin, hollow models.  However,
        using a finer degree of tessellation requires longer processing.

        For very narrow (sliver) areas, such that the ratio of the minimum to
        the maximum dimension is less than 0.01, the ASUM command can provide
        erroneous area information.  To ensure that the calculations are
        accurate, subdivide such areas so that the ratio of the minimum to the
        maximum is at least 0.05.
        """
        command = "ASUM,%s" % (str(lab))
        return self.run(command, **kwargs)

    def nsym(self, ncomp="", inc="", node1="", node2="", ninc="", **kwargs):
        """APDL Command: NSYM

        Generates a reflected set of nodes.

        Parameters
        ----------
        ncomp
            Symmetry key:

            X - X (or R) symmetry (default).

            Y - Y (or θ) symmetry.

            Z - Z (or Φ) symmetry.

        inc
            Increment all nodes in the given pattern by INC to form the
            reflected node pattern.

        node1, node2, ninc
            Reflect nodes from pattern beginning with NODE1 to NODE2 (defaults
            to NODE1) in steps of NINC (defaults to 1).  If  NODE1 = ALL, NODE2
            and NINC are ignored and pattern is all selected nodes [NSEL].  If
            NODE1 = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI).  A component name may
            also be substituted for NODE1 (NODE2 and NINC are ignored).

        Notes
        -----
        Generates nodes from a given node pattern by a symmetry reflection.
        Reflection is done in the active coordinate system by changing a
        particular coordinate sign.  Nodes in the pattern may have been
        generated in any coordinate system.   Nodal rotation angles are not
        reflected.

        Symmetry reflection may be used with any node pattern, in any
        coordinate system, as many times as desired.  Reflection is
        accomplished by a coordinate sign change (in the active coordinate
        system).  For example, an X-reflection in a Cartesian coordinate system
        generates additional nodes from a given pattern, with a node increment
        added to each node number, and an X coordinate sign change.  An
        R-reflection in a cylindrical coordinate system gives a reflected
        "radial" location by changing the "equivalent" Cartesian (i.e., the
        Cartesian system with the same origin as the active cylindrical system)
        X and Y coordinate signs.  An R-reflection in a spherical coordinate
        system gives a reflected "radial" location by changing the equivalent
        Cartesian X, Y, and Z coordinate location signs.  Nodal coordinate
        system rotation angles are not reflected.
        """
        command = "NSYM,%s,%s,%s,%s,%s" % (str(ncomp), str(inc), str(node1), str(node2), str(ninc))
        return self.run(command, **kwargs)

    def edhist(self, comp="", **kwargs):
        """APDL Command: EDHIST

        Specifies time-history output for an explicit dynamic analysis.

        Parameters
        ----------
        comp
            Name of the component containing nodes or elements for which output
            is desired. Comp is required.

        Notes
        -----
        The time-history output is written to the file Jobname.HIS.  Output is
        written only for the nodes or elements contained in Comp.  The data is
        written at time intervals specified on the EDHTIME command. If no time
        interval is specified, output is written at 1000 steps over the
        analysis. (See also the EDOUT command which controls time-history
        output in ascii form for an explicit dynamics analysis.)

        Use EDHIST,LIST to list the time-history output specification. (The
        listing will include output requested with the EDOUT command.) Use
        EDHIST,DELE to delete the time-history output specification.

        Jobname.HIS is a binary file that is read by the ANSYS time-history
        postprocessor (POST26). If LS-DYNA output has been requested on the
        EDWRITE command [EDWRITE,LSDYNA or EDWRITE,BOTH], the file D3THDT will
        also be written. D3THDT is a binary file that is read by the LS-POST
        postprocessor.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDHIST,%s" % (str(comp))
        return self.run(command, **kwargs)

    def pdvar(self, name="", type="", par1="", par2="", par3="", par4="",
              **kwargs):
        """APDL Command: PDVAR

        Specifies the parameters to be treated as probabilistic design
        variables.

        Parameters
        ----------
        name
            Parameter name (must be a scalar ANSYS parameter). The parameter
            must have been previously defined as a random input variable or a
            random output parameter with the PDVAR command. See the *SET
            command for restrictions about ANSYS parameters.

        type
            Probabilistic design variable type. This is the statistical
            distribution type. For more information on each of these types, see
            Probabilistic Design in the Advanced Analysis Guide.

            BETA - Beta distributed random variable.

            PAR1 = Shape parameter. Defaults to 2.0. - PAR2 = Shape parameter. Defaults to 2.0.

            PAR3 = Lower minimum value. Defaults to 0.0.  - PAR4 = Upper maximum value. Defaults to 1.0.

            EXPO - Exponential distributed random variable.

            PAR1 = Decay parameter λ. Must be larger then 0.0 and defaults to 1.0.  - PAR2 = Shift or minimum value. Defaults to 0.0.

            PAR3, PAR4 are ignored. - GAMA

            Gamma distributed random variable. - PAR1 = Decay parameter λ. Must be larger then 0.0 and defaults to 1.0.

            PAR2 = Exponential parameter k. Must be larger then 0.0 and defaults to 1.0.  - PAR3, PAR4 are ignored. Exponential distributed random variable.

            GAUS - Gaussian (Normal) distributed random variable.

            PAR1 = Mean value. Defaults to 0.0. - PAR2 = Standard deviation. Must be larger then 0.0 and defaults to 1.0.

            PAR3, PAR4 are ignored. - LOG1

            Lognormal distributed random variable specified directly with the statistical parameters mean value and standard deviation. - PAR1 = Mean value. Must be larger then 0.0 and defaults to 1.0.

            PAR2 = Standard deviation. Must be larger then 0.0 and defaults to 1.0. - PAR3, PAR4 are ignored.

            LOG2 - Lognormal distributed random variable specified with the statistical parameters
                   mean value and standard deviation of the logarithm of the
                   random values.

            PAR1 and PAR2 must also be defined. PAR1 = Mean value of the logarithm of the data. Defaults to 0.0.  - PAR2 = Standard deviation of the logarithm of the data. Must be larger then 0.0
                              and defaults to 1.0.

            PAR3, PAR4 are ignored. - UNIF

            Uniform distributed random variable. Note that PAR1 must be less than PAR2. - PAR1 = Minimum value. Defaults to 0.0.

            PAR2 = Maximum value. Defaults to 1.0. - PAR3, PAR4 are ignored.

            TGAU - Truncated Gaussian distributed random variable. Note that PAR3 must be less
                   than PAR4.

            PAR1 = Mean value of the untruncated Gaussian distribution. Defaults to 0.0. -  PAR2 = Standard deviation of the untruncated Gaussian distribution. Must be
                              larger then 0.0 and defaults to 1.0.

            PAR3 = Minimum value and lower truncation boundary. Defaults to -3.0. - PAR4 = Maximum value and upper truncation boundary. Defaults to +3.0.

            TRIA - Triangular distributed random variable. Note that PAR1 must be less than PAR2
                   which must be less than PAR3.

            PAR1 = Minimum value. Defaults to 0.0.  - PAR2 = Most Likely Value (MLV). Defaults to 0.5.

            PAR3 = Maximum value. Defaults to 1.0.  - PAR4 is ignored.

            WEIB - Weibull (Type III smallest) distributed random variable. Note that PAR2 must be
                   greater than PAR3. If PAR3 = 0.0, the random distribution is
                   equivalent to a two-parameter Weibull distribution.

            PAR1 = Weibull exponent. Must be larger then 0.0 and defaults to 1.0. - PAR2 = Characteristic value. Must be larger then 0.0 and defaults to 1.0.

            PAR3 = Shift or minimum value. Defaults to 0.0. - PAR4 is ignored.

            RESP - Random output or response parameter.PAR1 to PAR4 are not used.

            DEL - Deletes this probabilistic design variable (does not delete the ANSYS
                  parameter). This option is only valid if the parameter Name
                  was previously defined as a probabilistic design variable
                  (using Type = BETA, ..., WEIB or Type = RESP). The parameter
                  retains the value assigned during the last probabilistic
                  design loop.PAR1 to PAR4 are not used.

        par1, par2, par3, par4
            Parameters of the distribution function. The parameters must be
            specified according to the requirements of the individual
            distribution types described above.

        Notes
        -----
        Specifies the parameters to be treated as probabilistic design
        variables. A random input variable is specified by the name of the
        ANSYS parameter, the type of the distribution function (Type) and its
        distribution parameters (PAR1, ..., PAR4). A random output parameter is
        specified by the name of the ANSYS parameter and the type identifying
        it as a random output parameter (Type = RESP).
        """
        command = "PDVAR,%s,%s,%s,%s,%s,%s" % (str(name), str(type), str(par1), str(par2), str(par3), str(par4))
        return self.run(command, **kwargs)

    def mfimport(self, fnumb="", option="", fname="", ext="", **kwargs):
        """APDL Command: MFIMPORT

        Imports a new field into a current ANSYS Multi-field solver analysis.

        Parameters
        ----------
        fnumb
            Field number specified by the MFELEM command.

        option
            Selects data to read.

            DB - Reads a CDB file. The CDB file name and extension are specified by Fname and
                 Ext.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        Notes
        -----
        The field to be imported should be written to a CDB file (CDWRITE
        command). This file is read into the database, offsetting all existing
        element type numbers, node numbers, etc. in order to accommodate the
        imported field. (See the NUMOFF command for information on offset
        capabilities.) It then updates all of the previously issued MFxx
        commands to the new element type numbers. A new field is created using
        the specified field number, which must not currently exist. If there
        are no ANSYS Multi-field solver command files written for the existing
        fields in the database, one will be written for each field with the
        default name (see the MFCMMAND command). A MFCMMAND will be issued for
        the imported field as well.

        Repeat the MFIMPORT command to import additional fields.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFIMPORT,%s,%s,%s,%s" % (str(fnumb), str(option), str(fname), str(ext))
        return self.run(command, **kwargs)

    def mcheck(self, lab="", **kwargs):
        """APDL Command: MCHECK

        Checks mesh connectivity.

        Parameters
        ----------
        lab
            Operation:

            ESEL - Unselects the valid elements.

        Notes
        -----
         Wherever two area or volume elements share a common face, MCHECK
        verifies that the way the elements are connected to the face is
        consistent with their relative normals or integrated volumes. (This may
        detect folds or otherwise overlapping elements.)

         MCHECK verifies that the element exterior faces form simply-connected
        closed surfaces. (This may detect unintended cracks in a mesh.)

         MCHECK warns if the number of element facets in a 2-D loop or 3-D
        shell is not greater than a computed limit. This limit is the smaller
        of either three times the number of faces on one element, or one-tenth
        the total number of element faces in the model. (This may detect holes
        in the middle of a mesh.)

        The MCHECK command will perform a number of validity checks on the
        selected elements, including:

        Normal check:  Wherever two area elements share a common edge, MCHECK
        verifies that the ordering of the nodes on each element is consistent
        with their relative normals.

        Volume check:  Wherever two volume elements share a common face, MCHECK
        verifies that the sign of the integrated volume of each element is
        consistent.

        Closed surface check:  MCHECK verifies that the element exterior faces
        form simply-connected closed surfaces (this may detect unintended
        cracks in a mesh).

        Check for holes in the mesh:  MCHECK warns if the number of element
        faces surrounding an interior void in the mesh is small enough to
        suggest one or more accidentally omitted elements, rather than a
        deliberately formed hole. For this test, the number of faces around the
        void is compared to the smaller of a) three times the number of faces
        on one element, or b) one-tenth the total number of element faces in
        the model.
        """
        command = "MCHECK,%s" % (str(lab))
        return self.run(command, **kwargs)

    def sstate(self, action="", cm_name="", val1="", val2="", val3="", val4="",
               val5="", val6="", val7="", val8="", val9="", **kwargs):
        """APDL Command: SSTATE

        Defines a steady-state analysis.

        Parameters
        ----------
        action
            Action to perform for defining or manipulating steady-state
            analysis data:

            DEFINE - Define steady-state analysis data

            LIST - List current steady-state analysis data

            DELETE - Delete steady-state analysis data

        cm_name
            Element component name

        val1, ..., val9
            Input values (based on the Action type)

        Notes
        -----
        The SSTATE command specifies steady-state analysis parameters for the
        given element component. The program runs the steady-state analysis if
        the corresponding element key option is enabled for that element
        component.

        The command supports the following elements:

        SOLID185

        3-D 8-Node Structural Solid

        SOLID186

        3-D 20-Node Structural Solid

        SOLID187

        3-D 10-Node Tetrahedral Structural Solid

        SOLSH190

        3-D 8-Node Structural Solid Shell

        Degenerated shape (prism) option not supported.

        SOLID285

        3-D 4-Node Tetrahedral Structural Solid with Nodal Pressures

        For information about steady-state rolling for rebar and solid
        elements, see Steady State Rolling in the Mechanical APDL Theory
        Reference.

        The following data types can be defined:

        SPIN -- Steady-state spinning motion

        TRANSLATE -- Rigid body motion (velocity) that the spinning component
        is undergoing

        Define the steady-state spinning motion:

        SSTATE, DEFINE, CM_Name, SPIN, OMEGA, Method, Val4, Val5, Val6, Val7,
        Val8, Val9

        Spin velocity

        Method to use for defining the spin axis:

        Define the spin axis using two points:

        Val4, Val5, Val6 -- Coordinates of the first point

        Val7, Val8, Val9 -- Coordinates of the second point

        This definition method is currently the only option.

        This command defines a steady state spinning motion of 120 rad/s around
        the spin axis:

        In this case, two points with coordinates (0,0,0) and (0,1,0) define
        the spin axis in the global Y direction.

        Define the rigid body motion (velocity):

        SSTATE, DEFINE, CM_Name, TRANSLATE, Val2, Val3, Val4

        SSTATE, LIST, CM_Name

        Lists all steady-state analysis data defined on the specified element
        component. All data is listed if no component (CM_Name) is specified.

        SSTATE, DELETE, CM_Name

        Deletes all steady-state analysis data defined on the specified element
        component. All data is deleted if no component (CM_Name) is specified.
        """
        command = "SSTATE,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(action), str(cm_name), str(val1), str(val2), str(val3), str(val4), str(val5), str(val6), str(val7), str(val8), str(val9))
        return self.run(command, **kwargs)

    def cmsopt(self, cmsmeth="", nmode="", freqb="", freqe="", fbddef="",
               fbdval="", iokey="", **kwargs):
        """APDL Command: CMSOPT

        Specifies component mode synthesis (CMS) analysis options.

        Parameters
        ----------
        cmsmeth
            The component mode synthesis method to use. This value is required.

            FIX - Fixed-interface method.

            FREE - Free-interface method.

            RFFB - Residual-flexible free-interface method.

        nmode
            The number of normal modes extracted and used in the superelement
            generation. This value is required; the minimum is 1.

        freqb
            Beginning, or lower end, of frequency range of interest. This value
            is optional.

        freqe
            Ending, or upper end, of frequency range of interest. This value is
            optional.

        fbddef
            In a free-interface (CMSMETH = FREE) or residual-flexible free-
            interface (CMSMETH = RFFB) CMS analysis, the method to use for
            defining free body modes:

            FNUM - The number (FDBVAL) of rigid body modes in the calculation.

            FTOL - Employ a specified tolerance (FDBVAL) to determine rigid body modes in the
                   calculation.

            FAUTO - Automatically determine rigid body modes in the calculation. This method is the
                    default.

            RIGID - If no rigid body modes exist, define your own via the RIGID command.

        fbdval
            In a free-interface CMS analysis (CMSMETH = FREE), the number of
            rigid body modes if FBDDEF = fnum (where the value is an integer
            from 0 through 6), or the tolerance to employ if FBDDEF = ftol
            (where the value is a positive real number representing rad/sec).
            This value is required only when FBDDEF = fnum or FBDDEF = ftol;
            otherwise, any specified value is ignored.

        iokey
            Output key to control writing of the transformation matrix to the
            .TCMS file (FIX or FREE methods) or body properties to the .EXB
            file (FIX method).

            TCMS - Write the transformation matrix of the nodal component defined by the OUTPR
                   command to a .TCMS file. Refer to TCMS File Format in the
                   Programmer's Reference for more information on the this
                   file.

            EXB - Write a body property input file (.EXB file) containing the condensed
                  substructure matrices and other body properties for use with
                  AVL EXCITE. Refer to ANSYS Interface to AVL EXCITE in the
                  Substructuring Analysis Guide for more information.

        Notes
        -----
        CMS employs the Block Lanczos eigensolution method in the generation
        pass.

        CMS supports damping matrix reduction when a damping matrix exists. Set
        the matrix generation key to 3 (SEOPT,Sename,SEMATR) to generate and
        then reduce stiffness, mass, and damping matrices.

        CMS does not support the SEOPT,,,,,RESOLVE command. Instead, ANSYS sets
        the expansion method for the expansion pass (EXPMTH) to BACKSUB.

        For more information about performing a CMS analysis, see Component
        Mode Synthesis in the Substructuring Analysis Guide.

        If IOKEY = TCMS is used to output the transformation matrix, then only
        ITEM = NSOL is valid in the OUTPR command.  In the interactive
        sessions, the transformation matrix will not be output if the model has
        more than 10 elements.

        This command is also valid in /PREP7.
        """
        command = "CMSOPT,%s,%s,%s,%s,%s,%s,%s" % (str(cmsmeth), str(nmode), str(freqb), str(freqe), str(fbddef), str(fbdval), str(iokey))
        return self.run(command, **kwargs)

    def cm(self, cname="", entity="", **kwargs):
        """APDL Command: CM

        Groups geometry items into a component.

        Parameters
        ----------
        cname
            An alphanumeric name used to identify this component. Cname may be
            up to 32 characters, beginning with a letter and containing only
            letters, numbers, and underscores.  Component names beginning with
            an underscore (e.g., _LOOP) are reserved for use by ANSYS and
            should be avoided.  Components named “ALL,” “STAT,” and “DEFA” are
            not permitted. Overwrites a previously defined name.

        entity
            Label identifying the type of geometry items to be grouped:

            VOLU - Volumes.

            AREA - Areas.

            LINE - Lines.

            KP - Keypoints.

            ELEM - Elements.

            NODE - Nodes.

        Notes
        -----
        Components may be further grouped into assemblies [CMGRP].  The
        selected items of the specified entity type will be stored as the
        component.  Use of this component in the select command [CMSEL] causes
        all these items to be selected at once, for convenience.

        A component is a grouping of some geometric entity that can then be
        conveniently selected or unselected.  A component may be redefined by
        reusing a previous component name.  The following entity types may
        belong to a component: nodes, elements, keypoints, lines, areas, and
        volumes.  A component may contain only 1 entity type, but an individual
        item of any entity may belong to any number of components.  Once
        defined, the items contained in a component may then be easily selected
        or unselected [CMSEL].  Components may be listed [CMLIST], modified
        [CMMOD] and deleted [CMDELE].  Components may also be further grouped
        into assemblies [CMGRP].  Other entities associated with the entities
        in a component (e.g., the lines and keypoints associated with areas)
        may be selected by the ALLSEL command.

        An item will be deleted from a component if it has been deleted by
        another operation (see the KMODIF command for an example).  Components
        are automatically updated to reflect deletions of one or more of their
        items.  Components are automatically deleted and a warning message is
        issued if all their items are deleted.  Assemblies are also
        automatically updated to reflect deletions of one or more of their
        components or subassemblies, but are not deleted if all their
        components and subassemblies are deleted.

        This command is valid in any processor.
        """
        command = "CM,%s,%s" % (str(cname), str(entity))
        return self.run(command, **kwargs)

    def del_(self, val1="", val2="", **kwargs):
        """APDL Command: *DEL

        Deletes a parameter or parameters (GUI).

        Parameters
        ----------
        val1
            Command behavior key:

            Delete all user-defined parameters, or all user-defined parameters and all system parameters, as specified by Val2. - Delete the parameter(s) specified by Val2.

        val2
            The parameter or parameters to delete (used only when Val1 = ALL or
            (blank)):

            When Val1 is (blank), specifies the location of the parameter within the Array Parameters dialog box.  The location number is based on an alphabetically ordered list of all parameters in the database.   - When Val1 is ALL, deletes all parameters, including those named with a leading
                              underscore (_) (except _STATUS and _RETURN). When
                              Val1 is (blank), deletes only those parameters
                              named with a leading underscore (_) (except
                              _STATUS and _RETURN).

            When Val1 is (blank), deletes only those parameters named with a trailing underscore (_).  - When Val1 is ALL, a (blank) value for Val2 causes all user-defined parameters
                              to be deleted.

        Notes
        -----
        This is a command generally created by the graphical user interface
        (GUI).  It appears in the log file (Jobname.LOG) if an array parameter
        is deleted from within the Array Parameters dialog.

        Usage examples:

        Delete all user-defined parameters: *DEL,ALL

        Delete only those user-defined parameters named with a trailing
        underscore: *DEL,,PRM_

        Delete all user-defined and all system parameters (except for _STATUS
        and _RETURN): *DEL,ALL,_PRM

        Delete a parameter by specifying its location within the Array
        Parameters dialog: *DEL,,LOC

        Delete a single specified parameter by name: *DEL,ParmName (You cannot
        specify more than one named parameter at a time.)

        This command is valid in any processor.
        """
        command = "*DEL,%s,%s" % (str(val1), str(val2))
        return self.run(command, **kwargs)

    def edenergy(self, hgen="", swen="", sien="", rlen="", **kwargs):
        """APDL Command: EDENERGY

        Specifies energy dissipation controls for an explicit dynamics
        analysis.

        Parameters
        ----------
        hgen
            Hourglass energy control key:

            OFF or 0 - Hourglass energy is not computed.

            ON or 1 - Hourglass energy is computed and included in the energy balance (default).

        swen
            Stonewall energy dissipation control key:

            OFF or 0 - Stonewall energy dissipation is not computed.

            ON or 1 - Stonewall energy dissipation is computed and included in the energy balance
                      (default).

        sien
            Sliding interface energy dissipation control key:

            OFF or 0 - Sliding interface energy dissipation is not computed.

            ON or 1 - Sliding interface energy dissipation is computed and included in the energy
                      balance (default).

        rlen
            Rayleigh (damping) energy dissipation control key:

            OFF or 0 - Rayleigh energy dissipation is not computed.

            ON or 1 - Rayleigh energy dissipation is computed and included in the energy balance
                      (default).

        Notes
        -----
        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDENERGY,%s,%s,%s,%s" % (str(hgen), str(swen), str(sien), str(rlen))
        return self.run(command, **kwargs)

    def tbft(self, oper="", id="", option1="", option2="", option3="",
             option4="", option5="", option6="", option7="", **kwargs):
        """APDL Command: TBFT

        Performs material curve-fitting operations.

        Parameters
        ----------
        oper
            The specific curve-fitting operation:

            Define a constitutive model. - Delete a constitutive model.

            Write data related to a constitutive model to the database (same as TB command). - Initialize coefficients of a constitutive model for nonlinear curve-fitting
                              procedure.

            Deletes coefficients at current reference temperature. Applicable only for temperature dependent coefficients.  - Solve for coefficients.

            Fix (hold constant) the coefficient you specify in Option4. - Add experimental data.

            Delete experimental data. - List all data associated with the material model represented by the material ID
                              number.

        id
            The material reference number (same as MAT argument used in the TB
            command). Valid entry is any number greater than zero (default = 1)
            but less than 100,000.

        option1
            For curve-fit function operations (Oper = FADD, FDEL, FSET, SET,
            CDEL, SOLVE or FIX) this field specifies the category (HYPER).

        option2
            For curve-fit function operations (Oper = FADD, FDEL, FSET, SET,
            CDEL, SOLVE, or FIX), this field specifies constitutive model type.
            The valid entries are listed in Table 231: Hyperelastic Options
            below.

        option3
            For Oper = FADD, FDEL, FSET, CDEL, SET, SOLVE or FIX, some of the
            cases specified in Option2 will require that the polynomial order
            be specified. The applicable values for the order specification are
            listed in Table 231: Hyperelastic Options.

        option4
            When you are working on a specific coefficient (Oper = FIX), this
            field specifies the index of that coefficient. Valid entries vary
            from 1 to n, where n is the total number of coefficients (default =
            1).

        option5
            When you are working on a specific coefficient (Oper = FIX), this
            field specifies the index of that coefficient. Valid entries vary
            from 1 to N, where N is the total number of coefficients (default =
            1)

        option6
            If Oper = SOLVE, specifies the allowed tolerance in residual change
            to stop an iteration. Valid entry is 0.0 to 1.0 (default = 0.0).

        option7
            If Oper = SOLVE, specifies the allowed tolerance in coefficient
            change to stop an iteration. Valid entry is 0 to 1 (default = 0).
        """
        command = "TBFT,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(oper), str(id), str(option1), str(option2), str(option3), str(option4), str(option5), str(option6), str(option7))
        return self.run(command, **kwargs)

    def grtyp(self, kaxis="", **kwargs):
        """APDL Command: /GRTYP

        Selects single or multiple Y-axes graph displays.

        Parameters
        ----------
        kaxis
            Axis selection key:

            0 or 1 - Single Y-axis.  Up to 10 curves scaled to a single Y-axis.

            2 - Additional Y-axes (one for each curve) (3 curves maximum).  Allows better
                scaling of curves with widely differing numbering ranges.

            3 - Same as 2 but with additional Y-axis and curves projected out of the plane (6
                curves maximum).  Allows clearer display with an isometric
                view.  The default view when KAXIS = 3 is View,1,1,2,3.

        Notes
        -----
        The basic line graph has one or more curves plotted against the same Y
        and X axes.  Multiple curve graphs can also be plotted with individual
        Y axes and the same X axis.  The Y axis of the first curve is referred
        to as the base Y-axis and the Y axes of the other curves as additional
        Y axes.  Curves are numbered sequentially from 1 (the base curve) in
        the order in which they are displayed.  See the /AXLAB, /GROPT, /GRID,
        and /GTHK commands for other display options.

        This command is valid in any processor.
        """
        command = "/GRTYP,%s" % (str(kaxis))
        return self.run(command, **kwargs)

    def large(self, ir="", ia="", ib="", ic="", name="", facta="", factb="",
              factc="", **kwargs):
        """APDL Command: LARGE

        Finds the largest (the envelope) of three variables.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        ia, ib, ic
            Reference numbers of the three variables to be operated on.  If
            only two, leave IC blank.  If only one, leave IB blank also.

        name
            Thirty-two character name for identifying the variable on the
            printout and displays.  Embedded blanks are compressed upon output.

        --, --
            Unused fields.

        facta, factb, factc
            Scaling factors (positive or negative) applied to the corresponding
            variables (default to 1.0).

        Notes
        -----
        Creates a new variable by finding the largest of up to three variables
        according to the operation:

        IR = Largest of (FACTA x IA, FACTB x IB, FACTC x IC)

        The comparison is done at each time location, so that the new variable
        is the "envelope" of the three existing variables.
        """
        command = "LARGE,%s,%s,%s,%s,%s,%s,%s,%s" % (str(ir), str(ia), str(ib), str(ic), str(name), str(facta), str(factb), str(factc))
        return self.run(command, **kwargs)

    def sscale(self, wn="", smult="", **kwargs):
        """APDL Command: /SSCALE

        Sets the contour multiplier for topographic displays.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        smult
            Contour multiplier that factors in results based on the product of
            the multiplier and the result being plotted. Defaults to 0.0 (no
            topographic effects).

        Notes
        -----
        Use this command to scale values to the geometry when the contours are
        shown elevated.  For section displays [/TYPE], the elevation is
        performed perpendicular to the section face.

        Nonzero contour multipliers factoring in large results (stresses or
        displacements) can produce very large distortion, causing images to
        disappear.  To bring a distorted image back into view, reduce the
        contour multiplier value.

        Portions of this command are not supported by PowerGraphics
        [/GRAPHICS,POWER].
        """
        command = "/SSCALE,%s,%s" % (str(wn), str(smult))
        return self.run(command, **kwargs)

    def bsmd(self, dens="", **kwargs):
        """APDL Command: BSMD

        Specifies mass per unit length for a nonlinear general beam section.

        Parameters
        ----------
        dens
            Mass density.

        Notes
        -----
        The BSMD command, one of several nonlinear general beam section
        commands, specifies the mass density (assuming a unit area) for a beam
        section. The value specified is associated with the section most
        recently defined (via the SECTYPE command).

        Related commands are BSAX, BSM1, BSM2, BSTQ, BSS1, BSS2, and BSTE.

        For complete information, see Using Nonlinear General Beam Sections.
        """
        command = "BSMD,%s" % (str(dens))
        return self.run(command, **kwargs)

    def psymb(self, label="", key="", **kwargs):
        """APDL Command: /PSYMB

        Shows various symbols on displays.

        Parameters
        ----------
        label
            Show symbols as selected from the following labels:

            CS - Local coordinate systems.

            NDIR - Nodal coordinate systems (on rotated nodes only).

            ESYS - Element coordinate systems (element displays only).

            LDIR - Line directions (line displays only).

            LDIV - Controls the display of element divisions on lines.

            ADIR - Area direction symbol (for keypoint, line, area and volume plots).

            LAYR - Layer orientations (relative to the projected element x-axis) or fiber
                   orientations in smeared reinforcing elements. Used only
                   within an element display. Use KEY to specify the layer
                   number.

            ECON - Element mesh symbols on keypoints and lines.

            DOT - Larger symbols displayed for node and keypoint locations.  When Label = DOT,
                  KEY = 1 by default.

            XNOD - Extra node of surface or circuit elements.

            FBCS - Force boundary condition scaling. Subsequent KEY value determines whether or
                   not to scale the applied and derived forces/moments to the
                   same maximum value.

            DEFA - Resets the symbol keys so that ANSYS displays none of the symbols controlled by
                   the /PSYMB command.  The value of the KEY field is ignored.

            STAT - Prints the status of the settings of the symbol keys controlled by the /PSYMB
                   command.  The KEY field is ignored.

        key
            Symbol key:

            -1  - Effective only if Label = LAYR and solid shape element display (/ESHAPE) is
                  active. Orientation of all layers appears with the solid
                  shape element display.

            0  - No symbol (default). If Label = LDIV, then KEY= 0 indicates that the displayed
                 element divisions will correspond to the existing mesh (the
                 word MESHED or EXISTING can also be substituted). Also, for
                 Label = LDIV, if you execute any meshing command (such as
                 AMESH or VMESH), KEY is set to 0 (MESHED) automatically. If
                 Label = FBCS, then KEY= 0 indicates that boundary condition
                 scaling will not be common. The applied and derived
                 forces/moments will be scaled to their respective maximum
                 values.

            1  - Include symbol. If Label = LDIV, then KEY = 1 indicates that the displayed line
                 divisions will correspond to the value assigned by LESIZE (the
                 word LESIZE can also be substituted). Also, for Label = LDIV,
                 if you execute the LESIZE command, KEY is set to 1 (LESIZE)
                 automatically. If Label = FBCS, then KEY= 1 indicates that
                 boundary condition scaling will be common. The applied and
                 derived forces/moments will be scaled to the same maximum
                 value.

            N  - If Label = LAYR, then N is equal to the layer number. If Label = DOT, then N
                 can be equal to 0,1,.....15, indicating the dot size. If Label
                 = LDIV, then KEY = -1, indicates that no element divisions
                 will be displayed (the word OFF can also be substituted).

        Notes
        -----
        Includes various symbols on the display.  Triads are right-handed with
        x displayed as the longest leg.  Where color is displayed, x is white,
        y is green, and z is blue.  For beams, x is always along the length of
        the element.   For lines, an arrow represents the direction of a line,
        from the beginning keypoint to the end keypoint.  See /PLOPTS command
        for additional display options.  Use /PSTATUS or /PSYMB,STAT to display
        settings.  Use /PSYMB,DEFA to reset all specifications back to their
        defaults.  The command /PSYMB,ECON,1 causes the symbol "M" to be
        displayed on keypoints and lines associated with meshed entities.  When
        you issue the command /PSYMB,DOT,1, a larger symbol is displayed for
        each node and keypoint location.

        PowerGraphics (/GRAPHICS,POWER) does not support /PSYMB,ESYS and
        /PSYMB,LAYR.

        If KEY = N and PowerGraphics is off, the centroid of the surface
        elements is connected to the extra node using a gray line.  However, if
        PowerGraphics is on, the color of the line connecting the centroid to
        the extra node is the same as that for the elements themselves (as
        determined by /PNUM).

        When Label = LAYR, the layer systems can be visualized with all
        current-technology layered elements and the smeared reinforcing element
        REINF265. To use /PSYMB,LAYR with REINF265, first set the vector-mode
        graphics option (/DEVICE,VECTOR,1).

        This command is valid in any processor.
        """
        command = "/PSYMB,%s,%s" % (str(label), str(key))
        return self.run(command, **kwargs)

    def gap(self, **kwargs):
        """APDL Command: GAP

        Specifies "mode-superposition transient gap conditions" as the
        subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "GAP," % ()
        return self.run(command, **kwargs)

    def rmuse(self, option="", usefil="", **kwargs):
        """APDL Command: RMUSE

        Activates ROM use pass for ROM elements.

        Parameters
        ----------
        option
            Type of data to be plotted. Valid types are:

            1 or "ON" - Activates ROM use pass.

        usefil
            Name of the reduced displacement file (.rdsp) created by the ROM
            Use Pass (required field only for the Expansion Pass).

        Notes
        -----
        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMUSE,%s,%s" % (str(option), str(usefil))
        return self.run(command, **kwargs)

    def fefor(self, **kwargs):
        """APDL Command: FEFOR

        Specifies "Forces on nodes" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "FEFOR," % ()
        return self.run(command, **kwargs)

    def tallow(self, temp1="", temp2="", temp3="", temp4="", temp5="",
               temp6="", **kwargs):
        """APDL Command: TALLOW

        Defines the temperature table for safety factor calculations.

        Parameters
        ----------
        temp1, temp2, temp3, . . . , temp6
            Input up to six temperatures covering the range of nodal
            temperatures.  Temperatures must be input in ascending order.

        Notes
        -----
        Defines the temperature table for safety factor calculations [SFACT,
        SALLOW].  Use STAT command to list current temperature table.  Repeat
        TALLOW command to zero table and redefine points (6 maximum).

        Safety factor calculations are not supported by PowerGraphics. Both the
        SALLOW and TALLOW commands must be used with the Full Model Graphics
        display method active.
        """
        command = "TALLOW,%s,%s,%s,%s,%s,%s" % (str(temp1), str(temp2), str(temp3), str(temp4), str(temp5), str(temp6))
        return self.run(command, **kwargs)

    def ancntr(self, nfram="", delay="", ncycl="", **kwargs):
        """APDL Command: ANCNTR

        Produces an animated sequence of a contoured deformed shape.

        Parameters
        ----------
        nfram
            Number of frames captures (defaults to 5).

        delay
            Time delay during animation (defaults to 0.1 seconds).

        ncycl
            Number of animation cycles (defaults to 5).  Available in non-UI
            mode only.

        Notes
        -----
        ANCNTR involves an ANSYS macro which produces an animation of a
        contoured deformed shape of the last plot action command.  This command
        operates only on graphic display platforms supporting the /SEG command.
        After executing ANCNTR, you can replay the animated sequence by issuing
        the ANIM command.

        The command functions only in the postprocessor.
        """
        command = "ANCNTR,%s,%s,%s" % (str(nfram), str(delay), str(ncycl))
        return self.run(command, **kwargs)

    def starstatus(self, par="", imin="", imax="", jmin="", jmax="", kmin="",
                   kmax="", lmin="", lmax="", mmin="", mmax="", kpri="",
                   **kwargs):
        """APDL Command: *STATUS

        Lists the current parameters and abbreviations.

        Parameters
        ----------
        par
            Specifies the parameter or sets of parameters listed. For array
            parameters, use IMIN, IMAX, etc. to specify ranges.  Use *DIM to
            define array parameters. Use *VEDIT to review array parameters
            interactively. Use *VWRITE to print array values in a formatted
            output. If Par is blank, list all scalar parameter values, array
            parameter dimensions, and abbreviations.  If ARGX, list the active
            set of local macro parameters (ARG1 to ARG9 and AR10 to AR99)
            [*USE].

            Lists all parameters (except local macro parameters and those with names beginning or ending with an underbar) and toolbar abbreviations. - Lists only parameters with names beginning with an underbar (_). These are
                              ANSYS internal parameters.

            Lists only parameters with names ending with an underbar (_). A good APDL programming convention is to ensure that all parameters created by your system programmer are named with a trailing underbar. - Lists all toolbar abbreviations.

            Lists all parameters (except local macro parameters and those with names beginning or ending with an underbar). - Lists all APDL Math parameters, including vectors, matrices, and linear
                              solvers.

            Lists only the parameter specified. PARNAME cannot be a local macro parameter name. - Lists all local macro parameter values (ARG1- AR99) that are non-zero or non-
                              blank.

        imin, imax, jmin, jmax, kmin, kmax, lmin, lmax, mmin, mmax
            Range of array elements to display (in terms of the dimensions
            (row, column, plane, book, and shelf).   Minimum values default to
            1.  Maximum values default to the maximum dimension values.  Zero
            may be input for IMIN, JMIN, and KMIN to display the index numbers.
            See *TAXIS  command to list index numbers of 4- and 5-D tables.

        kpri
            Use this field to list your primary variable labels (X, Y, Z, TIME,
            etc.).

            List the labels (default). YES, Y, or ON are also valid entries.  - Do not list the labels. NO, N, or OFF are also valid entries.

        Notes
        -----
        You cannot obtain the value for a single local parameter (e.g.,
        *STATUS,ARG2). You can only request all local parameters simultaneously
        using *STATUS,ARGX.

        This command is valid in any processor.
        """
        command = "*STATUS,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(par), str(imin), str(imax), str(jmin), str(jmax), str(kmin), str(kmax), str(lmin), str(lmax), str(mmin), str(mmax), str(kpri))
        return self.run(command, **kwargs)

    def magsolv(self, opt="", nramp="", cnvcsg="", cnvflux="", neqit="",
                biot="", cnvtol="", **kwargs):
        """APDL Command: MAGSOLV

        Specifies magnetic solution options and initiates the solution.

        Parameters
        ----------
        opt
            Static magnetic solution option:

            0 - Vector potential (MVP) or edge formulation  (default).

            1 - Combined vector potential and reduced scalar potential (MVP-RSP).

            2 - Reduced scalar potential (RSP).

            3 - Difference scalar potential (DSP).

            4 - General scalar potential (GSP).

        nramp
            Number of ramped substeps for the first load step of a nonlinear
            MVP or MVP-RSP solution.  Defaults to 3.  If NRAMP = -1, ignore the
            ramped load step entirely.NRAMP is ignored for linear
            magnetostatics.

        cnvcsg
            Tolerance value on the program-calculated reference value for the
            magnetic current-segment convergence.  Used for the MVP, the MVP-
            RSP, and the edge formulation solution options (OPT = 0 and 1).
            Defaults to 0.001.

        cnvflux
            Tolerance value on the program-calculated reference value for the
            magnetic flux convergence.  Used for all scalar potential solution
            options (OPT = 2, 3, 4).  Defaults to 0.001.

        neqit
            Maximum number of equilibrium iterations per load step.  Defaults
            to 25.

        biot
            Option to force execution of a Biot-Savart integral solution
            [BIOT,NEW] for the scalar potential options.  Required if multiple
            load steps are being performed with different current source
            primitives (SOURC36 elements).

            0 - Do not force execution of Biot-Savart calculation (default); Biot-Savart is
                automatically calculated only for the first solution.

            1 - Force execution of Biot-Savart calculation.

        cnvtol
            Sets the convergence tolerance for AMPS reaction. Defaults to 1e-3.

        Notes
        -----
        MAGSOLV invokes an ANSYS macro which specifies magnetic solution
        options and initiates the solution.  The macro is applicable to any
        ANSYS magnetostatic analysis using the magnetic vector potential (MVP),
        reduced scalar potential (RSP), difference scalar potential (DSP),
        general scalar potential (GSP), or combined MVP-RSP formulation
        options.  Results are only stored for the final converged solution.
        (In POST1, issue *SET,LIST to identify the load step of solution
        results.)  The macro internally determines if a nonlinear analysis is
        required based on magnetic material properties.

        If you use the BIOT option and issue SAVE after solution or
        postprocessing, the Biot-Savart calculations are saved to the database,
        but will be overwritten upon normal exit from the program.  To save
        this data after issuing SAVE, use the /EXIT,NOSAVE command.  You can
        also issue the /EXIT,SOLU command to exit ANSYS and save all solution
        data, including the Biot-Savart calculations, in the database.
        Otherwise, when you issue RESUME, the Biot-Savart calculation will be
        lost (resulting in a zero solution).

        The MVP, MVP-RSP, and edge formulation options perform a two-load-step
        solution sequence.  The first load step ramps the applied loads over a
        prescribed number of substeps (NRAMP), and the second load step
        calculates the converged solution.  For linear problems, only a single
        load step solution is performed.  The ramped load step can be bypassed
        by setting NRAMP to -1.

        The RSP option solves in a single load step using the adaptive descent
        procedure.  The DSP option uses two load steps, and the GSP solution
        uses three load steps.

        The following analysis options and nonlinear options are controlled by
        this macro:  KBC, NEQIT, NSUBST, CNVTOL, NROPT, MAGOPT, and OUTRES.

        You cannot use constraint equations with OPT = 4.
        """
        command = "MAGSOLV,%s,%s,%s,%s,%s,%s,%s" % (str(opt), str(nramp), str(cnvcsg), str(cnvflux), str(neqit), str(biot), str(cnvtol))
        return self.run(command, **kwargs)

    def clear(self, read="", **kwargs):
        """APDL Command: /CLEAR

        Clears the database.

        Parameters
        ----------
        read
            File read option:

            START - Reread start162.ans file (default).

            NOSTART - Do not reread start162.ans file.

        Notes
        -----
        Resets the ANSYS database to the conditions at the beginning of the
        problem.  Sets the import and Boolean options back to the ANSYS
        default. All items are deleted from the database and memory values are
        set to zero for items derived from database information.  All files are
        left intact.  This command is useful between multiple analyses in the
        same run, or between passes of a multipass analysis (such as between
        the substructure generation, use, and expansion passes).  Should not be
        used in a do-loop since loop counters will be reset.  The start162.ans
        file will be reread (by default) after the database is cleared, unless
        Read is set to NOSTART.  Additional commands cannot be stacked (using
        the $ separator) on the same line as the /CLEAR command.

        Use care when placing the /CLEAR command within branching constructs
        (for example, those employing *DO or *IF commands).  The command
        deletes all parameters including the looping parameter for do-loops.
        (You can preserve your iteration parameter by issuing a PARSAV command
        prior to the /CLEAR command, then following the /CLEAR command with a
        PARRES command.)

        /CLEAR resets the jobname to match the currently open session .LOG and
        .ERR files. This will return the jobname to its original value, or to
        the most recent value specified on /FILNAME with KEY = 1.

        This command is valid only at the Begin level.
        """
        command = "/CLEAR,%s" % (str(read))
        return self.run(command, **kwargs)

    def hrexp(self, angle="", **kwargs):
        """APDL Command: HREXP

        Specifies the phase angle for the harmonic analysis expansion pass.

        Parameters
        ----------
        angle
            Phase angle (degrees) for expansion pass.  If ALL (default), use
            both 0.0° (real) and 90.0° (imaginary) phase angles.

        Notes
        -----
        Specifies the phase angle where the expansion pass will be done for a
        harmonic mode-superposition expansion pass.

        For a specific angle, the following real solution is stored in the
        results (*.rst) file:

        Where:

        i is the degree of freedom number.

         is the amplitude of the i th degree of freedom solution

        Φi is the phase shift angle of the i th degree of freedom solution

        ϕ is the supplied phase shift angle (ANGLE)

        If ANGLE is ALL, both the real and imaginary parts of the solution are
        stored in the results file.

        For more details about the solution equations, see Harmonic Analyses in
        the Mechanical APDL Theory Reference.

        This command is ignored if the HROPT command has been issued with
        Method = VT or Method = VTRU.

        This command is also valid in PREP7.
        """
        command = "HREXP,%s" % (str(angle))
        return self.run(command, **kwargs)

    def ealive(self, elem="", **kwargs):
        """APDL Command: EALIVE

        Reactivates an element (for the birth and death capability).

        Parameters
        ----------
        elem
            Element to be reactivated:

            ALL  - Reactivates all selected elements (ESEL).

            P  - Enables graphical picking of elements. All remaining command fields are
                 ignored. (Valid only in the ANSYS GUI.)

            Comp - Specifies a component name.

        Notes
        -----
        Reactivates the specified element when the birth and death capability
        is being used. An element can be reactivated only after it has been
        deactivated (EKILL).

        Reactivated elements have a zero strain (or thermal heat storage, etc.)
        state.

        ANSYS, Inc. recommends using the element deactivation/reactivation
        procedure for analyses involving linear elastic materials only. Do not
        use element deactivation/reactivation in analyses involving time-
        dependent materials, such as viscoelasticity, viscoplasticity, and
        creep analysis.

        This command is also valid in PREP7.
        """
        command = "EALIVE,%s" % (str(elem))
        return self.run(command, **kwargs)

    def secstop(self, dof1="", minvalue1="", maxvalue1="", dof2="",
                minvalue2="", maxvalue2="", dof3="", minvalue3="",
                maxvalue3="", **kwargs):
        """APDL Command: SECSTOP

        Specifies stops on the components of relative motion in a joint
        element.

        Parameters
        ----------
        dof
            Local degree of freedom to be stopped.

        minvalue
            Low end of the range of allowed movement for the specified DOF.

        maxvalue
            High end of the range of allowed movement for the specified DOF.

        Notes
        -----
        Stops restrict motion in a DOF; motion beyond the MINVALUE or MAXVALUE
        is prevented (motion away from a limit is allowed). You can specify up
        to three stops. If necessary, you can repeat the command.
        """
        command = "SECSTOP,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(dof1), str(minvalue1), str(maxvalue1), str(dof2), str(minvalue2), str(maxvalue2), str(dof3), str(minvalue3), str(maxvalue3))
        return self.run(command, **kwargs)

    def inistate(self, action="", val1="", val2="", val3="", val4="", val5="",
                 val6="", val7="", val8="", val9="", **kwargs):
        """APDL Command: INISTATE

        Defines initial state data and parameters.

        Parameters
        ----------
        action
            Specifies action for defining or manipulating initial state data:

            SET - Use Action = SET to designate initial state coordinate system, data type, and
                  material type parameters. See "Command Specification for
                  Action = SET".

            DEFINE - Use Action = DEFINE to specify the actual state values, and the corresponding
                     element, integration point, or layer information. See
                     "Command Specifications for Action = DEFINE".

            WRITE - Use Action = WRITE to write the initial state values to a file when the SOLVE
                    command is issued. See "Command Specifications for Action =
                    WRITE".

            READ - Use Action = READ to read the initial state values from a file. See "Command
                   Specifications for Action = READ".

            LIST - Use Action = LIST  to read out the initial state data. See "Command
                   Specifications for Action = LIST".

            DELETE - Use Action = DELE to delete initial state data from a selected set of elements.
                     See "Command Specifications for Action = DELETE"

        val1, val2, ..., val9
            Input values based on the Action type.

        Notes
        -----
        The INISTATE command is available for current-technology elements.
        Initial state supported for a given element is indicated in the
        documentation for the element under “Special Features.”

        The command is not for use with kinematic hardening material properties
        (TB,BKIN, TB,KINH, TB,PLAS,,,,KINH) or the shape memory alloy material
        model (TB,SMA).

        INISTATE with elastic strain alone is not supported for gasket
        materials (TB,GASK) and hyperelastic materials (TB,HYPER, TB,BB,
        TB,AHYPER, TB,CDM, TB,EXPE).

        INISTATE with initial stress alone is not supported for gasket
        materials (TB,GASK).

        INISTATE with plastic strain (which must include initial strain or
        stress, plastic strain, and accumulated plastic strain) does not
        support gasket materials (TB,GASK), porous media (TB,PM), rate-
        dependent plasticity (TB,RATE), and viscoplasticity (TB,PRONY,
        TB,SHIFT).

        For detailed information about using the initial state capability, see
        Initial State in the Basic Analysis Guide.
        """
        command = "INISTATE,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(action), str(val1), str(val2), str(val3), str(val4), str(val5), str(val6), str(val7), str(val8), str(val9))
        return self.run(command, **kwargs)

    def plnear(self, lab="", opt="", kcn="", val1="", val2="", val3="",
               val4="", val5="", val6="", val7="", val8="", val9="", **kwargs):
        """APDL Command: PLNEAR

        Plots the pressure in the near zone exterior to the equivalent source
        surface.

        Parameters
        ----------
        lab
            Plot the maximum pressure or sound pressure level:

            SPHERE - on the spherical structure

            PATH - along the path

        opt
            PSUM

            PSUM  - Maximum complex pressure for acoustics.

            PHAS  - Phase angle of complex pressure for acoustics.

            SPL  - Sound pressure level for acoustics.

            SPLA - A-weighted sound pressure level for acoustics (dBA).

        kcn
            KCN is the coordinate system reference number. It may be 0
            (Cartesian) or any previously defined local coordinate system
            number (>10). Defaults to 0.

        val1, val2, val3, . . . , val9
            For LAB = SPHERE:

            VAL1 - Radius of spherical surface in spherical coordinate system.

            VAL2 - Starting φ angle (degree) in the spherical coordinate system. Defaults to 0.

            VAL3 - Ending φ angle (degree) in the spherical coordinate system. Defaults to 0.

            VAL4 - Number of divisions between the starting and ending φ angles for data
                   computations. Defaults to 0.

            VAL5 - Starting θ angle (degrees) in the spherical coordinate system. Defaults to 0 in
                   3-D and 90 in 2-D extension.

            VAL6 - Ending θ angle (degrees) in the spherical coordinate system. Defaults to 0 in
                   3-D and 90 in 2-D extension.

            VAL7 - Number of divisions between the starting and ending θ angles for data
                   computations. Defaults to 0.

            VAL8 - Reference rms sound pressure. Defaults to 2x10-5 Pa.

            VAL9 - Thickness of 2-D model extension in z direction (defaults to 0).

        Notes
        -----
        PLNEAR uses the equivalent source principle to calculate the pressure
        in the near zone exterior to the equivalent source surface (flagged
        with the Maxwell surface flag in the preprocessor) for one of the
        following locations:

        A spherical surface in the KCN coordinate system

        A path defined by the PATH and PPATH commands

        To plot the pressure results for a path, use the PLPAGM or PLPATH
        commands. See the HFSYM command for the model symmetry.

        To retrieve saved equivalent source data, issue the
        SET,Lstep,Sbstep,,REAL command.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "PLNEAR,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(lab), str(opt), str(kcn), str(val1), str(val2), str(val3), str(val4), str(val5), str(val6), str(val7), str(val8), str(val9))
        return self.run(command, **kwargs)

    def escheck(self, sele="", levl="", defkey="", **kwargs):
        """APDL Command: ESCHECK

        Perform element shape checking for a selected element set.

        Parameters
        ----------
        sele
            Specifies whether to select elements for checking:

            (blank) - List all warnings/errors from element shape checking.

            ESEL - Select the elements based on the .Levl criteria specified below.

        levl
            WARN

            WARN - Select elements producing warning and error messages.

            ERR - Select only elements producing error messages (default).

        defkey
            Specifies whether check should be performed on deformed element
            shapes. .

            0 - Do not update node coordinates before performing shape checks (default).

            1 - Update node coordinates using the current set of deformations in the database.

        Notes
        -----
        Shape checking will occur according to the current SHPP settings.
        Although ESCHECK is valid in all processors, Defkey  uses the current
        results in the database. If no results are available a warning will be
        issued.

        This command is also valid in PREP7, SOLUTION and POST1.
        """
        command = "ESCHECK,%s,%s,%s" % (str(sele), str(levl), str(defkey))
        return self.run(command, **kwargs)

    def starexit(self, **kwargs):
        """APDL Command: *EXIT

        Exits a do-loop.

        Notes
        -----
        The command following the *ENDDO is executed next. The exit option may
        also be conditional [Use the *IF].  The *EXIT command must appear on
        the same file as the  *DO command.

        This command is valid in any processor.
        """
        command = "*EXIT," % ()
        return self.run(command, **kwargs)

    def color(self, lab="", clab="", n1="", n2="", ninc="", **kwargs):
        """APDL Command: /COLOR

        Specifies the color mapping for various items.

        Parameters
        ----------
        lab
            Apply color to the items specified by the following labels:

            AXES - Determines the color (specified in next argument, Clab) that the axes of a
                   graph will be plotted in.

            AXNUM - Determines the color (specified in next argument, Clab) that the numbering on
                    the axes of a graph will be plotted in.

            NUM - Discretely numbered items (such as element types, element materials, etc., as
                  shown on the /PNUM command).  Also specify number (1 to 11)
                  in the N1 field.  For example, /COLOR,NUM,RED,3 will assign
                  the color red to all items having the discrete number 3
                  (material displays would show elements having material 3 as
                  red).

            OUTL - Outline of elements, areas, and volumes.  Ex: /COLOR,OUTL,BLUE.

            ELEM - Elements. Use N1, N2, NINC fields for element numbers.

            LINE - Solid model lines.  Use N1, N2, NINC fields for line numbers.

            AREA - Solid model areas.  Use N1, N2, NINC fields for area numbers.

            VOLU - Solid model volumes.  Use N1, N2, NINC fields for volume numbers.

            ISURF - Isosurfaces (surfaces of constant stress, etc.).   This option is particularly
                    useful when capturing frames for animating a single
                    isosurface value.

            WBAK - Window background.  Use N1, N2, NINC fields for window numbers. The options
                   that you select using Lab = PBAK will supersede those
                   applied using Lab = WBAK.

            b.c.label - Boundary condition label.  Enter U, ROT, TEMP, PRES, V, VOLT, MAG, A, EMF,
                        CURR, F, M, HEAT, FLOW, VF, AMPS, FLUX, CSG, CURT,
                        VLTG, MAST, CP, CE, NFOR, NMOM, RFOR, RMOM, PATH. See
                        the /PBC command for boundary condition label
                        definitions.

            GRBAK - Graph background.

            GRID - Graph grid lines.

            AXLAB - Graph X and Y axis labels.

            CURVE - Graph curves (identify curve numbers (1-10) in N1, N2, NINC fields).

            CM - Component group.  Use N1 field for component name, ignore N2 and NINC.

            CNTR - ANSYS contour stress colors.  The maximum number of contours available is 128.
                   The number of colors that can be specified interactively
                   (GUI) is 9. (/CONTOUR, , 9). Any other setting will yield
                   inconsistent results.

            SMAX - Specifies that all stress values above the maximum value entered in /CONTOUR
                   will be displayed in the color designated in the Clab field.
                   Defaults to dark grey.

            SMIN - Specifies that all stress values below the minimum value entered in /CONTOUR
                   will be displayed in the color designated in the Clab field.
                   Defaults to dark grey.

            PBAK - Activates background shading options (see command syntax at end of argument
                   descriptions below). The options that you select using Lab =
                   PBAK will supersede those applied using Lab = WBAK.

        clab
            Valid color labels are:

            BLAC (0) - Black

            MRED (1) - Magenta-Red

            MAGE (2) - Magenta

            BMAG (3) - Blue-Magenta

            BLUE (4) - Blue

            CBLU (5) - Cyan-Blue

            CYAN (6) - Cyan

            GCYA ((7) - Green-Cyan

            GREE (8) - Green

            YGRE (9) - Yellow-Green

            YELL (10) - Yellow

            ORAN (11) - Orange

            RED (12) - Red

            DGRA (13) - Dark Gray

            LGRA (14) - Light Gray

            WHIT (15) - White

        n1, n2, ninc
            Apply color to Lab items numbered N1 to N2 (defaults to N1) in
            steps of NINC (defaults to 1).  If N1 is blank, apply color to
            entire selected range.  If Lab is CM, use component name for N1 and
            ignore N2 and NINC.  If N1 = P, graphical picking of elements,
            lines, areas and volumes is enabled; your can assign colors to the
            entities via the picker. When picking is enabled, the Lab and Clab
            fields are ignored.
        """
        command = "/COLOR,%s,%s,%s,%s,%s" % (str(lab), str(clab), str(n1), str(n2), str(ninc))
        return self.run(command, **kwargs)

    def dig(self, node1="", node2="", ninc="", **kwargs):
        """APDL Command: DIG

        Digitizes nodes to a surface.

        Parameters
        ----------
        node1, node2, ninc
            Digitize nodes NODE1 through NODE2 in steps of NINC.  NODE2
            defaults to NODE1 and NINC defaults to 1.

        Notes
        -----
        Digitizes nodes to the surface defined by the DSURF command.  The nodes
        indicated must be digitized from the tablet after this command is
        given.  The program must be in the interactive mode and the graphics
        terminal show option [/SHOW] must be active.  The global Cartesian
        coordinates of the nodes are stored.
        """
        command = "DIG,%s,%s,%s" % (str(node1), str(node2), str(ninc))
        return self.run(command, **kwargs)

    def anstoasas(self, fname="", key="", **kwargs):
        """APDL Command: ANSTOASAS

        Creates an ASAS input file from the current ANSYS model.

        Parameters
        ----------
        fname
            ASAS file name. Defaults to Jobname.

        key
            Key indicating type of file to produce:

            0 - ASAS file for use by ANSYS Aqwa (no loads written). Creates the file
                Fname.asas.

            1 - ASAS file (all data written, including loads). Creates the file Fname.asas.

            2 - ASAS(NL) file. Creates the file Fname.asnl.

        Notes
        -----
        This command creates an input file for the ANSYS Asas Finite Element
        Analysis System from the model and loads currently in the database,
        based on the currently selected set of elements. Most common structural
        element types are written, as well as sections (or real constants),
        materials, boundary conditions and loads, and solution and load step
        options.

        Data Written

        The following data is written:

        Solution control options

        Nodes

        Elements

        Material data

        Geometry data

        Section data

        ANSYS element components (ASAS sets)

        Boundary conditions

        Loads

        Added mass (via MASS21 element)

        Details are provided in the following sections.

        Not all data is written. You must verify the completeness and accuracy
        of the data. Only loading at the current step is transferred; hence, no
        load step history is captured.

        Solution Control Options

        The ASAS project name is defined as "ANSYS".

        The solution control options are converted as follows:

        JOB: STAT SPIT: KGEOM

        JOB: STAT SPIT: KGEOM

        For conversion to ASAS(NL), the large displacement option is set based
        on NLGEOM, final load solution time is set based on TIME, and sub-step
        times are set based on DELTIM or NSUBST (assuming constant step size).

        Element Data

        If you intend to use the data only with AQWA-WAVE, only the elements
        that form the wetted surface are required.  Selecting these elements
        before invoking the ANSTOASAS command will improve performance.  In
        order for AQWA-WAVE to identify the direction of the wave loading, all
        elements must be defined by nodes in a clockwise direction. For further
        information, refer to the AQWA-WAVE manual.

        The element types are converted as follows:

        SPR1:  SPR2: if: rotational: spring:  FLA2: (ASAS(L): only):  if:
        nodes: are: not: coincident:  and: longitudinal: spring:

        QUM4:  TRM3: -: if: Triangular

        BRK8:  TET4: -: if: Tetrahedral:  BRK6: -: if: Prism

        QUS4:  TBC3: -: if: Triangular

        QUM8:  TRM6: -: if: Triangular

        BR20:  TE10: -: if: Tetrahedral: :  BR15: -: if: Prism

        QUS4:  TBC3: -: if: Triangular

        QUM4:  TRM3: -: if: Triangular

        QUM8:  TRM6: -: if: Triangular

        BRK8:  TET4: -: if: Tetrahedral:  BRK6: -: if: Prism

        BR20:  TE10: -: if: Tetrahedral:  BR15: -: if: Prism

        TCBM: -: if: ASAS(L):  STF4: -: if: ASAS(NL)

        Documentation for this legacy element type appears in the Feature
        Archive.

        Material Data

        Linear isotropic material conversion is supported for ASAS and
        ASAS(NL).

        Geometry Data
        """
        command = "ANSTOASAS,%s,%s" % (str(fname), str(key))
        return self.run(command, **kwargs)

    def mshcopy(self, keyla="", laptrn="", lacopy="", kcn="", dx="", dy="",
                dz="", tol="", low="", high="", **kwargs):
        """APDL Command: MSHCOPY

        Simplifies the generation of meshes that have matching node element
        patterns on two different line groups (in 2-D) or area groups (3-D).

        Parameters
        ----------
        keyla
            Copy line mesh (default) if LINE, 0 or 1. Copy area mesh if AREA,
            or 2.

        laptrn
            Meshed line/area to be copied, or a component name containing a
            list. If LAPTRN = P, graphical picking is enabled (valid only in
            the GUI).

        lacopy
            Unmeshed line/area to get copied mesh, or a component name
            containing a list. If LACOPY = P, graphical picking is enabled
            (valid only in the GUI).

        kcn
            In coordinate system KCN, LAPTRN + DX DY DZ = LACOPY.

        dx, dy, dz
            Node location increments in the active coordinate system (DR, Dθ,
            DZ for cylindrical, DR, Dθ, DΦ for spherical or toroidal).

        tol
            Tolerance. Defaults to 1.e--4.

        low
            Name of low node component to be defined (optional).

        high
            Name of high node component to be defined (optional).

        Notes
        -----
        Matching meshes are used for rotational (cyclic) symmetry, or for
        contact analysis using coupling or node-to-node gap elements. See Using
        CPCYC and MSHCOPY Commands in the Modeling and Meshing Guide for more
        information.
        """
        command = "MSHCOPY,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(keyla), str(laptrn), str(lacopy), str(kcn), str(dx), str(dy), str(dz), str(tol), str(low), str(high))
        return self.run(command, **kwargs)

    def edipart(self, part="", option="", cvect="", tm="", ircs="", ivect="",
                vvect="", cid="", **kwargs):
        """APDL Command: EDIPART

        Defines inertia for rigid parts in an explicit dynamics analysis.

        Parameters
        ----------
        part
            Part number for which the inertia is defined (the part number must
            have been previously generated using the EDPART command).  The part
            should be composed of a rigid material (EDMP,RIGID). For Option =
            ADD, you must input a value; there is no default. For Option = DELE
            or LIST, PART defaults to all parts.

        option


            ADD - Define inertia for the specified PART (default).

            DELE - Delete the inertia properties for the specified PART. The remaining fields are
                   ignored. If PART is blank, inertia properties previously
                   specified using EDIPART are deleted for all rigid parts.

            LIST - List the inertia properties for the specified PART. The remaining fields are
                   ignored. If PART is blank, inertia properties are listed for
                   all rigid parts.

        cvect
            The vector containing the global Cartesian coordinates of the
            center of mass for the part. This vector must have been previously
            defined with a dimension of three (*DIM command) and filled in as
            shown below. If Cvect is blank, the global Cartesian origin (0,0,0)
            is used as the center of mass.

        tm
            Translation mass (no default, must be defined).

        ircs
            Flag for inertia tensor reference coordinate system.

            0 (or blank) - Global inertia tensor (default). You must supply all six inertia tensor
                           components (see Ivect).

            1 - Principal moments of inertia with orientation vectors. You must supply IXX,
                IYY, IZZ (see Ivect) and CID.

        ivect
            The name of a vector containing the components of the inertia
            tensor. This vector must have been previously defined (*DIM
            command) with a dimension of six and filled in as shown below.
            Vector entries 2, 3, and 5 are ignored if IRCS = 1. There is no
            default for this vector; it must be specified.

        vvect
            The name of a vector containing the initial velocity (relative to
            the global Cartesian coordinate system) of the rigid part. This
            vector must have been previously defined (*DIM command) with a
            dimension of six and filled in as shown below. If Vvect is blank,
            the initial velocity defaults to zero.

        cid
            Local coordinate system ID. This coordinate system must have been
            previously defined with the EDLCS command. You must input CID if
            IRCS = 1 (no default).

        Notes
        -----
        The EDIPART command applies only to rigid parts (EDMP,RIGID). It allows
        you to input the inertia properties for the rigid part rather than
        having the program calculate the properties from the finite element
        mesh.

        This command is also valid in Solution.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDIPART,%s,%s,%s,%s,%s,%s,%s,%s" % (str(part), str(option), str(cvect), str(tm), str(ircs), str(ivect), str(vvect), str(cid))
        return self.run(command, **kwargs)

    def rmlvscale(self, nload="", fact1="", fact2="", fact3="", fact4="",
                  fact5="", **kwargs):
        """APDL Command: RMLVSCALE

        Defines element load vector scaling for a ROM use pass.

        Parameters
        ----------
        nload
            Total number of load cases to be considered within a ROM use pass.
            If Nload = "DELETE", all defined load vectors are deleted.

        fact1, fact2, fact3, . . . , fact5
            Scale factors applied to load vectors (maximum 5). Defaults to 0.

        Notes
        -----
        Specifies the element load scale factor applied to a ROM analysis use
        pass.  Element load vectors are extracted from a Static Analysis using
        the RMNDISP command. Up to 5 element load vectors may be scaled and
        applied to a ROM use pass.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMLVSCALE,%s,%s,%s,%s,%s,%s" % (str(nload), str(fact1), str(fact2), str(fact3), str(fact4), str(fact5))
        return self.run(command, **kwargs)

    def prenergy(self, energytype="", cname1="", cname2="", cname3="",
                 cname4="", cname5="", cname6="", **kwargs):
        """APDL Command: PRENERGY

        Prints the total energies of a model or the energies of the specified
        components.

        Parameters
        ----------
        energytype
            Type of energies to be printed:

            ALL - All energies are printed: potential, kinetic, artificial hourglass/drill
                  stiffness, contact stabilization energy, and artificial
                  stabilization energy when applicable. This is the default.

            SENE - Potential energy.

            KENE - Kinetic energy.

        cname1, cname2, cname3,…
            Component names for energies of the components printout.

        Notes
        -----
        The PRENERGY command prints out either the total energies of the entire
        model or the energies of the components depending on the Cname1
        specification.

        Only existing components based on elements (defined with the CM
        command) are supported when component energies are listed.

        This command applies to structural elements only.
        """
        command = "PRENERGY,%s,%s,%s,%s,%s,%s,%s" % (str(energytype), str(cname1), str(cname2), str(cname3), str(cname4), str(cname5), str(cname6))
        return self.run(command, **kwargs)

    def ednb(self, option="", cname="", ad="", _as="", **kwargs):
        """APDL Command: EDNB

        Defines a nonreflecting boundary in an explicit dynamic analysis.

        Parameters
        ----------
        option
             Label identifying the nonreflecting boundary option to be
            performed.

            ADD - Define a nonreflecting boundary (default).

            DELE - Delete a nonreflecting boundary.

            LIST - List all defined nonreflecting boundaries (remaining fields are ignored).

        cname
            Name of existing nodal component to which the nonreflecting
            boundary is to be added or deleted. For Option = DELE, use Cname =
            ALL to delete all defined nonreflecting boundaries.

        ad
            Activation flag for dilatational waves (dampers normal to waves).

            0 - Dilatational activation flag is off (default).

            1 - Dilatational activation flag is on.

        as
            Activation flag for shear waves (dampers tangent to waves).

            0 - Shear activation flag is off (default).

            1 - Shear activation flag is on.

        Notes
        -----
        Nonreflecting boundaries can be defined on the external surfaces of
        SOLID164 and SOLID168 elements that are being used to model an infinite
        domain. They are typically used in geomechanical applications to limit
        the size of the model. For example, when a half space is being modeled
        with a finite geometry, the nonreflecting boundary option can be used
        to prevent artificial stress wave reflections generated at the boundary
        from reentering the model and contaminating the results.

        When using nonreflecting boundaries, you should not constrain the nodes
        at the boundary; doing so would negate the presence of the dampers.
        Usually, the large mass of the finite domain is sufficient to resist
        motion.

        This command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDNB,%s,%s,%s,%s" % (str(option), str(cname), str(ad), str(_as))
        return self.run(command, **kwargs)

    def annot(self, lab="", val1="", val2="", **kwargs):
        """APDL Command: /ANNOT

        Activates graphics for annotating displays (GUI).

        Parameters
        ----------
        lab
            Annotation control key:

            OFF - Turns off annotation for each subsequent display (default).

            ON - Turns on annotation for each subsequent display.

            DELE - Deletes all annotation.

            SAVE - Saves annotation on a file.  Use VAL1 for file name (defaults to Jobname) and
                   VAL2 for the extension (defaults to ANO).

            SCALE - Sets annotation scale factor (direct input only).  Use VAL1 for value (0.1 to
                    10.0) (defaults to 1.0).

            XORIG - Sets the annotation x origin (direct input only).  Use VAL1 for value (-3.0 to
                    3.0).

            YORIG - Sets annotation y origin (direct input only).  Use VAL1 for value (-3.0 to
                    3.0).

            SNAP - Sets annotation snap (menu button input only).  Use VAL1 for value (0.002 to
                   0.2) (defaults to 0.002).

            STAT - Displays current annotation status.

            DEFA - Sets annotation specifications to the default values.

            REFR - Redisplays annotation graphics.

            TMOD - Sets the annotation text mode. If VAL1 = 1, annotation text will be drawn in
                   scalable bitmap fonts (default). If VAL1 = 0, annotation
                   text will be drawn with stroke text.

        val1
            Value (or file name) as noted with label above.

        val2
            Value (or file name extension) as noted with label above.

        Notes
        -----
        This is a command generated by the GUI and will appear in the log file
        (Jobname.LOG) if annotation is used.  This command is not intended to
        be typed in directly in an ANSYS session (although it can be included
        in an input file for batch input or for use with the /INPUT command).

        You cannot use the “!” and “$” characters in ANSYS text annotation.

        /ANNOT activates annotation graphics for adding annotation to displays.
        Commands representing the annotation instructions are automatically
        created by the annotation functions in the GUI and written to
        Jobname.LOG.  The annotation commands are /ANNOT, /ANUM, /TLABEL,
        /LINE, /LARC, /LSYMBOL, /POLYGON, /PMORE, /PCIRCLE, /PWEDGE, /TSPEC,
        /LSPEC, and /PSPEC.  Annotation graphics are relative to the full
        Graphics Window and are not affected by ANSYS window-specific commands
        (/WINDOW, /VIEW, etc.).

        This command is valid in any processor.
        """
        command = "/ANNOT,%s,%s,%s" % (str(lab), str(val1), str(val2))
        return self.run(command, **kwargs)

    def mfpsimul(self, gname="", fname1="", fname2="", **kwargs):
        """APDL Command: MFPSIMUL

        Sets up a field solver group to simultaneously process with code
        coupling analyses.

        Parameters
        ----------
        gname
            Sets the group name with a character string of up to 80 characters.

        fname1, fname2
            Sets the field solver 1 and field solver 2 names, which are
            processed simultaneously, with a character string of up to 80
            characters.

        Notes
        -----
        This command is used to define a group of simultaneously-processed
        field solvers in an MFX analysis. For example, to define group g1 with
        field solvers ansys-code and cfx-code, enter MFPS,g1,ansys-code,cfx-
        code.

        To indicate groups of sequentially-processed field solvers for your MFX
        analysis, create two groups (g1 and g2).

        A field solver refers to a specific instance of an ANSYS or CFX solver
        execution that is defined by the respective input file(s) referenced
        when starting the solver (through the launcher or from the command
        line). The field solver names that are referenced in several MFX
        commands must be consistent with the names that will be used when
        starting the coupled simulation.

        Note:: : When running MFX from the launcher, you must use ANSYS and CFX
        (uppercase) as the field solver names (MFPSIMUL) in your input file.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFPSIMUL,%s,%s,%s" % (str(gname), str(fname1), str(fname2))
        return self.run(command, **kwargs)

    def dk(self, kpoi="", lab="", value="", value2="", kexpnd="", lab2="",
           lab3="", lab4="", lab5="", lab6="", **kwargs):
        """APDL Command: DK

        Defines DOF constraints at keypoints.

        Parameters
        ----------
        kpoi
            Keypoint at which constraint is to be specified.  If ALL, apply to
            all selected keypoints [KSEL].  If KPOI = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for KPOI.

        lab
            Valid degree of freedom label.  If ALL, use all appropriate labels
            except HDSP.  Structural labels:  UX, UY, or UZ (displacements);
            ROTX, ROTY, or ROTZ (rotations); WARP (warping); HDSP (hydrostatic
            pressure).  Thermal labels: TEMP, TBOT, TE2, TE3, . . ., TTOP
            (temperature). Acoustic labels:  PRES (pressure); UX, UY, or UZ
            (displacements for FSI coupled elements). Electric labels:  VOLT
            (voltage). Magnetic labels:  MAG (scalar magnetic potential); AX,
            AY, or AZ (vector magnetic potentials). Diffusion labels: CONC
            (concentration).

        value
            Degree of freedom value or table name reference for tabular
            boundary conditions.  To specify a table, enclose the table name in
            percent signs (%) (e.g., DK,NODE,TEMP,%tabname%).  Use the *DIM
            command to define a table.

        value2
            Second degree of freedom value (if any).  If the analysis type and
            the degree of freedom allow a complex input, VALUE (above) is the
            real component and VALUE2 is the imaginary component.

        kexpnd
            Expansion key:

            0 - Constraint applies only to the node at this keypoint.

            1 - Flags this keypoint for constraint expansion.

        lab2, lab3, lab4, . . . ,  lab6
            Additional degree of freedom labels.  The same values are applied
            to the keypoints for these labels.

        Notes
        -----
        A keypoint may be flagged using KEXPND to allow its constraints to be
        expanded to nodes on the attached solid model entities having similarly
        flagged keypoint constraints.  Constraints are transferred from
        keypoints to nodes with the DTRAN or SBCTRAN commands.  The expansion
        uses interpolation to apply constraints to the nodes on the lines
        between flagged keypoints.  If all keypoints of an area or volume
        region are flagged and the constraints (label and values) are equal,
        the constraints are applied to the interior nodes of the region.  See
        the D command for a description of nodal constraints.

        Tabular boundary conditions (VALUE = %tabname%) are available only for
        the following degree of freedom labels: Electric (VOLT), structural
        (UX, UY, UZ, ROTX, ROTY, ROTZ), Acoustic (PRES, UX, UY, UZ), and
        temperature (TEMP, TBOT, TE2, TE3, . . ., TTOP).

        Constraints specified by the DK command can conflict with other
        specified constraints.  See Resolution of Conflicting Constraint
        Specifications in the Basic Analysis Guide for details.

        This command is also valid in PREP7.
        """
        command = "DK,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(kpoi), str(lab), str(value), str(value2), str(kexpnd), str(lab2), str(lab3), str(lab4), str(lab5), str(lab6))
        return self.run(command, **kwargs)

    def prange(self, linc="", vmin="", vmax="", xvar="", **kwargs):
        """APDL Command: PRANGE

        Determines the path range.

        Parameters
        ----------
        linc, vmin, vmax
            Set the range for listing or displaying the table locations between
            a minimum value (VMIN) and a maximum value (VMAX) of the path
            distance with a location increment of LINC (defaults to 1).  The
            first location begins at VMIN.

        xvar
            Path variable item to be used as the x-axis plot variable.  Any
            valid path variable may be used (PDEF command).  Default variable
            is the path distance, S.

        Notes
        -----
        Determines the path distance range for use with the PRPATH and PLPATH
        commands.
        """
        command = "PRANGE,%s,%s,%s,%s" % (str(linc), str(vmin), str(vmax), str(xvar))
        return self.run(command, **kwargs)

    def ainp(self, na1="", na2="", na3="", na4="", na5="", na6="", na7="",
             na8="", na9="", **kwargs):
        """APDL Command: AINP

        Finds the pairwise intersection of areas.

        Parameters
        ----------
        na1, na2, na3, . . . , na9
            Numbers of areas to be intersected pairwise.  If NA1 = ALL, NA2 to
            NA9 are ignored and the pairwise intersection of all selected areas
            is found.  If NA1 = P, graphical picking is enabled and all
            remaining arguments are ignored (valid only in the GUI).  A
            component name may be substituted for NA1.

        Notes
        -----
        Finds the pairwise intersection of areas.  The pairwise intersection is
        defined as all regions shared by any two or more areas listed on this
        command.  New areas will be generated where the original areas
        intersect pairwise.  If the regions of pairwise intersection are only
        lines, new lines will be generated.  See the Modeling and Meshing Guide
        for an illustration.  See the BOPTN command for the options available
        to Boolean operations.  Element attributes and solid model boundary
        conditions assigned to the original entities will not be transferred to
        the new entities generated.
        """
        command = "AINP,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(na1), str(na2), str(na3), str(na4), str(na5), str(na6), str(na7), str(na8), str(na9))
        return self.run(command, **kwargs)

    def digit(self, **kwargs):
        """APDL Command: DIGIT

        Specifies "Node digitizing" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "DIGIT," % ()
        return self.run(command, **kwargs)

    def cpdele(self, nset1="", nset2="", ninc="", nsel="", **kwargs):
        """APDL Command: CPDELE

        Deletes coupled degree of freedom sets.

        Parameters
        ----------
        nset1, nset2, ninc
            Delete coupled sets from NSET1 to NSET2 (defaults to NSET1) in
            steps of NINC (defaults to 1).  If NSET1 = ALL, NSET2 and NINC are
            ignored and all coupled sets are deleted.

        nsel
            Additional node selection control:

            ANY - Delete coupled set if any of the selected nodes are in the set (default).

            ALL - Delete coupled set only if all of the selected nodes are in the set.

        Notes
        -----
        See the CP command for a method to delete individual nodes from a set.
        """
        command = "CPDELE,%s,%s,%s,%s" % (str(nset1), str(nset2), str(ninc), str(nsel))
        return self.run(command, **kwargs)

    def lswrite(self, lsnum="", **kwargs):
        """APDL Command: LSWRITE

        Writes load and load step option data to a file.

        Parameters
        ----------
        lsnum
            Number to be assigned to the load step file name for identification
            purposes.  Defaults to 1 + highest LSNUM used in the current
            session.  Issue LSWRITE,STAT to list the current value of LSNUM.
            Issue LSWRITE,INIT to reset to 1.  The load step file will be named
            Jobname.Sn, where n is the specified LSNUM value (preceded by "0"
            for values 1-9).  On systems with a 3-character limit on the file
            name extension, the "S" is dropped for LSNUM > 99.

        Notes
        -----
        Writes all load and load step option data for the selected model to a
        load step file for later use.  LSWRITE does not capture changes made to
        real constants (R), material properties (MP), couplings (CP), or
        constraint equations (CE).

        Solid model loads will not be saved if the model is not meshed. Solid
        model loads, if any, are transferred to the finite element model. Issue
        LSCLEAR,FE to delete finite element loads.

        One file is written for each load step. Use the LSREAD command to read
        a single load step file, and the LSDELE command to delete load step
        files.  Use the LSSOLVE command to read and solve the load steps
        sequentially.

        Solution control commands are typically not written to the file unless
        you specifically change a default solution setting.

        LSWRITE does not support the following commands: DJ, FJ, GSBDATA,
        GSGDATA, ESTIF, EKILL, EALIVE, MPCHG, and OUTRES. These commands will
        not be written to the load step file.

        LSWRITE cannot be used with the birth-death option.

        This command is also valid in PREP7.
        """
        command = "LSWRITE,%s" % (str(lsnum))
        return self.run(command, **kwargs)

    def xrange(self, xmin="", xmax="", **kwargs):
        """APDL Command: /XRANGE

        Specifies a linear abscissa (X) scale range.

        Parameters
        ----------
        xmin
            Minimum abscissa scale value.

        xmax
            Maximum abscissa scale value.

        Notes
        -----
        Specifies a linear abscissa (X) scale range for the line graph display.
        Use /XRANGE,DEFAULT to return to automatic scaling.

        Automatic scaling will often yield inappropriate range values for
        logarithmic scales (/GROPT, LOGX).

        This command is valid in any processor.
        """
        command = "/XRANGE,%s,%s" % (str(xmin), str(xmax))
        return self.run(command, **kwargs)

    def numstr(self, label="", value="", **kwargs):
        """APDL Command: NUMSTR

        Establishes starting numbers for automatically numbered items.

        Parameters
        ----------
        label
            Apply starting number to one of the following sets of items:

            NODE - Node numbers.  Value defaults (and is continually reset) to 1 + maximum node
                   number in model.  Cannot be reset lower.

            ELEM - Element numbers.  Value defaults (and is continually reset) to 1 + maximum
                   element number in model.  Cannot be reset lower.

            KP - Keypoint numbers.  Value defaults to 1.  Only undefined numbers are used.
                 Existing keypoints are not overwritten.

            LINE - Line numbers.  Value defaults to 1.  Only undefined numbers are used.  Existing
                   lines are not overwritten.

            AREA - Area numbers.  Value defaults to 1.  Only undefined numbers are used.  Existing
                   areas are not overwritten.

            VOLU - Volume numbers.  Value defaults to 1.  Only undefined numbers are used.
                   Existing volumes are not overwritten.

            DEFA - Default.  Returns all starting numbers to their default values.

        value
            Starting number value.

        Notes
        -----
        Establishes starting numbers for various items that may have numbers
        automatically assigned (such as element numbers with the EGEN command,
        and node and solid model entity numbers with the mesh [AMESH, VMESH,
        etc.] commands).  Use NUMSTR,STAT to display settings.  Use NUMSTR,DEFA
        to reset all specifications back to defaults.  Defaults may be lowered
        by deleting and compressing items (i.e., NDELE and NUMCMP,NODE for
        nodes, etc.).

        Note:: : A mesh clear operation (VCLEAR, ACLEAR, LCLEAR, and KCLEAR)
        automatically sets starting node and element numbers to the highest
        unused numbers.  If a specific starting node or element number is
        desired, issue NUMSTR after the clear operation.
        """
        command = "NUMSTR,%s,%s" % (str(label), str(value))
        return self.run(command, **kwargs)

    def edcrb(self, option="", neqn="", partm="", parts="", **kwargs):
        """APDL Command: EDCRB

        Constrains two rigid bodies to act as one in an explicit dynamics
        analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed:

            ADD - Define an equation to constrain two rigid bodies (default).

            DELE - Delete the equation (specified by NEQN) that constrains two rigid bodies. If
                   NEQN is blank, all equations constraining rigid bodies are
                   deleted.

            LIST - List constrained rigid bodies specified by NEQN. If NEQN is blank, all
                   constrained rigid bodies are listed.

        neqn
            Equation reference number. Defaults to PARTS.  NEQN should be a
            unique number for each pair of PARTM and PARTS. If it is not
            unique, the equation reference number defined last will overwrite
            any previously defined NEQN with the same number.

        partm
            PART number [EDPART] identifying the master rigid body. This value
            is ignored if the DELE or LIST labels are specified. No default;
            you must enter a value.

        parts
            PART number [EDPART] identifying the slave rigid body. This value
            is ignored if the DELE or LIST labels are specified. No default;
            you must enter a value.

        Notes
        -----
        EDCRB is valid only for materials defined as rigid bodies with the
        EDMP,RIGID command. EDCRB automatically generates a constraint equation
        to force the specified rigid bodies to behave as a single rigid body.
        The slave rigid body takes on the material properties and loading of
        the master rigid body. Any loads [EDLOAD] existing on the slave rigid
        body are ignored.

        To create a single large rigid body from several smaller bodies, use a
        series of EDCRB commands. With the first command, specify a master and
        slave to create the first combined rigid body. Then, using that body as
        the master, specify another slave to create a larger rigid body.
        Continue the process, using the expanding rigid body as the master and
        adding slave bodies until you have defined the desired large rigid
        body. All slave rigid bodies will take on the material properties and
        loading of the original master rigid body. Note that you will need to
        use different NEQN values for each pair of PARTM and PARTS.  This
        command will be ignored if you specify the previously-defined master
        rigid body as a slave rigid body in the same analysis. To change the
        master and slave definitions, first use the DELE option to delete all
        master and slave definitions, and then use the ADD option to redefine
        them.

        The equation number, NEQN, is a reference number by which the
        constrained bodies can be identified for listing and deleting purposes
        on the EDCRB command. For any other reference to the constrained bodies
        (loading, contact definitions, etc.), use the master body part number
        (PARTM).

        This command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDCRB,%s,%s,%s,%s" % (str(option), str(neqn), str(partm), str(parts))
        return self.run(command, **kwargs)

    def deact(self, **kwargs):
        """APDL Command: DEACT

        Specifies "Element birth and death" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "DEACT," % ()
        return self.run(command, **kwargs)

    def andyna(self, delay="", ncycl="", start="", end="", inc="",
               autocontourkey="", **kwargs):
        """APDL Command: ANDYNA

        Produces an animated sequence of contour values through substeps.

        Parameters
        ----------
        delay
            Time delay during animation (defaults to 0.1 seconds).

        ncycl
            Number of animation cycles (defaults to 5).  Available in non-UI
            mode only.

        start
            Number of the starting substep (defaults to 1).

        end
            Number of the ending substep (defaults to the maximum substep).

        inc
            Increment between substeps (defaults to 1).

        autocontourkey
            Auto-scales contour values, based on the overall subset range of
            values  (defaults to 0, no auto-scaling).

        Notes
        -----
        ANDYNA involves an ANSYS macro which produces an animation of contour
        values through all the substeps of the last plot action command.  This
        command operates only on graphic display platforms supporting the /SEG
        command.  After executing ANDYNA, you can replay the animated sequence
        by issuing the ANIM command.

        The command functions only in the postprocessor.
        """
        command = "ANDYNA,%s,%s,%s,%s,%s,%s" % (str(delay), str(ncycl), str(start), str(end), str(inc), str(autocontourkey))
        return self.run(command, **kwargs)

    def aadd(self, na1="", na2="", na3="", na4="", na5="", na6="", na7="",
             na8="", na9="", **kwargs):
        """APDL Command: AADD

        Adds separate areas to create a single area.

        Parameters
        ----------
        na1, na2, na3, . . . , na9
            Numbers of areas to be added.  If NA1 = ALL, add all selected areas
            and ignore NA2 to NA9.  If NA1 = P, graphical picking is enabled
            and all remaining arguments are ignored (valid only in the GUI).  A
            component name may also be substituted for NA1.

        Notes
        -----
        The areas must be coplanar.  The original areas (and their
        corresponding lines and keypoints) will be deleted by default.  See the
        BOPTN command for the options available to Boolean operations.  Element
        attributes and solid model boundary conditions assigned to the original
        entities will not be transferred to the new entities generated.
        Concatenated entities are not valid with this command.
        """
        command = "AADD,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(na1), str(na2), str(na3), str(na4), str(na5), str(na6), str(na7), str(na8), str(na9))
        return self.run(command, **kwargs)

    def aatt(self, mat="", real="", type="", esys="", secn="", **kwargs):
        """APDL Command: AATT

        Associates element attributes with the selected, unmeshed areas.

        Parameters
        ----------
        mat
            The material number to be associated with selected, unmeshed areas.

        real
            The real constant set number to be associated with selected,
            unmeshed areas.

        type
            The type number to be associated with selected, unmeshed areas.

        esys
            The coordinate system number to be associated with selected,
            unmeshed areas.

        secn
            The section number to be associated with selected unmeshed areas.

        Notes
        -----
        Areas subsequently generated from the areas will also have these
        attributes.  These element attributes will be used when the areas are
        meshed.  If an area does not have attributes associated with it (by
        this command) at the time it is meshed, the attributes are obtained
        from the then current MAT, REAL, TYPE, ESYS, and SECNUM command
        settings.  Reissue the AATT command (before areas are meshed) to change
        the attributes.  A zero (or blank) argument removes the corresponding
        association. If any of the arguments MAT, REAL, TYPE, ESYS, or SECN are
        defined as -1, then that value will be left unchanged in the selected
        set.

        In some cases, ANSYS can proceed with an area meshing operation even
        when no logical element type has been assigned via AATT,,,TYPE or TYPE.
        For more information, see the discussion on setting element attributes
        in Meshing Your Solid Model in the Modeling and Meshing Guide.
        """
        command = "AATT,%s,%s,%s,%s,%s" % (str(mat), str(real), str(type), str(esys), str(secn))
        return self.run(command, **kwargs)

    def rpoly(self, nsides="", lside="", majrad="", minrad="", **kwargs):
        """APDL Command: RPOLY

        Creates a regular polygonal area centered about the working plane
        origin.

        Parameters
        ----------
        nsides
            Number of sides in the regular polygon.  Must be greater than 2.

        lside
            Length of each side of the regular polygon.

        majrad
            Radius of the major (or circumscribed) circle of the polygon.  Not
            used if LSIDE is input.

        minrad
            Radius of the minor (or inscribed) circle of the polygon.  Not used
            if LSIDE or MAJRAD is input.

        Notes
        -----
        Defines a regular polygonal area on the working plane.  The polygon
        will be centered about the working plane origin, with the first
        keypoint defined at : θ = 0°.  The area will be defined with NSIDES
        keypoints and NSIDES lines.  See the RPR4 and POLY commands for other
        ways to create polygons.
        """
        command = "RPOLY,%s,%s,%s,%s" % (str(nsides), str(lside), str(majrad), str(minrad))
        return self.run(command, **kwargs)

    def dset(self, node1="", node2="", node3="", ddev="", **kwargs):
        """APDL Command: DSET

        Sets the scale and drawing plane orientation for a digitizing tablet.

        Parameters
        ----------
        node1, node2, node3
            Any three (noncolinear) nodes defining a plane parallel to the
            drawing.  Nodes and actual locations (in any coordinate system)
            must have been previously defined.

        ddev
            Digitizing device type number (device dependent).

        Notes
        -----
        Sets drawing scale size and defines the drawing plane orientation for
        use with a digitizing tablet.  Drawings must be to scale.  Views must
        represent standard orthogonal parallel projections.  The three nodes
        indicated must be digitized [DIG] from the tablet after this command is
        issued.
        """
        command = "DSET,%s,%s,%s,%s" % (str(node1), str(node2), str(node3), str(ddev))
        return self.run(command, **kwargs)

    def cnkmod(self, itype="", knum="", value="", **kwargs):
        """APDL Command: CNKMOD

        Modifies contact element key options.

        Parameters
        ----------
        itype
            Contact element type number as defined on the ET command.

        knum
            Number of the KEYOPT to be modified (KEYOPT(KNUM)).

        value
            Value to be assigned to the KEYOPT.

        Notes
        -----
        The CNKMOD command has the same syntax as the KEYOPT command. However,
        it is valid only in the SOLUTION processor. This command is intended
        only for use in a linear perturbation analysis, and can only be used to
        modify certain contact element KEYOPT values as described below.

        Modifying KEYOPT(12)

        One use for this command is to modify contact interface behavior
        between load steps in a linear perturbation analysis; it allows the
        user to control the contact status locally per contact pair. For this
        application, this command is limited to changing the contact interface
        behavior key option: KEYOPT(12) of CONTA171, CONTA172, CONTA173,
        CONTA174, CONTA175, CONTA176, and CONTA177; and KEYOPT(10) of CONTA178.

        When used for this purpose, the command adjusts the contact status from
        the linear perturbation base analysis (at the point of restart) as
        described in the table below. Note that CNKMOD allows you to take
        points in the base analysis that are near contact (within the pinball
        region) and modify them to be treated as "in contact" in the
        perturbation analysis; see the "1 - near-field" row with KEYOPT(12)
        values set to 4 or 5. CNKMOD also allows you to take points that are
        sliding in the base analysis and treat them as sticking in the
        perturbation analysis, irrespective of the MU value; see the "2 -
        sliding" row with KEYOPT(12) values set to 1,3, 5, or 6.

        Table: 128:: : Adjusted Contact Status with CNKMOD is Issued

        (if outside of the adjusted pinball region)

        (if inside of the adjusted pinball region)

        (if outside of the adjusted pinball region)

        (if inside of the adjusted pinball region)

        If an open gap exists at the end of the previous load step and the
        contact status is adjusted as sliding or sticking due to a “bonded” or
        “no seperation” contact behavior definition, then the program will
        treat it as near-field contact when executing CNKMOD in the subsequent
        load steps.

        In the linear perturbation analysis procedure, contact status can also
        be controlled or modified by the PERTURB command. The contact status
        always follows local controls defined by the CNKMOD command first, and
        is then adjusted by the global sticking or bonded setting (ContKey =
        STICKING or BONDED) on the PERTURB command (see the PERTURB command for
        details).

        Modifying KEYOPT(3)

        Another use for this command is to change the units of normal contact
        stiffness (contact element real constant FKN) in a linear perturbation
        modal analysis that is used to model brake squeal. For contact elements
        CONTA171, CONTA172, CONTA173, and CONTA174, KEYOPT(3) controls the
        units of normal contact stiffness. You can issue the command
        CNKMOD,ITYPE,3,1 during the first phase of the linear perturbation
        analysis in order to change the units of normal contact stiffness from
        FORCE/LENGTH3 (in the base analysis) to FORCE/LENGTH. Note that
        KEYOPT(3) = 1 is valid only when a penalty-based algorithm is used
        (KEYOPT(2) = 0 or 1) and the absolute normal contact stiffness value is
        explicitly specified (that is, a negative value input for real constant
        FKN).
        """
        command = "CNKMOD,%s,%s,%s" % (str(itype), str(knum), str(value))
        return self.run(command, **kwargs)

    def curr2d(self, **kwargs):
        """APDL Command: CURR2D

        Calculates current flow in a 2-D conductor.

        Notes
        -----
        CURR2D invokes an ANSYS macro which calculates the total current
        flowing in a conducting body for a 2-D planar or axisymmetric magnetic
        field analysis.  The currents may be applied source currents or induced
        currents (eddy currents).  The elements of the conducting region must
        be selected before this command is issued.  The total current
        calculated by the macro is stored in the parameter TCURR.  Also, the
        total current and total current density are stored on a per-element
        basis in the element table [ETABLE] with the labels TCURR and JT,
        respectively.  Use the PLETAB and PRETAB commands to plot and list the
        element table items.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "CURR2D," % ()
        return self.run(command, **kwargs)

    def physics(self, option="", title="", fname="", ext="", **kwargs):
        """APDL Command: PHYSICS

        Writes, reads, or lists all element information

        Parameters
        ----------
        option
            Specifies what to do with element information:

            WRITE - Write all appropriate element types, key options, real constants, material
                    properties, solution analysis options, load step options,
                    constraint equations, coupled nodes, defined components,
                    and GUI preference settings to the file specified with the
                    Fname and Ext arguments.

            READ - Deletes all solution information (material properties, solution options, load
                   step options, constraint equations, coupled nodes, results,
                   and GUI preference settings) then reads all the information
                   listed above into the ANSYS database from the location
                   specified by the Fname and Ext arguments.

            LIST - Lists currently defined physics files and their titles.

            DELETE - Deletes a specified physics file and its title from the database.

            CLEAR - Deletes all material properties, solution options, load step options,
                    constraint equations, coupled nodes, results, and GUI
                    preference settings from the database. Does NOT clear the
                    active physics file title from the database.

            STATUS - Displays information about all active elements and settings.

        title
            A user-defined title that quickly identifies a set of physics
            settings.  For example, you might use "Fluid," "Structural," or
            "Magnetic" as titles.  A title can contain up to 64 characters. It
            can be entered in lower or upper case. Lower case is internally
            converted to upper case within the program.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Use the PHYSICS command when you are performing a multiphysics analysis
        that involves two different disciplines (for example, magnetic and
        structural analyses) and you cannot solve both analyses simultaneously.
        Once you have set up physics environments for both analyses, you can
        use the PHYSICS,READ command to change between the defined physics
        environments.  For more information about doing multiphysics analyses,
        see Sequential Coupled-Field Analysis in the Coupled-Field Analysis
        Guide.

        The PHYSICS command outputs all solution information, including
        analysis options, to the Jobname.PHn file described above.  Although it
        also outputs components, the ANSYS program does not list entities
        (nodes, elements, lines, etc.).

        PHYSICS,WRITE will overwrite existing physics files with the same title
        (even if the name is different). In other words, if the directory has a
        physics file with the same title as the active physics file title, but
        a different name, the PHYSICS,WRITE command will overwrite the existing
        physics file and use the existing filename, not the filename specified
        on the PHYSICS,WRITE command.
        """
        command = "PHYSICS,%s,%s,%s,%s" % (str(option), str(title), str(fname), str(ext))
        return self.run(command, **kwargs)

    def mfouri(self, oper="", coeff="", mode="", isym="", theta="", curve="",
               **kwargs):
        """APDL Command: *MFOURI

        Calculates the coefficients for, or evaluates, a Fourier series.

        Parameters
        ----------
        oper
            Type of Fourier operation:

            Calculate Fourier coefficients COEFF from MODE, ISYM, THETA, and CURVE. - Evaluate the Fourier curve CURVE from COEFF, MODE, ISYM andTHETA

        coeff
            Name of the array parameter vector containing the Fourier
            coefficients (calculated if Oper = FIT, required as input if Oper =
            EVAL).  See *SET for name restrictions.

        mode
            Name of the array parameter vector containing the mode numbers of
            the desired Fourier terms.

        isym
            Name of the array parameter vector containing the symmetry key for
            the corresponding Fourier terms.  The vector should contain keys
            for each term as follows:

            Symmetric (cosine) term - Antisymmetric (sine) term.

        theta, curve
            Names of the array parameter vectors containing the theta vs. curve
            description, respectively.  Theta values should be input in
            degrees.  If Oper = FIT, one curve value should be supplied with
            each theta value.  If Oper = EVAL, one curve value will be
            calculated for each theta value.

        Notes
        -----
        Calculates the coefficients of a Fourier series for a given curve, or
        evaluates the Fourier curve from the given (or previously calculated)
        coefficients.  The lengths of the COEFF, MODE, and ISYM vectors must be
        the same--typically two times the number of modes desired, since two
        terms (sine and cosine) are generally required for each mode.  The
        lengths of the CURVE and THETA vectors should be the same or the
        smaller of the two will be used.  There should be a sufficient number
        of points to adequately define the curve--at least two times the number
        of coefficients.  A starting array element number (1) must be defined
        for each array parameter vector.  The vector specifications *VLEN,
        *VCOL, *VABS, *VFACT, and *VCUM do not apply to this command.  Array
        elements should not be skipped with the *VMASK and the NINC value of
        the *VLEN specifications.  The vector being calculated (COEFF if Oper
        is FIT, or CURVE if Oper is EVAL) must exist as a dimensioned array
        [*DIM].

        This command is valid in any processor.
        """
        command = "*MFOURI,%s,%s,%s,%s,%s,%s" % (str(oper), str(coeff), str(mode), str(isym), str(theta), str(curve))
        return self.run(command, **kwargs)

    def betad(self, value="", **kwargs):
        """APDL Command: BETAD

        Defines the stiffness matrix multiplier for damping.

        Parameters
        ----------
        value
            Stiffness matrix multiplier for damping.

        Notes
        -----
        This command defines the stiffness matrix multiplier β used to form the
        viscous damping matrix [C] = β [K] where [K] is the stiffness matrix.

        Values of : β may also be input as a material property (use the BETD
        label on the MP command).  If BETD is included, the BETD value is added
        to the BETAD value as appropriate (see Damping Matrices in the
        Mechanical APDL Theory Reference).  Damping is not used in the static
        (ANTYPE,STATIC) or buckling (ANTYPE,BUCKLE) analyses.

        This command is also valid in PREP7.
        """
        command = "BETAD,%s" % (str(value))
        return self.run(command, **kwargs)

    def kdist(self, kp1="", kp2="", **kwargs):
        """APDL Command: KDIST

        Calculates and lists the distance between two keypoints.

        Parameters
        ----------
        kp1
            First keypoint in distance calculation.  If KP1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).

        kp2
            Second keypoint in distance calculation.

        Notes
        -----
        KDIST lists the distance between keypoints KP1 and KP2, as well as the
        current coordinate system offsets from KP1 to KP2, where the X, Y, and
        Z locations of KP1 are subtracted from the X, Y, and Z locations of KP2
        (respectively) to determine the offsets.  KDIST is valid in any
        coordinate system except toroidal [CSYS,3].

        KDIST returns a variable, called "_RETURN," which contains the distance
        value.  You can use this value for various purposes; for example, to
        set the default number of line divisions to be generated along region
        boundary lines [ESIZE,_RETURN]. In interactive mode, you can access
        this command by using the Model Query Picker (Utility Menu> List>
        Picked Entities), where you can also access automatic annotation
        functions, and display the value on your model.

        This command is valid in any processor.
        """
        command = "KDIST,%s,%s" % (str(kp1), str(kp2))
        return self.run(command, **kwargs)

    def harfrq(self, freqb="", freqe="", logopt="", freqarr="", toler="",
               **kwargs):
        """APDL Command: HARFRQ

        Defines the frequency range in a harmonic analysis.

        Parameters
        ----------
        freqb
            Frequency (Hz) at the beginning of the FREQB to FREQE range (if
            FREQE > FREQB).  If FREQE is blank, the solution is done only at
            frequency FREQB (the central frequency of octave bands, when LogOpt
            = OB1, OB2, OB3, OB6, OB12 or OB24).

        freqe
            Frequency at end of this range.  Solutions are done at an interval
            of (FREQE-FREQB) / NSBSTP, ending at FREQE.  No solution is done at
            the beginning of the frequency range.  NSBSTP is input via the
            NSUBST command.  See the EXPSOL command documentation for expansion
            pass solutions.

        --
            Reserved.

        logopt
            Logarithm frequency span. Solutions are done at an interval of
            (log(FREQE) - log(FREQB)) / (NSBSTP-1), (NSBSTP>1). The central
            frequency or beginning frequency is used for NSBSTP = 1. Valid
            values are:

            OB1 - Octave band.

            OB2 - 1/2 octave band.

            OB3 - 1/3 octave band.

            OB6 - 1/6 octave band.

            OB12 - 1/12 octave band.

            OB24 - 1/24 octave band.

            LOG - General logarithm frequency span.

        freqarr
            An array containing frequency values (Hz). Combined with the
            tolerance argument, Toler, these values are merged with values
            calculated based on the specifications from FREQB, FREQE, and
            LogOpt, as well NSBSTP on the NSUBST command and Clust on the HROUT
            command. Enclose the array name in percent (%) signs (for example,
            HARFRQ,,,,,%arrname%). Use *DIM to define the array.

        toler
            Tolerance to determine if a user input frequency value in FREQARR
            is a duplicate and can be ignored. Two frequency values are
            considered duplicates if their difference is less than the
            frequency range multiplied by the tolerance. The default value is 1
            x 10-5.

        Notes
        -----
        Defines the frequency range for loads in the harmonic analysis
        (ANTYPE,HARMIC).

        Do not use this command for a harmonic ocean wave analysis (HROCEAN).

        When frequencies are user-defined, the array FREQARR must be one-
        dimensional and contain positive values. User-defined frequency input
        is not supported in the following cases:

        in a cyclic symmetry harmonic analysis

        when the Variational Technology method is used (Method = VT on the
        HROPT command)

        This command is also valid in PREP7.
        """
        command = "HARFRQ,%s,%s,%s,%s,%s" % (str(freqb), str(freqe), str(logopt), str(freqarr), str(toler))
        return self.run(command, **kwargs)

    def mdplot(self, function="", dmpname="", scale="", **kwargs):
        """APDL Command: MDPLOT

        Plots frequency-dependent modal damping coefficients calculated by
        DMPEXT.

        Parameters
        ----------
        function
            Function to display.

            d_coeff - Damping coefficient

            s_coeff - Squeeze coefficient

            d_ratio - Damping ratio

            s_ratio - Squeeze stiffness ratio

        dmpname
            Array parameter name where damping information is stored. Defaults
            to d_damp.

        scale
            Indicates whether to perform a linear or a double logarithmic plot.

            LIN - Perform a linear plot. Default

            LOG - Perform a double logarithmic plot.

        Notes
        -----
        See Thin Film Analysis for more information on thin film analyses.
        """
        command = "MDPLOT,%s,%s,%s" % (str(function), str(dmpname), str(scale))
        return self.run(command, **kwargs)

    def pivcheck(self, key="", prntcntrl="", **kwargs):
        """APDL Command: PIVCHECK

        Controls the behavior of an analysis when a negative or zero equation
        solver pivot value is encountered.

        Parameters
        ----------
        key
            Determines whether to stop or continue an analysis when a negative
            or zero equation solver pivot value is encountered:

            AUTO - Check for negative or zero pivot values for analyses performed with the sparse
                   and PCG solvers. When one is encountered, an error or
                   warning is issued, per various criteria relating to the type
                   of analysis being solved. An error causes the analysis to
                   stop; a warning allows the analysis to continue. A negative
                   pivot value may be valid for some nonlinear and multiphysics
                   analyses (for example, electromagnetic and thermal
                   analyses); this key has no effect in these cases.

            ERROR - Check for negative or zero pivot values for analyses performed with the sparse
                    and PCG solvers. When one is encountered, an error is
                    issued, stopping the analysis. A negative pivot value may
                    be valid for some nonlinear and multiphysics analyses (for
                    example, electromagnetic and thermal analyses); this key
                    has no effect in these cases.

            WARN - Check for negative or zero pivot values for analyses performed with the sparse
                   and PCG solvers. When one is encountered, a warning is
                   issued and the analysis continues. A negative pivot value
                   may be valid for some nonlinear and multiphysics analyses
                   (for example, electromagnetic and thermal analyses); this
                   key has no effect in these cases.

            OFF - Pivot values are not checked. This key causes the analysis to continue in spite
                  of a negative or zero pivot value.

        prntcntrl
            Provides print options. Print output with these options will be
            sent to the default output file, not to the files created by the
            nonlinear diagnostic tools (NLDIAG).

            ONCE - Print only the maximum and minimum pivot information on the first call to the
                   sparse solver (which is the default solver). This is the
                   default behavior.

            EVERY - Print the maximum and minimum pivot information at every call to the sparse
                    solver. This option is provided for nonlinear analysis
                    diagnostics.

        Notes
        -----
        This command is valid for all analyses. In a nonlinear analysis, a
        negative pivot may be valid. In some cases, rigid body motions in a
        nonlinear analysis will be trapped by error routines checking
        infinitely large displacements (DOF limit exceeded) or nonconvergence
        status. An under-constrained model may avoid the pivot check, but fail
        with a DOF limit exceeded error.

        Machine precision may affect whether a small pivot triggers an error or
        bypasses this checking logic. You may wish to review the ratio of the
        maximum to absolute minimum pivot values. For ratios exceeding 12 to 14
        orders of magnitude, the accuracy of the computed solution may be
        degraded by the severe ill-conditioning of the assembled matrix.

        Note that negative pivots corresponding to Lagrange multiplier based
        mixed u-P elements are not checked or reported by this command.
        Negative pivots arising from the u-P element formulation and related
        analyses can occur and lead to correct solutions.

        This command is also valid in PREP7.
        """
        command = "PIVCHECK,%s,%s" % (str(key), str(prntcntrl))
        return self.run(command, **kwargs)

    def pred(self, sskey="", lskey="", **kwargs):
        """APDL Command: PRED

        Activates a predictor in a nonlinear analysis.

        Parameters
        ----------
        sskey
            Substep predictor key:

            OFF - No prediction occurs.

            ON - Use a predictor on all substeps after the first.

            AUTO - The program uses a predictor but, within certain exceptions, automatically
                   switches prediction off. This behavior is the default; see
                   "Command Default" for details.

        --
            Unused field.

        lskey
            Load step predictor:

            OFF - No prediction across load steps occurs. This is the default behavior.

            ON - Use a predictor also on the first substep of the load step. (Sskey = ON is
                 required.)

        Notes
        -----
        Activates a predictor in a nonlinear analysis on the degree-of-freedom
        solution for the first equilibrium iteration of each substep.

        When using the arc-length method (ARCLEN, ARCTRM), you cannot issue the
        DOF solution predictor command (PRED), the automatic time stepping
        command (AUTOTS), or the line search command (LNSRCH). If you activate
        the arc-length method after you set PRED, AUTOTS, or LNSRCH, a warning
        message appears. If you elect to proceed with the arc-length method,
        the program disables your DOF predictor, automatic time stepping, and
        line search settings, and the time step size is controlled by the arc-
        length method internally.

        When using step-applied loads, such as TUNIF, BFUNIF, etc., or other
        types of non-monotonic loads, the predictor may adversely affect the
        convergence. If the solution is discontinuous, the predictor may need
        to be turned off.

        When performing a nonlinear analysis involving large rotations, the
        predictor may require using smaller substeps.

        This command is also valid in PREP7.
        """
        command = "PRED,%s,%s" % (str(sskey), str(lskey))
        return self.run(command, **kwargs)

    def pdcorr(self, name1="", name2="", corr="", **kwargs):
        """APDL Command: PDCORR

        Specifies the correlation between two random input variables.

        Parameters
        ----------
        name1
            Parameter name. The parameter must have been previously defined as
            a random input variable with the PDVAR command.

        name2
            Parameter name. The parameter must have been previously defined as
            a random input variable with the PDVAR command. Must be different
            from Name1.

        corr
            Specification of the correlation:

            Value - Sets the correlation coefficient between Name1 and Name2 to the specified
                    value. If this correlation coefficient was already defined
                    it will be changed to this new value. The correlation
                    coefficient must be between -1.0 and +1.0.

            DEL - Delete the previously defined correlation between Name1 and Name2.

        Notes
        -----
        Specifies the correlations between two random input variables. The PDS
        tool generates correlated samples if correlations exist. This applies
        to both probabilistic methods (Monte Carlo Simulation and Response
        Surface Methods).

        If there are correlated random input variables, the sampled locations
        of the random input variables reflect the correlation as illustrated
        below for the case of two standard normal distributed variables X1 and
        X2. The illustrations show no correlation (correlation coefficient
        0.0), a relatively moderate negative correlation (correlation
        coefficient -0.6), and a relative strong positive correlation
        (correlation coefficient 0.9).

        : : :
        """
        command = "PDCORR,%s,%s,%s" % (str(name1), str(name2), str(corr))
        return self.run(command, **kwargs)

    def cmap(self, fname="", ext="", kywrd="", ncntr="", **kwargs):
        """APDL Command: /CMAP

        Changes an existing or creates a new color mapping table.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        kywrd
            Keyword indicating the disposition of the color map file.

            (blank) - Loads existing color map file.

            CREATE - Starts the CMAP utility and modifies or creates the specified file.

            SAVE - Writes the active color map to the specified file, which can be imported into
                   future sessions.

        ncntr
            Number of contours to be defined. Default = 9 (even if an existing
            file is being modified). Maximum = 128.

        Notes
        -----
        Reads the color map file (RGB index specifications) to change from
        current specifications.  Only one color map may be active at a time.

        For 2-D drivers (especially Win32c), modifying the color map can
        produce anomalies, including legend/contour disagreement.

        When Kywrd equals CREATE, the 2-D drivers (X11c and Win32c) display the
        CMAP utility with an additional contour color picker called CONTOURS.
        Colors selected via the CONTOURS picker affect result contour displays
        (such as stresses). No other drivers offer the CONTOURS picker in the
        CMAP utility.

        Changing the color map using the /CMAP command changes the meaning of
        the color labels on the /COLOR command. See /COLOR for other color
        controls.

        This command is valid anywhere.
        """
        command = "/CMAP,%s,%s,%s,%s" % (str(fname), str(ext), str(kywrd), str(ncntr))
        return self.run(command, **kwargs)

    def cycfreq(self, option="", value1="", value2="", value3="", value4="",
                value5="", **kwargs):
        """APDL Command: CYCFREQ

        Specifies solution options for a cyclic symmetry mode-superposition
        harmonic analysis.

        Parameters
        ----------
        option
            One of the following options:

            AERO - Specify the array containing the aerodynamic damping coefficients.

            Value1 - The name of the array containing the aerodynamic stiffness damping
                     coefficients.

            BLADE - Blade information required for a mistuning analysis.

            Value1 - The name of the nodal component containing the blade boundary nodes at the
                     blade-to-disk interface. Also include boundary nodes at
                     any shroud interfaces.

            Value2 - The name of the element component containing the blade elements.

            Value3 - The number of blade modes to include in the CMS reduction.

            Value4 - The lower bound of the frequency range of interest. This value is optional.

            Value5 - The upper bound of the frequency range of interest. This value is optional.

            DEFAULT - Set the default cyclic harmonic solution settings.

            EO - Excitation engine order.

            Value1 - The value of the excitation order, which must be an integer. The loadings on
                     the other sectors will be related to the loading on the
                     basic sector based on the engine order phase shift.

            MIST - Mistuning parameters.

            Value1 - The type of mistuning:

            K - Stiffness (frequency) mistuning

            Value2 - The name of the array containing the stiffness mistuning parameters.

            MODAL - Specifies if a damped modal analysis should be performed on the reduced system.

            Value1 - On/Off key.

            0 (OFF or NO) - No modal solution. Perform the harmonic solution.

            1 (ON or YES) - Perform a damped modal analysis of the reduced system in order to obtain the
                            complex frequencies. The harmonic solution is not
                            performed.

            Value2 - Number of modes for the damped modal analysis.

            Value3 - The beginning, or lower end, of the frequency range of interest (in Hz).

            Value4 - The ending, or upper end, of the frequency range of interest (in Hz).

            RESTART - Defines the point at which to restart the harmonic analysis.

            Value1 - The restart point:

            OFF - No restart (default)

            SWEEP - Restart for a new frequency sweep range (HARFRQ)

            MIST - Restart for new mistuning parameters (new mistuning arrays)

            USER - Causes the program to call for a user-defined solution.

            Value1-5 - Values passed down to the user-defined solution.

            STATUS - List the harmonic solution option settings active for the cyclic model.

        Notes
        -----
        The program solves a cyclically symmetric model (set up via the CYCLIC
        command during preprocessing) at the harmonic indices specified via the
        CYCOPT command.

        The aerodynamic coefficients are specified in a 5×(N×r) array (*DIM),
        where N is the number of blades and r can be any positive integer. Each
        column has the structure:

        where:

        One aerodynamic damping coefficient must be specified for each IBPA
        (equal to the number of blades) while keeping m and n constant.

        For constant (frequency-independent) mistuning, the stiffness
        parameters are specified in an N×1 array (*DIM) where N is the number
        of blades.

        For stiffness mistuning, each row entry represents the deviation of
        Young’s modulus from nominal,  (or equivalently, the ratio of the
        frequency deviation squared). Each frequency can also be independently
        mistuned, in which case the array is N×M, where M is the number of
        blade frequencies (Value3 of CYCFREQ,BLADE). The entries in each row
        therefore correspond to the ratio of the mistuned frequency to the
        tuned frequency squared minus one:

        The USER option activates the solution macro CYCMSUPUSERSOLVE.MAC. The
        normal solution is skipped. You may implement your own mistuning
        solution using APDL and APDL Math operations, or call your own program
        for the solution.

        The CYCFREQ command is valid in the preprocessing and solution stages
        of an analysis.

        The CYCFREQ,MODAL,ON command writes modal frequencies to the output
        file. No other postprocessing is available for this modal solve.

        When using CYCFREQ,RESTART, only mistuning parameters or frequency
        range may be changed. All other changes in parameters are ignored.

        To learn more about analyzing a cyclically symmetric structure, see the
        Cyclic Symmetry Analysis Guide.
        """
        command = "CYCFREQ,%s,%s,%s,%s,%s,%s" % (str(option), str(value1), str(value2), str(value3), str(value4), str(value5))
        return self.run(command, **kwargs)

    def naxis(self, action="", val="", **kwargs):
        """APDL Command: NAXIS

        Generates nodes for general axisymmetric element sections.

        Parameters
        ----------
        action
            Specifies one of the following command behaviors:

            GEN - Generates nodes around the axis of an axisymmetric section (default).

            CLEAR - Clears all nodes around the axis of an axisymmetric section.

            EFACET - Specifies the number of facets per edge between nodal planes and integration
                     planes in the circumferential direction to display using
                     PowerGraphics.  This option is only valid with /ESHAPE,1
                     and RSYS,SOLU commands.

        val
            Tolerance value or number of facets per edge:

            TOLER - When Action = GEN, the tolerance to use for merging the generated nodes around
                    the axis.

            NUM - When Action = EFACET, the number of facets per element edge for element plots:

            AUTO - Use program-chosen facets per edge (default).

            1 - Use 1 facet per edge (default for elements with 9, 10, 11, or 12 nodal planes).
                Shows nodal and integration planes only.

            2 - Use 2 facets per edge (default for elements with 5, 6, 7, or 8 nodal planes,
                and maximum for elements with 9, 10, 11, or 12 nodal planes).

            3 - Use 3 facets per edge (default for elements with 3 or 4 nodal planes, and
                maximum for elements with 6, 7, or 8 nodal planes).

            4 - Use 4 facets per edge (maximum for elements with 5 nodal planes).

            5 - Use 5 facets per edge (maximum for elements with 4 nodal planes).

            6 - Use 6 facets per edge (maximum for elements with 3 nodal planes).

        Notes
        -----
        The NAXIS command generates or clears the nodes for general
        axisymmetric element sections. The command applies to elements SURF159,
        SOLID272, and SOLID273.

        The generate option (Action = GEN) operates automatically on any
        current-technology axisymmetric element. Any nodes within the tolerance
        value (TOLER) of the axis are merged into a single node. The default
        tolerance is 1.0e-4.

        If you want to change the number of nodes, use the clear option (Action
        = CLEAR) before regenerating the nodes.

        To cause the 3-D element plot to appear more like the actual 3-D model,
        use NAXIS,EFACET,NUM, where NUM > 1. In this case, the coordinate
        system specified for displaying element and nodal results (RSYS) must
        be solution (RSYS,SOLU); otherwise, ANSYS resets NUM to 1.
        """
        command = "NAXIS,%s,%s" % (str(action), str(val))
        return self.run(command, **kwargs)

    def cyclic(self, nsector="", angle="", kcn="", name="", usrcomp="",
               usrnmap="", **kwargs):
        """APDL Command: CYCLIC

        Specifies a cyclic symmetry analysis.

        Parameters
        ----------
        nsector
            The number of sectors in the full 360 degrees, or one of the
            following options:

            STATUS - Indicates the current cyclic status.

            OFF - Resets model to normal (non-cyclic) status and removes the duplicate sector if
                  it exists. This option also deletes automatically detected
                  edge components (generated when USRCOMP = 0).

            UNDOUBLE - Removes the duplicate sector if it exists. The duplicate sector is created
                       during the solution (SOLVE) stage of a modal cyclic
                       symmetry analysis.

        angle
            The sector angle in degrees.

        kcn
            An arbitrary reference number assigned to the cyclic coordinate
            system.  The default value of 0 specifies automatic detection.

        name
            The root name of sector low- and high-edge components (line, area,
            or node components). The default root name (when USRCOMP = 0) is
            "CYCLIC". A root name that you specify can contain up to 11
            characters.

        usrcomp
            The number of pairs of user-defined low- and high-edge components
            on the cyclic sector (if any). The default value of 0 specifies
            automatic detection of sector edges; however, the automatic setting
            is not valid in all cases. (For more information, see the Notes
            section below.) If the value is greater than 0, no verification of
            user-defined components occurs.

        usrnmap
            The name of a user-defined array specifying the matching node pairs
            between the sector low and high edges. Valid only when USRCOMP = 0.
            Skips the automatic detection of sector edges. Node pairs may be
            input in any order, but the low edge node must be the first entry
            in each pair.

        Notes
        -----
        You can input your own value for NSECTOR, ANGLE or KCN; if you do so,
        the command verifies argument values before executing.

        When USRCOMP = 0 and USRNMAP = blank (default), the CYCLIC command
        automatically detects low- and high-edge components for models
        comprised of any combination of line, area, or volume elements. If a
        solid model exists, however, the  command uses only the lines, areas,
        and/or volumes to determine the  low- and high-edge components; the
        elements, if any, are ignored.

        Nodes will be automatically rotated unless CYCOPT,USERROT,YES has been
        specified.

        If you issue a CYCOPT,TOLER command to set a tolerance for edge-
        component pairing before issuing the CYCLIC command, the CYCLIC command
        uses the specified tolerance when performing automatic edge-component
        detection.

        For 2-D models, autodetection does not consider the CSYS,5 or CSYS,6
        coordinate system specification.  Autodetection for 180 degree (two-
        sector) models is not possible unless a central hole exists.

        The CYCLIC command sets values and keys so that, if possible, the area-
        mesh (AMESH) or volume-mesh (VMESH) command meshes the sector with
        matching node and element face patterns on the low and high edges. (The
        command has no effect on any other element-creation command.)

        Issue the CYCLIC command prior to the meshing command to, if possible,
        produce a mesh with identical node and element patterns on the low and
        high sector edges. Only the AMESH or VMESH commands can perform
        automated matching. (Other meshing operation commands such as VSWEEP
        cannot.) If you employ a meshing operation other than AMESH or VMESH,
        you should ensure that node and element face patterns match, if
        desired. The CYCLIC command output indicates whether each edge-
        component pair has or can produce a matching node pair.

        A cyclic solution (via the SOLVE command) allows dissimilar mesh
        patterns on the extreme boundaries of a cyclically symmetric model. The
        allowance for dissimilar patterns is useful when you have only finite-
        element meshes for your model but not the geometry data necessary to
        remesh it to obtain identical node patterns. In such cases, it is
        possible to obtain solution results, although perhaps at the expense of
        accuracy. A warning message appears because results may be degraded
        near the sector edges.

        The constraint equations (CEs) that tie together the low and high edges
        of your model are generated at the solution stage of the analysis from
        the low- and high-edge components (and nowhere else). You should verify
        that automatically detected components are in the correct  locations
        and that you can account for all components; to do so, you can list
        (CMLIST) or plot (CMPLOT) the components.

        If you issue the CYCLIC command after meshing and have defined element
        types with rotational degrees of freedom (DOFs), ANSYS generates cyclic
        CEs for rotational DOFs that may not exist on the sector boundaries.
        Issue the CYCOPT,DOF command to prevent unused rotational terms from
        being generated.

        Modal cyclic symmetry analysis is supported by the following
        eigensolvers:

        Block Lanczos (MODOPT,LANB)

        PCG Lanczos (MODOPT,LANPCG)

        Super Node (MODOPT,SNODE)

        Subspace (MODOPT,SUBSP)

        To learn more about analyzing a cyclically symmetric structure, see the
        Cyclic Symmetry Analysis Guide.

        When using the: CYCLIC: command to automatically detect the sector, if
        an area is defined with the: AL: command, the lines need to be oriented
        to form the closed curve.
        """
        command = "CYCLIC,%s,%s,%s,%s,%s,%s" % (str(nsector), str(angle), str(kcn), str(name), str(usrcomp), str(usrnmap))
        return self.run(command, **kwargs)

    def esys(self, kcn="", **kwargs):
        """APDL Command: ESYS

        Sets the element coordinate system attribute pointer.

        Parameters
        ----------
        kcn
            Coordinate system number:

            0 - Use element coordinate system orientation as defined (either by default or by
                KEYOPT setting) for the element (default).

            N - Use element coordinate system orientation based on local coordinate system N
                (where N must be greater than 10). For global system 0, 1, or
                2, define a local system N parallel to appropriate system with
                the LOCAL or CS command (for example: LOCAL,11,1).

        Notes
        -----
        Identifies the local coordinate system to be used to define the element
        coordinate system of subsequently defined elements. Used only with area
        and volume elements. For non-layered volume elements, the local
        coordinate system N is simply assigned to be the element coordinate
        system. For shell and layered volume elements, the x and y axes of the
        local coordinate system N are projected onto the shell or layer plane
        to determine the element coordinate system. See Understanding the
        Element Coordinate System for more details. N refers to the coordinate
        system reference number (KCN) defined using the LOCAL (or similar)
        command. Element coordinate system numbers may be displayed [/PNUM].
        """
        command = "ESYS,%s" % (str(kcn))
        return self.run(command, **kwargs)

    def ssum(self, **kwargs):
        """APDL Command: SSUM

        Calculates and prints the sum of element table items.

        Notes
        -----
        Calculates and prints the tabular sum of each existing labeled result
        item [ETABLE] for the selected elements.  If absolute values are
        requested [SABS,1], absolute values are used.
        """
        command = "SSUM," % ()
        return self.run(command, **kwargs)

    def inres(self, item1="", item2="", item3="", item4="", item5="", item6="",
              item7="", item8="", **kwargs):
        """APDL Command: INRES

        Identifies the data to be retrieved from the results file.

        Parameters
        ----------
        item1, item2, item3, . . . , item8
            Data to be read into the database from the results file.  May
            consist of any of the following labels:

            ALL - All solution items (default).

            BASIC - NSOL, RSOL, NLOAD, STRS, FGRAD, and FFLUX items.

            NSOL - Nodal DOF solution.

            RSOL - Nodal reaction loads.

            ESOL - Element solution items (includes all of the following):

            NLOAD - Element nodal loads.

            STRS - Element nodal stresses.

            EPEL - Element elastic strains.

            EPTH - Element thermal, initial, and swelling strains.

            EPPL - Element plastic strains.

            EPCR - Element creep strains.

            FGRAD - Element nodal gradients.

            FFLUX - Element nodal fluxes.

            MISC - Element miscellaneous data (SMISC and NMISC).

        Notes
        -----
        Identifies the type of data to be retrieved from the results file for
        placement into the database through commands such as SET, SUBSET, and
        APPEND.  INRES is a companion command to the OUTRES command controlling
        data written to the database and the results file.  Since the INRES
        command can only flag data that has already been written to the results
        file, care should be taken when using the OUTRES command to include all
        data you wish to retrieve for postprocessing later on.
        """
        command = "INRES,%s,%s,%s,%s,%s,%s,%s,%s" % (str(item1), str(item2), str(item3), str(item4), str(item5), str(item6), str(item7), str(item8))
        return self.run(command, **kwargs)

    def setran(self, sename="", kcnto="", inc="", file="", ext="", dx="",
               dy="", dz="", norot="", **kwargs):
        """APDL Command: SETRAN

        Creates a superelement from an existing superelement.

        Parameters
        ----------
        sename
            The name (case-sensitive) of the file containing the original
            superelement matrix created by the generation pass (Sename.SUB).
            The default is the current Jobname.  If Sename is a number, it is
            the element number of a previously defined superelement in the
            current use pass.

        kcnto
            The reference number of the coordinate system to where the
            superelement is to be transferred. The default is the global
            Cartesian system.  Transfer occurs from the active coordinate
            system.

        inc
            The node offset.  The default is zero.  All new element node
            numbers are offset from those on the original by INC.

        file
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        dx, dy, dz
            Node location increments in the global Cartesian coordinate system.
            Defaults to zero.

        norot
            Node rotation key:

            0 - The nodal coordinate systems of the transferred superelement rotate into the
                KCNTO system. (That is, the nodal coordinate systems rotate
                with the superelement.) The superelement matrices remain
                unchanged. This value is the default.

            1 - The nodal coordinate systems do not rotate. (That is, they remain fixed in
                their original global orientation.)  The superelement matrices
                and load vectors are modified if any rotations occur.

        Notes
        -----
        The SETRAN command creates a superelement from an existing superelement
        and writes the new element to a file.  You can then issue an SE command
        to read the new element (during the use pass).

        You can create a superelement from an original by:

        Transferring the original's geometry from the active coordinate system
        into another coordinate system (KCNTO)

        Offsetting its geometry in the global Cartesian coordinate system (DX,
        DY, and DZ )

        Offsetting its node numbers (INC).

        A combination of methods is valid. If you specify both the geometry
        transfer and the geometry offset, the transfer occurs first.

        If you specify rotation of the transferred superelement's nodal
        coordinate systems into the KCNTO system (NOROT = 0), the rotated nodes
        cannot be coupled via the CP command; in this case, issue the CE
        command instead. If you specify no rotation of the nodal coordinate
        systems (NOROT = 1) for models with displacement degrees of freedom,
        and KCNTO is not the active system, the superelement Sename must have
        six MDOF at each node that has MDOF; therefore, only elements with all
        six structural DOFs are valid in such cases.

        There is no limit to the number of copies that can be made of a
        superelement, provided the copies are all generated from the same
        original superelement. However, nested copies are limited to five. In
        other words, the total number of different Sename usages on the SETRAN
        and SESYMM commands is limited to five.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "SETRAN,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(sename), str(kcnto), str(inc), str(file), str(ext), str(dx), str(dy), str(dz), str(norot))
        return self.run(command, **kwargs)

    def fc(self, mat="", lab1="", lab2="", data1="", data2="", data3="",
           data4="", data5="", data6="", **kwargs):
        """APDL Command: FC

        Provides failure criteria information and activates a data table to
        input temperature-dependent stress and strain limits.

        Parameters
        ----------
        mat
             Material reference number. You can define failure criteria for up
            to 250 different materials.

        lab1
            Type of data.

            TEMP - Temperatures. Each of the materials you define can have a different set of
                   temperatures to define the failure criteria.

            EPEL - Strains.

            S - Stresses.

        lab2
            Specific criteria. Not used if Lab1 = TEMP.

            XTEN - Allowable tensile stress or strain in the x-direction. (Must be positive.)

            XCMP - Allowable compressive stress or strain in the x-direction. (Defaults to
                   negative of XTEN.)

            YTEN - Allowable tensile stress or strain in the y-direction. (Must be positive.)

            YCMP - Allowable compressive stress or strain in the y-direction. (Defaults to
                   negative of YTEN.)

            ZTEN - Allowable tensile stress or strain in the z-direction. (Must be positive.)

            ZCMP - Allowable compressive stress or strain in the z-direction. (Defaults to
                   negative of ZTEN.)

            XY - Allowable XY stress or shear strain. (Must be positive.)

            YZ - Allowable YZ stress or shear strain. (Must be positive.)

            XZ - Allowable XZ stress or shear strain. (Must be positive.)

            XYCP - XY coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]

            YZCP - YZ coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]

            XZCP - XZ coupling coefficient (Used only if Lab1 = S). Defaults to -1.0. [1]

        data1, data2, data3, . . . , data6
            Description of DATA1 through DATA6.

            T1, T2, T3, T4, T5, T6 - Temperature at which limit data is input. Used only when Lab1 = TEMP.

            V1, V2, V3, V4, V5, V6 - Value of limit stress or strain at temperature T1 through T6. Used only when
                              Lab1 = S or EPEL.

        Notes
        -----
        The data table can be input in either PREP7 or POST1. This table is
        used only in POST1. When you postprocess failure criteria results
        defined via the FC command (PLESOL, PRESOL, PLNSOL, PRNSOL, PRRSOL,
        etc.), the active coordinate system must be the coordinate system of
        the material being analyzed. You do this using RSYS, SOLU. For layered
        applications, you also use the LAYER command. See the specific element
        documentation in the Element Reference for information on defining your
        coordinate system for layers.

        Some plotting and printing functions will not support Failure Criteria
        for your PowerGraphics displays. This could result in minor changes to
        other data when Failure Criteria are applied. See the appropriate plot
        or print command documentation for more information .
        """
        command = "FC,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(mat), str(lab1), str(lab2), str(data1), str(data2), str(data3), str(data4), str(data5), str(data6))
        return self.run(command, **kwargs)

    def bcsoption(self, memory_option="", memory_size="", solve_info="",
                  **kwargs):
        """APDL Command: BCSOPTION

         Sets memory option for the sparse solver.

        Parameters
        ----------
        --
            Unused field

        memory_option
            Memory allocation option:

            DEFAULT - Use the default memory allocation strategy for the sparse solver. The default
                      strategy attempts to run in the INCORE memory mode. If
                      there is not enough available physical memory when the
                      solver starts to run in the INCORE memory mode, the
                      solver will then attempt to run in the OUTOFCORE memory
                      mode.

            INCORE -  Use a memory allocation strategy in the sparse solver that will attempt to
                     obtain enough memory to run with the entire factorized
                     matrix in memory. This option uses the most amount of
                     memory and should avoid doing any I/O. By avoiding I/O,
                     this option achieves optimal solver performance. However,
                     a significant amount of memory is required to run in this
                     mode, and it is only recommended on machines with a large
                     amount of memory. If the allocation for in-core memory
                     fails, the solver will automatically revert to out-of-core
                     memory mode.

            OUTOFCORE - Use a memory allocation strategy in the sparse solver that will attempt to
                        allocate only enough work space to factor each
                        individual frontal matrix in memory, but will store the
                        entire factorized matrix on disk. Typically, this
                        memory mode results in poor performance due to the
                        potential bottleneck caused by the I/O to the various
                        files written by the solver.

            FORCE - This option, when used in conjunction with the Memory_Size option, allows you
                    to force the sparse solver to run with a specific amount of
                    memory. This option is only recommended for the advanced
                    user who understands sparse solver memory requirements for
                    the problem being solved, understands the physical memory
                    on the system, and wants to control the sparse solver
                    memory usage.

        memory_size
            Initial memory size allocation for the sparse solver in MB. This
            argument allows you to tune the sparse solver memory and is not
            generally required. Although there is no upper limit for
            Memory_Size, the Memory_Size setting should always be well within
            the physical memory available, but not so small as to cause the
            sparse solver to run out of memory. Warnings and/or errors from the
            sparse solver will appear if this value is set too low. If the
            FORCE memory option is used, this value is the amount of memory
            allocated for the entire duration of the sparse solver solution.

        --, --
            Unused fields

        solve_info
            Solver output option:

            OFF - Turns off additional output printing from the sparse solver (default).

            PERFORMANCE - Turns on additional output printing from the sparse solver, including a
                          performance summary and a summary of file I/O for the
                          sparse solver. Information on memory usage during
                          assembly of the global matrix (that is, creation of
                          the Jobname.FULL file) is also printed with this
                          option.

        Notes
        -----
        This command controls options related to the sparse solver in all
        analysis types where the sparse solver can be used. It also controls
        the Block Lanczos eigensolver in a modal or buckling analysis.

        The sparse solver runs from one large work space (that is, one large
        memory allocation). The amount of memory required for the sparse solver
        is unknown until the matrix structure is preprocessed, including
        equation reordering. The amount of memory allocated for the sparse
        solver is then dynamically adjusted to supply the solver what it needs
        to compute the solution.

        If you have a very large memory system, you may want to try selecting
        the INCORE memory mode for larger jobs to improve performance. When
        running the sparse solver on a machine with very slow I/O performance
        (for example, slow hard drive speed), you may want to try using the
        INCORE memory mode to achieve better performance. However, doing so may
        require much more memory compared to running in the OUTOFCORE memory
        mode.

        Running with the INCORE memory mode is best for jobs which comfortably
        fit within the limits of the physical memory on a given system. If the
        sparse solver work space exceeds physical memory size, the system will
        be forced to use virtual memory (or the system page/swap file). In this
        case, it is typically more efficient to run with the OUTOFCORE memory
        mode. Assuming the job fits comfortably within the limits of the
        machine, running with the INCORE memory mode is often ideal for jobs
        where repeated solves are performed for a single matrix factorization.
        This occurs in a modal or buckling analysis or when doing multiple load
        steps in a linear, static analysis.

        For repeated runs with the sparse solver, you may set the initial
        sparse solver memory allocation to the amount required for
        factorization. This strategy reduces the frequency of allocation and
        reallocation in the run to make the INCORE option fully effective. If
        you have a very large memory system, you may use the Memory_Size
        argument to increase the maximum size attempted for in-core runs.
        """
        command = "BCSOPTION,%s,%s,%s" % (str(memory_option), str(memory_size), str(solve_info))
        return self.run(command, **kwargs)

    def prjsol(self, item="", comp="", **kwargs):
        """APDL Command: PRJSOL

        Prints joint element output.

        Parameters
        ----------
        item
            Label identifying the item. Some items also require a component
            label.

            DISP - Relative displacements.

            ROT - Relative rotations.

            VEL - Relative linear velocities.

            OMG - Relative angular velocities.

            ACC - Relative linear accelerations.

            DMG - Relative angular accelerations.

            SMISC - Summable miscellaneous quantities.

        comp
            Component of the item (if required). For Item = DISP, ROT, VEL,
            OMG, ACC, and DMG, enter the direction label, X, Y, or Z. For Item
            = SMISC, enter a valid number.

        Notes
        -----
        Prints element output for the MPC184 joint element. The joint element
        quantities printed are the values for the free or unconstrained
        relative degrees of freedom.

        This command is valid in POST1 only.
        """
        command = "PRJSOL,%s,%s" % (str(item), str(comp))
        return self.run(command, **kwargs)

    def avprin(self, key="", effnu="", **kwargs):
        """APDL Command: AVPRIN

        Specifies how principal and vector sums are to be calculated.

        Parameters
        ----------
        key
            Averaging key:

            0 - Average the component values from the elements at a common node, then calculate
                the principal or vector sum from the averaged components
                (default).

            1 - Calculate the principal or vector sum values on a per element basis, then
                average these values from the elements at a common node.

        effnu
            Effective Poisson's ratio used for computing the von Mises
            equivalent strain (EQV). This command option is intended for use
            with line elements or in load case operations (LCOPER) only; ANSYS
            automatically selects the most appropriate effective Poisson's
            ratio, as discussed below.

        Notes
        -----
        Selects the method of combining components for certain derived nodal
        results when two or more elements connect to a common node.  The
        methods apply to the calculations of derived nodal principal stresses,
        principal strains, and vector sums for selects, sorts, and output
        [NSEL, NSORT, PRNSOL, PLNSOL, etc.].

        This command also defines the effective Poisson's ratio (EFFNU) used
        for equivalent strain calculations.  If you use EFFNU, the default
        effective Poisson's ratios shown below will be overridden for all
        elements by the EFFNU value. To return to the default settings, issue
        the RESET command. The default value for EFFNU is:

        Poisson's ratio as defined on the MP commands for EPEL and EPTH

        0.5 for EPPL and EPCR

        0.5 if the referenced material is hyperelastic

        0.0 for line elements (includes beam, link, and pipe elements, as well
        as discrete elements), cyclic symmetry analysis, mode superposition
        analyses (with MSUPkey = YES on the MXPAND command), and load case
        operations (LCOPER).

        For the von Mises equivalent strain (EQV), it is always computed using
        the average of the equivalent strains from the elements at a common
        node irrespective of the value of the averaging KEY. If EFFNU is input,
        though, the calculation will be performed according to the KEY setting.

        For a random vibration (PSD) analysis, issuing either AVPRIN,0 or
        AVPRIN,1 calculates the principal stresses using the appropriate
        averaging method. They are then used to determine SEQV.  The output
        will have non-zero values for the principal stresses.

        If AVPRIN is not issued, the Segalman-Fulcher method is used to
        calculate SEQV. This method does not calculate principal stresses, but
        directly calculates SEQV from the component stresses; therefore, the
        output will have zero values for the principal stresses. Beam and pipe
        elements are excluded

        This command is also valid in POST26, where applicable.

        See Combined Stresses and Strains in the Mechanical APDL Theory
        Reference for more information.
        """
        command = "AVPRIN,%s,%s" % (str(key), str(effnu))
        return self.run(command, **kwargs)

    def edrun(self, option="", cons="", ncpu="", **kwargs):
        """APDL Command: EDRUN

        Specify LS-DYNA serial or parallel processing.

        Parameters
        ----------
        option
             LS-DYNA processing option

            SERIAL - Use serial processing (default)

            SMP - Use Shared Memory Parallel processing

        cons
            Consistency setting (only applicable when Option = SMP)

            0 - Result consistency is not required (default)

            1 - Result consistency is required

        ncpu
            Number of processors to use (applicable only with Option = SMP)

        Notes
        -----
        The EDRUN command specifies either serial (one CPU) processing or
        shared (multiple CPU) memory parallel processing (SMP). When using SMP,
        the calculations may be executed in a different order, depending on CPU
        availability and the load on each CPU. You may therefore see slight
        differences in the results when running the same job multiple times,
        either with the same number or a different number of processors.
        Comparing nodal accelerations often shows wider discrepancies. To avoid
        such differences, you can specify that consistency be maintained by
        setting CONS = 1. Maintaining consistency can result in an increase of
        up to 15 percent in CPU time.

        The parallel processing setting is only effective when you have
        multiple CPUs and licenses for the appropriate number of ANSYS LS-DYNA
        SMP tasks. If your site does not meet both requirements, the EDRUN
        command sets serial processing, regardless of command settings.

        For more information on using SMP, see Solution Features in the ANSYS
        LS-DYNA User's Guide.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDRUN,%s,%s,%s" % (str(option), str(cons), str(ncpu))
        return self.run(command, **kwargs)

    def e(self, i="", j="", k="", l="", m="", n="", o="", p="", **kwargs):
        """APDL Command: E

        Defines an element by node connectivity.

        Parameters
        ----------
        i
            Number of node assigned to first nodal position (node I). If I = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).

        j, k, l, m, n, o, p
            Number assigned to second (node J) through eighth (node P) nodal
            position, if any.

        Notes
        -----
        Defines an element by its nodes and attribute values. Up to 8 nodes may
        be specified with the E command.  If more nodes are needed for the
        element, use the EMORE command. The number of nodes required and the
        order in which they should be specified are described in Chapter 4 of
        the Element Reference for each element type.  Elements are
        automatically assigned a number [NUMSTR] as generated. The current (or
        default) MAT, TYPE, REAL, SECNUM and ESYS attribute values are also
        assigned to the element.

        When creating elements with more than 8 nodes using this command and
        the EMORE command, it may be necessary to turn off shape checking using
        the SHPP command before issuing this command. If a valid element type
        can be created without using the additional nodes on the EMORE command,
        this command will create that element. The EMORE command will then
        modify the element to include the additional nodes. If shape checking
        is active, it will be performed before the EMORE command is issued.
        Therefore, if the shape checking limits are exceeded, element creation
        may fail before the EMORE command modifies the element into an
        acceptable shape.
        """
        command = "E,%s,%s,%s,%s,%s,%s,%s,%s" % (str(i), str(j), str(k), str(l), str(m), str(n), str(o), str(p))
        return self.run(command, **kwargs)

    def sv(self, damp="", sv1="", sv2="", sv3="", sv4="", sv5="", sv6="",
           sv7="", sv8="", sv9="", **kwargs):
        """APDL Command: SV

        Defines spectrum values to be associated with frequency points.

        Parameters
        ----------
        damp
            Damping ratio for this response spectrum curve.  If the same as a
            previously defined curve, the SV values are added to the previous
            curve.  Up to four different curves may be defined, each with a
            different damping ratio.  Damping values must be input in ascending
            order.

        sv1, sv2, sv3, . . . , sv9
            Spectrum values corresponding to the frequency points [FREQ].
            Values are interpreted as defined with the SVTYP command.   SV
            values should not be zero.  Values required outside the frequency
            range use the extreme input values.

        Notes
        -----
        Defines the spectrum values to be associated with the previously
        defined frequency points [FREQ].  Applies only to the single-point
        response spectrum.  Damping has no effect on the frequency solution.
        Damping values are used only to identify SV curves for the mode
        combinations calculation.  Only the curve with the lowest damping value
        is used in the initial mode coefficient calculation.  Use STAT command
        to list current spectrum curve values.

        Repeat SV command for additional SV points (100 maximum per DAMP
        curve).  SV values are added to the DAMP curve after the last nonzero
        SV value.

        The interpolation method between response spectrum points and curves is
        specified using KeyInterp in the SVTYP command. It is logarithmic by
        default.

        This command is also valid in PREP7.
        """
        command = "SV,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(damp), str(sv1), str(sv2), str(sv3), str(sv4), str(sv5), str(sv6), str(sv7), str(sv8), str(sv9))
        return self.run(command, **kwargs)

    def kmodif(self, npt="", x="", y="", z="", **kwargs):
        """APDL Command: KMODIF

        Modifies an existing keypoint.

        Parameters
        ----------
        npt
            Modify coordinates of this keypoint.  If NPT = ALL, modify
            coordinates of all selected keypoints [KSEL].  If NPT = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NPT.

        x, y, z
            Replace the previous coordinate values assigned to this keypoint
            with these corresponding coordinate values.  Values are interpreted
            according to the active coordinate system (R, θ, Z for cylindrical,
            R, θ,Φ for spherical).  If X = P, graphical picking is used to
            locate keypoint and Y and Z are ignored.  A blank retains the
            previous value.  You cannot specify Y = P.

        Notes
        -----
        Lines, areas, and volumes attached to the modified keypoint (if any)
        must all be selected and will be redefined using the active coordinate
        system.  However, solid modeling in a toroidal coordinate system is not
        recommended.

        Caution:: : Redefined entities may be removed from any defined
        components and assemblies. Nodes and elements will be automatically
        cleared from any redefined keypoints, lines, areas, or volumes.

        The KMODIF command moves keypoints for geometry modification without
        validating underlying entities. To merge keypoints and update higher
        order entities, issue the NUMMRG command instead.
        """
        command = "KMODIF,%s,%s,%s,%s" % (str(npt), str(x), str(y), str(z))
        return self.run(command, **kwargs)

    def ceintf(self, toler="", dof1="", dof2="", dof3="", dof4="", dof5="",
               dof6="", movetol="", **kwargs):
        """APDL Command: CEINTF

        Generates constraint equations at an interface.

        Parameters
        ----------
        toler
            Tolerance about selected elements, based on a fraction of the
            element dimension (defaults to 0.25 (25%)).  Nodes outside the
            element by more than the tolerance are not accepted as being on the
            interface.

        dof1, dof2, dof3, . . . , dof6
            Degrees of freedom for which constraint equations are written.
            Defaults to all applicable DOFs.  DOF1 accepts ALL as a valid
            label, in which case the rest are ignored (all DOFs are applied).

        movetol
            The allowed "motion" of a node (see Note below).  This distance is
            in terms of the element coordinates (-1.0 to 1.0).  A typical value
            is 0.05.  Defaults to 0 (do not move).  MoveTol must be less than
            or equal to TOLER.

        Notes
        -----
        This command can be used to "tie" together two regions with dissimilar
        mesh patterns by generating constraint equations that connect the
        selected nodes of one region to the selected elements of the other
        region.  At the interface between regions, nodes should be selected
        from the more dense mesh region, A, and the elements selected from the
        less dense mesh region, B.  The degrees of freedom of region A nodes
        are interpolated with the corresponding degrees of freedom of the nodes
        on the region B elements, using the shape functions of the region B
        elements.  Constraint equations are then written that relate region A
        and B nodes at the interface.

        The MoveTol field lets the nodes in the previously mentioned region A
        change coordinates when slightly inside or outside the elements of
        region B.  The change in coordinates causes the nodes of region A to
        assume the same surface as the nodes associated with the elements of
        region B.   The constraint equations that relate the nodes at both
        regions of the interface are then written.

        Solid elements with six degrees of freedom should only be interfaced
        with other six degree-of-freedom elements.  The region A nodes should
        be near the region B elements.   A location tolerance based on the
        smallest region B element length may be input.  Stresses across the
        interface are not necessarily continuous.  Nodes in the interface
        region should not have specified constraints.

        Use the CPINTF command to connect nodes by coupling instead of
        constraint equations.  Use the EINTF command to connect nodes by line
        elements.  See also the NSEL and ESEL commands for selecting nodes and
        elements.  See the Mechanical APDL Theory Reference for a description
        of 3-D space used to determine if a node will be considered by this
        command.

        As an alternative to the CEINTF command, you can use contact elements
        and the internal multipoint constraint (MPC) algorithm to tie together
        two regions having dissimilar meshes. See Solid-Solid and Shell-Shell
        Assemblies for more information.
        """
        command = "CEINTF,%s,%s,%s,%s,%s,%s,%s,%s" % (str(toler), str(dof1), str(dof2), str(dof3), str(dof4), str(dof5), str(dof6), str(movetol))
        return self.run(command, **kwargs)

    def spfreq(self, tblno="", freq1="", freq2="", freq3="", freq4="",
               freq5="", freq6="", freq7="", **kwargs):
        """APDL Command: SPFREQ

        Defines the frequency points for the input spectrum tables SPVAL vs.
        SPFREQ for multi-point spectrum analysis.

        Parameters
        ----------
        tblno
            Input table number. Up to 200 tables may be defined.

        freq1, freq2, freq3,..., freq7
            Frequency points (Hz) for spectrum vs. frequency tables. FREQ1
            should be greater than zero, and values must be in ascending order.

        Notes
        -----
        The spectrum values are input with the SPVAL command. A separate SPFREQ
        command must be used for each table defined. Frequencies must be in
        ascending order.

        Repeat SPFREQ command for additional frequency points. Values are added
        after the last nonzero frequency.

        If all fields after SPFREQ are blank, all input vs. frequency tables
        are erased. If TBLNO is the only non-blank field, all corresponding
        SPVAL curves are erased.

        Use the SPTOPT and STAT commands to list current frequency points.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "SPFREQ,%s,%s,%s,%s,%s,%s,%s,%s" % (str(tblno), str(freq1), str(freq2), str(freq3), str(freq4), str(freq5), str(freq6), str(freq7))
        return self.run(command, **kwargs)

    def itengine(self, type="", enginename="", precondname="", matrix="",
                 rhsvector="", solvector="", maxiter="", toler="", **kwargs):
        """APDL Command: *ITENGINE

        Performs a solution using an iterative solver.

        Parameters
        ----------
        type
            Specifies the algorithm to be used:

        enginename
            Name used to identify this iterative solver engine. Must be
            specified.

        precondname
            Linear solver engine name (*LSENGINE) identifying the factored
            matrix to be used as the preconditioner.

        matrix
            Name of the matrix to solve.

        rhsvector
            Matrix (load vector) name.

        solvector
            Solution vector name. If non-zero, it will be taken as the initial
            vector for the iterative process.

        maxiter
            Maximum number of iterations allowed. Default is 2 times the number
            of rows in the matrix.

        toler
            Convergence tolerance. Default is 1.0E-8.

        Notes
        -----
        This command solves Ax = b using a preconditioned conjugate gradient
        algorithm. It uses an existing factored system as the preconditioner.
        This solution method is useful if an existing matrix has been solved
        and minor changes have been made to the matrix.
        """
        command = "*ITENGINE,%s,%s,%s,%s,%s,%s,%s,%s" % (str(type), str(enginename), str(precondname), str(matrix), str(rhsvector), str(solvector), str(maxiter), str(toler))
        return self.run(command, **kwargs)

    def wpcsys(self, wn="", kcn="", **kwargs):
        """APDL Command: WPCSYS

        Defines the working plane location based on a coordinate system.

        Parameters
        ----------
        wn
            Window number whose viewing direction will be modified to be normal
            to the working plane (defaults to 1).  If WN is a negative value,
            the viewing direction will not be modified.

        kcn
            Coordinate system number.  KCN may be 0,1,2 or any previously
            defined local coordinate system number (defaults to the active
            system).

        Notes
        -----
        Defines a working plane location and orientation based on an existing
        coordinate system.  If a Cartesian system is used as the basis (KCN)
        for the working plane, the working plane will also be Cartesian, in the
        X-Y plane of the base system.  If a cylindrical, spherical, or toroidal
        base system is used, the working plane will be a polar system in the
        R-θ plane of the base system.

        If working plane tracking has been activated (CSYS,WP or CSYS,4), the
        updated active coordinate system will be of a similar type, except that
        a toroidal system will be updated to a cylindrical system.  See the
        Modeling and Meshing Guide for more information on working plane
        tracking.

        This command is valid in any processor.

        Some primitive generation commands will not honor R-theta
        transformations for non-cartesian coordinate systems. Refer to the
        primitive commands table for more information.
        """
        command = "WPCSYS,%s,%s" % (str(wn), str(kcn))
        return self.run(command, **kwargs)

    def vwrite(self, par1="", par2="", par3="", par4="", par5="", par6="",
               par7="", par8="", par9="", par10="", par11="", par12="",
               par13="", par14="", par15="", par16="", par17="", par18="",
               par19="", **kwargs):
        """APDL Command: *VWRITE

        Writes data to a file in a formatted sequence.

        Parameters
        ----------
        par1, par2, par3, . . . , par19
            You can write up to 19 parameters (or constants) at a time. Any Par
            values after a blank  Par value are ignored.  If you leave them all
            blank, one line will be written (to write a title or a blank line).
            If you input the keyword SEQU, a sequence of numbers (starting from
            1) will be written for that item.

        Notes
        -----
        You use *VWRITE to write data to a file in a formatted sequence. Data
        items (Par1, Par2, etc.) may be array parameters, scalar parameters,
        character parameters (scalar or array), or constants.  You must
        evaluate expressions and functions in the data item fields before using
        the *VWRITE command, since initially they will be evaluated to a
        constant and remain constant throughout the operation.  Unless a file
        is defined with the *CFOPEN  command, data is written to the standard
        output file. Data written to the standard output file may be diverted
        to a different file by first switching the current output file with the
        /OUTPUT command. You can also use the *MWRITE command to write data to
        a specified file. Both commands contain format descriptors on the line
        immediately following the command. The format descriptors can be in
        either Fortran or C format.

        You must enclose Fortran format descriptors in parentheses. They must
        immediately follow the *VWRITE command on a separate line of the same
        input file.  Do not include the word FORMAT. The format must specify
        the number of fields to be written per line, the field width, the
        placement of the decimal point, etc.  You should use one field
        descriptor for each data item written.  The write operation uses your
        system's available FORTRAN FORMAT conventions (see your system FORTRAN
        manual).  You can use any standard FORTRAN real format (such as
        (4F6.0), (E10.3,2X,D8.2), etc.) and alphanumeric format (A).
        Alphanumeric strings are limited to a maximum of 8 characters for any
        field (A8) using the Fortran format. Use the “C” format for string
        arrays larger than 8 characters. Integer (I) and list-directed (*)
        descriptors may not be used.  You can include text in the format as a
        quoted string.  The parentheses must be included in the format and the
        format must not exceed 80 characters (including parentheses).  The
        output line length is limited to 128 characters.

        The “C” format descriptors are used if the first character of the
        format descriptor line is not a left parenthesis. “C” format
        descriptors are up to 80 characters long, consisting of text strings
        and predefined "data descriptors" between the strings where numeric or
        alphanumeric character data will be inserted.  The normal descriptors
        are %I for integer data, %G for double precision data, %C for
        alphanumeric character data, and %/ for a line break. There must be one
        data descriptor for each specified value (8 maximum) in the order of
        the specified values. The enhanced formats described in *MSG may also
        be used.

        For array parameter items, you must define the starting array element
        number. Looping continues (incrementing the vector index number of each
        array parameter by one) each time you output a line, until the maximum
        array vector element is written.  For example, *VWRITE,A(1) followed by
        (F6.0) will write one value per output line, i.e., A(1), A(2), A(3),
        A(4), etc.  You write constants and scalar parameters with the same
        values for each loop.  You can also control the number of loops and
        loop skipping with the *VLEN and *VMASK commands.  The vector
        specifications *VABS,  *VFACT, and *VCUM  do not apply to this command.
        If looping continues beyond the supplied data array's length, zeros
        will be output for numeric array parameters and blanks for character
        array parameters.  For multi-dimensioned array parameters, only the
        first (row) subscript is incremented.  See the *VOPER command for
        details.  If you are in the GUI, the *VWRITE command must be contained
        in an externally prepared file and read into ANSYS (i.e., *USE, /INPUT,
        etc.).

        This command is valid in any processor.
        """
        command = "*VWRITE,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(par1), str(par2), str(par3), str(par4), str(par5), str(par6), str(par7), str(par8), str(par9), str(par10), str(par11), str(par12), str(par13), str(par14), str(par15), str(par16), str(par17), str(par18), str(par19))
        return self.run(command, **kwargs)

    def pdclr(self, type="", **kwargs):
        """APDL Command: PDCLR

        Clears the probabilistic design database.

        Parameters
        ----------
        type
            Specifies the part of the probabilistic database to be cleared.

            ALL - Clear the entire probabilistic database. Both the preprocessing and
                  postprocessing parts are cleared.

            POST - Clear only the postprocessing part of the probabilistic database. This is
                   necessary if you want to modify the deterministic model (the
                   analysis file) or probabilistic model (random variables,
                   correlations between random variables, or the random output
                   parameter) after a probabilistic analysis has already been
                   performed.

        Notes
        -----
        Clears the probabilistic design system (PDS) database. The settings are
        reset to their default values and the memory is cleared. Remember that
        the result files containing the results of the probabilistic loops are
        never deleted unless you intentionally delete them. We recommend that
        you use this command before switching to a new probabilistic analysis
        using a different probabilistic model (a different analysis loop file
        or deterministic model), or changing random input variables, their
        correlations, or random output parameters. Clearing the probabilistic
        database is not necessary if the probabilistic model remains the same
        and will be analyzed with a different probabilistic method or different
        method options. See the PDEXE command for restrictions. Before issuing
        the PDCLR command, you should save the probabilistic database using the
        PDSAVE command.
        """
        command = "PDCLR,%s" % (str(type))
        return self.run(command, **kwargs)

    def mftime(self, time="", **kwargs):
        """APDL Command: MFTIME

        Sets end time for an ANSYS Multi-field solver analysis.

        Parameters
        ----------
        time
            End time of an ANSYS Multi-field solver analysis. Defaults to 1.

        Notes
        -----
        A MFTIME setting overrides any other end time setting (TIME).

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFTIME,%s" % (str(time))
        return self.run(command, **kwargs)

    def trnopt(self, method="", maxmode="", minmode="", mcout="", tintopt="",
               vaout="", **kwargs):
        """APDL Command: TRNOPT

        Specifies transient analysis options.

        Parameters
        ----------
        method
            Solution method for the transient analysis:

            FULL - Full method (default).

            MSUP - Mode-superposition method.

            VT - Variational Technology method.

        maxmode
            Largest mode number to be used to calculate the response (for
            Method = MSUP).  Defaults to the highest mode calculated in the
            preceding modal analysis.

        --
            Unused field.

        minmode
            Smallest mode number to be used (for Method = MSUP).  Defaults to
            1.

        mcout
            Modal coordinates output key (valid only for the mode-superposition
            method):

            NO - No output of modal coordinates (default).

            YES - Output modal coordinates to the text file Jobname.MCF.

        tintopt
            Time integration method for the transient analysis:

            NMK or 0 - Newmark algorithm (default).

            HHT or 1 - HHT algorithm (valid only for the full transient method).

        vaout
            Velocities and accelerations output key (valid only for mode-
            superposition transient analysis):

            NO - No output of velocities and accelerations (default).

            YES - Write velocities and accelerations on the reduced displacement file
                  Jobname.RDSP.

        Notes
        -----
        Specifies transient analysis (ANTYPE,TRANS) options. If used in
        SOLUTION, this command is valid only within the first load step. Use
        the TINTP command to set transient integration parameters.

        Method = VT is valid for either thermal or structural analysis, where
        it attempts to reduce the total number of iterations. Both linear and
        nonlinear structural transient analyses are supported. The VT method is
        a full transient solution.

        To include residual vectors in your mode-superposition transient
        analysis (Method = MSUP), specify RESVEC,ON.

        Method = MSUP is not available for ocean loading.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: The VT transient solution method is not
        supported in Distributed ANSYS.

        Additional product restrictions for the TRNOPT command are shown in the
        table below.

        The ANSYS Professional - Nonlinear Thermal (PR) product supports the
        Method = FULL option only when thermal degrees of freedom are present
        in the model.
        """
        command = "TRNOPT,%s,%s,%s,%s,%s,%s" % (str(method), str(maxmode), str(minmode), str(mcout), str(tintopt), str(vaout))
        return self.run(command, **kwargs)

    def rprism(self, z1="", z2="", nsides="", lside="", majrad="", minrad="",
               **kwargs):
        """APDL Command: RPRISM

        Creates a regular prism volume centered about the working plane origin.

        Parameters
        ----------
        z1, z2
            Working plane Z coordinates of the prism.

        nsides
            Number of sides in the polygon defining the top and bottom faces of
            the prism.  Must be greater than 2.

        lside
            Length of each side of the polygon defining the top and bottom
            faces of the prism.

        majrad
            Radius of the major (or circumscribed) circle of the polygon
            defining the top and bottom faces of the prism.  Not used if LSIDE
            is input.

        minrad
            Radius of the minor (or inscribed circle) of the polygon defining
            the top and bottom faces of the prism.  Not used if LSIDE or MAJRAD
            is input.

        Notes
        -----
        Defines a regular prism volume centered about the working plane origin.
        The prism must have a spatial volume greater than zero. (i.e., this
        volume primitive command cannot be used to create a degenerate volume
        as a means of creating an area.)  The top and bottom faces are
        polygonal areas that are parallel to the working plane but neither face
        need be coplanar with (i.e., "on") the working plane. The first
        keypoint defined for each face is at : θ = 0°.  See the RPR4 and PRISM
        commands for other ways to create prisms.
        """
        command = "RPRISM,%s,%s,%s,%s,%s,%s" % (str(z1), str(z2), str(nsides), str(lside), str(majrad), str(minrad))
        return self.run(command, **kwargs)

    def prcamp(self, option="", slope="", unit="", freqb="", cname="",
               stabval="", keyallfreq="", keynegfreq="", **kwargs):
        """APDL Command: PRCAMP

        Prints Campbell diagram data for applications involving rotating
        structure dynamics.

        Parameters
        ----------
        option
            Flag to activate or deactivate sorting of forward or backward whirl
            frequencies:

            0 (OFF or NO) - No sorting.

            1 (ON or YES) - Sort. This value is the default.

        slope
            The slope of the line to be printed. This value must be positive.

            SLOPE > 0  - The line represents the number of excitations per revolution of the rotor. For
                         example, SLOPE = 1 represents one excitation per
                         revolution, usually resulting from unbalance.

            SLOPE = 0  - The line represents the stability threshold for stability values or logarithmic
                         decrements printout (STABVAL = 1 or 2)

        unit
            Specifies the unit of measurement for rotational angular
            velocities:

            RDS - Rotational angular velocities in radians per second (rad/s). This value is the
                  default.

            RPM - Rotational angular velocities in revolutions per minute (RPMs).

        freqb
            The beginning, or lower end, of the frequency range of interest.
            The default is zero.

        cname
            The rotating component name.

        stabval
            Flag to print the stability values:

            0 (OFF or NO) - Print the frequencies (the imaginary parts of the eigenvalues in Hz). This
                            value is the default.

            1 (ON or YES) - Print the stability values (the real parts of the eigenvalues in Hz).

            2 - Print the logarithmic decrements.

        keyallfreq
            Key to specify if all frequencies above FREQB are printed out:

            0 (OFF or NO) - A maximum of 10 frequencies are printed out. They correspond to the frequencies
                            displayed via the PLCAMP command. This value is the
                            default.

            1 (ON or YES) - All frequencies are printed out.

        keynegfreq
            Key to specify if the negative frequencies are printed out. It only
            applies to solutions obtained with the damped eigensolver
            (Method=DAMP on the MODOPT command):

            0 (OFF or NO) - Only positive frequencies are printed out. This value is the default.

            1 (ON or YES) - Negative and positive frequencies are printed out.

        Notes
        -----
        The following items are required when generating a Campbell diagram:

        Take the gyroscopic effect into account by issuing the CORIOLIS command
        in the SOLUTION module.

        Run a modal analysis using the QR damped (MODOPT,QRDAMP) or damped
        (MODOPT,DAMP) method. Complex eigenmodes are necessary
        (MODOPT,QRDAMP,,,,Cpxmod  = ON), and you must specify the number of
        modes to expand (MXPAND).

        Define two or more load step results with an ascending order of
        rotational velocity (OMEGA or CMOMEGA).

        In some cases where modes are not in the same order from one load step
        to the other, sorting the frequencies (Option = 1) can help to obtain a
        correct printout. Sorting is based on the comparison between complex
        mode shapes calculated at two successive load steps.

        At each load step, the application compares the mode shape to the loads
        to determine the whirl direction. If applicable, a label appears (on
        the rows of output data) representing the whirl mode (BW for backward
        whirl and FW for forward whirl).

        If you specify a non-zero slope (SLOPE > 0), the command prints the
        critical speeds corresponding to the intersection points of the
        frequency curves and the added line. In the case of a named component
        (Cname), critical speeds relate to the rotational velocity of the
        component. Critical speeds are available only if the frequencies are
        printed (STABVAL = OFF).

        If you specify a zero slope (SLOPE = 0), the command prints the
        stability threshold corresponding to the sign change of the stability
        values (or logarithmic decrements). In the case of a named component
        (Cname), stability thresholds relate to the rotational velocity of the
        component. Stability thresholds are available only if the stability
        values or logarithmic decrements are printed (STABVAL = 1 or 2).

        At each load step, the program checks for instability (based on the
        sign of the real part of the eigenvalue). The label “U” appears on the
        printout for each unstable frequency.

        If specified, the rotational velocities of the named component (Cname)
        are printed out along with the natural frequencies.

        In general, printing a Campbell diagram is recommended only when your
        analysis is performed in a stationary reference frame
        (CORIOLIS,,,,RefFrame = ON).

        For information on printing a Campbell diagram for a prestressed
        structure, see Solving for a Subsequent Campbell Analysis of a
        Prestressed Structure Using the Linear Perturbation Procedure in the
        Rotordynamic Analysis Guide.

        For a usage example of the companion command PLCAMP (used for plotting
        a Campbell diagram), see Example Campbell Diagram Analysis.

        For more information on Campbell diagram generation, see Campbell
        Diagram in the Rotordynamic Analysis Guide.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "PRCAMP,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(slope), str(unit), str(freqb), str(cname), str(stabval), str(keyallfreq), str(keynegfreq))
        return self.run(command, **kwargs)

    def outopt(self, **kwargs):
        """APDL Command: OUTOPT

        Specifies "Output options" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "OUTOPT," % ()
        return self.run(command, **kwargs)

    def nlhist(self, key="", name="", item="", comp="", node="", elem="",
               shell="", layer="", stop_value="", stop_cond="", **kwargs):
        """APDL Command: NLHIST

        Specify result items to track during solution.

        Parameters
        ----------
        key
            Specifies the command operation:

            NSOL - Nodal solution data.

            ESOL - Element nodal data.

            PAIR  - Contact data (for pair-based contact).

            GCN - Contact data (for general contact).

            STAT - Displays a list of items to track.

            OFF or 0 - Deactivates tracking of all variables. This value is the default.

            ON or 1 - Activates tracking of all variables.  Tracking also activates whenever any
                      specification changes.

            DEL - Removes the specified variable from the set of result items to track. If Name =
                  ALL (default), all specifications are removed.

        name
            The 32-character user-specified name.

        item, comp
            Predetermined output item and component label for valid elements.
            See the Element Reference for more information.

        node
            Number identifying one of the following:

        elem
            Valid element number for element results. Used for ESOL items. If
            ELEM is specified, then a node number that belongs to the element
            must also be specified in the NODE field.

        shell
            Valid labels are TOP, MID or BOT. This field can specify the
            location on shell elements for which to retrieve data. Used only
            for element nodal data (ESOL).

        layer
            Layer number (for layered elements only). Used only for element
            nodal data (ESOL).

        stop_value
            Critical value of the tracked variable. This value is used to
            determine if the analysis should be terminated. This field is only
            valid for contact data (Key = PAIR or GCN).

        stop_cond
            Specifies the conditional relationship between the variable being
            tracked and the STOP_VALUE upon which the analysis will be
            terminated:

            -1 - Terminate the analysis when the tracked variable is less than or equal to
                 STOP_VALUE.

            0 - Terminate the analysis when the tracked variable equals STOP_VALUE.

            1 - Terminate the analysis when the tracked variable is greater than or equal to
                STOP_VALUE.

        Notes
        -----
        The NLHIST command is a nonlinear diagnostics tool that enables you to
        monitor diagnostics results of interest in real time during a solution.

        You can track a maximum of 50 variables during solution. The specified
        result quantities are written to the file Jobname.nlh. Nodal results
        and contact results are written for every converged substep
        (irrespective of the OUTRES command setting) while element results are
        written only at time points specified via the OUTRES command. For time
        points where element results data is not available, a very small number
        is written instead. If the conditions for contact to be established are
        not satisfied, 0.0 will be written for contact results.

        Results tracking is available only for a nonlinear structural analysis
        (static or transient), a nonlinear steady-state thermal analysis, or a
        transient thermal analysis (linear or nonlinear). All results are
        tracked in the Solution Coordinate System (that is, nodal results are
        in the nodal coordinate system and element results are in the element
        coordinate system).

        Contact results can be tracked for elements CONTA171 through CONTA177;
        they cannot be tracked for CONTA178.

        When contact results are tracked (Key = PAIR or GCN), the user-
        specified name (Name argument) is used to create a user-defined
        parameter. This enables you to monitor the parameter during solution.
        As an example, you can use a named parameter to easily convert the
        contact stiffness units from FORCE/LENGTH3 to FORCE/LENGTH based on the
        initial contact area CAREA. Be sure to specify Name using the APDL
        parameter naming convention.

        The STOP_VALUE and STOP_COND arguments enable you to automatically
        terminate the analysis when a desired value for a tracked contact
        result has been reached. This capability is only available for contact
        variables (Key = PAIR or GCN).

        The Jobname.nlh file is an ASCII file that lists each time point at
        which a converged solution occurs along with the values of the relevant
        result quantities.

        The GUI option Solution> Results tracking provides an interface to
        define the result items to be tracked. The GUI also allows you to graph
        one or more variables against time or against other variables during
        solution. You can use the interface to graph or list variables from any
        .nlh file generated by the ANSYS program.

        You can also track results during batch runs. Either access the ANSYS
        Launcher and select File Tracking from the Tools menu, or type
        nlhist162 at the command line. Use the supplied file browser to
        navigate to your Jobname.nlh file, and click on it to invoke the
        tracking utility. You can use this utility to read the file at any
        time, even after the solution is complete (the data in the file must be
        formatted correctly).

        Table: 205:: : NLHIST - Valid NSOL Item and Component Labels

        For SHELL131 and SHELL132 elements with KEYOPT(3) = 0 or 1, use the
        labels TBOT, TE2, TE3, . . ., TTOP instead of TEMP.

        For SHELL131 and SHELL132 elements with KEYOPT(3) = 0 or 1, use the
        labels HBOT, HE2, HE3, . . ., HTOP instead of HEAT.

        Table: 206:: : NLHIST - Valid ESOL Item and Component Labels
        """
        command = "NLHIST,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(key), str(name), str(item), str(comp), str(node), str(elem), str(shell), str(layer), str(stop_value), str(stop_cond))
        return self.run(command, **kwargs)

    def supl(self, surfname="", rsetname="", kwire="", **kwargs):
        """APDL Command: SUPL

        Plot result data on all selected surfaces or on a specified surface.

        Parameters
        ----------
        surfname
            Eight character surface name. ALL will plot all selected surfaces.

        rsetname
            Eight character result name.

        kwire
            Plot in context of model.

            0 - Plot results without the outline of selected elements.

            1 - Plot results with the outline of selected elements.

        Notes
        -----
        If RSetName is left blank, then the surface geometry will be plotted.
        If the Setname portion of the argument is a vector prefix (i.e. if
        result sets of name SetNameX, SetNameY and SetNameZ exist), ANSYS will
        plot these vectors on the surface as arrows. For example, SUPL, ALL,
        NORM will plot the surface normals as vectors on all selected surfaces,
        since NORMX NORMY and NORMZ are pre-defined geometry items.
        """
        command = "SUPL,%s,%s,%s" % (str(surfname), str(rsetname), str(kwire))
        return self.run(command, **kwargs)

    def staopt(self, method="", **kwargs):
        """APDL Command: STAOPT

        Specifies static analysis options.

        Parameters
        ----------
        method
            Solution method for the static analysis:

            DEFA - Standard ANSYS solve (default).

            VT - Solve with Variational Technology.

        Notes
        -----
        Specifies the method of solution for a static analysis (ANTYPE,STATIC).
        If used in SOLUTION, this command is valid only within the first load
        step.

        The VT option is valid for either thermal or structural nonlinear
        analyses, where it attempts to reduce the total number of iterations.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: The VT static solution method is not
        supported in Distributed ANSYS.
        """
        command = "STAOPT,%s" % (str(method))
        return self.run(command, **kwargs)

    def msave(self, key="", **kwargs):
        """APDL Command: MSAVE

        Sets the solver memory saving option. This option only applies to the
        PCG solver (including PCG Lanczos).

        Parameters
        ----------
        key
            Activation key:

            0 or OFF - Use global assembly for the stiffness matrix (and mass matrix, when using PCG
                       Lanczos) of the entire model.

            1 or ON - Use an element-by-element approach when possible to save memory during the
                      solution. In this case, the global stiffness (and mass)
                      matrix is not assembled; element stiffness (and mass) is
                      regenerated during PCG or PCG Lanczos iterations.

        Notes
        -----
        MSAVE,ON only applies to and is the default for parts of the model
        using the following element types with linear material properties that
        meet the conditions listed below.

        SOLID186 (Structural Solid only)

        SOLID187

        The following conditions must also be true:

        The PCG solver has been specified.

        Small strains are assumed (NLGEOM,OFF).

        No prestress effects (PSTRES) are included.

        All nodes on the supported element types must be defined (i.e., the
        midside nodes cannot be removed using the EMID command).

        For elements with thermally dependent material properties, MSAVE,ON
        applies only to elements with uniform temperatures prescribed.

        The default element coordinate system must be used.

        If you manually force MSAVE,ON by including it in the input file, the
        model can include the following additional conditions:

        The analysis can be a modal analysis using the PCG Lanczos method
        (MODOPT,LANPCG).

        Large deflection effects (NLGEOM,ON) are included.

        SOLID185 (brick shapes and KEYOPT(2) = 3 only) elements can be
        included.

        All other element types or other parts of the model that don't meet the
        above criteria will be solved using global assembly (MSAVE,OFF). This
        command can result in memory savings of up to 70 percent over the
        global assembly approach for the part of the model that meets the
        criteria. Depending on the hardware (e.g., processor speed, memory
        bandwidth, etc.), the solution time may increase or decrease when this
        feature is used.

        This memory-saving feature runs in parallel when multiple processors
        are used with the /CONFIG command or with Distributed ANSYS. The gain
        in performance with using multiple processors with this feature turned
        on should be similar to the default case when this feature is turned
        off. Performance also improves when using the uniform reduced
        integration option for SOLID186 elements.

        This command does not support the layered option of the SOLID185 and
        SOLID186 elements.

        When using MSAVE,ON with the PCGOPT command, note the following
        restrictions:

        For static and modal analyses, MSAVE,ON is not valid when using a
        Lev_Diff value of 5 on the PCGOPT command; Lev_Diff will automatically
        be reset to 2.

        For modal analyses, MSAVE,ON is not valid with the StrmCk option of the
        PCGOPT command; Strmck will be set to OFF.

        For all analysis types, MSAVE,ON is not valid when the Lagrange
        multiplier option (LM_Key) of the PCGOPT command is set to ON; the
        MSAVE activation key will be set to OFF.

        For linear perturbation static and modal analyses, MSAVE,ON is not
        valid; the MSAVE activation key will be set to OFF.

        When using MSAVE,ON for modal analyses, no .FULL file will be created.
        The .FULL file may be necessary for subsequent analyses (e.g.,
        harmonic, transient mode-superposition, or spectrum analyses). To
        generate the .FULL file, rerun the modal analysis using the WRFULL
        command.
        """
        command = "MSAVE,%s" % (str(key))
        return self.run(command, **kwargs)

    def ic(self, node="", lab="", value="", value2="", nend="", ninc="",
           **kwargs):
        """APDL Command: IC

        Specifies initial conditions at nodes.

        Parameters
        ----------
        node
            Node at which initial condition is to be specified.  If ALL, apply
            to all selected nodes (NSEL).  If NODE = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI). A component name may be substituted for NODE.

        lab
            Degree-of-freedom label for which the initial condition is to be
            specified.  If ALL, use all appropriate labels.

        value
            Initial value of the degree of freedom (first-order value).
            Defaults to the program default for that degree of freedom (0.0 for
            structural analysis, TUNIF for thermal analysis, etc.). Values are
            in the nodal coordinate system and in radians for rotational
            degrees of freedom.

        value2
            Second-order degree of freedom value, mainly used to specify
            initial structural velocity.  Defaults to the program default for
            that degree of freedom (0.0 for structural analysis).  Values are
            in the nodal coordinate system and in radians/time for rotational
            degrees of freedom.

        nend, ninc
            Specifies the same initial condition values at the range of nodes
            from NODE to NEND (defaults to NODE), in steps of NINC (defaults to
            1).

        Notes
        -----
        The IC command specifies initial conditions, which are the initial
        values of the specified degrees of freedom. It is valid only for a
        static analysis and full method transient analysis (TIMINT,ON and
        TRNOPT,FULL). For the transient, the initial value is specified at the
        beginning of the first load step, that is, at time = 0.0.

        Initial conditions should always be step applied (KBC,1) and not
        ramped.

        If constraints (D, DSYM, etc.) and initial conditions are applied at
        the same node, the constraint specification overrides. Exercise caution
        when specifying constraints. The degree-of-freedom values start from
        zero, or the first value given in the table when table name is
        specified. To match the nonzero initial condition value with the
        initial value for degree-of-freedom constraint, use a table for the
        degree-of-freedom constraint.

        For thermal analyses, any TUNIF specification should be applied before
        the IC command; otherwise, the TUNIF specification is ignored.  If the
        IC command is input before any TUNIF specification, use the ICDELE
        command and then reissue any TUNIF specification and then follow with
        the IC command.

        When issuing the IC command for elements SOLID278 Layered Thermal Solid
        and SOLID279 Layered Thermal Solid with through-the-thickness degrees
        of freedom (KEYOPT(3) = 2), layers are always interpolated linearly
        based on the location of the degrees of freedom.

        Define consistent initial conditions. For example, if you define an
        initial velocity at a single degree of freedom, the initial velocity at
        every other degree of freedom will be 0.0, potentially leading to
        conflicting initial conditions. In most cases, you should define
        initial conditions at every unconstrained degree of freedom in your
        model. If you define an initial condition for any degree of freedom at
        the pilot node of a rigid body (see Modeling Rigid Bodies in the
        Contact Technology Guide for the definition of rigid body), then the
        same initial condition must also be defined for the same degree of
        freedom on all other nodes of the rigid body.

        After a solution has been performed, the specified initial conditions
        are overwritten by the actual solution and are no longer available. You
        must respecify them if you want to perform a subsequent analysis. You
        may want to keep a database file saved prior to the first solution for
        subsequent reuse.

        If you use the CDWRITE command to archive your model, first-order
        values (initial displacements, temperatures, etc.) specified via the IC
        command are not written to the archive file; however, second-order
        (structural velocity) terms are written.

        This command is also valid in PREP7.
        """
        command = "IC,%s,%s,%s,%s,%s,%s" % (str(node), str(lab), str(value), str(value2), str(nend), str(ninc))
        return self.run(command, **kwargs)

    def rmalist(self, **kwargs):
        """APDL Command: RMALIST

        Lists all defined master nodes for a ROM method.

        Notes
        -----
        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMALIST," % ()
        return self.run(command, **kwargs)

    def pdmeth(self, method="", samp="", **kwargs):
        """APDL Command: PDMETH

        Specifies the probabilistic analysis method.

        Parameters
        ----------
        method
            Label for the probabilistic analysis method.

            MCS - Monte Carlo Simulation

            RSM - Response Surface Method

        samp
            Label for the sampling techniques. The sampling technique
            determines the values of the random input variables during the
            simulation loops.

            DIR - Direct or Crude Monte Carlo Sampling. This technique randomly samples the
                  random input variables according to their distribution
                  functions without "memory" of previous simulations.

            The parameters for a Monte Carlo Simulation using direct sampling are specified with the PDDMCS command. - LHS

            Latin Hypercube Sampling (default). Valid only for Method = MCS. For this sampling technique the random input variables are sampled randomly according to their distribution functions, efficiently stratifying the samples into layers and avoiding the re-use of those layers. The sampling process has a "memory" of previous simulations, which prevents accumulation of clusters of samples. In addition, this sampling strategy forces the extreme ends of a distribution function to participate in the sampling. This generally leads to smoother distribution functions of the sampled set. - The parameters for a Monte Carlo Simulation using Latin-Hypercube sampling are
                              specified with the PDLHS command.

            USER - User specified sampling. Valid only for Method = MCS. In this case you provide
                   a file containing the sampling "points" (values) of all
                   random input variables for all simulation loops. These
                   samples are simply executed and it is your responsibility to
                   specify the samples correctly. The probabilistic design
                   system can perform only limited checks on the samples you
                   provide. ANSYS allows Monte Carlo specific postprocessing
                   operations on the results generated with user-specified
                   samples. The parameters for the user-supplied sampling
                   technique are specified with the PDUSER command.

            CCD - Central Composite Design. Valid only for Method = RSM. A central composite
                  design is composed of a center point, axis points, and corner
                  points, called factorial points. Using large numbers of
                  random input variables produces prohibitively large numbers
                  of factorial points; therefore, ANSYS automatically reduces
                  the number of factorial points by switching to a fractional
                  plan for the factorial part of the design. See the PDDOEL
                  command for more information.

            Note:This option is only valid for 2 to 20 random input variables. You will receive an error if you have specified fewer than 2 or more than 20 random input variables. - BBM

            Box-Behnken Matrix Design. Valid only for Method = RSM. A Box-Behnken Matrix design is composed of a center point plus the points at the middle of the edges of the hypercube in the space of random input variables. A Box-Behnken design might be advantageous if the corner points of the hypercube represent very extreme conditions that are undesirable and therefore should not be used for the sampling.  See the PDDOEL command for more information. - Note:  This option is only valid for 3 to 12 random input variables. You will
                              receive an error if you have specified fewer than
                              3 or more than 12 random input variables.

            USER - User specified sampling. In this case you provide a file containing the
                   sampling "points" (values) of all random input variables for
                   all simulation loops. These samples are simply executed and
                   it is your responsibility to specify the samples correctly.
                   The PDS can perform only limited checks on the samples you
                   provide, if user-supplied sampling technique are specified
                   with the PDUSER command.

        Notes
        -----
        Specifies the probabilistic analysis method and the sampling technique
        used for the individual probabilistic analysis method.
        """
        command = "PDMETH,%s,%s" % (str(method), str(samp))
        return self.run(command, **kwargs)

    def bfvlist(self, volu="", lab="", **kwargs):
        """APDL Command: BFVLIST

        Lists the body force loads on a volume.

        Parameters
        ----------
        volu
            Volume at which body load is to be listed.  If ALL (or blank), list
            for all selected volumes [VSEL].  If VOLU = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for VOLU.

        lab
            Valid body load label. If ALL, use all appropriate labels. Load
            labels are listed under "Body Loads" in the input table for each
            element type in the Element Reference. See the BFV command for
            labels.

        Notes
        -----
        Lists the body force loads for the specified volume and label.  Body
        loads may be defined on a volume with the BFV command.

        This command is valid in any processor.
        """
        command = "BFVLIST,%s,%s" % (str(volu), str(lab))
        return self.run(command, **kwargs)

    def lsfactor(self, enginename="", option="", **kwargs):
        """APDL Command: *LSFACTOR

        Performs the numerical factorization of a linear solver system.

        Parameters
        ----------
        enginename
            Name used to identify this engine. Must have been previously
            created using *LSENGINE.

        option
            Option to invert the matrix, used only with an LAPACK engine
            (*LSENGINE,LAPACK):

        Notes
        -----
        Performs the computationally intensive, memory intensive factorization
        of a matrix specified by *LSENGINE, using the solver engine also
        specified by *LSENGINE.
        """
        command = "*LSFACTOR,%s,%s" % (str(enginename), str(option))
        return self.run(command, **kwargs)

    def linl(self, nl1="", nl2="", nl3="", nl4="", nl5="", nl6="", nl7="",
             nl8="", nl9="", **kwargs):
        """APDL Command: LINL

        Finds the common intersection of lines.

        Parameters
        ----------
        nl1, nl2, nl3, . . . , nl9
            Numbers of lines to be intersected.  If NL1 = ALL, find the
            intersection of all selected lines and NL2 to NL9 are ignored.  If
            NL1 = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI).  A component name may
            also be substituted for NL1.

        Notes
        -----
        Finds the common (not pairwise) intersection of lines.  The common
        intersection is defined as the regions shared (in common) by all lines
        listed on this command.  New lines will be generated where the original
        lines intersect.  If the regions of intersection are only points, new
        keypoints will be generated instead.  See the Modeling and Meshing
        Guide for an illustration.  See the BOPTN command for the options
        available to Boolean operations.  Element attributes and solid model
        boundary conditions assigned to the original entities will not be
        transferred to the new entities generated.
        """
        command = "LINL,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nl1), str(nl2), str(nl3), str(nl4), str(nl5), str(nl6), str(nl7), str(nl8), str(nl9))
        return self.run(command, **kwargs)

    def vdot(self, labr="", labx1="", laby1="", labz1="", labx2="", laby2="",
             labz2="", **kwargs):
        """APDL Command: VDOT

        Forms an element table item from the dot product of two vectors.

        Parameters
        ----------
        labr
            Label assigned to dot product result.

        labx1, laby1, labz1
            X, Y, and Z-component of first vector label.

        labx2, laby2, labz2
            X, Y, and Z-component of second vector label.

        Notes
        -----
        Forms labeled result items for the selected element from the dot
        product of two vectors:

        LabR = {LabX1, LabY1, LabZ1} : :  {LabX2, LabY2, LabZ2}

        Data must be in a consistent coordinate system.  Labels are those
        associated with the ETABLE command.
        """
        command = "VDOT,%s,%s,%s,%s,%s,%s,%s" % (str(labr), str(labx1), str(laby1), str(labz1), str(labx2), str(laby2), str(labz2))
        return self.run(command, **kwargs)

    def vfsm(self, action="", encl="", opt="", maxiter="", conv="", **kwargs):
        """APDL Command: VFSM

        Adjusts view factor matrix to satisfy reciprocity and/or row sum
        properties.

        Parameters
        ----------
        action
            Action to be performed:

            Define - Define a view factor summation (default)

            Clear - Resets the scaling method to 0 for all enclosures. All subsequent arguments are
                    ignored.

            Status - Outputs the OPT value for each enclosure in the model.

        encl
            Previously defined enclosure number for the view factor adjustment.

        opt
            Option key:

            0 - The view factor matrix values are not adjusted (default).

            1 - The view factor matrix values are adjusted so that the row sum equals 1.0.

            2 - The view factor matrix values are adjusted so that the row sum equals 1.0 and
                the reciprocity relationship is satisfied.

            3 - The view factor matrix values are adjusted so that the original row sum is
                maintained.

            4 - The view factor matrix values are adjusted so that the original row sum is
                maintained and the reciprocity relationship is satisfied.

        maxiter
            Maximum number of iterations to achieve convergence. Valid only
            when OPT = 2 or 4. Default is 100.

        conv
            Convergence value for row sum. Iterations will continue (up to
            MAXITER) until the maximum residual over all the rows is less than
            this value. Valid only when OPT = 2 or 4. Default is 1E-3.

        Notes
        -----
        To have a good energy balance, it is important to satisfy both the row
        sum and reciprocity relationships. For more information, see View
        Factors in the Mechanical APDL Theory Reference.

        OPT = 1 and 2 are suitable for perfect enclosures. OPT = 1 is less
        expensive than OPT = 2 because no iterations are involved. However,
        with OPT = 1, the reciprocity relationship is not satisfied.

        OPT = 3 and 4 are suitable for leaky enclosures. OPT = 3 is less
        expensive than OPT = 4 because no iterations are involved. However,
        with OPT = 3, the reciprocity relationship is not satisfied.

        The VFSM command must be used before VFOPT is issued, or Solve is
        initiated.
        """
        command = "VFSM,%s,%s,%s,%s,%s" % (str(action), str(encl), str(opt), str(maxiter), str(conv))
        return self.run(command, **kwargs)

    def cvar(self, ir="", ia="", ib="", itype="", datum="", name="", **kwargs):
        """APDL Command: CVAR

        Computes covariance between two quantities.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previous
            variable, the previous variable will be overwritten with this
            result.

        ia, ib
            Reference numbers of the two variables to be operated on.  If only
            one, leave IB blank.

        itype
            Defines the type of response PSD to be calculated:

            0,1 - Displacement (default).

            2 - Velocity.

            3 - Acceleration.

        datum
            Defines the reference with respect to which covariance is to be
            calculated:

            1 - Absolute value.

            2 - Relative to base (default).

        name
            Thirty-two character name for identifying the variable on listings
            and displays.  Embedded blanks are compressed upon output.

        Notes
        -----
        This command computes the covariance value for the variables referenced
        by the reference numbers IA and IB.  If DATUM = 2, the variable
        referenced by IR will contain the individual modal contributions (i.e.,
        the dynamic or relative values).  If DATUM = 1, the variable referenced
        by IR will contain the modal contributions followed by the
        contributions of pseudo-static and covariance between dynamic and
        pseudo-static responses. File.PSD must be available for the
        calculations to occur.
        """
        command = "CVAR,%s,%s,%s,%s,%s,%s" % (str(ir), str(ia), str(ib), str(itype), str(datum), str(name))
        return self.run(command, **kwargs)

    def r(self, nset="", r1="", r2="", r3="", r4="", r5="", r6="", **kwargs):
        """APDL Command: R

        Defines the element real constants.

        Parameters
        ----------
        nset
            Real constant set identification number (arbitrary).  If same as a
            previous set number, set is redefined. Set number relates to that
            defined with the element [REAL]. Note that the GUI automatically
            assigns this value.

        r1, r2, r3, . . . , r6
            Real constant values (interpreted as area, moment of inertia,
            thickness, etc., as required for the particular element type using
            this set), or table names for tabular input of boundary conditions.
            Use RMORE command if more than six real constants per set are to be
            input.

        Notes
        -----
        Defines the element real constants.  The real constants required for an
        element are shown in the Input Summary of each element description in
        the Element Reference.  Constants must be input in the same order as
        shown in that table.  If more than the required number of element real
        constants are specified in a set, only those required are used.  If
        fewer than the required number are specified, zero values are assumed
        for the unspecified constants.

        If using table inputs (SURF151, SURF152, FLUID116, CONTA171, CONTA172,
        CONTA173, CONTA174, and CONTA175 only), enclose the table name in %
        signs (e.g., %tabname%).

        Specify NSET = GCN to define real constants for real constant sets that
        were previously assigned by the GCDEF command (that is, real constants
        used in general contact interactions).

        When copying real constants to new sets, ANSYS, Inc. recommends that
        you use the command input. If you do use the GUI, restrict the real
        constant copy to only the first six real constants (real constants
        seven and greater will be incorrect for both the master and copy set).

        This command is also valid in SOLUTION.
        """
        command = "R,%s,%s,%s,%s,%s,%s,%s" % (str(nset), str(r1), str(r2), str(r3), str(r4), str(r5), str(r6))
        return self.run(command, **kwargs)

    def ancyc(self, numframes="", kcycl="", delay="", **kwargs):
        """APDL Command: ANCYC

        Applies a traveling wave animation to graphics data in a modal cyclic
        symmetry analysis.

        Parameters
        ----------
        numframes
            The number of plot frames for the animation. Valid values range
            from 5 through 36. The default is 18. A low value (because it
            specifies fewer graphical frames) produces a rougher animation but
            loads faster. A high value produces a smoother animation but
            requires more time to load.

        kcycl
            The animation mode:

            0 - Continuous animation cycle (forward-reverse-forward).

            1 - Discontinuous animation cycle (forward-reset-forward). This option is the
                default.

        delay
            The time delay (in seconds) between animation frames. Valid values
            range from 0.1 through 1.0. The default is 0.1 seconds, which
            produces a seemingly real-time animation. A higher value produces a
            slower animation.

        Notes
        -----
        The ANCYC command is valid in a modal cyclic symmetry analysis only.

        The command animates the cyclic symmetry mode shape plot in the General
        Post Processor (/POST1). When you issue a nodal- or element-results
        plot command (for example, PLNSOL, PLESOL, or PLDISP) and then issue
        the ANCYC command, ANSYS applies a traveling wave animation to the mode
        shape plot.

        Each frame of the animation is created by expanding the cyclic symmetry
        mode shape at increasing phase angles (via the /CYCEXPAND command)
        starting at zero in equal increments over 360°. The phase-angle
        increment is 360 / NUMFRAMES.

        The animation display shows the traveling wave of the result quantity
        being plotted. The traveling wave animation is applicable only to nodal
        diameters (harmonic indices) greater than 0 and less than N / 2 (where
        N is the number of cyclic sectors in the model).

        For more information, see Applying a Traveling Wave Animation to the
        Cyclic Model in the Cyclic Symmetry Analysis Guide.
        """
        command = "ANCYC,%s,%s,%s" % (str(numframes), str(kcycl), str(delay))
        return self.run(command, **kwargs)

    def ocdata(self, val1="", val2="", val3="", val14="", **kwargs):
        """APDL Command: OCDATA

        Defines an ocean load using non-table data.

        Parameters
        ----------
        val1, val2, val3, . . . , val14
            Values describing the basic ocean load or a wave condition.

        Notes
        -----
        The OCDATA command specifies non-table data that defines the ocean
        load, such as the depth of the ocean to the mud line, the ratio of
        added mass over added mass for a circular cross section, or the wave
        type to apply. The terms VAL1, VAL2, etc. are specialized according to
        the input set required for the given ocean load.

        The program interprets the data input via the OCDATA command within the
        context of the most recently issued OCTYPE command.

        Input values in the order indicated.

        This command is also valid in PREP7.

        You can define the following ocean data types:

        For a better understanding of how to set up a basic ocean type, see
        Figure: 5:: Basic Ocean Data Type Components .

        DEPTH -- The depth of the ocean (that is, the distance between the mean
        sea level and the mud line). The water surface is assumed to be level
        in the XY plane, with Z being positive upwards. This value is required
        and must be positive.

        MATOC -- The material number of the ocean. This value is required and
        is used to input the required density. It is also used to input the
        viscosity if the Reynolds number is used (OCTABLE).

        KFLOOD -- The inside-outside fluid-interaction key:

        For beam subtype CTUBE and HREC used with BEAM188 or BEAM189 and ocean
        loading, KFLOOD is always set to 1.

        Cay -- The ratio of added mass of the external fluid over the mass of
        the fluid displaced by the element cross section in the y direction
        (normal). The added mass represents the mass of the external fluid
        (ocean water) that moves with the pipe, beam, or link element when the
        element moves in the element y direction during a dynamic analysis.

        If no value is specified, and the coefficient of inertia CMy is not
        specified (OCTABLE), both values default to 0.0.

        If no value is specified, but CMy is specified, this value defaults to
        Cay = CMy - 1.0.

        If this value should be 0.0, enter 0.0.

        Caz -- The ratio of added mass of the external fluid over the mass of a
        cross section in the element z direction (normal). The added mass
        represents the mass of the external fluid (ocean water) that moves with
        the pipe, beam, or link element when the element moves in the element z
        direction during a dynamic analysis.

        If no value is specified, and Cay is specified, this value defaults to
        Cay.

        If no value is specified, and the coefficient of inertia CMz is not
        specified (OCTABLE), both values default to 0.0.

        If no value is specified, but CMz is specified, this value defaults to
        Cay = CMz - 1.0.

        If this value should be 0.0, enter 0.0.

        Cb -- The ratio of buoyancy force used over buoyancy force based on the
        outside diameter and water density. Accept the default value in most
        cases. Adjust this option only when you must account for additional
        hardware (such as a control valve) attached to the pipe exterior. A
        non-default value may lead to small non-physical inconsistencies;
        testing is therefore recommended for non-default values.

        If no value is specified, this value defaults to 1.0.

        If this value should be 0.0 (useful when troubleshooting your input),
        enter 0.0.

        Zmsl -- A vertical offset from the global origin to the mean sea level.
        The default value is zero (meaning that the origin is located at the
        mean sea level).

        Two example cases for Zmsl are:

        A structure with its origin on the sea floor (Zmsl = DEPTH).

        A tidal change (tc) above the mean sea level (Zmsl = tc, and DEPTH
        becomes DEPTH + tc)

        Ktable -- The dependency of VAL1 on the OCTABLE command:

        Figure: 5:: : Basic Ocean Data Type Components

         KWAVE -- The incident wave type:

        THETA -- Angle of the wave direction θ from the global Cartesian X axis
        toward the global Cartesian Y axis (in degrees).

        WAVELOC (valid when KWAVE = 0 through 3, and 101+) -- The wave location
        type:

        SPECTRUM (valid when KWAVE = 5 through 7) -- The wave spectrum type:

        KCRC -- The wave-current interaction key.

        Adjustments to the current profile are available via the KCRC constant
        of the water motion table. Typically, these options are used only when
        the wave amplitude is large relative to the water depth, such that
        significant wave-current interaction exists.
        """
        command = "OCDATA,%s,%s,%s,%s" % (str(val1), str(val2), str(val3), str(val14))
        return self.run(command, **kwargs)

    def plcamp(self, option="", slope="", unit="", freqb="", cname="",
               stabval="", keyallfreq="", keynegfreq="", **kwargs):
        """APDL Command: PLCAMP

        Plots Campbell diagram data for applications involving rotating
        structure dynamics.

        Parameters
        ----------
        option
            Flag to activate or deactivate sorting of forward or backward whirl
            frequencies:

            0 (OFF or NO) - No sorting.

            1 (ON or YES) - Sort. This value is the default.

        slope
            The slope of the line to be printed. This value must be positive.

            SLOPE > 0  - The line represents the number of excitations per revolution of the rotor. For
                         example, SLOPE = 1 represents one excitation per
                         revolution, usually resulting from unbalance.

            SLOPE = 0  - The line represents the stability threshold for stability values or logarithmic
                         decrements printout (STABVAL = 1 or 2)

        unit
            Specifies the unit of measurement for rotational angular
            velocities:

            RDS - Rotational angular velocities in radians per second (rad/s). This value is the
                  default.

            RPM - Rotational angular velocities in revolutions per minute (RPMs).

        freqb
            The beginning, or lower end, of the frequency range of interest.
            The default is zero.

        cname
            The rotating component name.

        stabval
            Flag to plot the stability values:

            0 (OFF or NO) - Plot the frequencies (the imaginary parts of the eigenvalues in Hz). This value
                            is the default.

            1 (ON or YES) - Plot the stability values (the real parts of the eigenvalues in Hz).

            2 - Plot the logarithmic decrements.

        keyallfreq
            Key to specify if all frequencies above FREQB are plotted:

            0 (OFF or NO) - A maximum of 10 frequencies are plotted. This value is the default.

            1 (ON or YES) - All frequencies are plotted.

        keynegfreq
            Key to specify if the negative frequencies are plotted. It only
            applies to solutions obtained with the damped eigensolver (Method =
            DAMP on the MODOPT command):

            0 (OFF or NO) - Only positive frequencies are plotted. This value is the default.

            1 (ON or YES) - Negative and positive frequencies are plotted.

        Notes
        -----
        The following items are required when generating a Campbell diagram:

        Take the gyroscopic effect into account by issuing the CORIOLIS command
        in the SOLUTION module.

        Run a modal analysis using the QR damped (MODOPT,QRDAMP) or damped
        (MODOPT,DAMP) method. Complex eigenmodes are necessary
        (MODOPT,QRDAMP,,,,Cpxmod  = ON), and you must specify the number of
        modes to expand (MXPAND).

        Define two or more load step results with an ascending order of
        rotational velocity (OMEGA or CMOMEGA).

        In some cases where modes are not in the same order from one load step
        to the other, sorting the frequencies (Option = 1) can help to obtain a
        correct plot. Sorting is based on the comparison between complex mode
        shapes calculated at two successive load steps.

        At each load step, the application compares the mode shape to the loads
        at other load steps to determine whirl direction at the load step. If
        applicable, a label appears (in the plot legend) representing each
        whirl mode (BW for backward whirl and FW for forward whirl).

        At each load step, the program checks for instability (based on the
        sign of the real part of the eigenvalue). The labels “stable” or
        “unstable” appear in the plot legend for each frequency curve.

        The rotational velocities of a named component (Cname) are displayed on
        the X-axis.

        For information on plotting a Campbell diagram for a prestressed
        structure, see Solving for a Subsequent Campbell Analysis of a
        Prestressed Structure Using the Linear Perturbation Procedure in the
        Rotordynamic Analysis Guide.

        In general, plotting a Campbell diagram is recommended only when your
        analysis is performed in a stationary reference frame
        (CORIOLIS,,,,RefFrame = ON).

        For a usage example of the PLCAMP command, see Campbell Diagram in the
        Rotordynamic Analysis Guide.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "PLCAMP,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(slope), str(unit), str(freqb), str(cname), str(stabval), str(keyallfreq), str(keynegfreq))
        return self.run(command, **kwargs)

    def eslv(self, type="", **kwargs):
        """APDL Command: ESLV

        Selects elements associated with the selected volumes.

        Parameters
        ----------
        type
            Label identifying the type of element selected:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        Notes
        -----
        Selects volume elements belonging to meshed [VMESH], selected [VSEL]
        volumes.

        This command is valid in any processor.
        """
        command = "ESLV,%s" % (str(type))
        return self.run(command, **kwargs)

    def edweld(self, option="", nweld="", n1="", n2="", sn="", ss="", expn="",
               exps="", epsf="", tfail="", nsw="", cid="", **kwargs):
        """APDL Command: EDWELD

        Defines a massless spotweld or generalized weld for use in an explicit
        dynamic analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed:

            ADD - Define a weld (default). This weld may be a spotweld between two nodes or a
                  generalized weld. A massless spotweld will be defined if
                  valid node numbers are specified in fields N1 and N2. A
                  generalized weld will be defined if a node component is
                  specified in field N1.

            DELE - Delete specified weld. If NWELD is blank, all welds are deleted.

            LIST - List specified weld. If NWELD is blank, all welds are listed.

        nweld
            Reference number identifying the spotweld or generalized weld.

        n1, n2
            For a spotweld, N1 and N2 are the nodes which are connected by the
            spotweld. For a generalized weld, input a nodal component name in
            N1 and leave N2 blank. The nodal component should contain all nodes
            that are to be included in the generalized weld.

        sn
            Normal force at spotweld failure.

        ss
            Shear force at spotweld failure.

        expn
            Exponent for normal spotweld force.

        exps
            Exponent for shear spotweld force.

        epsf
            Effective plastic strain at ductile failure (used only for a
            generalized weld).

        tfail
            Failure time for constraint set (used only for a generalized weld);
            default = 1.0e20.

        nsw
            Number of spot welds for the generalized weld.

        cid
            Coordinate system ID number (CID) to be used for output data (used
            only for a generalized weld). The coordinate system must be
            previously defined with the EDLCS command.

        Notes
        -----
        This command can be used to define a massless spotweld between two
        nodes or a generalized weld for a group of nodes.  For a spotweld, the
        nodes specified by N1 and N2 must not be coincident. For a generalized
        weld, coincident nodes are permitted, but CID must be specified when
        using coincident nodes. EDWELD is not updated after a node merge
        operation; therefore, node merging [NUMMRG,NODE] should be done before
        any EDWELD definitions. Nodes connected by a spotweld or generalized
        weld cannot be constrained in any other way.

        Failure of the weld occurs when:

        where fn and fs are normal and shear interface forces. Normal interface
        force fn is nonzero for tensile values only.

        You can graphically display spotwelds by issuing the command
        /PBC,WELD,,1.

        This command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDWELD,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(nweld), str(n1), str(n2), str(sn), str(ss), str(expn), str(exps), str(epsf), str(tfail), str(nsw), str(cid))
        return self.run(command, **kwargs)

    def sumap(self, rsetname="", item="", comp="", **kwargs):
        """APDL Command: SUMAP

        Map results onto selected surface(s).

        Parameters
        ----------
        rsetname
            Eight-character name for the result being mapped.

        item
            Label identifying the item.

        comp
            Component label of item (if required).

        Notes
        -----
        The SUMAP command maps results in the current coordinate system (RSYS)
        using the selected set of elements.

        The command interpolates and stores the results data on to each of the
        selected surfaces.

        SUMAP,ALL,CLEAR deletes all results sets from all selected surfaces.
        """
        command = "SUMAP,%s,%s,%s" % (str(rsetname), str(item), str(comp))
        return self.run(command, **kwargs)

    def edcts(self, dtms="", tssfac="", **kwargs):
        """APDL Command: EDCTS

        Specifies mass scaling and scale factor of computed time step for an
        explicit dynamics analysis.

        Parameters
        ----------
        dtms
            Time step size for mass scaled solutions (defaults to 0).

        tssfac
            Scale factor for computed time step. Defaults to 0.9; if high
            explosives are used, the default is lowered to 0.67.

        Notes
        -----
        If DTMS is positive, the same time step size will be used for all
        elements and mass scaling will be done for all elements.  Therefore,
        positive values should only be used if inertial effects are
        insignificant.

        If DTMS is negative, mass scaling is applied only to elements whose
        calculated time step size is smaller than DTMS.  Negative values should
        only be used in transient analyses if the mass increases are
        insignificant.

        In order to use mass scaling in an explicit dynamic small restart
        analysis (EDSTART,2) or full restart analysis (EDSTART,3), mass scaling
        must have been active in the original analysis. The time step and scale
        factor used in the original analysis will be used by default in the
        restart. You can issue EDCTS in the restart analysis to change these
        settings.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDCTS,%s,%s" % (str(dtms), str(tssfac))
        return self.run(command, **kwargs)

    def nsmooth(self, np_ass="", **kwargs):
        """APDL Command: NSMOOTH

        Smooths selected nodes among selected elements.

        Parameters
        ----------
        npass
            Number of smoothing passes. Defaults to 3.

        Notes
        -----
        Repositions each selected node at the average position of its immediate
        neighbors on the selected elements. The node positions converge after
        some number of smoothing passes. For some initial conditions, NPASS may
        need to be much larger than 3. If the boundary of a mesh is to be
        undisturbed (usually desirable), the boundary nodes should be
        unselected before issuing NSMOOTH.
        """
        command = "NSMOOTH,%s" % (str(np_ass))
        return self.run(command, **kwargs)

    def linv(self, nl="", nv="", **kwargs):
        """APDL Command: LINV

        Finds the intersection of a line with a volume.

        Parameters
        ----------
        nl
            Number of line to be intersected.  If NL = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).

        nv
            Number of volume to be intersected.

        Notes
        -----
        Finds the intersection of a line with a volume.  New lines will be
        generated where the lines intersect the volumes.  If the regions of
        intersection are only points, new keypoints will be generated instead.
        See the Modeling and Meshing Guide for an illustration.  See the BOPTN
        command for the options available to Boolean operations.  Element
        attributes and solid model boundary conditions assigned to the original
        entities will not be transferred to the new entities generated.
        """
        command = "LINV,%s,%s" % (str(nl), str(nv))
        return self.run(command, **kwargs)

    def axpy(self, vr="", vi="", m1="", wr="", wi="", m2="", **kwargs):
        """APDL Command: *AXPY

        Performs the matrix operation M2= v*M1 + w*M2.

        Parameters
        ----------
        vr, vi
            The real and imaginary parts of the scalar v. Default value is 0.

        m1
            Name of matrix M1. If not specified, the operation M2 = w*M2 will
            be performed.

        wr, wi
            The real and imaginary parts of the scalar w. Default value is 0.

        m2
            Name of matrix M2. Must be specified.

        Notes
        -----
        The matrices M1 and M2 must have the same dimensions and same type
        (dense or sparse). If M2 is real, vi and wi are ignored.
        """
        command = "*AXPY,%s,%s,%s,%s,%s,%s" % (str(vr), str(vi), str(m1), str(wr), str(wi), str(m2))
        return self.run(command, **kwargs)

    def deriv(self, ir="", iy="", ix="", name="", facta="", **kwargs):
        """APDL Command: DERIV

        Differentiates a variable.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        iy, ix
            Reference numbers of variables to be operated on.  IY is
            differentiated with respect to IX.

        --
            Unused field.

        name
            Thirty-two character name for identifying the variable on printouts
            and displays. Embedded blanks are compressed for output.

        --, --
            Unused fields.

        facta
            Scaling factor (positive or negative) applied as shown below
            (defaults to 1.0).

        Notes
        -----
        Differentiates variables according to the operation:

        IR = FACTA x d(IY)/d(IX)
        """
        command = "DERIV,%s,%s,%s,%s,%s" % (str(ir), str(iy), str(ix), str(name), str(facta))
        return self.run(command, **kwargs)

    def edndtsd(self, vect1="", vect2="", datap="", fitpt="", vect3="",
                vect4="", disp="", **kwargs):
        """APDL Command: EDNDTSD

        Allows smoothing of noisy data for explicit dynamics analyses and
        provides a graphical representation of the data.

        Parameters
        ----------
        vect1
            Name of the first vector that contains the noisy data set (i.e.,
            independent variable). You must create and fill this vector before
            issuing EDNDTSD.

        vect2
            Name of the second vector that contains the dependent set of data.
            Must be the same length as the first vector. You must create and
            fill this vector before issuing EDNDTSD.

        datap
            Number of data points to be fitted, starting from the beginning of
            the vector. If left blank, the entire vector will be fitted. The
            maximum number of data points is 100,000 (or greater, depending on
            the memory of the computer).

        fitpt
            Curve fitting order to be used as a smooth representation of the
            data. This number should be less than or equal to the number of
            data points. However, because high order polynomial curve fitting
            can cause numerical difficulties, a polynomial order less than 7 is
            suggested. The default (blank) is one-half the number of data
            points or 7, which ever is less. The following values are
            available:

            1 - Curve is the absolute average of all of the data points.

            2 - Curve is the least square average of all of the data points.

            3 or more - Curve is a polynomial of the order (n-1), where n is the number of data fitting
                        order points.

        vect3
            Name of the vector that contains the smoothed data of the
            independent variable. This vector should have a length equal to or
            greater than the number of smoothed data points. In batch (command)
            mode, you must create this vector before issuing the EDNDTSD
            command. In interactive mode, the GUI automatically creates this
            vector (if it does not exist). If you do not specify a vector name,
            the GUI will name the vector smth_ind.

        vect4
            Name of the vector that contains the smoothed data of the dependent
            variable.  This vector must be the same length as Vect3.  In batch
            (command) mode, you must create this vector before issuing the
            EDNDTSD command. In interactive mode, the GUI automatically creates
            this vector (if it does not exist). If you do not specify a vector
            name, the GUI will name the vector smth_dep.

        disp
            Specifies how you want to display data. No default; you must
            specify an option.

            1 - Unsmoothed data only

            2 - Smoothed data only

            3 - Both smoothed and unsmoothed data

        Notes
        -----
        You can control the attributes of the graph using standard ANSYS
        controls (/GRID, /GTHK, /COLOR, etc.). If working interactively, these
        controls appear in this dialog box for convenience, as well as in their
        standard dialog boxes. You must always create Vect1 and Vect2 (using
        *DIM) and fill these vectors before smoothing the data. If you're
        working interactively, ANSYS automatically creates Vect3 and Vect4, but
        if you're working in batch (command) mode, you must create Vect3 and
        Vect4 (using *DIM) before issuing EDNDTSD.  Vect3 and Vect4 are then
        filled automatically by ANSYS.  In addition, ANSYS creates an
        additional TABLE type array that contains the smoothed array and the
        unsmoothed data to allow for plotting later with *VPLOT.  Column 1 in
        this table corresponds to Vect1, column 2 to Vect2, and column 3 to
        Vect4.  This array is named Vect3_SMOOTH, up to a limit of 32
        characters. For example, if the array name is X1, the table name is
        X1_SMOOTH.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDNDTSD,%s,%s,%s,%s,%s,%s,%s" % (str(vect1), str(vect2), str(datap), str(fitpt), str(vect3), str(vect4), str(disp))
        return self.run(command, **kwargs)

    def sffun(self, lab="", par="", par2="", **kwargs):
        """APDL Command: SFFUN

        Specifies a varying surface load.

        Parameters
        ----------
        lab
            Valid surface load label.  Load labels are listed under "Surface
            Loads" in the input table for each element type in the Element
            Reference.  Issue SFFUN,STATUS to list current command settings.

        par
            Parameter containing list of surface load values.  If Lab = CONV,
            values are typically the film coefficients and Par2 values (below)
            are typically the bulk temperatures.

        par2
            Parameter containing list of second surface load values (if any).
            If Lab = CONV, the Par2 values are typically the bulk temperatures.
            Par2 is not used for other surface load labels.

        Notes
        -----
        Specifies a surface load "function" to be used when the SF or SFE
        command is issued.  The function is supplied through an array parameter
        vector which contains nodal surface load values.  Node numbers are
        implied from the sequential location in the array parameter.  For
        example, a value in location 11 applies to node 11.  The element faces
        are determined from the implied list of nodes when the SF or SFE
        command is issued.  Zero values should be supplied for nodes that have
        no load.  A tapered load value may be applied over the element face.
        These loads are in addition to any loads that are also specified with
        the SF or SFE commands.  Issue SFFUN (with blank remaining fields) to
        remove this specification.  Issue SFFUN,STATUS to list current
        settings.

        Starting array element numbers must be defined for each array parameter
        vector.  For example, SFFUN,CONV,A(1,1),A(1,2) reads the first and
        second columns of array A (starting with the first array element of
        each column) and associates the values with the nodes.  Operations
        continue on successive column array elements until the end of the
        column. Another example to show the order of the commands:

        SFFUN does not work for tabular boundary conditions.

        This command is also valid in PREP7.
        """
        command = "SFFUN,%s,%s,%s" % (str(lab), str(par), str(par2))
        return self.run(command, **kwargs)

    def bfecum(self, lab="", oper="", fact="", tb_ase="", **kwargs):
        """APDL Command: BFECUM

        Specifies whether to ignore subsequent element body force loads.

        Parameters
        ----------
        lab
            Valid body load label.  If ALL, use all appropriate labels.

        oper
            Replace or ignore key:

            REPL - Subsequent values replace the previous values (default).

            IGNO - Subsequent values are ignored.

        fact
            Scale factor for the element body load values.  Zero (or blank)
            defaults to 1.0.  Use a small number for a zero scale factor.  The
            scale factor is not applied to body load phase angles.

        tbase
            Used (only with  Lab = TEMP) to calculate the temperature used in
            the add or replace operation (see Oper) as:

        Notes
        -----
        Allows repeated element body force loads to be replaced or ignored.
        Element body loads are applied with the BFE command.  Issue the BFELIST
        command to list the element body loads.  The operations occur when the
        next body loads are defined.  For example, issuing the BFE command with
        a temperature value of 25 after a previous BFE command with a
        temperature value of 20 causes the new value of that temperature to be
        25 with the replace operation, or 20 with the ignore operation.  A
        scale factor is also available to multiply the next value before the
        replace operation.  A scale factor of 2.0 with the previous "replace"
        example results in a temperature of 50.  The scale factor is applied
        even if no previous values exist.  Issue BFECUM,STAT to show the
        current label, operation, and scale factors.

        BFECUM does not work for tabular boundary conditions.

        This command is also valid in PREP7.
        """
        command = "BFECUM,%s,%s,%s,%s" % (str(lab), str(oper), str(fact), str(tb_ase))
        return self.run(command, **kwargs)

    def config(self, lab="", value="", **kwargs):
        """APDL Command: /CONFIG

        Assigns values to ANSYS configuration parameters.

        Parameters
        ----------
        lab
            Configuration parameter to be changed:

            NORSTGM - Option to write or not write geometry data to the results file. VALUE is either
                      0 (write geometry data) or 1 (do not write geometry
                      data). Useful when complex analyses will create
                      abnormally large files. Default is 0.

            NBUF - VALUE is the number of buffers (1 to 32) per file in the solver.  Defaults to
                   4.

            LOCFL - File open and close actions.  For VALUE use: 0 for global (default); 1 for
                    local.  Applicable to File.EROT, File.ESAV, and File.EMAT.
                    Typically  used for large problems where locally closed
                    files may be deleted  earlier in the run with the /FDELE
                    command.

            SZBIO - VALUE is the record size (1024 to 4194304) of binary files (in integer words).
                    Defaults to 16384 (system dependent).

            ORDER - Automatic reordering scheme.  For VALUE use: 0 for WSORT,ALL; 1 for WAVES; 2
                    for both WSORT,ALL and WAVES (default).

            FSPLIT - Defines split points for binary files.  VALUE is the file split point in
                     megawords and defaults to the maximum file size for the
                     system.

            MXND - Maximum number of nodes. If not specified, defaults to 100 at first encounter.
                   Dynamically expanded by doubling, even at first encounter,
                   when maximum is exceeded.

            MXEL - Maximum number of elements.  Default and expansion as for MXND.

            MXKP - Maximum number of keypoints.  Default and expansion as for MXND.

            MXLS - Maximum number of lines.  Default and expansion as for MXND.

            MXAR - Maximum number of areas.  Default and expansion as for MXND.

            MXVL - Maximum number of volumes.  Default and expansion as for MXND.

            MXRL - Maximum number of sets of real constants (element attributes).  Default and
                   expansion as for MXND.

            MXCP - Maximum number of sets of coupled degrees of freedom.  Default and expansion as
                   for MXND.

            MXCE - Maximum number of constraint equations.  Default and expansion as for MXND.

            NOELDB - Option to write or not write results into the database after a solution.  When
                     VALUE = 0 (default), write results into the database.
                     When VALUE = 1, do not write results into the database.

            DYNA_DBL - Option to invoke the double precision version of the explicit dynamics solver
                       LS-DYNA. When VALUE = 0 (default), the single precision
                       version is used. When VALUE = 1, the double precision
                       version is used.

            STAT - Displays current values set by the /CONFIG command.

        value
            Value (an integer number) assigned to the configuration parameter.

        Notes
        -----
        All configuration parameters have initial defaults, which in most cases
        do not need to be changed.  Where a specially configured version of the
        ANSYS program is desired, the parameters may be changed with this
        command.  Issue /CONFIG,STAT to display current values.  Changes must
        be defined before the parameter is required.  These changes (and
        others) may also be incorporated into the config162.ans file which is
        read upon execution of the program (see The Configuration File in the
        Basic Analysis Guide).  If the same configuration parameter appears in
        both the  configuration file and this command, this command overrides.

        Distributed ANSYS uses the default FSPLIT value, and forces NOELDB = 1
        and NORSTGM = 0 for all results files. The FSPLIT, NOELDB, and NORSTGM
        options cannot be changed when using Distributed ANSYS.

        The /CONFIG command is not valid for the ANSYS Multiphysics 1, 2, or 3
        products.

        The ANSYS Multi-field solver (MFS and MFX) does not support
        /CONFIG,NOELDB,1. The ANSYS Multi-field solver needs the updated ANSYS
        database.
        """
        command = "/CONFIG,%s,%s" % (str(lab), str(value))
        return self.run(command, **kwargs)

    def wtbcreate(self, iel="", node="", damp="", **kwargs):
        """APDL Command: WTBCREATE

        Creates a USER300 element to model the turbine for full aeroelastic
        coupling analysis and specifies relevant settings for the analysis.

        Parameters
        ----------
        iel
            Element number (next available number by default).

        node
            Node number connecting support structure and turbine.

        damp
            Damping option for the turbine:

            0 - Damping matrix obtained from the aeroelastic code plus Rayleigh damping
                (default).

            1 - Rayleigh damping only.

            2 - Damping from the aeroelastic code only.

        Notes
        -----
        WTBCREATE invokes a predefined ANSYS macro that will automatically
        generate a turbine element and issue relevant data commands that are
        necessary to run a full aeroelastic coupling analysis. For detailed
        information on how to perform a fully coupled aeroelastic analysis, see
        Fully Coupled Wind Turbine Example in Mechanical APDL in the Mechanical
        APDL Programmer's Reference.

        The generated USER300 turbine element will have 9 nodes with node
        numbers NODE, NMAX+1, NMAX+2, ..., NMAX+8, where NMAX is the maximum
        node number currently in the model.

        There are 6 freedoms on the first node of the element: UX, UY, UZ,
        ROTX, ROTY, ROTZ, and these are true structural freedoms. For all the
        other nodes (i.e., nodes 2 to 9), only the translational freedoms (UX,
        UY, UZ) are used. These are generalized freedoms that are internal to
        the turbine element and are used by the aeroelastic code only.

        The element type integer of the USER300 element is the current maximum
        element type integer plus one.

        The command will also set up the analysis settings appropriate for a
        full aeroelastic coupling analysis. These include full Newton-Raphson
        solution (NROPT,FULL) and a USRCAL command to activate the relevant
        user routines.
        """
        command = "WTBCREATE,%s,%s,%s" % (str(iel), str(node), str(damp))
        return self.run(command, **kwargs)

    def read(self, fname="", nskip="", format="", xfield="", yfield="",
             zfield="", prfield="", pifield="", **kwargs):
        """APDL Command: READ

        Reads coordinate and pressure data from a file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        nskip
            Number of lines at the beginning of the file that will be skipped
            while it is read. Default = 0. NSKIP is ignored for FileType =
            CFXTBR or CFDPOST on the FTYPE command.

        format
            For FileType = FORMATTED on the FTYPE command, Format is the read
            format in the FORTRAN FORMAT convention enclosed in parentheses;
            for example: (3e10.0,10x,e10.0,70x,e10.0)

        xfield, yfield, zfield, prfield, pifield
            For FileType = CSV on the FTYPE command, these are field numbers
            locating the coordinates and real and imaginary (if present)
            pressures. The field value may not exceed 20.

        Notes
        -----
        Reads coordinate and pressure data from the specified file. The file
        type must have been previously specified on the FTYPE command.

        Upon reading the file, nodes are created for the source points. For
        FileType = CFXTBR or CFDPOST on the FTYPE command, if face data is
        available, SURF154 elements are also created. A nodal component named
        SOURCENODES and an element component named SOURCEELEMS are created
        automatically.
        """
        command = "READ,%s,%s,%s,%s,%s,%s,%s,%s" % (str(fname), str(nskip), str(format), str(xfield), str(yfield), str(zfield), str(prfield), str(pifield))
        return self.run(command, **kwargs)

    def fatigue(self, **kwargs):
        """APDL Command: FATIGUE

        Specifies "Fatigue data status" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "FATIGUE," % ()
        return self.run(command, **kwargs)

    def vlscale(self, nv1="", nv2="", ninc="", rx="", ry="", rz="", kinc="",
                noelem="", imove="", **kwargs):
        """APDL Command: VLSCALE

        Generates a scaled set of volumes from a pattern of volumes.

        Parameters
        ----------
        nv1, nv2, ninc
            Set of volumes (NV1 to NV2 in steps of NINC) that defines the
            pattern to be scaled.  NV2 defaults to NV1, NINC defaults to 1.  If
            NV1 = ALL, NV2 and NINC are ignored and the pattern is defined by
            all selected volumes.  If NV1 = P, graphical picking is enabled and
            all remaining command fields are ignored (valid only in the GUI).
            A component name may also be substituted for NV1 (NV2 and NINC are
            ignored).

        rx, ry, rz
            Scale factors to be applied to the X, Y, and Z keypoint coordinates
            in active coordinate system (RR, Rθ, RZ for cylindrical; RR, Rθ, RΦ
            for spherical).  Note that the Rθ and RΦ scale factors are
            interpreted as angular offsets.  For example, if CSYS = 1, RX, RY,
            RZ input of (1.5,10,3) would scale the specified keypoints 1.5
            times in the radial and 3 times in the Z direction, while adding an
            offset of 10 degrees to the keypoints.  Zero, blank, or negative
            scale factor values are assumed to be 1.0.  Zero or blank angular
            offsets have no effect.

        kinc
            Increment to be applied to keypoint numbers for generated set.  If
            zero, the lowest available keypoint numbers will be assigned
            [NUMSTR].

        noelem
            Specifies whether nodes and elements are also to be generated:

            0 - Nodes and elements associated with the original volumes will be generated
                (scaled) if they exist.

            1 - Nodes and elements will not be generated.

        imove
            Specifies whether volumes will be moved or newly defined:

            0 - Additional volumes will be generated.

            1 - Original volumes will be moved to new position (KINC and NOELEM are ignored).
                Use only if the old volumes are no longer needed at their
                original positions.  Corresponding meshed items are also moved
                if not needed at their original position.

        Notes
        -----
        Generates a scaled set of volumes (and their corresponding keypoints,
        lines, areas,  and mesh) from a pattern of volumes.  The MAT, TYPE,
        REAL, and ESYS attributes are based on the volumes in the pattern and
        not the current settings.  Scaling is done in the active coordinate
        system.  Volumes in the pattern could have been generated in any
        coordinate system.  However, solid modeling in a toroidal coordinate
        system is not recommended.
        """
        command = "VLSCALE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nv1), str(nv2), str(ninc), str(rx), str(ry), str(rz), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def sspb(self, b11="", b21="", b31="", b22="", b32="", b33="", t="",
             b12="", b13="", b23="", **kwargs):
        """APDL Command: SSPB

        Specifies a preintegrated coupling stiffness for shell sections.

        Parameters
        ----------
        b11, b21, b31, b22, b32, b33
            Coupling stiffness component (symmetric lower part of submatrix
            [B]).

        t
            Temperature.

        b12, b13, b23
            Upper part of submatrix [B]

        Notes
        -----
        The behavior of shell elements is governed by the generalized-
        stress/generalized-strain relationship of the form:

        If the coefficients B12, B13, B23 are undefined, ANSYS uses a symmetric
        form of submatrix [B].  If any one of the coefficients B12, B13, B23 is
        nonzero, ANSYS considers submatrix [B] to be unsymmetric.

        The SSPB command, one of several preintegrated shell section commands,
        specifies the coupling stiffness quantity (submatrix [B] data) for a
        preintegrated shell section. The section data defined is associated
        with the section most recently defined (via the SECTYPE command).

        Unspecified values default to zero.

        Related commands are SSPA, SSPD, SSPE, SSMT, SSBT, and SSPM.

        If you are using the SHELL181 or SHELL281 element's Membrane option
        (KEYOPT(1) = 1), it is not necessary to issue this command.

        For complete information, see Using Preintegrated General Shell
        Sections.
        """
        command = "SSPB,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(b11), str(b21), str(b31), str(b22), str(b32), str(b33), str(t), str(b12), str(b13), str(b23))
        return self.run(command, **kwargs)

    def edwrite(self, option="", fname="", ext="", **kwargs):
        """APDL Command: EDWRITE

        Writes explicit dynamics input to an LS-DYNA input file.

        Parameters
        ----------
        option
            Sets a flag in the LS-DYNA input file (Fname.Ext) to produce
            desired output.

            ANSYS - Set a flag to write results files for the ANSYS postprocessors (default).  The
                    files that will be written are Jobname.RST and Jobname.HIS
                    (see Notes below).

            LSDYNA - Set a flag to write results files for the LS-DYNA postprocessor (LS-POST).  The
                     files that will be written are D3PLOT, and files specified
                     by EDOUT and EDHIST (see Notes below).

            BOTH - Set a flag to write results files for both ANSYS and LS-DYNA postprocessors.

        fname
            File name and directory path (80 characters maximum, including
            directory; this limit is due to an LS-DYNA program limitation). If
            you do not specify a directory path, it will default to your
            working directory. The file name defaults to Jobname. Previous data
            on this file, if any, are overwritten.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        This command writes an LS-DYNA input file for the LS-DYNA solver.
        EDWRITE is only valid if explicit dynamic elements have been specified.
        This command is not necessary if the LS-DYNA solver is invoked from
        within ANSYS, in which case Jobname.K (or Jobname.R) is written
        automatically when the solution is initiated. (If LS-DYNA is invoked
        from within ANSYS, use EDOPT to specify desired output.)

        If the analysis is a small restart (EDSTART,2), the file that is
        written will have the name Jobname.R (by default) and will only contain
        changes from the original analysis.

        If the analysis is a full restart (EDSTART,3), the file that is written
        will have the name Jobname_nn.K (by default) and will contain all the
        information from the database. In a full restart, the jobname is
        changed to Jobname_nn (nn = 01 initially, and is incremented for each
        subsequent full restart.)

        A command is included in the LS-DYNA input file to instruct the LS-DYNA
        solver to write the results files indicated by Option.  By default, LS-
        DYNA will write the ANSYS results file Jobname.RST (see the EDRST
        command).  If Jobname.HIS is desired, you must also issue EDHIST.

        Option = LSDYNA or BOTH will cause LS-DYNA to write results files for
        the LS-POST postprocessor. The D3PLOT file is always written for these
        two options. If other LS-POST files are desired, you must issue the
        appropriate EDHIST and EDOUT commands.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDWRITE,%s,%s,%s" % (str(option), str(fname), str(ext))
        return self.run(command, **kwargs)

    def post26(self, **kwargs):
        """APDL Command: /POST26

        Enters the time-history results postprocessor.

        Notes
        -----
        Enters the time-history results postprocessor (POST26).

        This command is valid only at the Begin Level.
        """
        command = "/POST26," % ()
        return self.run(command, **kwargs)

    def mwrite(self, parr="", fname="", ext="", label="", n1="", n2="", n3="",
               **kwargs):
        """APDL Command: *MWRITE

        Writes a matrix to a file in a formatted sequence.

        Parameters
        ----------
        parr
            The name of the array parameter. See *SET for name restrictions.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        label
            Can use a value of IJK, IKJ, JIK, JKI, KIJ, KJI, or blank (JIK).

        n1, n2, n3
            Write as (((ParR(i,j,k), k = 1,n1), i = 1, n2), j = 1, n3) for
            Label = KIJ. n1, n2, and n3 default to the corresponding dimensions
            of the array parameter ParR.

        Notes
        -----
        Writes a matrix or vector to a specified file in a formatted sequence.
        You can also use the *VWRITE command to write data to a specified file.
        Both commands contain format descriptors on the line immediately
        following the command. The format descriptors can be in either Fortran
        or C format.

        Fortran format descriptors are enclosed in parentheses. They must
        immediately follow the *MWRITE command on a separate line of the same
        input file. The word FORMAT should not be included. The format must
        specify the number of fields to be written per line, the field width,
        the placement of the decimal point, etc. There should be one field
        descriptor for each data item written. The write operation uses the
        available system FORTRAN FORMAT conventions (see your system FORTRAN
        manual). Any standard FORTRAN real format (such as (4F6.0),
        (E10.3,2X,D8.2), etc.) and character format (A) may be used.  Integer
        (I) and list-directed (*) descriptors may not be used. Text may be
        included in the format as a quoted string. The FORTRAN descriptor must
        be enclosed in parentheses and the format must not exceed 80 characters
        (including parentheses).

        The “C” format descriptors are used if the first character of the
        format descriptor line is not a left parenthesis. “C” format
        descriptors may be up to 80 characters long, consisting of text strings
        and predefined "data descriptors" between the strings where numeric or
        alphanumeric character data are to be inserted. The normal descriptors
        are %I for integer data, %G for double precision data, %C for
        alphanumeric character data, and %/ for a line break. There must be one
        data descriptor for each specified value in the order of the specified
        values. The enhanced formats described in *MSG may also be used.

        The starting array element number must be defined. Looping continues in
        the directions indicated by the Label argument. The number of loops and
        loop skipping may also be controlled with the *VLEN and *VMASK
        commands, which work in the n2 direction (by row on the output file),
        and by  the *VCOL command, which works in the n1 direction (by column
        in the output file).  The vector specifications *VABS and *VFACT apply
        to this command, while *VCUM does not apply to this command. See the
        *VOPER command for details. If you are in the GUI, the *MWRITE command
        must be contained in an externally prepared file and read into ANSYS
        (i.e., *USE, /INPUT, etc.).

        This command is valid in any processor.
        """
        command = "*MWRITE,%s,%s,%s,%s,%s,%s,%s" % (str(parr), str(fname), str(ext), str(label), str(n1), str(n2), str(n3))
        return self.run(command, **kwargs)

    def kwpave(self, p1="", p2="", p3="", p4="", p5="", p6="", p7="", p8="",
               p9="", **kwargs):
        """APDL Command: KWPAVE

        Moves the working plane origin to the average location of keypoints.

        Parameters
        ----------
        p1, p2, p3, . . . , p9
            Keypoints used in calculation of the average.  At least one must be
            defined.  If P1 = P, graphical picking is enabled and all remaining
            command fields are ignored (valid only in the GUI).

        Notes
        -----
        Moves the origin of the working plane to the average of the specified
        keypoints.  Averaging is based on the active coordinate system.

        This command is valid in any processor.
        """
        command = "KWPAVE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(p1), str(p2), str(p3), str(p4), str(p5), str(p6), str(p7), str(p8), str(p9))
        return self.run(command, **kwargs)

    def gmatrix(self, symfac="", condname="", numcond="", matrixname="",
                **kwargs):
        """APDL Command: GMATRIX

        Performs electric field solutions and calculates the self and mutual
        conductance between multiple conductors.

        Parameters
        ----------
        symfac
            Geometric symmetry factor.  Conductance values are scaled by this
            factor which represents the fraction of the total device modeled.
            Defaults to 1.

        condname
            Alphanumeric prefix identifier used in defining named conductor
            components.

        numcond
            Total number of components.  If a ground is modeled, it is to be
            included as a component.

        --
            Unused field.

        matrixname
            Array name for computed conductance matrix.  Defaults to GMATRIX.

        Notes
        -----
        To invoke the GMATRIX macro, the exterior nodes of each conductor must
        be grouped into individual components using the CM command.  Each set
        of  independent components is assigned a component name with a common
        prefix followed by the conductor number.  A conductor system with a
        ground must also include the ground nodes as a component.  The ground
        component is numbered last in the component name sequence.

        A ground conductance matrix relates current to a voltage vector.  A
        ground matrix cannot be applied to a circuit modeler.  The lumped
        conductance matrix is a combination of  lumped "arrangements" of
        voltage differences between conductors.  Use the lumped conductance
        terms in a circuit modeler to represent conductances between
        conductors.

        Enclose all name-strings in single quotes in the GMATRIX command line.

        GMATRIX works with the following elements:

        SOLID5 (KEYOPT(1) = 9)

        SOLID98 (KEYOPT(1) = 9)

        LINK68

        PLANE230

        SOLID231

        SOLID232

        This command is available from the menu path shown below only if
        existing results are available.

        This command does not support multiframe restarts

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "GMATRIX,%s,%s,%s,%s" % (str(symfac), str(condname), str(numcond), str(matrixname))
        return self.run(command, **kwargs)

    def deltim(self, dtime="", dtmin="", dtmax="", carry="", **kwargs):
        """APDL Command: DELTIM

        Specifies the time step sizes to be used for the current load step.

        Parameters
        ----------
        dtime
            Time step size for this step. If automatic time stepping is used
            (AUTOTS), DTIME is the starting time substep.

        dtmin
            Minimum time step (if automatic time stepping is used). The program
            automatically determines the default based on the physics of the
            model.

        dtmax
            Maximum time step (if automatic time stepping is used). The program
            automatically determines the default based on the physics of the
            model.

        carry
            Time step carry over key:

            OFF - Use DTIME as time step at start of each load step.

            ON - Use final time step from previous load step as the starting time step (if
                 automatic time stepping is used).

        Notes
        -----
        See NSUBST for an alternative input.

        Use consistent values for DTIME and TIME (TIME). For example, using 0.9
        for DTIME and 1.0 for TIME results in one time step because 1.0 (TIME)
        is divisible by .9 (DTIME) at most once. If you intend to load in 10
        increments over a time span of 1.0, use 0.1 for DTIME and 1.0 for TIME.

        The program calculates the initial incremental time so that (EndingTime
        - StartingTime)/DTIME is an integer, which may affect the initial
        incremental time that you specify. For example, if the starting time is
        0, the ending time is 1, and the initial incremental time is 0.4, the
        program rounds to the nearest integer and adjusts the time to 0.33333.

        For solution efficiency, specify values for all fields of this command.

        This command is also valid in PREP7.
        """
        command = "DELTIM,%s,%s,%s,%s" % (str(dtime), str(dtmin), str(dtmax), str(carry))
        return self.run(command, **kwargs)

    def usrcal(self, rnam1="", rnam2="", rnam3="", rnam4="", rnam5="",
               rnam6="", rnam7="", rnam8="", rnam9="", **kwargs):
        """APDL Command: USRCAL

        Allows user-solution subroutines to be activated or deactivated.

        Parameters
        ----------
        rnam1, rnam2, rnam3, . . . , rnam9
            User-defined solution subroutine names to be activated.  Up to nine
            may be defined on one command or multiple commands may be used.  If
            Rnam1 = ALL, activate all valid user subroutines.   If Rnam1 =
            NONE, deactivate all valid user subroutines.  All characters are
            required:

            USREFL - Allows user defined scalar field (body force) loads.

            USERCV - Allows user defined convection (surface) loads.

            USERPR - Allows user defined pressure (surface) loads.

            USERFX - Allows user-defined heat flux (surface) loads.

            USERCH - Allows user-defined charge density (surface) loads.

            USERFD - Computes the complex load vector for the frequency domain logic.

            USEROU - Allows user supplied element output.

            USERMC - Allows user control of the hygrothermal growth).

            USOLBEG - Allows user access before each solution.

            ULDBEG - Allows user access before each load step.

            USSBEG - Allows user access before each substep.

            UITBEG - Allows user access before each equilibrium iteration.

            UITFIN - Allows user access after each equilibrium iteration.

            USSFIN - Allows user access after each substep.

            ULDFIN - Allows user access after each load step.

            USOLFIN - Allows user access after each solution.

            UANBEG - Allows user access at start of run.

            UANFIN - Allows user access at end of run.

            UELMATX - Allows user access to element matrices and load vectors.

            UTIMEINC - Allows a user-defined time step, overriding the program-determined time step.

            UCNVRG - Allows user-defined convergence checking, overriding the program-determined
                     convergence.

        Notes
        -----
        Allows certain user-solution subroutines to be activated or deactivated
        (system-dependent).  This command only affects the subroutines named.
        Other user subroutines (such as user elements, user creep, etc.) have
        their own activation controls described with the feature.

        The routines are commented and should be listed after performing a
        custom installation from the distribution media for more details.  See
        also the Advanced Analysis Guide for a general description of user-
        programmable features.

        Users must have system permission, system access, and knowledge to
        write, compile, and link the appropriate subroutines into the program
        at the site where it is to be run.  All routines should be written in
        FORTRAN. (For more information on FORTRAN compilers please refer to
        either the ANSYS, Inc. Windows Installation Guide or the ANSYS, Inc.
        Linux Installation Guide for details specific to your platform or
        operating system.) Issue USRCAL,STAT to list the status of these user
        subroutines.  Since a user-programmed subroutine is a nonstandard use
        of the program, the verification of any ANSYS run incorporating these
        commands is entirely up to the user.  In any contact with ANSYS
        customer support regarding the performance of a custom version of the
        ANSYS program, you should explicitly state that a user programmable
        feature has been used.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "USRCAL,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(rnam1), str(rnam2), str(rnam3), str(rnam4), str(rnam5), str(rnam6), str(rnam7), str(rnam8), str(rnam9))
        return self.run(command, **kwargs)

    def gsgdata(self, lfiber="", xref="", yref="", rotx0="", roty0="",
                **kwargs):
        """APDL Command: GSGDATA

        Specifies the reference point and defines the geometry in the fiber
        direction for the generalized plane strain element option.

        Parameters
        ----------
        lfiber
            Fiber length from the reference point. Defaults to 1.

        xref
            X coordinate of the reference point. Defaults to zero.

        yref
            Y coordinate of the reference point. Defaults to zero.

        rotx0
            Rotation of the ending plane about X in radians Defaults to zero.

        roty0
            Rotation of the ending plane about Y in radians Defaults to zero.

        Notes
        -----
        The ending point is automatically determined from the starting
        (reference) point and the geometry inputs. All inputs are in the global
        Cartesian coordinate system. For more information about the generalized
        plane strain feature, see Generalized Plane Strain Option of Current-
        Technology Solid Elements in the  Element Reference.
        """
        command = "GSGDATA,%s,%s,%s,%s,%s" % (str(lfiber), str(xref), str(yref), str(rotx0), str(roty0))
        return self.run(command, **kwargs)

    def mfcalc(self, fnumb="", freq="", **kwargs):
        """APDL Command: MFCALC

        Specifies a calculation frequency for a field in an ANSYS Multi-field
        solver analysis.

        Parameters
        ----------
        fnumb
            Field number set by the MFELEM command.

        freq
            Perform calculation every Nth ANSYS Multi-field solver time step.
            Defaults to 1 for every time step.

        Notes
        -----
        This command only applies to a harmonic analysis of the specified
        field. It is useful when a field contributes negligible field
        interaction within a single ANSYS Multi-field solver time step.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFCALC,%s,%s" % (str(fnumb), str(freq))
        return self.run(command, **kwargs)

    def blc4(self, xcorner="", ycorner="", width="", height="", depth="",
             **kwargs):
        """APDL Command: BLC4

        Creates a rectangular area or block volume by corner points.

        Parameters
        ----------
        xcorner, ycorner
            Working plane X and Y coordinates of one corner of the rectangle or
            block face.

        width
            The distance from XCORNER on or parallel to the working plane
            X-axis that, together with YCORNER, defines a second corner of the
            rectangle or block face.

        height
            The distance from YCORNER on or parallel to the working plane
            Y-axis that, together with XCORNER, defines a third corner of the
            rectangle or block face.

        depth
            The perpendicular distance (either positive or negative based on
            the working plane Z direction) from the working plane representing
            the depth of the block.  If DEPTH = 0 (default), a rectangular area
            is created on the working plane.

        Notes
        -----
        Defines a rectangular area anywhere on the working plane or a
        hexahedral volume with one face anywhere on the working plane.  A
        rectangle will be defined with four keypoints and four lines.  A volume
        will be defined with eight keypoints, twelve lines, and six areas, with
        the top and bottom faces parallel to the working plane.  See the BLC5,
        RECTNG, and BLOCK commands for alternate ways to create rectangles and
        blocks.
        """
        command = "BLC4,%s,%s,%s,%s,%s" % (str(xcorner), str(ycorner), str(width), str(height), str(depth))
        return self.run(command, **kwargs)

    def nplot(self, knum="", **kwargs):
        """APDL Command: NPLOT

        Displays nodes.

        Parameters
        ----------
        knum
            Node number key:

            0 - No node numbers on display.

            1 - Include node numbers on display.  See also /PNUM command.

        Notes
        -----
        Produces a node display.  Only selected nodes [NSEL] are displayed.
        Elements need not be defined.  See the DSYS command for display
        coordinate system.

        This command is valid in any processor.
        """
        command = "NPLOT,%s" % (str(knum))
        return self.run(command, **kwargs)

    def kbc(self, key="", **kwargs):
        """APDL Command: KBC

        Specifies ramped or stepped loading within a load step.

        Parameters
        ----------
        key
            Ramping key:

            0 - Loads are linearly interpolated (ramped) for each substep from the values of
                the previous load step to the values of this load step. This is
                the default value.

            1 - Loads are step changed (stepped) at the first substep of this load step to the
                values of this load step (i.e., the same values are used for
                all substeps).  Useful for rate-dependent behavior (e.g.,
                creep, viscoplasticity, etc.) or transient load steps only.

        Notes
        -----
        Specifies whether loads applied to intermediate substeps within the
        load step are to be stepped or ramped. Used only if DTIME on the DELTIM
        command is less than the time span or, conversely, if NSBSTP on the
        NSUBST command is greater than one. Flags (FSI, MXWF, MVDI, etc.) are
        always stepped.

        Changing the ramping KEY (i.e., switching between ramped and stepped
        boundary conditions) between load steps is not recommended.

        For ramped loading (KBC,0), when a load is applied for the first time,
        it is interpolated from zero to the value of the current load step, and
        not from the initial condition or value of the degree of freedom from
        the previous load step.

        Spatially varying tabular loads or boundary conditions do not support
        direct ramping or stepping options and, instead, apply their full
        values according to the supplied tabular functions regardless of the
        KBC setting.

        For a static or harmonic cyclic symmetry analysis, any load that varies
        by sector (CYCOPT,LDSECT) is tabular and is applied as a step change,
        regardless of the KBC setting; however, any non-tabular loads in the
        same analysis are ramped or stepped according to the KBC setting.

        Irrespective of the KBC setting, loads are usually step-removed. See
        Stepping or Ramping Loads in the Basic Analysis Guide for more
        information.

        It is sometimes difficult to obtain successful convergence with stepped
        loading in a nonlinear transient problem. If divergence is encountered,
        determine if stepped loading was used by default, then determine if it
        is appropriate for the analysis.

        This command is also valid in PREP7.
        """
        command = "KBC,%s" % (str(key))
        return self.run(command, **kwargs)

    def gst(self, lab="", lab2="", **kwargs):
        """APDL Command: /GST

        Turns Graphical Solution Tracking (GST) on or off.

        Parameters
        ----------
        lab
            Determines whether the Graphical Solution Tracking feature is
            active.  Specify ON to activate GST, or OFF to deactivate the
            feature.

        lab2
            Activates generation of interface and field convergence files
            (ANSYS MFX analyses only).

        Notes
        -----
        For interactive runs using GUI [/MENU,ON] or graphics [/MENU,GRPH]
        mode, ANSYS directs GST graphics to the screen.  For interactive
        sessions not using GUI or graphics mode, or for batch sessions, GST
        graphics are saved in the ANSYS graphics file Jobname.GST when Lab2 is
        unspecified. The file Jobname.GST can be viewed with the DISPLAY
        program in this case. You must select All File Types to access it. For
        more information on the DISPLAY program see Getting Started with the
        DISPLAY Program in the Basic Analysis Guide. For MFX runs (when
        Lab2=ON), the Jobname.GST file is in XML format, and it can be viewed
        with the Results Tracker Utility, accessed from within the Tools menu
        of the Mechanical APDL Product Launcher.

        The GST feature is available only for nonlinear structural, thermal,
        electric, magnetic, fluid, or CFD simulations. For more information
        about this feature and illustrations of the GST graphics for each
        analysis type, see the ANSYS Analysis Guide for the appropriate
        discipline.  See also the CNVTOL command description.

        When running an ANSYS MFX analysis, specify /GST,ON,ON to generate both
        the interface (Jobname.NLH) and field convergence (Fieldname.GST) files
        for monitoring the analysis. This field is not available on the GUI.
        """
        command = "/GST,%s,%s" % (str(lab), str(lab2))
        return self.run(command, **kwargs)

    def parsav(self, lab="", fname="", ext="", **kwargs):
        """APDL Command: PARSAV

        Writes parameters to a file.

        Parameters
        ----------
        lab
            Write operation:

            Write only scalar parameters (default). - Write scalar and array parameters.  Parameters may be numeric or alphanumeric.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Writes the current parameters to a coded file.  Previous parameters on
        this file, if any, will be overwritten.  The parameter file may be read
        with the PARRES command.

        PARSAV/PARRES operations truncate some long decimal strings, and can
        cause differing values in your solution data when other operations are
        performed. A good practice is to limit the number of decimal places you
        will use before and after these operations.

        This command is valid in any processor.
        """
        command = "PARSAV,%s,%s,%s" % (str(lab), str(fname), str(ext))
        return self.run(command, **kwargs)

    def grp(self, signif="", label="", forcetype="", **kwargs):
        """APDL Command: GRP

        Specifies the grouping mode combination method.

        Parameters
        ----------
        signif
            Combine only those modes whose significance level exceeds the
            SIGNIF  threshold.  For single point, multipoint, or DDAM response
            (SPOPT,SPRS, MPRS or DDAM), the significance level of a mode is
            defined as the mode coefficient of the mode, divided by the maximum
            mode coefficient of all modes.  Any mode whose significance level
            is less than SIGNIF is considered insignificant and is not
            contributed to the mode combinations.  The higher the SIGNIF
            threshold, the fewer the number of modes combined.  SIGNIF defaults
            to 0.001.  If SIGNIF is specified as 0.0, it is taken as 0.0.
            (This mode combination method is not valid for SPOPT,PSD.)

        label
            Label identifying the combined mode solution output.

            DISP - Displacement solution (default).  Displacements, stresses, forces, etc., are
                   available.

            VELO - Velocity solution.  Velocities, "stress velocities," "force velocities," etc.,
                   are available.

            ACEL - Acceleration solution.  Accelerations, "stress accelerations," "force
                   accelerations," etc., are available.

        forcetype
            Label identifying the forces to be combined:

            STATIC - Combine the modal static forces (default).

            TOTAL - Combine the modal static plus inertial forces.

        Notes
        -----
        The SIGNIF value set with this command (including the default value of
        0.001) overrides the SIGNIF value set with the MXPAND command.

        This command is also valid for PREP7.
        """
        command = "GRP,%s,%s,%s" % (str(signif), str(label), str(forcetype))
        return self.run(command, **kwargs)

    def nummrg(self, label="", toler="", gtoler="", action="", switch="",
               **kwargs):
        """APDL Command: NUMMRG

        Merges coincident or equivalently defined items.

        Parameters
        ----------
        label
            Items to be merged:

            NODE - Nodes

            ELEM - Elements

            KP - Keypoints (will also merge lines, areas, and volumes)

            MAT - Materials

            TYPE - Element types

            REAL - Real constants

            CP - Coupled sets

            CE - Constraint equations

            ALL - All items

        toler
            Range of coincidence.  For Label = NODE and KP, defaults to 1.0E-4
            (based on maximum Cartesian coordinate difference between nodes or
            keypoints).  For Label = MAT, REAL, and CE, defaults to 1.0E-7
            (based on difference of the values normalized by the values).  Only
            items within range are merged.  (For keypoints attached to lines,
            further restrictions apply.  See the GTOLER field and Merging Solid
            Model Entities below.)

        gtoler
            Global solid model tolerance -- used only when merging keypoints
            attached to lines.  If specified, GTOLER will override the internal
            relative solid model tolerance.  See Merging Solid Model Entities
            below.

        action
            Specifies whether to merge or select coincident items.

            SELE - Select coincident items but do not merge. Action = SELE is only valid for Label
                   = NODE.

            (Blank) - Merge the coincident items (default).

        switch
            Specifies whether the lowest or highest numbered coincident item is
            retained after the merging operation.  This option does not apply
            to keypoints; i.e., for Label = KP, the lowest numbered keypoint is
            retained regardless of the Switch setting.

            LOW - Retain the lowest numbered coincident item after the merging operation
                  (default).

            HIGH - Retain the highest numbered coincident item after the merging operation.

        Notes
        -----
        After issuing the command, the area and volume sizes (ASUM and VSUM)
        may give slightly different results. In order to obtain the same
        results as before, use /FACET, /NORMAL, and ASUM / VSUM.

        The merge operation is useful for tying separate, but coincident, parts
        of a model together. If not all items are to be checked for merging,
        use the select commands (NSEL, ESEL, etc.) to select items.  Only
        selected items are included in the merge operation for nodes,
        keypoints, and elements.

        By default, the merge operation retains the lowest numbered coincident
        item.  Higher numbered coincident items are deleted.  Set Switch to
        HIGH to retain the highest numbered coincident item after the merging
        operation.  Applicable related items are also checked for deleted item
        numbers and if found, are replaced with the retained item number.  For
        example, if nodes are merged, element connectivities (except
        superelements), mesh item range associativity, coupled degrees of
        freedom, constraint equations, master degrees of freedom, gap
        conditions, degree of freedom constraints, nodal force loads, nodal
        surface loads, and nodal body force loads are checked.  Merging
        material numbers [NUMMRG,ALL or NUMMRG,MAT] does not update the
        material number referenced:

        By temperature-dependent film coefficients as part of convection load
        or a temperature-dependent emissivity as part of a surface-to-surface
        radiation load [SF, SFE, SFL, SFA]

        By real constants for multi-material elements (such as SOLID65)

        If a unique load is defined among merged nodes, the value is kept and
        applied to the retained node.  If loads are not unique (not
        recommended), only the value on the lowest node (or highest if Switch =
        HIGH) will be kept, except for "force" loads for which the values will
        be summed if they are not defined using tabular boundary conditions.

        Note:: : The unused nodes (not recommended) in elements, couplings,
        constraint equations, etc. may become active after the merge operation.

        The Action field provides the option of visualizing the coincident
        items before the merging operation.

        Caution:: : When merging entities in a model that has already been
        meshed, the order in which you issue multiple NUMMRG commands is
        significant.  If you want to merge two adjacent meshed regions that
        have coincident nodes and keypoints, always merge nodes [NUMMRG,NODE]
        before merging keypoints [NUMMRG,KP].  Merging keypoints before nodes
        can result in some of the nodes becoming "orphaned"; that is, the nodes
        lose their association with the solid model.  Orphaned nodes can cause
        certain operations (such as boundary condition transfers, surface load
        transfers, and so on) to fail. However, using NUMMRG should be avoided
        if at all possible, as the procedure outlined above may even cause
        meshing failure, especially after multiple merging and meshing
        operations.

        After a NUMMRG,NODE, is issued, some nodes may be attached to more than
        one solid entity. As a result, subsequent attempts to transfer solid
        model loads to the elements may not be successful. Issue NUMMRG,KP to
        correct this problem. Do NOT issue VCLEAR before issuing NUMMRG,KP.

        For NUMMRG,ELEM, elements must be identical in all aspects, including
        the direction of the element coordinate system.

        For certain solid and shell elements (181, 185, 190, etc) ANSYS will
        interpret coincident faces as internal and eliminate them. To prevent
        this from occurring, shrink the entities by a very small factor to
        delineate coincident items (/SHRINK, 0.0001) and no internal nodes,
        lines, areas or elements will be eliminated.

        When working with solid models, you may have better success with the
        gluing operations (AGLUE, LGLUE, VGLUE). Please read the following
        information when attempting to merge solid model entities.

        Gluing Operations vs. Merging Operations

        Adjacent, touching regions can be joined by gluing them (AGLUE, LGLUE,
        VGLUE) or by merging coincident keypoints (NUMMRG,KP, which also causes
        merging of identical lines, areas, and volumes).  In many situations,
        either approach will work just fine. Some factors, however, may lead to
        a preference for one method over the other.

        Geometric Configuration

        Gluing is possible regardless of the initial alignment or offset of the
        input entities. Keypoint merging is  possible only if each keypoint on
        one side of the face to be joined is matched by a coincident keypoint
        on the other side. This is commonly the case after a symmetry
        reflection (ARSYM or VSYMM) or a copy (AGEN or VGEN),  especially for a
        model built entirely in ANSYS rather than imported from a CAD system.
        When the geometry is  extremely precise, and the configuration is
        correct for  keypoint merging, NUMMRG is more efficient and robust than
        AGLUE or VGLUE.
        """
        command = "NUMMRG,%s,%s,%s,%s,%s" % (str(label), str(toler), str(gtoler), str(action), str(switch))
        return self.run(command, **kwargs)

    def nkpt(self, node="", npt="", **kwargs):
        """APDL Command: NKPT

        Defines a node at an existing keypoint location.

        Parameters
        ----------
        node
            Arbitrary reference number for node.  If zero or blank, defaults to
            the highest node number +1 [NUMSTR].

        npt
            Keypoint number defining global X, Y, Z  location.  If NPT = All,
            then a node will be placed at each selected keypoint.  If NPT = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NPT.
        """
        command = "NKPT,%s,%s" % (str(node), str(npt))
        return self.run(command, **kwargs)

    def lccalc(self, **kwargs):
        """APDL Command: LCCALC

        Specifies "Load case settings" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.

        This command is also valid for rezoning.
        """
        command = "LCCALC," % ()
        return self.run(command, **kwargs)

    def sbctran(self, **kwargs):
        """APDL Command: SBCTRAN

        Transfers solid model loads and boundary conditions to the FE model.

        Notes
        -----
        Causes a manual transfer of solid model loads and boundary conditions
        to the finite element model.  Loads and boundary conditions on
        unselected keypoints, lines, areas, and volumes are not transferred.
        Boundary conditions and loads will not be transferred to unselected
        nodes or elements.  The SBCTRAN operation is also automatically done
        upon initiation of the solution calculations [SOLVE].

        This command is also valid in PREP7.
        """
        command = "SBCTRAN," % ()
        return self.run(command, **kwargs)

    def mfsurface(self, inumb="", fnumb1="", label="", fnumb2="", **kwargs):
        """APDL Command: MFSURFACE

        Defines a surface load transfer for an ANSYS Multi-field solver
        analysis.

        Parameters
        ----------
        inumb
            Interface number for load transfer. The interface number
            corresponds to the interface number specified by the surface flag
            FSIN (SFxxcommands).

        fnumb1
            Field number of sending field.

        label
            Valid surface load labels:

        fnumb2
            Field number for receiving field.

        Notes
        -----
        This command is also valid in PREP7.

        The ANSYS Multi-field solver solver does not allow you to switch the
        load transfer direction for the same load quantity across the same
        interfaces for a restart run. For example, if Field1 sends temperature
        to and receives heat flow from Field2 across Interface 1 in a previous
        solution, then you cannot make Field1 send heat flow to and receive
        temperatures from Field2 across the same interface in a restart run,
        even if you cleared the corresponding load transfer command.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFSURFACE,%s,%s,%s,%s" % (str(inumb), str(fnumb1), str(label), str(fnumb2))
        return self.run(command, **kwargs)

    def asbw(self, na="", sepo="", keep="", **kwargs):
        """APDL Command: ASBW

        Subtracts the intersection of the working plane from areas (divides
        areas).

        Parameters
        ----------
        na
            Area (or areas, if picking is used) to be subtracted from.  If NA =
            ALL, use all selected areas.  If NA = P, graphical picking is
            enabled (valid only in the GUI).  A component name may also be
            input for NA.

        sepo
            Behavior of the created boundary.

            (blank) - The resulting areas will share line(s) where they touch.

            SEPO - The resulting areas will have separate, but coincident line(s).

        keep
            Specifies whether NA areas are to be deleted.

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NA areas after ASBW operation (override BOPTN command settings).

            KEEP - Keep NA areas after ASBW operation (override BOPTN command settings).

        Notes
        -----
        Generates new areas by subtracting the intersection of the working
        plane from the NA areas.  The intersection will be a line(s).  The
        working plane must not be in the same plane as the NA areas(s).  If
        SEPO is blank, the NA area is divided at the line and the resulting
        areas will be connected, sharing a common line where they touch.  If
        SEPO is set to SEPO, NA is divided into two unconnected areas with
        separate lines.  The SEPO option may cause unintended consequences if
        any keypoints exist along the cut plane. See Solid Modeling in the
        Modeling and Meshing Guide for an illustration.  See the BOPTN command
        for an explanation of the options available to Boolean operations.
        Element attributes and solid model boundary conditions assigned to the
        original entities will not be transferred to the new entities
        generated.

        Issuing the ASBW command under certain conditions may generate a
        topological degeneracy error. Do not issue the command if:

        A sphere or cylinder has been scaled. (A cylinder must be scaled
        unevenly in the XY plane.)

        A sphere or cylinder has not been scaled but the work plane has been
        rotated.
        """
        command = "ASBW,%s,%s,%s" % (str(na), str(sepo), str(keep))
        return self.run(command, **kwargs)

    def tble(self, **kwargs):
        """APDL Command: TBLE

        Specifies "Data table properties" as the subsequent status topic.

        Notes
        -----
        This is a status (STAT) topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "TBLE," % ()
        return self.run(command, **kwargs)

    def seg(self, label="", aviname="", delay="", **kwargs):
        """APDL Command: /SEG

        Allows graphics data to be stored in the local terminal memory.

        Parameters
        ----------
        label
            Storage key:

            SINGL - Store subsequent display in a single segment (overwrites last storage).

            MULTI - Store subsequent displays in unique segments [ANIM].

            DELET - Delete all currently stored segments.

            OFF - Stop storing display data in segments.

            STAT - Display segment status.

            PC - This option only applies to PC versions of ANSYS and only when animating via
                 the AVI movie player (i.e., /DEVICE,ANIM,2).  This command
                 appends frames to the File.AVI, so that the animation goes in
                 both directions (i.e., forward--backward--forward).  You must
                 have a current animation file to use this option.

        aviname
            Name of the animation file that will be created when each frame is
            saved. The .AVI extension is applied automatically. Defaults to
            Jobname.AVI if no filename is specified.

        delay
            Delay factor between each frame, in seconds. Defaults to 0.015
            seconds if no value is specified.

        Notes
        -----
        Allows graphics data to be stored in the terminal local memory (device-
        dependent).  Storage occurs concurrently with the display.

        Although the information from your graphics window is stored as an
        individual segment, you cannot plot directly (GPLOT) from the segment
        memory.

        For the DISPLAY program, the Aviname and DELAY fields are ignored.

        This command is valid in any processor.
        """
        command = "/SEG,%s,%s,%s" % (str(label), str(aviname), str(delay))
        return self.run(command, **kwargs)

    def source(self, x="", y="", z="", **kwargs):
        """APDL Command: SOURCE

        Defines a default location for undefined nodes or keypoints.

        Parameters
        ----------
        x, y, z
            Global Cartesian coordinates for source nodes or keypoints
            (defaults to the origin).

        Notes
        -----
        Defines a global Cartesian location for undefined nodes or keypoints
        moved during intersection calculations [MOVE or KMOVE].
        """
        command = "SOURCE,%s,%s,%s" % (str(x), str(y), str(z))
        return self.run(command, **kwargs)

    def cwd(self, dirpath="", **kwargs):
        """APDL Command: /CWD

        Changes the current working directory.

        Parameters
        ----------
        dirpath
            The full path name of the new working directory.

        Notes
        -----
         After issuing the /CWD command, all new files opened with no default
        directory specified (via the FILE, /COPY, or RESUME commands, for
        example) default to the new DIRPATH directory.
        """
        command = "/CWD,%s" % (str(dirpath))
        return self.run(command, **kwargs)

    def prnld(self, lab="", tol="", item="", **kwargs):
        """APDL Command: PRNLD

        Prints the summed element nodal loads.

        Parameters
        ----------
        lab
            Nodal reaction load type.  If blank, use the first ten of all
            available labels.  Valid labels are:

        tol
            Tolerance value about zero within which loads are not printed, as
            follows:

            > 0  - Relative tolerance about zero within which loads are not printed. In this case,
                   the tolerance is TOL * Load, where Load is the absolute
                   value of the maximum load on the selected nodes.

             0  -  Print all nodal loads.

            > 0  - Absolute tolerance about zero within which loads are not printed.

        item
            Selected set of nodes.

            (blank) - Prints the summed element nodal loads for all selected nodes (default),
                      excluding contact elements.

            CONT - Prints the summed element nodal loads for contact nodes only.

            BOTH - Prints the summed element nodal loads for all selected nodes, including contact
                   nodes.

        Notes
        -----
        Prints the summed element nodal loads (forces, moments, heat flows,
        flux, etc.) for the selected nodes in the sorted sequence.  Results are
        in the global Cartesian coordinate directions unless transformed
        [RSYS].  Zero values (within a tolerance range) are not printed.  Loads
        applied to a constrained degree of freedom are not included.  The FORCE
        command can be used to define which component of the nodal load is to
        be used (static, damping, inertia, or total).

        By default, PRNLD excludes elements TARGE169 - CONTA177. Setting ITEM =
        CONT will only account for nodal forces on selected contact elements
        (CONTA171 - CONTA177). Setting ITEM = BOTH will account for nodal
        forces on all selected nodes, including contact nodes.
        """
        command = "PRNLD,%s,%s,%s" % (str(lab), str(tol), str(item))
        return self.run(command, **kwargs)

    def bftran(self, **kwargs):
        """APDL Command: BFTRAN

        Transfers solid model body force loads to the finite element model.

        Notes
        -----
        Body loads are transferred from selected keypoints and lines to
        selected nodes and from selected areas and volumes to selected
        elements.  The BFTRAN operation is also done if the SBCTRAN command is
        either explicitly issued or automatically issued upon initiation of the
        solution calculations [SOLVE].

        This command is also valid in PREP7.
        """
        command = "BFTRAN," % ()
        return self.run(command, **kwargs)

    def mapvar(self, option="", matid="", istrtstress="", ntenstress="",
               istrtstrain="", ntenstrain="", istrtvect="", nvect="",
               **kwargs):
        """APDL Command: MAPVAR

        Defines tensors and vectors in user-defined state variables for
        rezoning and in 2-D to 3-D analyses.

        Parameters
        ----------
        option
            DEFINE

            DEFINE - Define variables for the specified MatId material ID (default).

            LIST - List the defined variables for the specified MatId material ID.

        matid
            The material ID for the state variables which you are defining
            (Option = DEFINE) or listing (Option = LIST).

        istrtstress
            The start position of stress-like tensors in the state variables.
            This value must be either a positive integer or 0 (meaning no
            stress-like tensors).

        ntenstress
            The number of stress-like tensors in the state variables. This
            value must be either a positive integer (or 0), and all stress-like
            tensors must be contiguous.

        istrtstrain
            The start position of strain-like tensors in the state variables.
            This value must be either a positive integer or 0 (meaning no
            strain-like tensors).

        ntenstrain
            The number of strain-like tensors in the state variables. This
            value must be either a positive integer (or 0), and all strain-like
            tensors must be contiguous.

        istrtvect
            The start position of vectors in the state variables. This value
            must be either a positive integer or 0 (meaning no vectors).

        nvect
            The number of vectors in the state variables. This value must be
            either a positive integer (or 0), and all vectors must be
            contiguous.

        Notes
        -----
        The MAPVAR command identifies the tensors and vectors in user-defined
        state variables (TB,STATE) for user-defined materials (TB,USER and
        UserMat or UserMatTh) or user-defined creep laws (TB,CREEP,,,,100 and
        UserCreep).

        The command ensures that user-defined state variables are mapped
        correctly during rezoning and in 2-D to 3-D analyses.

        In a rezoning operation, MAPVAR must be issued after remeshing
        (REMESH,FINISH) but before mapping (MAPSOLVE).
        """
        command = "MAPVAR,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(matid), str(istrtstress), str(ntenstress), str(istrtstrain), str(ntenstrain), str(istrtvect), str(nvect))
        return self.run(command, **kwargs)

    def pmlsize(self, freqb="", freqe="", dmin="", dmax="", thick="", angle="",
                **kwargs):
        """APDL Command: PMLSIZE

        Determines number of PML layers.

        Parameters
        ----------
        freqb
            Minimum operating frequency

        freqe
            Maximum operating frequency

        dmin
            Minimum distance from radiation source to PML interface.

        dmax
            Maximum distance from radiation source to PML interface.

        thick
            Thickness of PML region. Defaults to 0.

        angle
            Incident angle of wave to the PML interface. Defaults to 0.

        Notes
        -----
        PMLSIZE determines the number of PML layers for acceptable numerical
        accuracy.

        PMLSIZE must be issued before any meshing commands. If the thickness of
        the PML region is known, it determines an element edge length (h) and
        issues ESIZE,h.  If the thickness of the PML region is unknown, it
        determines the number of layers (n) and issues ESIZE,,n.
        """
        command = "PMLSIZE,%s,%s,%s,%s,%s,%s" % (str(freqb), str(freqe), str(dmin), str(dmax), str(thick), str(angle))
        return self.run(command, **kwargs)

    def pdpinv(self, rlab="", name="", prob="", conf="", **kwargs):
        """APDL Command: PDPINV

        Prints the result of the inversion of a probability.

        Parameters
        ----------
        rlab
            Result set label. Identifies the result set to be used for
            postprocessing. A result set label can be the solution set label
            you defined in a PDEXE command (if you are directly postprocessing
            Monte Carlo Simulation results), or the response surface set label
            defined in an RSFIT command (for Response Surface Analyses).

        name
            Parameter name. The parameter must have been previously defined as
            a random input variable or a random output parameter with the PDVAR
            command.

        prob
            Target probability for which the random parameter value should be
            determined.

        --
            Unused field.

        conf
            Confidence level. The confidence level is used to print the
            confidence bounds on the random parameter value. The value for the
            confidence level must be between 0.0 and 1.0 and it defaults to
            0.95 (95%). Printing of confidence bound is suppressed for CONF
            0.5. This parameter is ignored for response surface methods results
            postprocessing.

        Notes
        -----
        Prints the value for the random parameter Name at which the probability
        that there are simulation values lower than that value is equal to
        PROB. This corresponds to an inversion of the cumulative distribution
        function (see PDCDF command) at a given probability. In this sense the
        PDPINV is doing the opposite of the PDPROB command. The PDPROB command
        evaluates a probability for a given random parameter value and the
        PDPINV command evaluates the random parameter value that corresponds to
        a given probability.

        If Rlab is left blank, then the result set label is inherited from the
        last PDEXE command (Slab), RSFIT command (RSlab), or the most recently
        used PDS postprocessing command where a result set label was explicitly
        specified.

        The confidence level is a probability expressing the confidence that
        the value for the requested result is in fact between the confidence
        bounds. The larger the confidence level, the wider the confidence
        bounds. Printing the confidence bounds only makes sense for
        postprocessing Monte Carlo simulation results, where the confidence
        bounds represent the accuracy of the results. With increasing sample
        sizes, the width of the confidence bounds gets smaller for the same
        confidence level. For response surface analysis methods, the number of
        simulations done on the response surface is usually very large;
        therefore, the accuracy of the results is determined by the response
        surface fit and not by the confidence level.

        The PDPINV command cannot be used to postprocess the results in a
        solution set that is based on Response Surface Methods, only Monte
        Carlo Simulations.
        """
        command = "PDPINV,%s,%s,%s,%s" % (str(rlab), str(name), str(prob), str(conf))
        return self.run(command, **kwargs)

    def fvmesh(self, keep="", **kwargs):
        """APDL Command: FVMESH

        Generates nodes and tetrahedral volume elements from detached exterior
        area elements (facets).

        Parameters
        ----------
        keep
            Specifies whether to keep the area elements after the tetrahedral
            meshing operation is complete.

            0 - Delete area elements (default).

            1 - Keep area elements.

        Notes
        -----
        The FVMESH command generates a tetrahedral volume mesh from a selected
        set of detached exterior area elements (facets).  (Detached elements
        have no solid model associativity.)  The area elements can be
        triangular-shaped, quadrilateral-shaped, or a mixture of the two.

        The FVMESH command is in contrast to the VMESH command, which requires
        a volume to be input.

        The main tetrahedra mesher [MOPT,VMESH,MAIN] is the only tetrahedra
        mesher that supports the FVMESH command.  The alternate tetrahedra
        mesher [MOPT,VMESH,ALTERNATE] does not support FVMESH. MESH200 elements
        do not support FVMESH.

        Tetrahedral mesh expansion [MOPT,TETEXPND,Value] is supported for both
        the FVMESH and VMESH commands.  Tet-mesh expansion is the only mesh
        control supported by FVMESH.

        Triangle- or quadrilateral-shaped elements may be used as input to the
        FVMESH command. Where quadrilaterals are used, the default behavior is
        for the pyramid-shaped elements to be formed at the boundary when the
        appropriate element type is specified. See the MOPT,PYRA command for
        details.

        The FVMESH command does not support multiple "volumes."  If you have
        multiple volumes in your model, select the surface elements for one
        "volume," while making sure that the surface elements for the other
        volumes are deselected.  Then use FVMESH to generate a mesh for the
        first volume.  Continue this procedure by selecting one volume at a
        time and meshing it, until all of the volumes in the model have been
        meshed.

        If an error occurs during the meshing operation, the area elements are
        kept even if KEEP = 0.
        """
        command = "FVMESH,%s" % (str(keep))
        return self.run(command, **kwargs)

    def plls(self, labi="", labj="", fact="", kund="", viewup="", **kwargs):
        """APDL Command: PLLS

        Displays element table items as contoured areas along elements.

        Parameters
        ----------
        labi
            Label of element table item (ETABLE) for node I magnitude.

        labj
            Label of element table item for node J magnitude.

        fact
            Scale factor for display (defaults to 1).  A negative scaling
            factor may be used to invert the display.

        kund
            Undisplaced shape key:

            0 - Display selected items on undeformed shape.

            1 - Display selected items on deformed shape.

        viewup
            View Up key:

            0 - Ignore the view-up (/VUP) vector when calculating trapezoid orientation
                (default).

            1 - Use the view-up (/VUP) vector to calculate trapezoid orientation.

        Notes
        -----
        Displays selected items (such as shears and moments) as a contoured
        area (trapezoid) display along line elements and 2-D axisymmetric shell
        elements (such as shear and moment diagrams).  Three sides of the
        trapezoid are formed by the element (one side) and lines at nodes I and
        J of length proportional to the item magnitude and displayed normal to
        the element and the viewing direction (the two parallel sides).

        When ViewUP = 1, the trapezoid is oriented within the plane created by
        the element and the global Cartesian coordinate system reference
        orientation (/VUP or view up) vector. In this case, the program does
        not perform the calculation involving the element and view direction.

        Portions of this command are not supported by PowerGraphics
        [/GRAPHICS,POWER].
        """
        command = "PLLS,%s,%s,%s,%s,%s" % (str(labi), str(labj), str(fact), str(kund), str(viewup))
        return self.run(command, **kwargs)

    def lspec(self, lcolor="", linstl="", xlnwid="", **kwargs):
        """APDL Command: /LSPEC

        Specifies annotation line attributes (GUI).

        Parameters
        ----------
        lcolor
            Line color:

            0 - Black

            1 - Red-Magenta

            2 - Magenta

            3 - Blue-Magenta

            4 - Blue

            5 - Cyan-Blue

            6 - Cyan

            7 - Green-Cyan

            8 - Green

            9 - Yellow-Green

            10 - Yellow

            11 - Orange

            12 - Red

            13 - Dark Gray

            14 - Light Gray

            15 - White

        linstl
            Line style:

            0 - Solid line.

            1 - Dashed line.

        xlnwid
            Line width multiplier (1.0 to 20.0).  Defaults to 1.0.

        Notes
        -----
        Specifies annotation line attributes to control certain characteristics
        of the lines created via the /LINE, /LARC, /LSYMBOL, /POLYGON, /PMORE,
        /PCIRCLE, and /PWEDGE commands.  This is a command generated by the
        Graphical User Interface (GUI) and will appear in the log file
        (Jobname.LOG) if annotation is used.  This command is not intended to
        be typed in directly in an ANSYS session (although it can be included
        in an input file for batch input or for use with the /INPUT command).

        This command is valid in any processor.
        """
        command = "/LSPEC,%s,%s,%s" % (str(lcolor), str(linstl), str(xlnwid))
        return self.run(command, **kwargs)

    def cecmod(self, neqn="", const="", **kwargs):
        """APDL Command: CECMOD

        Modifies the constant term of a constraint equation during solution.

        Parameters
        ----------
        neqn
            Reference number of constraint equation.

        const
            New value of the constant term of equation.

        Notes
        -----
        Other terms of the constraint equation cannot be changed during the
        solution phase, but must be defined or changed within PREP7 prior to
        the solution.  See the CE command for details.

        This command is also valid in PREP7.
        """
        command = "CECMOD,%s,%s" % (str(neqn), str(const))
        return self.run(command, **kwargs)

    def mfci(self, val1="", val2="", **kwargs):
        """APDL Command: MFCI

        Sets the control parameters used by the conservative (CPP)
        interpolation scheme.

        Parameters
        ----------
        val1
            Controls the pixel resolution. The higher the resolution, the more
            accurate and more expensive the conservative (CPP) interpolation
            will be. Valid values are 10 to 256; defaults to 100.

        val2
            The separation factor to handle any gap between the two surfaces.
            It is a relative measure of the gap, normalized by the averaged
            element face sizes from both sides of the interface. Defaults to
            0.1.

        Notes
        -----
        In a conservative (CPP) interpolation scheme as specified on the
        MFLCOMM command, each element face is first divided into n number of
        faces, where n is the number of nodes on the face. The three-
        dimensional faces are then converted onto a two-dimensional polygon
        made up of rows and columns of dots called pixels. By default, these
        pixels have a resolution of 100 x 100; use VAL1 to increase the
        resolution and improve the accuracy of the algorithm. See Load
        Interpolation in the Coupled-Field Analysis Guide for more information
        on interpolation schemes and adjusting the pixel resolution for the
        conservative interpolation scheme.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFCI,%s,%s" % (str(val1), str(val2))
        return self.run(command, **kwargs)

    def edale(self, option="", afac="", bfac="", dfac="", efac="", start="",
              end="", **kwargs):
        """APDL Command: EDALE

        Assigns mesh smoothing to explicit dynamic elements that use the ALE
        formulation.

        Parameters
        ----------
        option
            Label identifying the option to be performed:

            ADD - Add smoothing controls (default).

            DELETE - Delete smoothing controls.

            LIST - List smoothing controls.

        --
            Unused field.

        afac
            Simple average smoothing weight factor (default = 0).

        bfac
            Volume weighted smoothing weight factor (default = 0).

        --
            Unused field.

        dfac
            Equipotential smoothing weight factor (default = 0).

        efac
            Equilibrium smoothing weight factor (default = 0). EFAC is only
            applicable to PLANE162 elements.

        start
            Start time for ALE smoothing (default = 0).

        end
            End time for ALE smoothing (default = 1e20).

        Notes
        -----
        Mesh smoothing specified by the EDALE command is only applicable to
        PLANE162 and SOLID164 elements that are flagged to use the ALE
        formulation (KEYOPT(5) = 1). To activate the ALE formulation, you must
        specify at least one smoothing weight factor on this command and the
        number of cycles between advection (NADV) on the EDGCALE command. See
        Arbitrary Lagrangian-Eulerian Formulation in the ANSYS LS-DYNA User's
        Guide for more information.

        The EDALE command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDALE,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(afac), str(bfac), str(dfac), str(efac), str(start), str(end))
        return self.run(command, **kwargs)

    def accat(self, na1="", na2="", **kwargs):
        """APDL Command: ACCAT

        Concatenates multiple areas in preparation for mapped meshing.

        Parameters
        ----------
        na1, na2
            Areas to be concatenated.  If NA1 = ALL, NA2 will be ignored and
            all selected areas [ASEL] will be concatenated.  If NA1 = P,
            graphical picking is enabled and all remaining arguments are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NA1 (NA2 is ignored).

        Notes
        -----
        Concatenates multiple, adjacent areas (the input areas) into one area
        (the output area) in preparation for mapped meshing.  A volume that
        contains too many areas for mapped meshing can still be mapped meshed
        if some of the areas in that volume are first concatenated (see Meshing
        Your Solid Model in the Modeling and Meshing Guide for details on
        mapped meshing restrictions).

        Because of modeling restrictions that result from its use, ACCAT is
        meant to be used solely for meshing.  Specifically, (a) the output area
        and any volumes that have the output area on their area list [VLIST]
        cannot be used as input to any other solid modeling operation (not even
        another ACCAT command); and (b) the output area cannot accept solid
        model boundary conditions [DA, SFA].

        The output area (or volumes which contain it) will be meshed [AMESH,
        VMESH] by meshing the input areas, which themselves must be meshable.
        The output area from the ACCAT operation will be coincident with the
        input areas and the input areas will be retained.  Consider the AADD
        command instead of ACCAT if you wish to delete the input areas.  When
        an ACCAT command is issued, volume area lists [VLIST] that contain all
        of the input areas will be updated so that the volume area lists refer
        to the output area instead of the input area.  Deletion of the output
        area [ADELE] effectively reverses the ACCAT operation and restores
        volume area lists to their original condition.  ACCAT operations on
        pairs of adjacent four-sided areas automatically concatenate
        appropriate lines [LCCAT]; in all other situations, line concatenations
        must be addressed by the user.

        You can use the ASEL command to select areas that were created by
        concatenation, and then follow it with an ADELE,ALL command to delete
        them.  See Meshing Your Solid Model in the Modeling and Meshing Guide
        for a discussion on how to easily select and delete concatenated areas
        in one step.
        """
        command = "ACCAT,%s,%s" % (str(na1), str(na2))
        return self.run(command, **kwargs)

    def sphere(self, rad1="", rad2="", theta1="", theta2="", **kwargs):
        """APDL Command: SPHERE

        Creates a spherical volume centered about the working plane origin.

        Parameters
        ----------
        rad1, rad2
            Inner and outer radii (either order) of the sphere.  A value of
            zero or blank for either RAD1 or RAD2 defines a solid sphere.

        theta1, theta2
            Starting and ending angles (either order) of the sphere.  Used for
            creating a spherical sector.  The sector begins at the
            algebraically smaller angle, extends in a positive angular
            direction, and ends at the larger angle.  The starting angle
            defaults to 0.0° and the ending angle defaults to 360.0°.  See the
            Modeling and Meshing Guide for an illustration.

        Notes
        -----
        Defines either a solid or hollow sphere or spherical sector centered
        about the working plane origin.  The sphere must have a spatial volume
        greater than zero. (i.e., this volume primitive command cannot be used
        to create a degenerate volume as a means of creating an area.)
        Inaccuracies can develop when the size of the object you create is much
        smaller than the relative coordinate system values (ratios near to or
        greater than 1000). If you require an exceptionally small sphere,
        create a larger object, and scale it down to the appropriate size.

        For a solid sphere of 360°, you define it with two areas, each
        consisting of a hemisphere.  See the SPH4 and SPH5 commands for the
        other ways to create spheres.
        """
        command = "SPHERE,%s,%s,%s,%s" % (str(rad1), str(rad2), str(theta1), str(theta2))
        return self.run(command, **kwargs)

    def prep7(self, **kwargs):
        """APDL Command: /PREP7

        Enters the model creation preprocessor.

        Notes
        -----
        Enters the general input data preprocessor (PREP7).

        This command is valid only at the Begin Level.
        """
        command = "/PREP7," % ()
        return self.run(command, **kwargs)

    def force(self, lab="", **kwargs):
        """APDL Command: FORCE

        Selects the element nodal force type for output.

        Parameters
        ----------
        lab
            Type of force to be associated with the force items:

            TOTAL - Total forces (static, damping, and inertia).

            STATIC - Static forces.

            DAMP - Damping forces.

            INERT - Inertia forces.

        Notes
        -----
        FORCE selects the element nodal force type for output with the POST1
        PRESOL, PLESOL, PRRFOR, NFORCE, FSUM, etc. commands, the POST26 ESOL
        command, and reaction force plotting [/PBC].  For example, FORCE,STATIC
        causes item F of the PRESOL command to be the static forces for the
        elements processed. Element member forces (such as those available for
        beams and shells and processed by Item and Sequence number) are not
        affected by this command. The SMISC records extract the static force.

        The PRRSOL command is not valid with FORCE.  Use the PRRFOR command,
        which provides the same functionality as PRRSOL, instead.

        Use the FORCE command prior to any load case operations (LCOPER) to
        insure the correct element nodal force combinations.

        In POST26, the ESOL data stored is based on the active FORCE
        specification at the time the data is stored. To store data at various
        specifications (for example, static and inertia forces), issue a STORE
        command before each new specification.

        The FORCE command cannot be used to extract static, damping, and
        inertial forces for MPC184 joint elements.

        To retrieve the different force types, use the *GET command with
        Entity=ELEM and Item1=EFOR.

        The FORCE command is not supported in a spectrum analysis. You can
        specify the force type directly on the combination method commands
        (ForceType on the PSDCOM, SRSS, CQC, etc. commands).

        The FORCE command is not supported in a modal analysis.
        """
        command = "FORCE,%s" % (str(lab))
        return self.run(command, **kwargs)

    def endif(self, **kwargs):
        """APDL Command: *ENDIF

        Ends an if-then-else.

        Notes
        -----
        Required terminator for the if-then-else construct. See the *IF  for
        details.  If a batch input stream hits an end-of-file during a false
        *IF condition, the ANSYS run will not terminate normally. You will need
        to terminate it externally (use either the Linux “kill” function or the
        Windows task manager). The *ENDIF command must appear on the same file
        as the *IF command, and all six characters must be input.

        This command is valid in any processor.
        """
        command = "*ENDIF," % ()
        return self.run(command, **kwargs)

    def torq2d(self, **kwargs):
        """APDL Command: TORQ2D

        Calculates torque on a body in a magnetic field.

        Notes
        -----
        TORQ2D invokes an ANSYS macro which calculates mechanical torque on a
        body in a magnetic field.  The body must be completely surrounded by
        air (symmetry permitted), and a closed path [PATH] passing through the
        air elements surrounding the body must be available.  A
        counterclockwise ordering of nodes on the PPATH command will give the
        correct sign on the torque result.  The macro is valid for 2-D planar
        analysis.

        The calculated torque is stored in the parameter TORQUE.  A node plot
        showing the path is produced in interactive mode.  The torque is
        calculated using a Maxwell stress tensor approach.  Path operations are
        used for the calculation, and all path items are cleared upon
        completion.  See the TORQC2D command for torque calculation based on a
        circular path.
        """
        command = "TORQ2D," % ()
        return self.run(command, **kwargs)

    def cnvtol(self, lab="", value="", toler="", norm="", minref="", **kwargs):
        """APDL Command: CNVTOL

        Sets convergence values for nonlinear analyses.

        Parameters
        ----------
        lab
            Valid convergence labels. If STAT, list the status of the currently
            specified criteria.

        value
            Typical reference value for the specified convergence label (Lab).

        toler
            Tolerance; defaults to 0.005 (0.5%) for force and moment, 1.0E-4
            (0.01%) for DVOL, 0.05 (5%) for displacement when rotational DOFs
            are not present, and 0.05 (5%) for HDSP.

        norm
            Specifies norm selection:

            2 - L2 norm (check SRSS value). Default, except for Lab = U.

            1 - L1 norm (check absolute value sum).

            0 - Infinite norm (check each DOF separately). Default for Lab = U.

        minref
            The minimum value allowed for the program calculated reference
            value. If negative, no minimum is enforced. Used only if VALUE is
            blank. Defaults to 0.01 for force, moment, and volume convergence,
            1.0E-6 for heat flow, 1.0E-12 for VLTG and CHRG, 1.0E-6 for HDSP,
            and 0.0 otherwise.

        Notes
        -----
        This command is usually not needed because the default convergence
        criteria are sufficient for most nonlinear analyses. In rare cases, you
        may need to use this command to diagnose convergence difficulties.

        Values may be set for the degrees of freedom (DOF) and/or the out-of-
        balance load for the corresponding forcing quantities.

        Issuing CNVTOL to set a convergence criterion for a specific
        convergence label (Lab) does not affect the convergence criterion for
        any other label. All other convergence criteria will remain at their
        default setting or at the value set by a previous CNVTOL command.

         When the GUI is on, if a "Delete" operation in a Nonlinear Convergence
        Criteria dialog box writes this command to a log file (Jobname.LOG or
        Jobname.LGW), you will observe that Lab is blank, VALUE = -1, and TOLER
        is an integer number.  In this case, the GUI has assigned a value of
        TOLER that corresponds to the location of a chosen convergence label in
        the dialog box's list.  It is not intended that you type in such a
        location value for TOLER in an ANSYS session.  However, a file that
        contains a GUI-generated CNVTOL command of this form can be used for
        batch input or with the /INPUT command.

        Convergence norms specified with CNVTOL may be graphically tracked
        while the solution is in process using the ANSYS program's Graphical
        Solution Tracking (GST) feature.  Use the /GST command to turn GST on
        or off.  By default, GST is ON for interactive sessions and OFF for
        batch runs.

        This command is also valid in PREP7.
        """
        command = "CNVTOL,%s,%s,%s,%s,%s" % (str(lab), str(value), str(toler), str(norm), str(minref))
        return self.run(command, **kwargs)

    def secread(self, fname="", ext="", unused="", option="", **kwargs):
        """APDL Command: SECREAD

        Reads a custom section library or a user-defined section mesh into
        ANSYS.

        Parameters
        ----------
        fname
            Section library file name and directory path containing the section
            library file (248 characters maximum, including directory). If you
            do not specify a directory path, it will default to your working
            directory and you can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        option
            LIBRARY

            LIBRARY - Reads in a library of sections and their associated section data values; the
                      default. A section library may be created by editing the
                      section-defining portions of the Jobname.LOG file and
                      saving it with a .SECT suffix.

        Notes
        -----
        The SECREAD command operates on the section specified via the most
        recently issued SECTYPE command. Issue a separate SECREAD command for
        each section ID that you want to read in.

        Here are excerpts from a sample user section mesh file for a section
        with 75 nodes, 13 cells, and 9 nodes per cell for a two-hole box
        section. Illustrations of the two-hole box section and the cell mesh
        for it appear later in this command description.

        The mesh file is divided into three sections: the First Line, the Cells
        Section, and the Nodes Section.  Here are brief descriptions of the
        contents of each.

        First Line:  The First Line defines the number of nodes and the number
        of cells for the mesh.

        Cells Section:  The Cells Section contains as many lines as there are
        cells.  In this example, there are thirteen cells, so there are
        thirteen lines in this section. In each line, the number “1” that
        follows the cell connectivity information is the material number.

        Cell nodal connectivity must be given in a counterclockwise direction,
        with the center node being the ninth node. For details, see Figure:
        10:: Cell Mesh for the Two-hole Box Section.

        Nodes Section:  The Nodes Section contains as many lines as there are
        nodes.  In this example, there are 75 nodes, so there are a total of 75
        lines in this section.  Each node line contains the node's boundary
        flag, the Y coordinate of the node, and the Z coordinate of the node.
        Currently, all node boundary flags appear as 0s in a cell mesh file (as
        illustrated in Figure: 9:: Two-hole Box Section). Since all node
        boundary flags are 0, SECREAD ignores them when it reads a cell mesh
        file into ANSYS.

        There cannot be any gaps in the node numbering of a cell mesh.  The
        nodes in a cell mesh must be numbered consecutively, with the first
        node having a node number of 1, and the last node having a node number
        that is equal to the maximum number of nodes in the cell mesh.

        Figure: 9:: : Two-hole Box Section

        Figure: 10:: : Cell Mesh for the Two-hole Box Section
        """
        command = "SECREAD,%s,%s,%s,%s" % (str(fname), str(ext),
                                           str(unused), str(option))
        return self.run(command, **kwargs)

    def sspe(self, e11="", e21="", e22="", t="", **kwargs):
        """APDL Command: SSPE

        Specifies a preintegrated transverse shear stiffness for shell
        sections.

        Parameters
        ----------
        e11, e21, e22
            Transverse shear stiffness component (symmetric lower part of
            submatrix [E]).

        t
            Temperature.

        Notes
        -----
        The behavior of shell elements is governed by the generalized-
        stress/generalized-strain relationship of the form:

        The SSPE command, one of several preintegrated shell section commands,
        specifies the transverse shear stiffness quantity (submatrix [E] data)
        for a preintegrated shell section. The section data defined is
        associated with the section most recently defined (via the SECTYPE
        command).

        Unspecified values default to zero.

        Related commands are SSPA, SSPB, SSPD, SSMT, SSBT, and SSPM.

        If you are using the SHELL181 or SHELL281 element's Membrane option
        (KEYOPT(1) = 1), it is not necessary to issue this command.

        For complete information, see Using Preintegrated General Shell
        Sections.
        """
        command = "SSPE,%s,%s,%s,%s" % (str(e11), str(e21), str(e22), str(t))
        return self.run(command, **kwargs)

    def upcoord(self, factor="", key="", **kwargs):
        """APDL Command: UPCOORD

        Modifies the coordinates of the active set of nodes, based on the
        current displacements.

        Parameters
        ----------
        factor
            Scale factor for displacements being added to nodal coordinates.
            If FACTOR = 1.0, the full displacement value will be added to each
            node, 0.5, half the displacement value will be added, etc.  If
            FACTOR = -1, the full displacement value will be subtracted from
            each node, etc.

        key
            Key for zeroing displacements in the database:

            OFF - Do not zero the displacements (default).

            ON - Zero the displacements.

        Notes
        -----
        The UPCOORD command uses displacements stored in the ANSYS database,
        and not those contained within the results file, Jobname.RST.  Nodal
        coordinates are updated each time the command is issued.  After
        updating, both the nodal displacements and rotations are set to zero if
        Key = ON.

        For structural solutions with an updated mesh, unless the coefficient
        matrix is otherwise reformed (e.g., a new analysis or NLGEOM,ON) it
        should first be reformed by issuing a KUSE,-1 command.

        UPCOORD should not be issued between load steps in structural analysis.

        For a multiphysics simulation where a CFD or electromagnetic field is
        being coupled to a structure undergoing large displacements, all (or a
        portion) of the surrounding field mesh may take part in the structural
        solution to "move" with the displacing structure.  You can use the
        UPCOORD command with a suitable FACTOR to update the coordinates of the
        nodes using the newly computed displacements.  The mesh will now
        conform with the displaced structure for subsequent field solutions.
        However, the mesh should always be restored to its original location by
        using an UPCOORD,FACTOR command before performing any subsequent
        structural solutions.  This is true for both repeated linear solutions,
        and for nonlinear restarts. (All saved displacements are relative to
        the original mesh location.)

        This command is not intended to replace either the large displacement
        or birth and death logic.

        This command is also valid in PREP7.
        """
        command = "UPCOORD,%s,%s" % (str(factor), str(key))
        return self.run(command, **kwargs)

    def esla(self, type="", **kwargs):
        """APDL Command: ESLA

        Selects those elements associated with the selected areas.

        Parameters
        ----------
        type
            Label identifying the type of element select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        Notes
        -----
        Selects area elements belonging to meshed [AMESH], selected [ASEL]
        areas.

        This command is valid in any processor.
        """
        command = "ESLA,%s" % (str(type))
        return self.run(command, **kwargs)

    def kmove(self, npt="", kc1="", x1="", y1="", z1="", kc2="", x2="", y2="",
              z2="", **kwargs):
        """APDL Command: KMOVE

        Calculates and moves a keypoint to an intersection.

        Parameters
        ----------
        npt
            Move this keypoint.  If NPT = P, graphical picking is enabled and
            all remaining command fields are ignored (valid only in the GUI).
            A component name may also be substituted for NPT.

        kc1
            First coordinate system number.  Defaults to 0 (global Cartesian).

        x1, y1, z1
            Input one or two values defining the location of the keypoint in
            this coordinate system.  Input "U" for unknown value(s) to be
            calculated and input "E" to use an existing coordinate value.
            Fields are R1, θ1, Z1 for cylindrical, or R1, θ1, ϕ1 for spherical.

        kc2
            Second coordinate system number.

        x2, y2, z2
            Input two or one value(s) defining the location of the keypoint in
            this coordinate system.  Input "U" for unknown value(s) to be
            calculated and input "E" to use an existing coordinate value.
            Arguments are R2, θ2, Z2 for cylindrical, or R2, θ2, ϕ2 for
            spherical.

        Notes
        -----
        Calculates and moves a keypoint to an intersection location.  The
        keypoint must have been previously defined (at an approximate location)
        or left undefined (in which case it is internally defined at the SOURCE
        location).  The actual location is calculated from the intersection of
        three surfaces (implied from three coordinate constants in two
        different coordinate systems).  Note that solid modeling in a toroidal
        coordinate system is not recommended.  See the MOVE command for surface
        and intersection details.  The three (of six) constants easiest to
        define should be used.  The program will calculate the remaining three
        coordinate constants.  All arguments, except KC1, must be input.  Use
        the repeat command [*REPEAT] after the KMOVE command to move a series
        of keypoints, if desired.
        """
        command = "KMOVE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(npt), str(kc1), str(x1), str(y1), str(z1), str(kc2), str(x2), str(y2), str(z2))
        return self.run(command, **kwargs)

    def errang(self, emin="", emax="", einc="", **kwargs):
        """APDL Command: ERRANG

        Specifies the element range to be read from a file.

        Parameters
        ----------
        emin, emax, einc
            Elements with numbers from EMIN (defaults to 1) to EMAX (defaults
            to 99999999) in steps of EINC (defaults to 1) will be read.

        Notes
        -----
        Defines the element number range to be read [EREAD] from the element
        file. If a range is also implied from the NRRANG command, only those
        elements satisfying both ranges will be read.
        """
        command = "ERRANG,%s,%s,%s" % (str(emin), str(emax), str(einc))
        return self.run(command, **kwargs)

    def freq(self, freq1="", freq2="", freq3="", freq4="", freq5="", freq6="",
             freq7="", freq8="", freq9="", **kwargs):
        """APDL Command: FREQ

        Defines the frequency points for the SV vs. FREQ tables.

        Parameters
        ----------
        freq1, freq2, freq3, . . . , freq9
            Frequency points for SV vs. FREQ tables.  Values must be in
            ascending order. FREQ1 should be greater than zero.  Units are
            cycles/time.

        Notes
        -----
        Repeat the FREQ command for additional frequency points (100 maximum).
        Values are added after the last nonzero frequency.  If all fields
        (FREQ1 -- FREQ9) are blank, erase SV vs. FREQ tables.

        Frequencies must be in ascending order.

        Spectral values are input with the SV command and interpreted according
        to the SVTYP command.  Applies only to the SPRS (single-point) option
        of the SPOPT command.  See the SPFREQ command for frequency input in
        MPRS (multi-point) analysis.

        Use the STAT command to list current frequency points.

        This command is also valid in PREP7.
        """
        command = "FREQ,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(freq1), str(freq2), str(freq3), str(freq4), str(freq5), str(freq6), str(freq7), str(freq8), str(freq9))
        return self.run(command, **kwargs)

    def graphics(self, key="", **kwargs):
        """APDL Command: /GRAPHICS

        Defines the type of graphics display.

        Parameters
        ----------
        key
            Graphics key:

            FULL - Display all model geometry and results.

            POWER - Activate PowerGraphics (default when GUI is on).

        Notes
        -----
        The /GRAPHICS command specifies the type of graphics display. Key =
        POWER activates the PowerGraphics capability. PowerGraphics offers
        faster plotting than the Key = FULL option, and speeds up element,
        results, area, line, and volume displays. PowerGraphics mode (the
        default) is automatically invoked when the GUI is accessed. This action
        supersedes all prior macros or start up routines (start.ans,
        config.ans, etc.). Full graphics mode can be accessed only by issuing
        /GRAPHICS, FULL after the GUI is active.

        Results values (both printed and plotted) may differ between the Key =
        FULL and Key = POWER options because each option specifies a different
        set of data for averaging and display. For Key = FULL, all element and
        results values (interior and surface) are included.  For Key = POWER,
        only element and results values along the model exterior surface are
        processed.

        Caution:: : If you have specified one facet per element edge for
        PowerGraphics displays (via the /EFACET command or via choices from the
        General Postproc or Utility Menus), PowerGraphics does not plot midside
        nodes.

        The /EFACET command is only applicable to element type displays. (See
        the descriptions of these commands for more information.)

        Maximum values shown in plots can differ from printed maximum values.
        This is due to different averaging schemes used for plotted and printed
        maximum values.

        PowerGraphics displays do not average at geometric discontinuities. The
        printouts in PowerGraphics will, however, provide averaging information
        at geometric discontinuities if the models do not contain shell
        elements. Carefully inspect the data you obtain at geometric
        discontinuities.

        PowerGraphics does not support the following diffusion analysis
        results: CONC, CG, DF, EPDI.

        Note:: : In Full Graphics mode, it is possible to deselect an
        individual node, select all elements (including the element that
        contains that node), and then perform postprocessing calculations on
        those elements and have that unselected node not be considered in those
        calculations.  However, if PowerGraphics is active, postprocessing
        always displays based on selected elements.

        PowerGraphics does not support membrane shell elements such as SHELL41,
        and these elements using the membrane-stiffness-only option (KEYOPT1) =
        1): SHELL181, SHELL208, and SHELL209.

        Commands that are not supported by PowerGraphics are listed below.
        These commands are executed using the Key = FULL option, regardless of
        whether PowerGraphics is activated.  Only certain options for /CTYPE,
        /EDGE, /ESHAPE, *GET, /PNUM, /PSYMB, SHELL, and *VGET are not supported
        by PowerGraphics.  (See the descriptions of these commands for more
        information.)
        """
        command = "/GRAPHICS,%s" % (str(key))
        return self.run(command, **kwargs)

    def vec(self, vector="", type="", method="", val1="", val2="", val3="",
            val4="", **kwargs):
        """APDL Command: *VEC

        Creates a vector.

        Parameters
        ----------
        vector
            Name used to identify the vector. Must be specified.

        type
            Vector type:

            Double precision real values (default). - Complex double precision values.

        method
            Method used to create the vector:

            Allocate space for a vector (default). - Resize an existing vector to a new length. Values are kept from the original
                              vector. If the length specified by Val1 is
                              greater than the original vector length, the
                              additional rows are assigned a value of zero.

            Copy an existing vector. - Import the vector from a file.

        val1, val2, val3, val4, val5
            Additional input. The meaning of Val1 through Val5 will vary
            depending on the specified Method. See details below.

        Notes
        -----
        Use the *DMAT command to create a matrix.

        For more information on the BACK and FORWARD nodal mapping vectors, see
        Degree of Freedom Ordering in the ANSYS Parametric Design Language
        Guide.
        """
        command = "*VEC,%s,%s,%s,%s,%s,%s,%s" % (str(vector), str(type), str(method), str(val1), str(val2), str(val3), str(val4))
        return self.run(command, **kwargs)

    def msolve(self, numslv="", nrmtol="", nrmchkinc="", **kwargs):
        """APDL Command: MSOLVE

        Starts multiple solutions for random acoustics analysis with diffuse
        sound field.

        Parameters
        ----------
        numslv
            Number of multiple solutions (load steps) corresponding to the
            number of samplings. Default = 1.

        Notes
        -----
        The MSOLVE command starts multiple solutions (load steps) for random
        acoustics analysis with multiple samplings.

        The process is controlled by the norm convergence tolerance NRMTOL or
        the number of multiple solutions NUMSLV (if the solution steps reach
        the defined number).

        The program checks the norm convergence by comparing two averaged sets
        of radiated sound powers with the interval NRMCHKINC over the frequency
        range. For example, if NRMCHKINC = 5, the averaged values from 5
        solutions are compared with the averaged values from 10 solutions, then
        the averaged values from 10 solutions are compared with the averaged
        values from 15 solutions, and so on.

        The incident diffuse sound field is defined via the DFSWAVE command.

        The average result of multiple solutions with different samplings is
        calculated via the PLST command.
        """
        command = "MSOLVE,%s,%s,%s" % (str(numslv), str(nrmtol), str(nrmchkinc))
        return self.run(command, **kwargs)

    def andata(self, delay="", ncycl="", rsltdat="", min="", max="", incr="",
               frclst="", autocont="", unused="", autocntr="", **kwargs):
        """APDL Command: ANDATA

        Displays animated graphics data for nonlinear problems.

        Parameters
        ----------
        delay
            Time delay during animation (defaults to 0.5 seconds).

        ncycl
            Number of animation cycles (defaults to 5).  Available in non-UI
            mode only.

        rsltdat
            The type of results data to be used for the animation sequence.
            This can be:

            0 - Current load step data (default).

            1 - Range of load step data.

            2 - Range of results data.

        min
            The range minimum value.  If left blank or 0, defaults to the first
            data point.

        max
            The range maximum value.  If left blank or 0, defaults to the last
            data point.

        incr
            The increment between result data (defaults to 1).

        frclst
            Key to force the last sub step in a selected load step to be
            included in the animation (defaults to 0).

        autocont
            A value of 1 enables automatic scaling of contour values based on
            the overall subset range of values. The default value is 0 (no
            automatic scaling).

        --
            Unused field.

        autocntr
            A value of 1 disables automatic centering of displaced plots. The
            default value is 0 (allow automatic centering).

        Notes
        -----
        Use the ANDATA command to create animations for nonlinear problems. The
        command works by displaying an individual graphical image for each
        result data set from the results file. For information about creating
        animations for linear problems, see the ANIM command.

        The command operates only on graphic display platforms supporting the
        /SEG command. It uses a macro to produce an animation based on the last
        plot action command (for example, PLDISP).

        The results file must have more than one set of results.

        The command implicitly issues /DSCALE, 1 for default displacement
        scaling. Large displacements may not give good results.

        This command functions only in the postprocessor.
        """
        command = "ANDATA,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(delay),
                                                         str(ncycl),
                                                         str(rsltdat),
                                                         str(min),
                                                         str(max),
                                                         str(incr),
                                                         str(frclst),
                                                         str(autocont),
                                                         str(unused),
                                                         str(autocntr))
        return self.run(command, **kwargs)

    def dmpstr(self, coeff="", **kwargs):
        """APDL Command: DMPSTR

        Sets a constant structural damping coefficient.

        Parameters
        ----------
        coeff
            Structural damping coefficient.

        Notes
        -----
        Sets a constant structural (or hysteretic) damping coefficient for use
        in harmonic (ANTYPE,HARMIC) analyses (FULL, MSUP, and VT) and modal
        analyses (ANTYPE,MODAL with MODOPT,UNSYM, DAMP or QRDAMP).

        Note that for structures with multiple materials, MP,DMPR can also be
        used to specify constant structural material damping on a per material
        basis. Note that if both DMPSTR and MP,DMPR are specified, the damping
        effects are additive.

        Caution:: : DMPSTR adds the damping contribution as gK, whereas MP,DMPR
        adds the contribution on a per-material basis as 2gK. For more
        information, see Damping Matrices in the Mechanical APDL Theory
        Reference.

        This command is also valid in PREP7.
        """
        command = "DMPSTR,%s" % (str(coeff))
        return self.run(command, **kwargs)

    def zoom(self, wn="", lab="", x1="", y1="", x2="", y2="", **kwargs):
        """APDL Command: /ZOOM

        Zooms a region of a display window.

        Parameters
        ----------
        wn
            Window number to which command applies (defaults to 1).

        lab
            Label to define the desired type of zoom:

            OFF - Turns zoom off (refits image of entire model to the window).

            BACK - Goes back to previous zoom setting (five successive back ups, maximum).

            SCRN - Interprets X1,Y1 as the screen coordinates of the center of a square zoom
                   region; X2,Y2 as the screen coordinates of a point on one
                   side of that square.

            RECT - Interprets X1,Y1 and X2,Y2 as the screen coordinates of two opposite corners of
                   a rectangular zoom region.

        Notes
        -----
        Zooms (centers and magnifies) the specified region of a display window.
        /ZOOM will operate on a display that has been formed by an explicit
        graphics action command (APLOT, EPLOT, etc.).  /ZOOM has no effect on
        an "immediate" graphics display.  When /ZOOM is executed, the display
        is automatically replotted such that the specified zoom region is
        centered and sized to fill the window.

        Auto resizing is disabled when you issue the /ZOOM command.  To restore
        auto resizing, issue the  /AUTO command, or select FIT from the Pan,
        Zoom, Rotate box.

        This command is valid in any processor.
        """
        command = "/ZOOM,%s,%s,%s,%s,%s,%s" % (str(wn), str(lab), str(x1), str(y1), str(x2), str(y2))
        return self.run(command, **kwargs)

    def djlist(self, elem="", **kwargs):
        """APDL Command: DJLIST

        Lists boundary conditions applied to joint elements.

        Parameters
        ----------
        elem
            Element number or ALL (or blank). Lists joint element boundary
            conditions on the specified element(s).

        Notes
        -----
        This command is valid for MPC184 joint elements. See DJ for information
        on specifying boundary conditions on joint elements.
        """
        command = "DJLIST,%s" % (str(elem))
        return self.run(command, **kwargs)

    def asbv(self, na="", nv="", sepo="", keepa="", keepv="", **kwargs):
        """APDL Command: ASBV

        Subtracts volumes from areas.

        Parameters
        ----------
        na
            Area (or areas, if picking is used) to be subtracted from.  If ALL,
            use all selected areas.  If P, graphical picking is enabled (valid
            only in the GUI) and remaining fields are ignored.  A component
            name may also be substituted for NA.

        nv
            Volume (or volumes, if picking is used) to subtract.  If ALL, use
            all selected volumes.  A component name may also be substituted for
            NV.

        sepo
            Behavior if the intersection of the areas and the volumes is a line
            or lines:

            (blank) - The resulting areas will share line(s) where they touch.

            SEPO - The resulting areas will have separate, but coincident line(s) where they
                   touch.

        keepa
            Specifies whether NA areas are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NA areas after ASBV operation (override BOPTN command settings).

            KEEP - Keep NA areas after ASBV operation (override BOPTN command settings).

        keepv
            Specifies whether NV volumes are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete volumes after ASBV operation (override BOPTN command settings).

            KEEP - Keep volumes after ASBV operation (override BOPTN command settings).

        Notes
        -----
        Generates new areas by subtracting the regions common to both NA areas
        and NV volumes (the intersection) from the NA areas.  The intersection
        can be an area(s) or line(s).  If the intersection is a line and SEPO
        is blank, the NA area is divided at the line and the resulting areas
        will be connected, sharing a common line where they touch.  If SEPO is
        set to SEPO, NA is divided into two unconnected areas with separate
        lines where they touch.  See Solid Modeling in the Modeling and Meshing
        Guide for an illustration.  See the BOPTN command for an explanation of
        the options available to Boolean operations.  Element attributes and
        solid model boundary conditions assigned to the original entities will
        not be transferred to the new entities generated.
        """
        command = "ASBV,%s,%s,%s,%s,%s" % (str(na), str(nv), str(sepo), str(keepa), str(keepv))
        return self.run(command, **kwargs)

    def splot(self, na1="", na2="", ninc="", mesh="", **kwargs):
        """APDL Command: SPLOT

        Displays the selected areas and a faceted view of their underlying
        surfaces

        Parameters
        ----------
        na1
            Starting area for display of areas and underlying surfaces. If NA1
            = ALL (default), NA2 and NINC are ignored and all selected areas
            are displayed (ASEL command).

        na2
            Last area to be displayed.

        ninc
            Numeric value setting steps between NA1 and NA2 for display.
            Default value is (1).

        mesh
            Specifies a rectangular mesh density used to display the underlying
            surface (default 4, i.e. 4 x 4).

        Notes
        -----
        This command is valid in any processor. The plot output displays the
        external and internal trim curves and underlying surface. You cannot
        obtain a faceted view of your surface areas when you are using the
        /EXPAND command to create larger graphics displays.

        Use APLOT for trimmed surface display.
        """
        command = "SPLOT,%s,%s,%s,%s" % (str(na1), str(na2), str(ninc), str(mesh))
        return self.run(command, **kwargs)

    def cdread(self, option="", fname="", ext="", unused="", fnamei="", exti="",
               **kwargs):
        """APDL Command: CDREAD

        Reads a file of solid model and database information into the database.

        Parameters
        ----------
        option
            Selects which data to read:

            ALL - Read all geometry, material property, load, and component data (default).
                  Solid model geometry and loads will be read from the file
                  Fnamei.Exti.  All other data will be read from the file
                  Fname.Ext.

            DB - Read all database information contained in file Fname.Ext. This file should
                 contain all information mentioned above except the solid model
                 loads. If reading a .CDB file written with the GEOM option of
                 the CDWRITE  command, element types [ET] compatible with the
                 connectivity of the elements on the file must be defined prior
                 to reading.

            SOLID - Read the solid model geometry and solid model loads from the file Fnamei.Exti.
                    This file could have been written by the CDWRITE or IGESOUT
                    command.

            COMB - Read the combined solid model and database information from the file Fname.Ext.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        fnamei
            Name of the IGES file and its directory path (248 characters
            maximum, including directory). If you do not specify a directory
            path, it will default to your working directory and you can use all
            248 characters for the file name.

        exti
            Filename extension (eight-character maximum).

        Notes
        -----
        This command causes coded files of solid model (in IGES format) and
        database (in command format) information to be read.  These files are
        normally written by the CDWRITE or IGESOUT command.  Note that the
        active coordinate system in these files has been reset to Cartesian
        (CSYS,0).

        If a set of data exists prior to the CDREAD operation, that data set is
        offset upward to allow the new data to fit without overlap. The
        NOOFFSET command allows this offset to be ignored on a set-by-set
        basis, causing the existing data set to be overwritten with the new
        data set.

        When you write the geometry data using the CDWRITE,GEOM option, you use
        the CDREAD,DB option to read the geometry information.

        Using the CDREAD,COMB option will not write NUMOFF commands to offset
        entity ID numbers if there is no solid model in the database.

        Multiple CDB file imports cannot have elements with real constants in
        one file and section definitions in another. The section attributes
        will override the real constant attributes.  If you use CDREAD to
        import multiple CDB files, define all of the elements using only real
        constants, or using only section definitions.  Combining real constants
        and section definitions is not recommended.

        This command is valid in any processor.
        """
        command = "CDREAD,%s,%s,%s,%s,%s,%s" % (str(option), str(fname), str(ext),
                                                str(unused), str(fnamei), str(exti))
        return self.run(command, **kwargs)

    def edpart(self, option="", partid="", cname="", **kwargs):
        """APDL Command: EDPART

        Configures parts for an explicit dynamics analysis.

        Parameters
        ----------
        option
            Option used to organize parts. (No default; Option must be
            specified.)

            CREATE - Creates new PART IDs assigned to groups of elements with unique combinations of
                     MAT, TYPE, and REAL set numbers. If this option is issued
                     repeatedly, the part list is overwritten, except for PART
                     IDs created with the ADD option. Remaining fields are
                     ignored for this option.

            UPDATE - Updates the PART IDs for the element groups without changing the order of the
                     existing part list. If elements are redefined (or new
                     elements are created) with different MAT, TYPE, or REAL
                     set numbers, then use this option to create an updated
                     list of PART IDs. Remaining fields are ignored for this
                     option.

            ADD - Assigns a user-specified PART ID (PARTID) to the elements contained in the
                  element component Cname, or to the currently selected set of
                  elements if Cname = ALL. Use this option to assign a specific
                  PART ID to an element group that has the same combination of
                  MAT, TYPE, and REAL set numbers. An UPDATE operation is
                  automatically performed on the currently selected set of
                  elements immediately following the ADD operation.

            DELE - Deletes a PART ID assigned by the ADD option. PARTID is also required. An
                   UPDATE operation is automatically performed on the currently
                   selected set of elements immediately following the DELE
                   operation.

            LIST - Lists the PART IDs for the element groups. The part list consists of five
                   columns of numbers, one each for PART, MAT, TYPE, and REAL
                   numbers, and one to indicate if the PART ID is used
                   (including how many elements use it). The part list is based
                   on the last CREATE or UPDATE operation. Remaining fields are
                   ignored for this option.

        partid
            A positive integer to be used as PART ID for the elements specified
            by Cname (no default). The number input must not be currently used
            for an existing part (except when Option = DELE). Any previously
            defined PART IDs for the elements, whether assigned by the user or
            created by ANSYS LS-DYNA, will be overwritten. The user-specified
            PART ID will not be changed by subsequent EDPART,CREATE or
            EDPART,UPDATE commands.

        cname
            Element component name for user-specified PART ID definition
            (Option = ADD). If Cname = ALL (default), all currently selected
            elements are considered for the part. The elements in the element
            component (or the currently selected set of elements if Cname = ALL
            or blank) must have the same combination of MAT, TYPE, and REAL set
            numbers, or the ADD option will be ignored.

        Notes
        -----
        Certain ANSYS LS-DYNA commands (such as EDCGEN, EDLOAD, EDREAD, etc.)
        refer to PART IDs. You must define PART IDs (EDPART,CREATE or
        EDPART,ADD) before using these commands.

        If parts are repeatedly created using Option = CREATE, the part list is
        continuously overwritten. This may cause problems for previously
        defined commands that reference a part number that has changed. To
        avoid this problem, the part list should be updated (Option = UPDATE)
        rather than recreated to obtain the current part list.

        EDPART,ADD allows you to assign a specific part number to a group of
        elements instead of a number generated by the ANSYS LS-DYNA program.
        The user-specified PART IDs will not be changed by subsequent
        EDPART,CREATE or EDPART,UPDATE commands. Thus, you can use EDPART,ADD
        to specify PART IDs for some element groups, and use EDPART,CREATE or
        EDPART,UPDATE to assign PART IDs for the remaining element groups. Use
        EDPART,DELE to delete a PART ID generated by the ADD option. In this
        case, ANSYS LS-DYNA will generate a new PART ID for those elements
        associated with the deleted PART ID.

        After creating or updating the part list, use EDPART,LIST to list the
        PART IDs and choose the correct one for use with other ANSYS LS-DYNA
        commands. For a detailed discussion on PART IDs, see The Definition of
        Part in the ANSYS LS-DYNA User's Guide.

        This command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDPART,%s,%s,%s" % (str(option), str(partid), str(cname))
        return self.run(command, **kwargs)

    def lslk(self, type="", lskey="", **kwargs):
        """APDL Command: LSLK

        Selects those lines containing the selected keypoints.

        Parameters
        ----------
        type
            Label identifying the type of line select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        lskey
            Specifies whether all contained line keypoints must be selected
            [KSEL]:

            0 - Select line if any of its keypoints are in the selected keypoint set.

            1 - Select line only if all of its keypoints are in the selected keypoint set.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "LSLK,%s,%s" % (str(type), str(lskey))
        return self.run(command, **kwargs)

    def gcgen(self, option="", featureangle="", edgekey="", splitkey="",
              selopt="", **kwargs):
        """APDL Command: GCGEN

        Creates contact elements for general contact.

        Parameters
        ----------
        option
            Option to be performed.

            NEW - Create a new general contact definition. This option removes all existing
                  general contact elements and generates new elements with new
                  section IDs. Any existing GCDEF specifications, general
                  contact SECTYPE/SECDATA data, and general contact element
                  types are also removed. If no general contact elements or
                  data exist, this option behaves the same as Option = UPDATE.

            UPDATE - Generate general contact elements on newly added (or selected) base elements.
                     Newly generated contact elements are assigned new Section
                     IDs. Existing general contact elements remain with their
                     previously assigned section IDs and element attributes.
                     Existing GCDEF and SECTYPE/SECDATA general contact data
                     are respected. (This is the default option.)

            DELETE - Remove all existing general contact elements. Existing GCDEF specifications,
                     general contact SECTYPE/SECDATA data, and general contact
                     element types are also removed.

            SELECT - Select all existing general contact elements.

        featureangle
            Angle tolerance for determining feature edges (EdgeKEY) and general
            surfaces (SplitKey). Default = 42 degrees.

        edgekey
            Key that controls creation of general contact line elements
            (CONTA177) on base shell element perimeter edges and/or base solid
            element feature edges. See Understanding FeatureANGLE for an
            explanation of the feature edge criteria.

            0 - Exclude feature edges and shell perimeter edges (default).

            1 - Include feature edges only.

            2 - Include shell perimeter edges only.

            3 - Include both feature edges and shell perimeter edges.

        splitkey
            Key that controls how section IDs and contact element type IDs are
            assigned to surfaces.

            SPLIT - Assign a different section ID and contact element type ID for every general
                    surface of the selected base elements (default). See
                    Understanding FeatureANGLE for an explanation of the split
                    criteria. Different section IDs are assigned to top and
                    bottom surfaces of 2-D beam and 3-D shell bodies. This
                    allows different GCDEF specifications for different
                    portions of the assembly.

            PART - Assign a different section ID and contact element type ID for every general
                   surface which covers a physical part. Compared to the SPLIT
                   option, this option produces fewer unique section IDs, which
                   can make it easier to specify interactions via GCDEF.
                   However, it may also result in a less accurate and/or less
                   efficient solution.

        selopt
            Key that controls which base elements are considered for general
            contact.

            ATTACH - Use a recursive adjacency selection to obtain complete physical parts, starting
                     from the selected base elements, before generating general
                     contact elements (default).

            SELECT - Use only the initially selected base elements to generate general contact
                     elements.

        Notes
        -----
        GCGEN creates general contact elements on the exterior faces of
        selected base elements. The base elements can be 2-D or 3-D solids, 2-D
        beams (top and bottom), or 3-D shells (top and bottom). The contact
        element types can be CONTA172, CONTA174, and/or CONTA177, depending
        upon the types of base elements in the model and the specified GCGEN
        options. General contact elements are identified by a real constant ID
        equal to zero.

        You can control contact interactions between specific general contact
        surfaces that could potentially be in contact by using the GCDEF
        command. See General Contact in the Contact Technology Guide for more
        information on the overall procedure to create general contact.

        Understanding FeatureANGLE

        The exterior facets of the selected base solid and shell elements are
        divided into subsets based on the angle between the normals of
        neighboring faces. On a flat or smooth surface, adjacent exterior
        element faces have normals that are parallel or nearly parallel; that
        is, the angle between the adjacent normals is near zero degrees.

        When the angle between the normals of two adjacent faces is greater
        than FeatureANGLE, the two faces are considered to be on two separate
        surfaces (SplitKey = SPLIT). The edge between the faces may be convex
        or concave. A convex (or outside) edge is considered to be a feature
        edge and may be affected by the EdgeKEY setting. For more information,
        see Feature Angle (FeatureANGLE) in the Contact Technology Guide.
        """
        command = "GCGEN,%s,%s,%s,%s,%s" % (str(option), str(featureangle), str(edgekey), str(splitkey), str(selopt))
        return self.run(command, **kwargs)

    def lsoper(self, **kwargs):
        """APDL Command: LSOPER

        Specifies "Load step operations" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "LSOPER," % ()
        return self.run(command, **kwargs)

    def number(self, nkey="", **kwargs):
        """APDL Command: /NUMBER

        Specifies whether numbers, colors, or both are used for displays.

        Parameters
        ----------
        nkey
            Numbering style:

             0  - Color (terminal dependent) the numbered items and show numbers.

             1  - Color the numbered items.  Do not show the numbers.

             2  - Show the numbers.  Do not color the items.

            -1  - Do not color the items or show the numbers. For contour plots, the resulting
                  display will vary (see below).

        Notes
        -----
        Specifies whether numbers, colors, or both are used for numbering
        displays [/PNUM] of nodes, elements, keypoints, lines, areas, and
        volumes.

          Shading is also available for terminals configured with more than 4
        color planes [/SHOW].  Color automatically appears for certain items
        and may be manually controlled (off or on) for other items.

        When you suppress color (NKEY = -1) your contour plots will produce
        different results, depending on your graphics equipment. For non-3-D
        devices (X11, Win32, etc.) your contour plot will be white (no color).
        For 3-D devices, such as OpenGL, the resulting display will be in
        color.

        The following items are automatically given discrete colors:  Boundary
        condition symbols [/PBC], curves on graph displays, and distorted
        geometry on postprocessing displays.  Contour lines in postprocessing
        displays are automatically colored based upon a continuous, rather than
        a discrete, spectrum so that red is associated with the highest contour
        value.  On terminals with raster capability [/SHOW], the area between
        contour lines is filled with the color of the higher contour.

        Explicit entity colors or the discrete color mapping may be changed
        with the /COLOR command.

        This command is valid in any processor.
        """
        command = "/NUMBER,%s" % (str(nkey))
        return self.run(command, **kwargs)

    def pmore(self, unused="", x5="", y5="", x6="", y6="", x7="", y7="", x8="", y8="",
              **kwargs):
        """APDL Command: /PMORE

        Creates an annotation polygon (GUI).

        Parameters
        ----------
        --
            Unused field.

        x5
            X location for vertex 5 of polygon (-1.0 < X < 2.0).

        y5
            Y location for vertex 5 of polygon (-1.0 < Y < 1.0).

        x6
            X location for vertex 6 of polygon (-1.0 < X < 2.0).

        y6
            Y location for vertex 6 of polygon (-1.0 < Y < 1.0).

        x7
            X location for vertex 7 of polygon (-1.0 < X < 2.0).

        y7
            Y location for vertex 7 of polygon (-1.0 < Y < 1.0).

        x8
            X location for vertex 8 of polygon (-1.0 < X < 2.0).

        y8
            Y location for vertex 8 of polygon (-1.0 < Y < 1.0).

        Notes
        -----
        Defines the 5th through 8th vertices of an annotation polygon
        [/POLYGON].  This is a command generated by the Graphical User
        Interface (GUI) and will appear in the log file (Jobname.LOG) if
        annotation is used.  This command is not intended to be typed in
        directly in an ANSYS session (although it can be included in an input
        file for batch input or for use with the /INPUT command).

        This command is valid in any processor.
        """
        command = "/PMORE,%s,%s,%s,%s,%s,%s,%s,%s" % (str(x5), str(y5), str(x6), str(y6), str(x7), str(y7), str(x8), str(y8))
        return self.run(command, **kwargs)

    def vcone(self, wn="", phi="", **kwargs):
        """APDL Command: /VCONE

        Defines the view cone angle for perspective displays.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        phi
            View cone angle (0.0 to 85.°) to define perspective.  Use PHI =
            45.0° for typical perspective.   Increase angle for more
            perspective, decrease angle for less.  If the distance [/DIST] is
            not specified, it will be automatically calculated to give full
            window magnification.  If the distance is also specified, PHI
            controls both the perspective and the magnification.  The larger
            the angle, the more the perspective and the less the magnification.
            Defaults to 0.0 (no perspective).

        Notes
        -----
        Perspective shows the true depth of the object in the display.  A
        variable magnification results since the back plane of the object is
        further from the observer than the front plane.  The largest
        magnification occurs at the front plane.  With perspective, the
        magnification factor (MAGF) is not only a function of the distance from
        the object, but also the window shape and the perspective (or view
        cone) angle: Φ as follows:

        where , for square windows, is the largest in-plane vertical or
        horizontal dimension, d is the distance from the observer to the plane
        of:  (usually the front plane of the object), and: Φ is the view cone
        angle (defined with the /VCONE command).  The bigger the cone angle,
        the more the perspective.  The magnification factor proportionally
        decreases with increasing: Φ.  The distance can be defined with the
        /DIST or the /FOCUS command.  Note, the distance input on the /DIST
        command is equal to d only if the focus point is located on the plane
        of : .  It is recommended that if a general perspective is desired
        (i.e., not any specific cone angle), use Φ = 45.0 (since TAN(45.0) =
        1.0) and let the d value be automatically calculated for full window
        magnification.

        Note that any number of /DIST, /FOCUS, and /VCONE combinations can be
        used to produce the same magnification.  Distances less than the object
        depth will produce views from within the object.

        A magnification factor of 1.0 just fills the window.  If the automatic
        scaling option is used [/AUTO], the magnification factor is fixed at
        0.91 (to allow a 10% margin around the object) and d is automatically
        calculated for the given /VCONE and /FOCUS values.  Any value of Φ
        between 0.0 and 85.0 (usually 45.0) may be used to activate the
        perspective.  Views from inside the object are not possible when d is
        automatically calculated (use manual scaling [/USER] along with /DIST
        specification).

        This command is valid in any processor.
        """
        command = "/VCONE,%s,%s" % (str(wn), str(phi))
        return self.run(command, **kwargs)

    def mxpand(self, nmode="", freqb="", freqe="", elcalc="", signif="",
               msupkey="", modeselmethod="", **kwargs):
        """APDL Command: MXPAND

        Specifies the number of modes to expand and write for a modal or
        buckling analysis.

        Parameters
        ----------
        nmode
            Number of modes or array name (enclosed in percent signs) to expand
            and write. If blank or ALL, expand and write all modes within the
            frequency range specified. If -1, do not expand and do not write
            modes to the results file during the analysis. If an array name is
            input, the array must contain 1 for the expanded modes and zero
            otherwise, where the array index corresponds to the mode number. To
            specify an array containing the individual modes to expand, enclose
            the array name in percent (%) signs (for example,
            MXPAND,%arrname%). Use the *DIM command to define the array.

        freqb
            Beginning, or lower end, of frequency range of interest. If FREQB
            and FREQE are both blank, expand and write the number of modes
            specified without regard to the frequency range. Defaults to the
            entire range.

        freqe
            Ending, or upper end, of frequency range of interest.

        elcalc
            Element calculation key:

            NO - Do not calculate element results, reaction forces, and energies (default).

            YES - Calculate element results, reaction forces, energies, and the nodal degree of
                  freedom solution.

        signif
            Expand only those modes whose significance level exceeds the SIGNIF
            threshold (only applicable when ModeSelMethod is defined).

        msupkey
            Element result superposition key:

            NO - Do not write element results to the mode file Jobname.MODE.

            YES - Write element result to the mode file for use in the expansion pass of a
                  subsequent mode-superposition PSD, transient, or harmonic
                  analysis (default if Elcalc = YES and the mode shapes are
                  normalized to the mass matrix).

        modeselmethod
            Methods for mode selection (not supported for complex
            eigensolvers):

            blank - No mode selection is performed (default).

            MODM - The mode selection is based on the modal effective masses.

            MODC - The mode selection is based on the mode coefficients.

            DDAM - The mode selection is based on DDAM procedure (see Mode Selection Based on DDAM
                   Procedure in the Mechanical APDL Structural Analysis Guide
                   for more information). This option is applicable only to
                   DDAM spectrum analysis.

        Notes
        -----
        Specifies the number of modes to expand and write over a frequency
        range for a modal (ANTYPE,MODAL) or buckling (ANTYPE,BUCKLE) analysis.
        If used in SOLUTION, this command is valid only within the first load
        step.

        There is no limit on the number of expanded modes (NMODE). However,
        there is a limit on the maximum number of modes used via the *GET,,MODE
        command, mode combinations, and the MDAMP command.

        With MSUPkey = YES, the computed element results (Elcalc = YES) are
        written to Jobname.MODE for use in subsequent downstream mode-
        superposition analyses, including harmonic, transient, and PSD
        analyses. This significantly reduces computation time for the
        combination or expansion passes. For limitations, see Option: Number of
        Modes to Expand (MXPAND) in the Mechanical APDL Structural Analysis
        Guide.

        If a mode selection method (ModeSelMethod) is defined, only the
        selected modes will be expanded. See Using Mode Selection in the
        Mechanical APDL Structural Analysis Guide for more details about the
        procedure.

        For array input (NMODE), the array must be dimensioned to be the size
        of the number of modes extracted (NMODE on the MODOPT command). A value
        of 1 in the array indicates the mode is to be expanded, and a value of
        0 indicates not to expand the mode. For the DAMP modal solution, the
        modes are in pairs, so be sure to verify that both modes of a pair have
        the same value. (For example, if modes #3 and #4 are a pair, indices 3
        and 4 in the array should have the same value, 0 or 1.)

        For linear perturbation modal analyses, you must set both Elcalc and
        MSUPkey to YES so that the downstream stress expansion pass can produce
        a solution consistent with the linear or nonlinear base (static or full
        transient) analysis. The prestressed nonlinear element history (saved
        variables) is accessible only in the first and second phases of the
        linear perturbation. The downstream MSUP or PSD analysis can only reuse
        the nonlinear information contained in the Jobname.MODE file that is
        generated in the linear perturbation.

        In a Distributed ANSYS analysis, you must issue MXPAND to specify the
        number of modes to expand when computing the modes and mode shapes. In
        a Distributed ANSYS run, MXPAND cannot be issued in an expansion pass
        (EXPASS).

        This command is also valid in PREP7.
        """
        command = "MXPAND,%s,%s,%s,%s,%s,%s,%s" % (str(nmode), str(freqb), str(freqe), str(elcalc), str(signif), str(msupkey), str(modeselmethod))
        return self.run(command, **kwargs)

    def vsel(self, type="", item="", comp="", vmin="", vmax="", vinc="",
             kswp="", **kwargs):
        """APDL Command: VSEL

        Selects a subset of volumes.

        Parameters
        ----------
        type
            Label identifying the type of volume select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

            ALL - Restore the full set.

            NONE - Unselect the full set.

            INVE - Invert the current set (selected becomes unselected and vice versa).

            STAT - Display the current select status.

        Notes
        -----
        Selects volumes based on values of a labeled item and component.  For
        example, to select a new set of volumes based on volume numbers 1
        through 7, use VSEL,S,VOLU,,1,7.  The subset is used when the ALL label
        is entered (or implied) on other commands, such as VLIST,ALL.  Only
        data identified by volume number are selected.  Data are flagged as
        selected and unselected; no data are actually deleted from the
        database.

        This command is valid in any processor.

        For Selects based on non-integer numbers (coordinates, results, etc.),
        items that are within the range VMIN-Toler and VMAX+Toler are selected.
        The default tolerance Toler is based on the relative values of VMIN and
        VMAX as follows:

        If VMIN = VMAX, Toler = 0.005 x VMIN.

        If VMIN = VMAX = 0.0, Toler = 1.0E-6.

         If VMAX ≠ VMIN, Toler = 1.0E-8 x (VMAX-VMIN).

        Use the SELTOL command to override this default and specify Toler
        explicitly.

        Table: 251:: : VSEL - Valid Item and Component Labels
        """
        command = "VSEL,%s,%s,%s,%s,%s,%s,%s" % (str(type), str(item), str(comp), str(vmin), str(vmax), str(vinc), str(kswp))
        return self.run(command, **kwargs)

    def anmode(self, nfram="", delay="", ncycl="", kaccel="", **kwargs):
        """APDL Command: ANMODE

        Produces an animated sequence of a mode shape.

        Parameters
        ----------
        nfram
            Number of frames captures (defaults to 5).

        delay
            Time delay during animation (defaults to 0.1 seconds).

        ncycl
            Number of animation cycles (defaults to 5).  Available in non-UI
            mode only.

        kaccel
            Acceleration type:

            0 - Linear acceleration.

            1 - Sinusoidal acceleration.

        Notes
        -----
        ANMODE involves an ANSYS macro which produces an animation of mode
        shape of the last plot action command (for example, PLDISP).  The
        ANMODE command operates only on graphic display platforms supporting
        the /SEG command.  After executing ANMODE, you can replay the animated
        sequence by issuing the ANIM command.

        This command functions only in the postprocessor.
        """
        command = "ANMODE,%s,%s,%s,%s" % (str(nfram), str(delay), str(ncycl), str(kaccel))
        return self.run(command, **kwargs)

    def vread(self, parr="", fname="", ext="", label="", n1="", n2="", n3="",
              nskip="", **kwargs):
        """APDL Command: *VREAD

        Reads data and produces an array parameter vector or matrix.

        Parameters
        ----------
        parr
            The name of the resulting array parameter vector.  See *SET for
            name restrictions.  The parameter must exist as a dimensioned array
            [*DIM]. String arrays are limited to a maximum of 8 characters.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        label
            Can take a value of IJK, IKJ, JIK, JKI, KIJ, KJI, or blank (IJK).

        n1, n2, n3
            Read as (((ParR (i,j,k), k = 1,n1), i = 1, n2), j = 1, n3) for
            Label = KIJ. n2 and n3 default to 1.

        nskip
            Number of lines at the beginning of the file being read that will
            be skipped during the reading.  Default = 0.

        Notes
        -----
        Reads data from a file and fills in an array parameter vector or
        matrix.  Data are read from a formatted file or, if the menu is off
        [/MENU,OFF] and Fname is blank, from the next input lines.  The format
        of the data to be read must be input immediately following the *VREAD
        command.  The format specifies the number of fields to be read per
        record, the field width, and the placement of the decimal point (if
        none specified in the value).  The read operation follows the available
        FORTRAN FORMAT conventions of the system (see your system FORTRAN
        manual).  Any standard FORTRAN real format (such as (4F6.0),
        (E10.3,2X,D8.2), etc.) or alphanumeric format (A) may be used.
        Alphanumeric strings are limited to a maximum of 8 characters for any
        field (A8). For storage of string arrays greater than 8 characters, the
        *SREAD command can be used. Integer (I) and list-directed (*)
        descriptors may not be used.  The parentheses must be included in the
        format and the format must not exceed 80 characters (including
        parentheses).  The input line length is limited to 128 characters.

        A starting array element number must be defined for the result array
        parameter vector (numeric or character).  For example, entering these
        two lines:

        will read two values from each line of file ARRAYVAL and assign the
        values to A(1), A(2), A(3), etc.  Reading continues until successive
        row elements [*VLEN, *VMASK, *DIM] are filled.

        For an array parameter matrix, a starting array element row and column
        number must be defined.  For example, entering these two lines:

        will read two values from each line of file ARRAYVAL and assign the
        values to A(1,1), A(2,1), A(3,1), etc.  Reading continues until n1 (10)
        successive row elements are filled.  Once the maximum row number is
        reached, subsequent data will be read into the next column (e.g.,
        A(1,2), A(2,2), A(3,2), etc.)

        For numerical parameters, absolute values and scale factors may be
        applied to the result parameter [*VABS, *VFACT].  Results may be
        cumulative [*VCUM].  See the *VOPER command for details.  If you are in
        the GUI the *VREAD command must be contained in an externally prepared
        file read into the ANSYS program (i.e., *USE, /INPUT, etc.).

        This command is not applicable to 4- or 5-D arrays.

        This command is valid in any processor.
        """
        command = "*VREAD,%s,%s,%s,%s,%s,%s,%s,%s" % (str(parr), str(fname), str(ext), str(label), str(n1), str(n2), str(n3), str(nskip))
        return self.run(command, **kwargs)

    def mat(self, mat="", **kwargs):
        """APDL Command: MAT

        Sets the element material attribute pointer.

        Parameters
        ----------
        mat
            Assign this material number to subsequently defined elements
            (defaults to 1).

        Notes
        -----
        Identifies the material number to be assigned to subsequently defined
        elements.  This number refers to the material number (MAT) defined with
        the material properties [MP].  Material numbers may be displayed
        [/PNUM].
        """
        command = "MAT,%s" % (str(mat))
        return self.run(command, **kwargs)

    def dj(self, elem="", label="", value="", **kwargs):
        """APDL Command: DJ

        Specifies boundary conditions on the components of relative motion of a
        joint element.

        Parameters
        ----------
        elem
            Element number or ALL to be specified.

        label
            Valid labels are:

            UX - Displacement in local x direction.

            UY - Displacement in local y direction.

            UZ - Displacement in local z direction.

            ROTX - Rotation about local x axis.

            ROTY - Rotation about local y axis.

            ROTZ - Rotation about local y axis.

            VELX - Linear velocity in local x direction.

            VELY - Linear velocity in local y direction.

            VELZ - Linear velocity in local z direction.

            OMGX - Angular velocity in local x direction.

            OMGY - Angular velocity in local y direction.

            OMGZ - Angular velocity in local z direction.

            ACCX - Linear acceleration in local x direction.

            ACCY - Linear acceleration in local y direction.

            ACCZ - Linear acceleration in local z direction.

            DMGX - Angular acceleration in local x direction.

            DMGY - Angular acceleration in local y direction.

            DMGZ - Angular acceleration in local z direction.

        value
            Value of the label.

        Notes
        -----
        This command is valid for MPC184 joint elements. See DJDELE for
        information on deleting boundary conditions applied with the DJ
        command.

        You can apply only one displacement, velocity, or acceleration load at
        any relative degree of freedom. If multiple loads are specified, the
        last applied load overrides the previous ones. For example, the
        following commands apply loads to element 100:

        In this case, the velocity load (VELX) applied in the last command will
        override the displacement load (UX).

        Tabular boundary conditions (VALUE = %tabname%) can be used.

        %_FIX% is an ANSYS reserved table name. When VALUE is set to %_FIX%,
        ANSYS will prescribe the degree of freedom to the “current” relative
        displacement value. This option is only valid for the following labels:
        UX, UY, UZ, ROTX, ROTY, ROTZ. In most cases, %_FIX% usage is efficient
        and recommended for all structural degrees of freedom.
        """
        command = "DJ,%s,%s,%s" % (str(elem), str(label), str(value))
        return self.run(command, **kwargs)

    def plzz(self, rotvel="", deltarotvel="", **kwargs):
        """APDL Command: PLZZ

        Plots the interference diagram from a cyclic modal analysis.

        Parameters
        ----------
        rotvel
            Rotational speed in revolutions per minute (RPM) used to define the
            speed line. If blank, use the rotational speed (from OMEGA)
            specified in the prestressing step of the linear perturbation
            analysis. If explicitly input as 0, or if the linear perturbation
            was not used, no speed lines are plotted.

        deltarotvel
            Adds speed lines about the RotVel speed line corresponding to
            RotVel ± DeltaRotVel. Only plotted if RotVel is known.

        Notes
        -----
        PLZZ plots the cyclic modal frequencies as points on a frequency vs.
        harmonic index (nodal diameter) graph. If rotational speed (RotVel) is
        provided, the speed line is also plotted, leading to the interference
        diagram (also known as the SAFE or ZZENF diagram). If DeltaRotVel is
        also provided, two additional speed lines are plotted, enveloping the
        safe speed line itself.

        For more information, see Postprocessing a Modal Cyclic Symmetry
        Analysis in the Cyclic Symmetry Analysis Guide.
        """
        command = "PLZZ,%s,%s" % (str(rotvel), str(deltarotvel))
        return self.run(command, **kwargs)

    def ftran(self, **kwargs):
        """APDL Command: FTRAN

        Transfers solid model forces to the finite element model.

        Notes
        -----
        Forces are transferred only from selected keypoints to selected nodes.
        The FTRAN operation is also done if the SBCTRAN command is issued or
        automatically done upon initiation of the solution calculations
        [SOLVE].

        This command is also valid in PREP7.
        """
        command = "FTRAN," % ()
        return self.run(command, **kwargs)

    def exunit(self, ldtype="", load="", untype="", name="", **kwargs):
        """APDL Command: EXUNIT

        Specifies the interface load unit labels to be written to the export
        file for ANSYS to CFX transfer.

        Parameters
        ----------
        ldtype
            Load type:

            SURF  - Surface load.

            VOLU  - Volumetric load.

        load
            Surface loads:

            DISP  -  Displacement in a static analysis. Mode shape in a modal analysis.

            TIME  - Time. The unit for frequency is the inverse of the unit for time.

            MASS  -  Mass.

            TEMP  - Temperature.

            HFLU  - Heat flux.

        untype
            Unit type:

            COMM  - Predefined unit

            USER  - User-specified unit

        name
            Commonly used predefined unit name or user-specified unit name.

            SI - International System of units (meter-kilogram-second) (default)

            FT -  English System of units (feet-pound-second)

        Notes
        -----
        This command only specifies which unit labels are to be written to the
        file when the EXPROFILE is issued. It does not perform unit
        conversions.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EXUNIT,%s,%s,%s,%s" % (str(ldtype), str(load), str(untype), str(name))
        return self.run(command, **kwargs)

    def amap(self, area="", kp1="", kp2="", kp3="", kp4="", **kwargs):
        """APDL Command: AMAP

        Generates a 2-D mapped mesh based on specified area corners.

        Parameters
        ----------
        area
            Area number of area to be meshed.  If AREA = P, graphical picking
            is enabled and all remaining arguments are ignored (valid only in
            the GUI).

        kp1, kp2, kp3, kp4
            Keypoints defining corners of the mapped mesh.  Three or four
            corners may be specified, and may be input in any order.

        Notes
        -----
        Only one area at a time can be meshed with this command.  The program
        internally concatenates all lines between the specified keypoints, then
        meshes the area with all quadrilateral elements.  If line divisions are
        set, the mesh will follow the rules for mapped meshing (see Meshing
        Your Solid Model in the Modeling and Meshing Guide).

        If the area being meshed has concatenated lines, the program will ask
        if those concatenations should be removed (in batch, the concatenations
        will automatically be removed).  Nodes required for the generated
        elements are created and assigned the lowest available node numbers.
        If a mapped mesh is not possible due to mismatched line divisions or
        poor element shapes, the meshing operation is aborted.
        """
        command = "AMAP,%s,%s,%s,%s,%s" % (str(area), str(kp1), str(kp2), str(kp3), str(kp4))
        return self.run(command, **kwargs)

    def cswpla(self, kcn="", kcs="", par1="", par2="", **kwargs):
        """APDL Command: CSWPLA

        Defines a local coordinate system at the origin of the working plane.

        Parameters
        ----------
        kcn
            Arbitrary reference number assigned to this coordinate system.
            Must be greater than 10.  A coordinate system previously defined
            with this number will be redefined.

        kcs
            Coordinate system type:

            0 or CART - Cartesian

            1 or CYLIN - Cylindrical (circular or elliptical)

            2 or SPHE - Spherical (or spheroidal)

            3 or TORO - Toroidal

        par1
            Used for elliptical, spheroidal, or toroidal systems.  If KCS = 1
            or 2, PAR1 is the ratio of the ellipse Y-axis radius to X-axis
            radius (defaults to 1.0 (circle)).  If KCS = 3, PAR1 is the major
            radius of the torus.

        par2
            Used for spheroidal systems.  If KCS = 2, PAR2 = ratio of ellipse
            Z-axis radius to X-axis radius (defaults to 1.0 (circle)).

        Notes
        -----
        Defines and activates a local right-handed coordinate system centered
        at the origin of the working plane.  The coordinate system's local x-y
        plane (for a Cartesian system) or R-θ plane (for a cylindrical or
        spherical system) corresponds to the working plane.  This local system
        becomes the active coordinate system.  See the CS, LOCAL, CLOCAL, and
        CSKP commands for alternate ways to define a local coordinate system.
        Local coordinate systems may be displayed with the /PSYMB command.

        This command is valid in any processor.
        """
        command = "CSWPLA,%s,%s,%s,%s" % (str(kcn), str(kcs), str(par1), str(par2))
        return self.run(command, **kwargs)

    def seopt(self, sename="", sematr="", sepr="", sesst="", expmth="",
              seoclvl="", **kwargs):
        """APDL Command: SEOPT

        Specifies substructure analysis options.

        Parameters
        ----------
        sename
            The name (case-sensitive, thirty-two character maximum) assigned to
            the superelement matrix file. The matrix file will be named
            Sename.SUB. This field defaults to Fname on the /FILNAME command.

        sematr
            Matrix generation key:

            1 - Generate stiffness (or conductivity) matrix (default).

            2 - Generate stiffness and mass (or conductivity and specific heat) matrices.

            3 - Generate stiffness, mass and damping matrices.

        sepr
            Print key:

            0 - Do not print superelement matrices or load vectors.

            1 - Print both load vectors and superelement matrices.

            2 - Print load vectors but not matrices.

        sesst
            Stress stiffening key:

            0 - Do not save space for stress stiffening in a later run.

            1 - Save space for the stress stiffening matrix (calculated in a subsequent
                generation run after the expansion pass).

        expmth
            Expansion method for expansion pass:

            BACKSUB - Save necessary factorized matrix files for backsubstitution during subsequent
                      expansion passes (default). This normally results in a
                      large usage of disk space

            RESOLVE - Do not save factorized matrix files. Global stiffness matrix will be reformed
                      during expansion pass. This option provides an effective
                      way to save disk space usage. This option cannot be used
                      if the use pass uses large deflections (NLGEOM,ON).

        seoclvl
            For the added-mass calculation, the ocean level to use when ocean
            waves (OCTYPE,,WAVE) are present:

            ATP - The ocean level at this point in time (default).

            MSL - The mean ocean level.

        Notes
        -----
        The SEOPT command specifies substructure analysis options
        (ANTYPE,SUBSTR).  If used during solution, the command is valid only
        within the first load step.

        When ocean waves (OCTYPE,,WAVE) are present, the SeOcLvL argument
        specifies the ocean height or level to use for the added-mass
        calculation, as the use-run analysis type is unknown during the
        generation run.

        The expansion pass method RESOLVE is not supported with component mode
        synthesis analysis (CMSOPT). ExpMth is automatically set to BACKSUB for
        CMS analysis. The RESOLVE method invalidates the use of the NUMEXP
        command. The RESOLVE method does not allow the computation of results
        based on nodal velocity and nodal acceleration (damping force, inertial
        force, kinetic energy, etc.) in the substructure expansion pass.

        This command is also valid in PREP7.
        """
        command = "SEOPT,%s,%s,%s,%s,%s,%s" % (str(sename), str(sematr), str(sepr), str(sesst), str(expmth), str(seoclvl))
        return self.run(command, **kwargs)

    def eresx(self, key="", **kwargs):
        """APDL Command: ERESX

        Specifies extrapolation of integration point results.

        Parameters
        ----------
        key
            Extrapolation key:

            DEFA - If element is fully elastic (no active plasticity, creep, or swelling
                   nonlinearities), extrapolate the integration point results
                   to the nodes.  If any portion of the element is plastic (or
                   other active material nonlinearity), copy the integration
                   point results to the nodes (default).

            YES - Extrapolate the linear portion of the integration point results to the nodes
                  and copy the nonlinear portion (for example, plastic
                  strains).

            NO - Copy the integration point results to the nodes.

        Notes
        -----
        Specifies whether the solution results at the element integration
        points are extrapolated or copied to the nodes for element and nodal
        postprocessing. The structural stresses, elastic and thermal strains,
        field gradients, and fluxes are affected.  Nonlinear data (plastic,
        creep, and swelling strains) are always copied to the nodes, never
        extrapolated. For shell elements, ERESX applies only to integration
        point results in the in-plane directions.

        This command is also valid in PREP7.
        """
        command = "ERESX,%s" % (str(key))
        return self.run(command, **kwargs)

    def vatt(self, mat="", real="", type="", esys="", secnum="", **kwargs):
        """APDL Command: VATT

        Associates element attributes with the selected, unmeshed volumes.

        Parameters
        ----------
        mat, real, type, esys, secnum
            Material number, real constant set number, type number, coordinate
            system number, and section number to be associated with selected,
            unmeshed volumes.

        Notes
        -----
        These element attributes will be used when the volumes are meshed.  If
        a volume does not have attributes associated with it (by this command)
        at the time it is meshed, the attributes are obtained from the then
        current MAT, REAL, TYPE, ESYS, and SECNUM command settings.  Reissue
        the VATT command (before volumes are meshed) to change the attributes.
        A zero (or blank) argument removes the corresponding association.

        If any of the arguments MAT, REAL, TYPE, ESYS or SECNUM are defined as
        -1, then that value will be left unchanged in the selected set.

        In some cases, ANSYS can proceed with a volume meshing operation even
        when no logical element type has been assigned via VATT,,,TYPE or TYPE.
        For more information, see the discussion on setting element attributes
        in Meshing Your Solid Model of the Modeling and Meshing Guide.
        """
        command = "VATT,%s,%s,%s,%s,%s" % (str(mat), str(real), str(type), str(esys), str(secnum))
        return self.run(command, **kwargs)

    def edrd(self, option="", part="", mrb="", **kwargs):
        """APDL Command: EDRD

        Switches a part from deformable to rigid or from rigid to deformable in
        an explicit dynamic analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed.

            D2R - Change specified part from deformable to rigid (default).

            R2D - Change specified part from rigid to deformable. Use this option to switch a
                  part back to a deformable state after it has been changed to
                  rigid using EDRD,D2R.

            LIST - List parts that are flagged to change from deformable to rigid or rigid to
                   deformable.

        part
            Part number for part to be changed (no default).

        mrb
            Part number of the master rigid body to which the part is merged.
            MRB is used only if Option = D2R. If MRB = 0 (which is the
            default), the part becomes an independent rigid body.

        Notes
        -----
        This command is valid in a new explicit dynamic analysis or in a
        restart. It is only possible to switch parts (D2R or R2D) in a restart
        if part switching is first activated in the original analysis. If part
        switching is not required in the original analysis but will be used in
        the restart, you must issue EDRD,D2R with no further arguments in the
        original analysis. You can use the EDRI command to define inertia
        properties for newly created rigid bodies (D2R).

        Parts that are defined as rigid using EDMP,RIGID are permanently rigid
        and cannot be changed to deformable.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDRD,%s,%s,%s" % (str(option), str(part), str(mrb))
        return self.run(command, **kwargs)

    def tread(self, par="", fname="", ext="", nskip="", **kwargs):
        """APDL Command: *TREAD

        Reads data from an external file into a table array parameter.

        Parameters
        ----------
        par
            Table array parameter name as defined by the *DIM command.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        nskip
            Number of comment lines at the beginning of the file being read
            that will be skipped during the reading.  Default = 0.

        Notes
        -----
        Use this command to read in a table of data from an external file into
        an ANSYS table array parameter.  The external file may be created using
        a text editor or by an external application or program.  The external
        file must be in tab-delimited, blank-delimited, or comma-delimited
        format to be used by *TREAD. The ANSYS TABLE type array parameter must
        be defined before you can read in an external file.  See *DIM  for more
        information.

        This command is not applicable to 4- or 5-D tables.
        """
        command = "*TREAD,%s,%s,%s,%s" % (str(par), str(fname), str(ext), str(nskip))
        return self.run(command, **kwargs)

    def tbin(self, oper="", par1="", par2="", par3="", par4="", **kwargs):
        """APDL Command: TBIN

        Sets parameters used for interpolation of the material data tables.

        Parameters
        ----------
        oper
            Operation to perform:

            Operation to perform: - SCALE

        par1
            Independent variable, which can be any field variable specified via
            the TBFIELD command.

        par2
            Index of any material parameter specified via the TBDATA command.

        par3
            Scale to be used for the independent variable. Valid options are
            LINEAR (linear) or LOG (logarithmic).

        par4
            Scale to be used for the dependent variable (the material parameter
            specified via Par2). Valid options are LINEAR (linear) or LOG
            (logarithmic).

        Notes
        -----
        For a list of the supported material data tables (TB), see Logarithmic
        Interpolation and Scaling in the Material Reference.
        """
        command = "TBIN,%s,%s,%s,%s,%s" % (str(oper), str(par1), str(par2), str(par3), str(par4))
        return self.run(command, **kwargs)

    def erefine(self, ne1="", ne2="", ninc="", level="", depth="", post="",
                retain="", **kwargs):
        """APDL Command: EREFINE

        Refines the mesh around specified elements.

        Parameters
        ----------
        ne1, ne2, ninc
            Elements (NE1 to NE2 in increments of NINC) around which the mesh
            is to be refined. NE2 defaults to NE1, and NINC defaults to 1. If
            NE1 = ALL, NE2 and NINC are ignored and all selected elements are
            used for refinement. If NE1 = P, graphical picking is enabled and
            all remaining command fields are ignored (valid only in the GUI). A
            component name may also be substituted for NE1 (NE2 and NINC are
            ignored).

        level
            Amount of refinement to be done. Specify the value of LEVEL as an
            integer from 1 to 5, where a value of 1 provides minimal
            refinement, and a value of 5 provides maximum refinement (defaults
            to 1).

        depth
            Depth of mesh refinement in terms of number of elements outward
            from the indicated elements, NE1 to NE2 (defaults to 0).

        post
            Type of postprocessing to be done after element splitting, in order
            to improve element quality:

            OFF - No postprocessing will be done.

            SMOOTH - Smoothing will be done. Node locations may change.

            CLEAN - Smoothing and cleanup will be done. Existing elements may be deleted, and node
                    locations may change (default).

        retain
            Flag indicating whether quadrilateral elements must be retained in
            the refinement of an all-quadrilateral mesh. (The ANSYS program
            ignores the RETAIN argument when you are refining anything other
            than a quadrilateral mesh.)

            ON - The final mesh will be composed entirely of quadrilateral elements, regardless
                 of the element quality (default).

            OFF - The final mesh may include some triangular elements in order to maintain
                  element quality and provide transitioning.

        Notes
        -----
        EREFINE performs local mesh refinement around the specified elements.
        By default, the surrounding elements are split to create new elements
        with 1/2 the edge length of the original elements (LEVEL = 1).

        EREFINE refines all area elements and tetrahedral volume elements that
        are adjacent to the specified elements. Any volume elements that are
        adjacent to the specified elements, but are not tetrahedra (for
        example, hexahedra, wedges, and pyramids), are not refined.

        You cannot use mesh refinement on a solid model that contains initial
        conditions at nodes [IC], coupled nodes [CP family of commands],
        constraint equations [CE family of commands], or boundary conditions or
        loads applied directly to any of its nodes or elements. This applies to
        nodes and elements anywhere in the model, not just in the region where
        you want to request mesh refinement.   If you have detached the mesh
        from the solid model, you must disable postprocessing cleanup or
        smoothing (POST = OFF) after the refinement to preserve the element
        attributes.

        For additional restrictions on mesh refinement, see Revising Your Model
        in the Modeling and Meshing Guide.

        This command is also valid for rezoning.
        """
        command = "EREFINE,%s,%s,%s,%s,%s,%s,%s" % (str(ne1), str(ne2), str(ninc), str(level), str(depth), str(post), str(retain))
        return self.run(command, **kwargs)

    def outres(self, item="", freq="", cname="", nsvar="", dsubres="",
               **kwargs):
        """APDL Command: OUTRES

        Controls the solution data written to the database.

        Parameters
        ----------
        item
            Results item for database and file write control:

            ALL - All solution items except LOCI and SVAR. This behavior is the default.

            CINT - All available results generated by the CINT command

            ERASE - Resets OUTRES specifications to their default values.

            STAT - Lists the current OUTRES specifications.

            BASIC - Write only NSOL, RSOL, NLOAD, STRS, FGRAD, and FFLUX records to the results
                    file and database.

            NSOL - Nodal DOF solution.

            RSOL - Nodal reaction loads.

            V - Nodal velocity (applicable to structural full transient analysis only
                (ANTYPE,TRANS)).

            A - Nodal acceleration (applicable to structural full transient analysis only
                (ANTYPE,TRANS)).

            ESOL - Element solution (includes all items following):

            NLOAD - Element nodal, input constraint, and force loads (also used with the /POST1
                    commands PRRFOR, NFORCE, and FSUM to calculate reaction
                    loads).

            STRS - Element nodal stresses.

            EPEL - Element elastic strains.

            EPTH - Element thermal, initial, and swelling strains.

            EPPL - Element plastic strains.

            EPCR - Element creep strains.

            EPDI - Element diffusion strains.

            FGRAD - Element nodal gradients.

            FFLUX - Element nodal fluxes.

            LOCI - Integration point locations.

            SVAR - State variables (used only by UserMat).

            MISC - Element miscellaneous data (SMISC and NMISC items of the ETABLE command).

        freq
            Specifies how often (that is, at which substeps) to write the
            specified solution results item. The following values are valid:

        cname
            The name of the component, created with the CM command, defining
            the selected set of elements or nodes for which this specification
            is active.  If blank, the set is all entities.  A component name is
            not allowed with the ALL, BASIC, or RSOL items.

        --
            Reserved for future use.

        nsvar
            The number of user-defined state variables (TB,STATE) to be written
            to the results file. Valid only when Item = SVAR and user-defined
            state variables exist. The specified value cannot exceed the total
            number of state variables defined; if no value is specified, all
            user-defined state variables are written to the results file. This
            argument acts on all sets of user-defined state variables that
            exist for the model.

        dsubres
            Specifies whether to write additional results in Jobname.DSUB
            during a substructure or CMS use pass in transient or harmonic
            analysis.

            Blank - Write the nodal DOF solution in Jobname.DSUB (default).

            ALL - In addition to the nodal DOF solution, also write necessary data to compute
                  quantities using nodal velocity and nodal acceleration
                  (damping force, inertial force, kinetic energy, etc.) in the
                  subsequent expansion pass. For more information, see Step 3:
                  Expansion Pass in the Substructuring Analysis Guide.

        Notes
        -----
        The OUTRES command allows you to specify the following:

        The solution item (Item) to write to the database (and to the reduced
        displacement and results files)

        The frequency (Freq) at which the solution item is written (applicable
        to static, transient, or full harmonic analyses)

        The set of elements or nodes (Cname) to which your specification
        applies.
        """
        command = "OUTRES,%s,%s,%s,%s,%s" % (str(item), str(freq), str(cname), str(nsvar), str(dsubres))
        return self.run(command, **kwargs)

    def lnsrch(self, key="", **kwargs):
        """APDL Command: LNSRCH

        Activates a line search to be used with Newton-Raphson.

        Parameters
        ----------
        key
            Line search key:

            OFF - Do not use a line search.

            ON - Use a line search.  Note, adaptive descent is suppressed when LNSRCH is on
                 unless explicitly requested on the NROPT command.   Having
                 line search on and adaptive descent on at the same time is not
                 recommended.

            AUTO - The program automatically switches line searching ON and OFF between substeps
                   of a load step as needed.  This option is recommended.

        Notes
        -----
        Activates a line search to be used with the Newton-Raphson method
        [NROPT].  Line search is an alternative to adaptive descent (see Line
        Search in the Mechanical APDL Theory Reference).

        LNSRCH,AUTO can be very efficient for problems in which LNSRCH is
        needed at only certain substeps.

        You cannot use line search [LNSRCH], automatic time stepping [AUTOTS],
        or the DOF solution predictor [PRED] with the arc-length method
        [ARCLEN, ARCTRM]. If you activate the arc-length method after you set
        LNSRCH, AUTOTS, or PRED, a warning message appears. If you choose to
        proceed with the arc-length method, the program disables your line
        search, automatic time stepping, and DOF predictor settings, and the
        time step size is controlled by the arc-length method internally.

        This command is also valid in PREP7.
        """
        command = "LNSRCH,%s" % (str(key))
        return self.run(command, **kwargs)

    def ugin(self, name="", extension="", path="", entity="", layer="", fmt="",
             **kwargs):
        """APDL Command: ~UGIN

        Transfers an NX part into the ANSYS program.

        Parameters
        ----------
        name
            The file name of the NX part to be imported, which cannot exceed 64
            characters in length. The path name must begin with an alphanumeric
            character. Special characters such as &, -,  and * are not
            permitted in the part name.

        extension
            The NX part file extension. The default is .prt.

        path
            The full path name to the directory containing the part, enclosed
            in single quotes; for example, '/ug_parts'. The default is the
            current working directory.

        entity
            Entity to be imported.

            0 or Solid - Solids only, imported as ANSYS volumes (the default).

            1 or Surface - Surfaces only, imported as ANSYS areas.

            2 or Wireframe - Wireframe only, imported as ANSYS lines.

            3 or All - All entities. Use this option when the part contains entities that may not be
                       attached to each other, such as a solid in one location
                       and a surface in another.

        layer
            The number(s) assigned to the layer(s) to be imported. You can
            import one layer or a range of layers (designated by hyphens).
            Defaults to 1-256 (all layers).

        fmt
            The format in which ANSYS will store the model.

            0 - Neutral format (default). Defeaturing after import is restricted.

            1 - Solid format; this allows defeaturing after import.

        Notes
        -----
        More information on importing NX parts is available in UG/NX in the
        Connection User's Guide.
        """
        command = "~UGIN,%s,%s,%s,%s,%s,%s" % (str(name), str(extension), str(path), str(entity), str(layer), str(fmt))
        return self.run(command, **kwargs)

    def edbx(self, option="", boxid="", xmin="", xmax="", ymin="", ymax="",
             zmin="", zmax="", **kwargs):
        """APDL Command: EDBX

        Creates a box shaped volume to be used in a contact definition for
        explicit dynamics.

        Parameters
        ----------
        option
            Label identifying the contact box definition option to be
            performed.

            ADD - Adds a contact box definition (default).

            DELETE - Deletes a contact box definition.

            LIST - Lists each box ID number, and the coordinates that make up each box shaped
                   volume.

        boxid
            User defined list ID number.

        xmin
            Minimum x-coordinate.

        xmax
            Maximum x-coordinate.

        ymin
            Minimum y-coordinate.

        ymax
            Maximum y-coordinate.

        zmin
            Minimum z-coordinate.

        zmax
            Maximum z-coordinate.

        Notes
        -----
        The ANSYS LS-DYNA command EDCGEN allows you to define contact and
        target volumes using box ID numbers BOXID1 and BOXID2, respectively. If
        you use these arguments to define contact volumes, you must first
        define their coordinates using the EDBX command.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDBX,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(boxid), str(xmin), str(xmax), str(ymin), str(ymax), str(zmin), str(zmax))
        return self.run(command, **kwargs)

    def fcum(self, oper="", rfact="", ifact="", **kwargs):
        """APDL Command: FCUM

        Specifies that force loads are to be accumulated.

        Parameters
        ----------
        oper
            Accumulation key:

            REPL - Subsequent values replace the previous values (default).

            ADD - Subsequent values are added to the previous values.

            IGNO - Subsequent values are ignored.

        rfact
            Scale factor for the real component.  Zero (or blank) defaults to
            1.0.  Use a small number for a zero scale factor.

        ifact
            Scale factor for the imaginary component.  Zero (or blank) defaults
            to 1.0.  Use a small number for a zero scale factor.

        Notes
        -----
        Allows repeated force load (force, heat flow, etc.) values to be
        replaced, added, or ignored.  Operations apply to the selected nodes
        [NSEL]. and the force labels corresponding to the selected force labels
        [DOFSEL].  The operations occur when the next force specifications are
        defined.  For example, issuing the command F,1,FX,250 after a previous
        F,1,FX,200 causes the current value of the force on node 1 in the
        x-direction to be 450 with the add operation, 250 with the replace
        operation, or 200 with the ignore operation.  Scale factors are also
        available to multiply the next value before the add or replace
        operation.  A scale factor of 2.0 with the previous "add" example
        results in a force of 700.  Scale factors are applied even if no
        previous values exist.  Issue FCUM,STAT to show the current label,
        operation, and scale factors.  Solid model boundary conditions are not
        affected by this command, but boundary conditions on the FE model are
        affected.

        Note:: : FE boundary conditions may still be overwritten by existing
        solid model boundary conditions if a subsequent boundary condition
        transfer occurs.

        FCUM does not work for tabular boundary conditions.

        This command is also valid in PREP7.
        """
        command = "FCUM,%s,%s,%s" % (str(oper), str(rfact), str(ifact))
        return self.run(command, **kwargs)

    def realvar(self, ir="", ia="", name="", facta="", **kwargs):
        """APDL Command: REALVAR

        Forms a variable using only the real part of a complex variable.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        ia
            Reference number of the variable to be operated on.

        --, --
            Unused fields.

        name
            Thirty-two character name identifying the variable on printouts and
            displays.  Embedded blanks are compressed for output.

        --, --
            Unused fields.

        facta
            Scaling factor (positive or negative) applied to variable IA
            (defaults to 1.0).

        Notes
        -----
        Forms a variable using only the real part of a variable.  Used only
        with harmonic analyses (ANTYPE,HARMIC).

        Complex variables are stored in two-column arrays with the real
        component stored in the first column and the imaginary component stored
        in the second column.  This command extracts the value stored in the
        first column (i.e., real component).  However with harmonic analyses,
        all variables are stored in two-column arrays as complex variables.  If
        the variable is not complex, then the same value is stored in both
        columns.  This command will extract the variable in the first column of
        the array, even if this variable is not the real component of a complex
        variable.
        """
        command = "REALVAR,%s,%s,%s,%s" % (str(ir), str(ia), str(name), str(facta))
        return self.run(command, **kwargs)

    def cpngen(self, nset="", lab="", node1="", node2="", ninc="", **kwargs):
        """APDL Command: CPNGEN

        Defines, modifies, or adds to a set of coupled degrees of freedom.

        Parameters
        ----------
        nset
            Set reference number [CP].

        lab
            Degree of freedom label [CP].

        node1, node2, ninc
            Include in coupled set nodes NODE1 to NODE2 in steps of NINC
            (defaults to 1).  If NODE1 = P, graphical picking is enabled and
            all remaining command fields are ignored (valid only in the GUI).
            If -NODE1, delete range of nodes from set instead of including.  A
            component name may also be substituted for NODE1 (NODE2 and NINC
            are ignored).

        Notes
        -----
        Defines, modifies, or adds to a set of coupled degrees of freedom.  May
        be used in combination with (or in place of) the CP command.  Repeat
        CPNGEN command for additional nodes.
        """
        command = "CPNGEN,%s,%s,%s,%s,%s" % (str(nset), str(lab), str(node1), str(node2), str(ninc))
        return self.run(command, **kwargs)

    def flist(self, node1="", node2="", ninc="", **kwargs):
        """APDL Command: FLIST

        Lists force loads on the nodes.

        Parameters
        ----------
        node1, node2, ninc
            List forces for nodes NODE1 to NODE2 (defaults to NODE1) in steps
            of NINC (defaults to 1).  If ALL, list for all selected nodes
            [NSEL] and NODE2 and NINC  are ignored (default).  If NODE1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NODE1.

        Notes
        -----
        Listing applies to the selected nodes [NSEL] and the selected force
        labels [DOFSEL].

        Caution:: : A list containing a node number that is larger than the
        maximum defined node (NODE2), could deplete the system memory and
        produce unpredictable results.

        This command is valid in any processor.
        """
        command = "FLIST,%s,%s,%s" % (str(node1), str(node2), str(ninc))
        return self.run(command, **kwargs)

    def extrem(self, nvar1="", nvar2="", ninc="", **kwargs):
        """APDL Command: EXTREM

        Lists the extreme values for variables.

        Parameters
        ----------
        nvar1, nvar2, ninc
            List extremes for variables NVAR1 through NVAR2 in steps of NINC.
            Variable range defaults to its maximum. NINC defaults to 1.

        Notes
        -----
        Lists the extreme values (and the corresponding times) for stored and
        calculated variables. Extremes for stored variables are automatically
        listed as they are stored. Only the real part of a complex number is
        used. Extreme values may also be assigned to parameters [*GET].
        """
        command = "EXTREM,%s,%s,%s" % (str(nvar1), str(nvar2), str(ninc))
        return self.run(command, **kwargs)

    def plst(self, fname="", ext="", parmplot="", mslvstep="", **kwargs):
        """APDL Command: PLST

        Plots sound power parameters vs. frequency, or postprocesses results
        for a random acoustics analysis with diffuse sound field.

        Parameters
        ----------
        fname
            File name and directory path of a sound power data file (248
            characters maximum, including the characters needed for the
            directory path). The sound power data file is created via the
            SPOWER command macro. An unspecified directory path defaults to the
            working directory; in this case, you can use all 248 characters for
            the file name. When postprocessing a random acoustics analysis, a
            file named Fname is generated if no file already exists.

        ext
            Extension of the sound power data file (.anp where n is the number
            of ports), or the random acoustics data file.  When postprocessing
            a random acoustics analysis, an extension named Ext is assigned if
            no extension already exists.

        parmplot
            Specified parameter to plot:

            LWIN  - Input sound power level (default)

            LWOUT  - Output sound power level at driven port

            RL - Return loss

            ALPHA - Absorption coefficient

            TL  - Transmission loss

            DFSTL   - Transmission loss of random acoustics analysis

            DFSPW - Radiated power in random acoustics analysis

        mslvstep
            Solution step (load step) of a random acoustics analysis (MSOLVE):

            0  - Average result of multiple samplings (default)

            > 0 - Result at the specified solution step (load step)

            ALL  - Average of all solution step (load step) results

        Notes
        -----
        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "PLST,%s,%s,%s,%s" % (str(fname), str(ext), str(parmplot), str(mslvstep))
        return self.run(command, **kwargs)

    def edshell(self, wpan="", shnu="", shtc="", wpbt="", shpl="", itrst="",
                **kwargs):
        """APDL Command: EDSHELL

        Specifies shell computation controls for an explicit dynamics analysis.

        Parameters
        ----------
        wpan
            Maximum shell element warpage angle in degrees. Defaults to 20.

        shnu
            Hughes-Liu shell normal update option:

            -2 - Unique nodal fibers. This option is required for SHELL163 (KEYOPT(1) = 1, 6, or
                 7) if the real constant NLOC = 1 or -1.

            -1 - Compute normals each cycle (default). This option is recommended.

            1 - Compute on restarts.

            n - Compute every nth substep.

        shtc
            Shell thickness change option:

            0 - No change.

            1 - Membrane straining causes thickness change. Important in sheet metal forming
                (default).

        wpbt
            Warping stiffness option for Belytschko-Tsay shells:

            1 - Belytschko-Wong-Chiang warping stiffness added. This option is recommended.

            2 - Belytschko-Tsay warping stiffness (default).

        shpl
            Shell plasticity option. This option is only valid for these
            material models: strain rate independent plastic kinematic, strain
            rate dependent plasticity, power law plasticity, and piecewise
            linear plasticity.

            1 - Iterative plasticity with 3 secant iterations (default).

            2 - Full iterative plasticity.

            3 - Radial return noniterative plasticity. (Use this option with caution; it may
                lead to inaccurate results.)

        itrst
            Triangular shell sorting option. If sorting is on, degenerate
            quadrilateral shell elements are treated as triangular shells.

            1 - Full sorting (default).

            2 - No sorting.

        Notes
        -----
        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDSHELL,%s,%s,%s,%s,%s,%s" % (str(wpan), str(shnu), str(shtc), str(wpbt), str(shpl), str(itrst))
        return self.run(command, **kwargs)

    def bfedele(self, elem="", lab="", **kwargs):
        """APDL Command: BFEDELE

        Deletes element body force loads.

        Parameters
        ----------
        elem
            Element at which body load is to be deleted.  If ALL, delete for
            all selected elements [  A component name may also be substituted
            for ELEM.

        lab
            Valid body load label. If ALL, use all appropriate labels. See BFE
            command for labels.

        Notes
        -----
        Deletes element body force loads for a specified element and label.
        Element body loads may be defined with the BFE commands.

        Graphical picking is available only via the listed menu paths.

        This command is also valid in PREP7.
        """
        command = "BFEDELE,%s,%s" % (str(elem), str(lab))
        return self.run(command, **kwargs)

    def secplot(self, secid="", val1="", val2="", val3="", **kwargs):
        """APDL Command: SECPLOT

        Plots the geometry of a beam, pipe, shell, or reinforcing section to
        scale.

        Parameters
        ----------
        secid
            The section ID number (as defined via the SECTYPE command).

        val1, val2, val3
            Values that control the information to be plotted. See the "Notes"
            section of this command description for more information. For
            clarity, the labels VAL1, VAL2, and VAL3 are renamed according to
            the section type.

        Notes
        -----
        The SECPLOT command is valid only for "Beams and Pipes", "Shells", and
        "Reinforcings".

        SECPLOT cannot display the plot of an ASEC (arbitrary section) subtype.

        Plots the geometry of the beam or pipe section to scale depicting the
        centroid, shear center, and origin.  SECPLOT also lists various section
        properties such as Iyy, Iyz, and Izz.

        Data to be supplied in the value fields:

        Beam or pipe section mesh display options:

        Display section outline only.

        Display beam or pipe section mesh.

        Display the section mesh with node numbers.

        Display the section mesh with cell numbers.

        Display the section mesh with material numbers and colors.

        Display the section mesh with material colors only.

        Display the section mesh with the RST node numbers. RST nodes are
        section corner nodes where results are available. This is applicable
        when the averaged results format (KEYOPT(15) = 0 for BEAM188, BEAM189,
        PIPE288, and PIPE289) is used.

        Display the section mesh with the RST cell numbers. RST cells are
        section cells where results are available. This is applicable when the
        non-averaged results format (KEYOPT(15) = 1 for BEAM188, BEAM189,
        PIPE288, and PIPE289) is used.

        Options 2 through 6 do not depict centroid and shear center, nor do
        they list section properties.

        Following is a sample section plot for the beam section type:

        Plots the layer arrangement of the shell section showing the layer
        material and orientation.

        Data to be supplied in the value fields:

        The range of layer numbers to be displayed. If LAYR1 is greater than
        LAYR2, a reversed order display is produced. Up to 20 layers may be
        displayed at the same time. LAYR1 defaults to 1. LAYR2 defaults to
        LAYR1 if LAYR1 is input or to the number of layers (or to 19+LAYR1, if
        smaller) if LAYR1 is not input.

        Following is a sample section plot for the shell section type:

        Plots the arrangement of a reinforcing section within the base element.

        Data to be supplied in the value fields:

        REINF1, REINF2 -- The numerical range of reinforcings to be displayed.
        The default REINF1 value is 1. The default REINF2 value is the number
        of reinforcings.

        OVERLAY -- The section ID of the base element within which to display
        the reinforcing section. The section appears translucent and the
        reinforcing section is solid. Valid values are:

        SOLID -- Display a translucent solid block over the reinforcing section

        SECID -- A number corresponding to a specific section ID of the base
        element.

        If no OVERLAY value is specified, ANSYS displays the reinforcing
        section only.

        Following is a sample section plot for the reinforcing section type:

        For more information about reinforcing, see the documentation for the
        SECDATA command, and the REINF264 and REINF265 elements.
        """
        command = "SECPLOT,%s,%s,%s,%s" % (str(secid), str(val1), str(val2), str(val3))
        return self.run(command, **kwargs)

    def fsdele(self, nloc="", nev="", nlod="", **kwargs):
        """APDL Command: FSDELE

        Deletes a stress condition for a fatigue location, event, and loading.

        Parameters
        ----------
        nloc
            Delete stresses associated with location NLOC.  Defaults to zero.

        nev
            Delete stresses associated with event NEV.  Defaults to zero.

        nlod
            Delete stresses associated with loading NLOD.  Defaults to zero.

        Notes
        -----
        Deletes a stress condition stored for a particular fatigue location,
        event, and loading.  Use FE command to delete all stresses for a
        particular event or FL command to delete all stresses for a particular
        location.
        """
        command = "FSDELE,%s,%s,%s" % (str(nloc), str(nev), str(nlod))
        return self.run(command, **kwargs)

    def magopt(self, value="", **kwargs):
        """APDL Command: MAGOPT

        Specifies options for a 3-D magnetostatic field analysis.

        Parameters
        ----------
        value
            Option key:

            0 - Calculate a complete H field solution in the entire domain using a single
                (reduced) potential.

            Caution:When used in problems with both current sources and iron regions, errors may result due to numerical cancellation. - 1

            Calculate and store a preliminary H field in "iron" regions (μr ≠ 1).  Requires flux-parallel boundary conditions to be specified on exterior iron boundaries.  Used in conjunction with subsequent solutions with VALUE = 2 followed by VALUE = 3.  Applicable to multiply-connected iron domain problems. - 2

            Calculate and store a preliminary H field in "air" regions (μr = 1).  The air-iron interface is appropriately treated internally by the program.  Used in conjunction with a subsequent solution with VALUE = 3.  Applicable to singly-connected iron domain problems (with subsequent solution with VALUE = 3) or to multiply-connected iron domain problems (when preceded by a solution with VALUE = 1 and followed by a solution with VALUE = 3). - 3

        Notes
        -----
        Specifies the solution sequence options for a 3-D magnetostatic field
        analysis using a scalar potential (MAG).  The solution sequence is
        determined by the nature of the problem.

        You cannot use constraint equations with Value = 1.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: The MAGOPT,3 option is not supported in
        Distributed ANSYS when the following contact elements are present in
        the model: CONTA173, CONTA174, CONTA175, CONTA176, or CONTA177.
        """
        command = "MAGOPT,%s" % (str(value))
        return self.run(command, **kwargs)

    def wprota(self, thxy="", thyz="", thzx="", **kwargs):
        """APDL Command: WPROTA

        Rotates the working plane.

        Parameters
        ----------
        thxy
            First rotation about the working plane Z axis (positive X toward
            Y).

        thyz
            Second rotation about working plane X axis (positive Y toward Z).

        thzx
            Third rotation about working plane Y axis (positive Z toward X).

        Notes
        -----
        The specified angles (in degrees) are relative to the orientation of
        the working plane.

        This command is valid in any processor.
        """
        command = "WPROTA,%s,%s,%s" % (str(thxy), str(thyz), str(thzx))
        return self.run(command, **kwargs)

    def nmodif(self, node="", x="", y="", z="", thxy="", thyz="", thzx="",
               **kwargs):
        """APDL Command: NMODIF

        Modifies an existing node.

        Parameters
        ----------
        node
            Modify coordinates of this node.  If ALL, modify coordinates of all
            selected nodes [NSEL].  If NODE = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).  A component name may also be substituted for NODE.

        x, y, z
            Replace the previous coordinate values assigned to this node with
            these corresponding coordinate values.  Values are interpreted in
            the active coordinate system (R, θ, Z for cylindrical; R, θ, Φ for
            spherical or toroidal).  Leaving any of these fields blank retains
            the previous value(s).

        thxy
            First rotation of nodal coordinate system about nodal Z (positive X
            toward Y). Leaving this field blank retains the previous value.

        thyz
            Second rotation of nodal coordinate system about nodal X (positive
            Y toward Z). Leaving this field blank retains the previous value.

        thzx
            Third rotation of nodal coordinate system about nodal Y (positive Z
            toward X). Leaving this field blank retains the previous value.

        Notes
        -----
        Modifies an existing node.  Nodal coordinate system rotation angles are
        in degrees and redefine any existing rotation angles.  Nodes can also
        be redefined with the N command.

        See the NROTAT, NANG, and NORA commands for other rotation options.

        This command is also valid in the /MAP processor.
        """
        command = "NMODIF,%s,%s,%s,%s,%s,%s,%s" % (str(node), str(x), str(y), str(z), str(thxy), str(thyz), str(thzx))
        return self.run(command, **kwargs)

    def dtran(self, **kwargs):
        """APDL Command: DTRAN

        Transfers solid model DOF constraints to the finite element model.

        Notes
        -----
        Constraints are transferred only from selected solid model entities to
        selected nodes.  The DTRAN operation is also done if the SBCTRAN
        command is issued, and is automatically done upon initiation of the
        solution calculations [SOLVE].

        This command is also valid in PREP7.
        """
        command = "DTRAN," % ()
        return self.run(command, **kwargs)

    def pddoel(self, name="", method="", vtype="", lopt="", val1="", val2="",
               val3="", val4="", val5="", **kwargs):
        """APDL Command: PDDOEL

        Defines design of experiment levels for an individual random input
        variable.

        Parameters
        ----------
        name
            Parameter name. The parameter name must have been previously
            defined as a random input variable using the PDVAR command.

        method
            Specifies the response surface method for which the levels of the
            design of experiment are to be defined. This field must not be left
            blank.

            CCD - Use the Central Composite Design method. The design experiment levels of a
                  central composite design are defined in the fields VAL1 to
                  VAL5.

            BBM - Use the Box-Behnken Matrix method. The design experiment levels of a Box-
                  Behnken Matrix design are defined in the fields VAL1 to VAL3.
                  The fields VAL4 and VAL5 are ignored

        vtype
            Specifies the type of the values of the design of experiment
            levels.

            PROB - The design of experiment levels are specified in terms of probabilities. This
                   is the default.

            PHYS - The design of experiment levels are specified in terms of physical values.

        lopt
            Specifies the type of the design of experiment levels, indicating
            if they are defined by lower and upper bound only (default) or all
            specified by the user.

            BND - You specify the lower and upper bounds for the design of experiment levels. The
                  values for intermediate levels are calculated automatically
                  at run time (default). The lower and upper levels of the
                  design of experiment itself can be specified either in terms
                  of probabilities or in terms of physical values, depending on
                  the Vtype field.

            For Lopt = BND and Method = CCD only the entries VAL1 and VAL5 are processed and they represent the lower and upper bound values of a central composite design. The intermediate levels VAL2 to VAL4 are evaluated automatically. For Lopt = BND and Method = BBM only the entries VAL1 and VAL3 are processed and they represent the lower and upper bound values of a Box-Behnken Matrix design respectively. The intermediate level VAL2 is evaluated automatically. - NOTE: The intermediate levels between the lower and upper bounds are calculated
                              so they are at equal intervals along the curve
                              (interpolated linearly in the physical space
                              whether the curve is symmetrical or not)
                              regardless of whether the lower and upper bounds
                              are specified as probabilities (Vtype = PROB) or
                              as physical values (Vtype = PHYS).

            ALL - You explicitly specify all necessary design of experiment levels. The design of
                  experiment levels can be in terms of probabilities or in
                  terms of physical values, depending on the Vtype field.

        val1, val2, val3, . . . , val5
            Values for the levels of the design of experiment for the random
            input variable Name. Must be specified in ascending order. All
            probabilities must be between 0.0 and 1.0.

        Notes
        -----
        If Vtype = PHYS, you must enter values for VAL1 through VAL3 or VAL5
        (depending on the Method and Lopt option you choose). If Vtype = PROB
        and you do not enter values, they default to the values shown below.

        For Method = CCD:

        For Method = BBM:

        See Probabilistic Design in the Advanced Analysis Guide for more
        information on the PDS methods.
        """
        command = "PDDOEL,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(name), str(method), str(vtype), str(lopt), str(val1), str(val2), str(val3), str(val4), str(val5))
        return self.run(command, **kwargs)

    def ftcalc(self, nloc="", node="", **kwargs):
        """APDL Command: FTCALC

        Performs fatigue calculations for a particular node location.

        Parameters
        ----------
        nloc
            Location number of stress conditions to be used for fatigue
            calculation.

        node
            Node number (used only for convenience if NLOC is not input).
        """
        command = "FTCALC,%s,%s" % (str(nloc), str(node))
        return self.run(command, **kwargs)

    def page(self, iline="", ichar="", bline="", bchar="", comma="", **kwargs):
        """APDL Command: /PAGE

        Defines the printout and screen page size.

        Parameters
        ----------
        iline
            Number of lines (11 minimum) per "page" or screen.  Defaults to 24.
            Applies to interactive non-GUI to the screen output only.

        ichar
            Number of characters (41 to 132) per line before wraparound.
            Defaults to 80.  Applies to interactive non-GUI to the screen
            output only.

        bline
            Number of lines (11 minimum) per page.  Defaults to 56.  Applies to
            batch mode [/BATCH], diverted [/OUTPUT], or interactive GUI [/MENU]
            output. If negative, no page headers are output.

        bchar
            Number of characters (41 to 240 (system dependent)) per line before
            wraparound.  Defaults to 132.  Applies to batch mode [/BATCH],
            diverted [/OUTPUT], or interactive GUI [/MENU] output.

        comma
            Input 1 to specify comma-separated output for node [NLIST] and
            element [ELIST] output.

        Notes
        -----
        Defines the printout page size for batch runs and the screen page size
        for interactive runs.  Applies to the POST1 PRNSOL, PRESOL, PRETAB,
        PRRSOL, and PRPATH commands.  See the /HEADER command for additional
        controls (page ejects, headers, etc.) that affect the amount of
        printout.  A blank (or out-of-range) value retains the previous
        setting.  Issue /PAGE,STAT to display the current settings.  Issue
        /PAGE,DEFA to reset the default specifications.

        This command is valid in any processor.
        """
        command = "/PAGE,%s,%s,%s,%s,%s" % (str(iline), str(ichar), str(bline), str(bchar), str(comma))
        return self.run(command, **kwargs)

    def vget(self, par="", ir="", tstrt="", kcplx="", **kwargs):
        """APDL Command: VGET

        Moves a variable into an array parameter vector.

        Parameters
        ----------
        par
            Array parameter vector in the operation.

        ir
            Reference number of the variable (1 to NV [NUMVAR]).

        tstrt
            Time (or frequency) corresponding to start of IR data.  If between
            values, the nearer value is used.

        kcplx
            Complex number key:

            0 - Use the real part of the IR data.

            1 - Use the imaginary part of the IR data.

        Notes
        -----
        Moves a variable into an array parameter vector.  The starting array
        element number must be defined.  For example, VGET,A(1),2 moves
        variable 2 (starting at time 0.0) to array parameter A.  Looping
        continues from array element A(1) with the index number incremented by
        one until the variable is filled.  The number of loops may be
        controlled with the *VLEN command (except that loop skipping (NINC) is
        not allowed).  For multi-dimensioned array parameters, only the first
        (row) subscript is incremented.
        """
        command = "VGET,%s,%s,%s,%s" % (str(par), str(ir), str(tstrt), str(kcplx))
        return self.run(command, **kwargs)

    def dval(self, b_aseid="", lab="", value="", value2="", keycal="",
             **kwargs):
        """APDL Command: DVAL

        Defines values at enforced motion base.

        Parameters
        ----------
        baseid
            The identification number of the enforced motion base (defined
            using the D command in the modal analysis).

        lab
            U

            U - Enforced displacement.

            ACC - Enforced acceleration.

        value
            The value or table name reference for tabular boundary conditions.
            To specify a table, enclose the table name in percent (%) signs
            (DVAL,BaseID,U,%tablename%). Use the *DIM command to define a
            table.

        value2
            The value of the second degree of freedom (if present). If the
            analysis type and the degree of freedom allow a complex input,
            VALUE is the real component and VALUE2 is the imaginary component.

        keycal
            Displacement result calculation key:

            ON - Calculate absolute displacement and acceleration results (default).

            OFF - Calculate relative displacement and acceleration results.

        Notes
        -----
        In a mode-superposition harmonic or transient analysis, you can apply
        enforced displacement or acceleration loads. If multiple loads are
        specified for the same base identification number (BaseID), the last
        load applied overrides the previous ones. For example, the following
        commands apply displacement to the base with identification number 1:

        In this case, the acceleration (ACC) applied in the last command will
        override the displacement (U).

        Issue LSCLEAR,LSOPT to delete DVAL command options from the database.

        For more information, see Enforced Motion Method for Mode-Superposition
        Transient and Harmonic Analyses in the Structural Analysis Guide and
        Enforced Motion Method for Transient and Harmonic Analyses in the
        Mechanical APDL Theory Reference.
        """
        command = "DVAL,%s,%s,%s,%s,%s" % (str(b_aseid), str(lab), str(value), str(value2), str(keycal))
        return self.run(command, **kwargs)

    def rate(self, option="", **kwargs):
        """APDL Command: RATE

        Specifies whether the effect of creep strain rate will be used in the
        solution of a load step.

        Parameters
        ----------
        option
            Activates implicit creep analysis.

            0 or OFF  - No implicit creep analysis. This option is the default.

            1 or ON  - Perform implicit creep analysis.

        Notes
        -----
        Set Option = 1 (or ON) to perform an implicit creep analysis (TB,CREEP
        with TBOPT :  1). For viscoplasticity/creep analysis, Option specifies
        whether or not to include the creep calculation in the solution of a
        load step. If Option = 1 (or ON), ANSYS performs the creep calculation.
        Set an appropriate time for solving the load step via a TIME,TIME
        command.
        """
        command = "RATE,%s" % (str(option))
        return self.run(command, **kwargs)

    def print(self, **kwargs):
        """APDL Command: PRINT

        Specifies "Print settings" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "PRINT," % ()
        return self.run(command, **kwargs)

    def mpplot(self, lab="", mat="", tmin="", tmax="", pmin="", pmax="",
               **kwargs):
        """APDL Command: MPPLOT

        Plots linear material properties as a function of temperature.

        Parameters
        ----------
        lab
            Linear material property label (EX, EY, etc.) [MP].

        mat
            Material reference number. Defaults to 1.

        tmin
            Minimum abscissa value to be displayed.

        tmax
            Maximum abscissa value.

        pmin
            Minimum property (ordinate) value to be displayed.

        pmax
            Maximum property value.

        Notes
        -----
        When the property is from tables, the MPPLOT command will not be valid
        because the property could be a function of more than temperature.

        This command is valid in any processor.
        """
        command = "MPPLOT,%s,%s,%s,%s,%s,%s" % (str(lab), str(mat), str(tmin), str(tmax), str(pmin), str(pmax))
        return self.run(command, **kwargs)

    def reset(self, **kwargs):
        """APDL Command: RESET

        Resets all POST1 or POST26 specifications to initial defaults.

        Notes
        -----
        Has the same effect as entering the processor the first time within the
        run.  In POST1, resets all specifications to initial defaults, erases
        all element table items, path table data, fatigue table data, and load
        case pointers.  In POST26, resets all specifications to initial
        defaults, erases all variables defined, and zeroes the data storage
        space.
        """
        command = "RESET," % ()
        return self.run(command, **kwargs)

    def conjug(self, ir="", ia="", name="", facta="", **kwargs):
        """APDL Command: CONJUG

        Forms the complex conjugate of a variable.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        ia
            Reference number of the variable to be operated on.

        --, --
            Unused fields.

        name
            Thirty-two character name for identifying the variable on printouts
            and displays.  Embedded blanks are compressed for output.

        --, --
            Unused fields.

        facta
            Scaling factor (positive or negative) applied to variable (default
            to 1.0).

        Notes
        -----
        Used only with harmonic analyses (ANTYPE,HARMIC).
        """
        command = "CONJUG,%s,%s,%s,%s" % (str(ir), str(ia), str(name), str(facta))
        return self.run(command, **kwargs)

    def modcont(self, mlskey="", enforcedkey="", **kwargs):
        """APDL Command: MODCONT

        Specify additional modal analysis options.

        Parameters
        ----------
        mlskey
            Multiple load step key:

            OFF - Perform the modal analysis (compute the eigenvalues and the load vector) for
                  each load step. (default)

            ON - Perform the modal analysis (compute the eigenvalues and the load vector) only
                 for the first load step; form the load vector for each
                 subsequent load step (without repeating the eigenvalue
                 calculations) and write all load vectors to the Jobname.MODE
                 file for downstream mode-superposition analyses.

        enforcedkey
            Enforced motion key:

            OFF - Do not calculate enforced static modes. (default)

            ON - Calculate enforced static modes and write them to the Jobname.MODE file.

        Notes
        -----
        Specifies additional modal analysis (ANTYPE,MODAL) options.

        Use the LVSCALE command to apply the desired load in a mode-
        superposition transient or harmonic analysis.

        The maximum number of load vectors that can be used in the downstream
        mode-superposition transient or harmonic analysis is: 240.

        Generation of multiple loads (MLSkey = ON) is supported by the Block
        Lanczos, PCG Lanczos, Supernode, Subspace, Unsymmetric, and QR damped
        modal methods.

        The enforced motion calculation (EnforcedKey = ON) is supported by the
        Block Lanczos and Supernode mode extraction methods.
        """
        command = "MODCONT,%s,%s" % (str(mlskey), str(enforcedkey))
        return self.run(command, **kwargs)

    def aina(self, na1="", na2="", na3="", na4="", na5="", na6="", na7="",
             na8="", na9="", **kwargs):
        """APDL Command: AINA

        Finds the intersection of areas.

        Parameters
        ----------
        na1, na2, na3, . . . , na9
            Numbers of areas to be intersected.  If NA1 = ALL, NA2 to NA9 are
            ignored and the intersection of all selected areas is found.  If
            NA1 = P, graphical picking is enabled and all remaining arguments
            are ignored (valid only in the GUI).  A component name may also be
            substituted for NA1.

        Notes
        -----
        Finds the common (not pairwise) intersection of areas.  The common
        intersection is defined as the regions shared (in common) by all areas
        listed on this command.  New areas will be generated where the original
        areas intersect.  If the regions of intersection are only lines, new
        lines will be generated instead.  See the Modeling and Meshing Guide
        for an illustration.  See the BOPTN command for the options available
        to Boolean operations.  Element attributes and solid model boundary
        conditions assigned to the original entities will not be transferred to
        the new entities generated.
        """
        command = "AINA,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(na1), str(na2), str(na3), str(na4), str(na5), str(na6), str(na7), str(na8), str(na9))
        return self.run(command, **kwargs)

    def hfang(self, lab="", phi1="", phi2="", theta1="", theta2="", **kwargs):
        """APDL Command: HFANG

        Defines or displays spatial angles of a spherical radiation surface for
        sound radiation parameter calculations.

        Parameters
        ----------
        lab
            Spatial angle label.

            ANGLE - Define spatial angles (default).

            STATE - Display spatial angles. PHI1, PHI2, THETA1, and THETA2 are ignored.

        phi1, phi2
            Starting and ending ϕ angles (degrees) in the spherical coordinate
            system. Defaults to 0.

        theta1, theta2
            Starting and ending θ angles (degrees) in the spherical coordinate
            system. Defaults to 0.

        Notes
        -----
        Defines or displays spatial angles of a spherical radiation surface.

        Use this command only with PLFAR,Lab = PRES, or PRFAR,Lab = PRES.
        """
        command = "HFANG,%s,%s,%s,%s,%s" % (str(lab), str(phi1), str(phi2), str(theta1), str(theta2))
        return self.run(command, **kwargs)

    def eigen(self, kmatrix="", mmatrix="", cmatrix="", evals="", evects="",
              **kwargs):
        """APDL Command: *EIGEN

        Performs a modal solution with unsymmetric or damping matrices.

        Parameters
        ----------
        kmatrix
            Name of the stiffness matrix. May be a real or complex-valued
            matrix.

        mmatrix
            Name of the mass matrix.

        cmatrix
            Name of the damping matrix (used only for MODOPT,DAMP).

        evals
            Name of the output eigenvalues vector. It will be an m-long *VEC
            vector of complex values, where m is the number of eigenvalues
            requested (MODOPT).

        evects
            Name of the output eigenvector matrix. It will be a n x m *DMAT
            (dense) matrix of complex values, where n is the size of the matrix
            and m is the number of eigenvalues requested (MODOPT).

        Notes
        -----
        Use the command ANTYPE,MODAL and the MODOPT command to specify the
        modal solution options. Only MODOPT,DAMP, MODOPT,UNSYM, MODOPT,LANB,
        and MODOPT,SUBSP are supported.

        *EIGEN with Block Lanczos (LANB) only supports sparse matrices.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "*EIGEN,%s,%s,%s,%s,%s" % (str(kmatrix), str(mmatrix), str(cmatrix), str(evals), str(evects))
        return self.run(command, **kwargs)

    def kdele(self, np1="", np2="", ninc="", **kwargs):
        """APDL Command: KDELE

        Deletes unmeshed keypoints.

        Parameters
        ----------
        np1, np2, ninc
            Delete keypoints from NP1 to NP2 (defaults to NP1) in steps of NINC
            (defaults to 1).  If NP1 = ALL, NP2 and NINC are ignored and all
            selected keypoints [KSEL] are deleted.  If NP1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).  A component name may also be substituted
            for NP1 (NP2 and NINC are ignored).

        Notes
        -----
        Deletes selected keypoints.  A keypoint attached to a line cannot be
        deleted unless the line is first deleted.
        """
        command = "KDELE,%s,%s,%s" % (str(np1), str(np2), str(ninc))
        return self.run(command, **kwargs)

    def cyccalc(self, fileprefix="", fileformat="", **kwargs):
        """APDL Command: CYCCALC

        Calculates results from a cyclic harmonic mode-superposition analysis
        using the specifications defined by CYCSPEC.

        Parameters
        ----------
        fileprefix
            Each result table (corresponding to each CYCSPEC specification) is
            written to a file beginning with FilePrefix. If blank (default),
            the result tables are written to the output file.

        fileformat
            If FilePrefix is specified, then use FileFormat to specify the
            format of the file to be written:

            FORM - Formatted file (default)

            CSV - Comma-separated value file

        Notes
        -----
        CYCCALC loops through the specification given by CYCSPEC and computes
        the requested outputs. The outputs are given in a table format, with
        the rows corresponding to each frequency solution from the harmonic
        analysis, and the columns corresponding to each sector. The table
        entries are the maximum value of the specified quantity at the
        specified location in the sector. In addition, columns containing the
        maximum value at the frequency, the sector in which it occurs, and the
        node in the sector at which it occurs are output.

        If FilePrefix is specified, a file is created for each output table
        with the name FilePrefix_node_type.ext, where node is the node number
        or component name, type is the item/component requested, and the file
        extension .ext is either .txt or .csv, depending on FileFormat.

        A SET command must precede the CYCCALC command.

        The CYCCALC results are based on the currently active RSYS, SHELL,
        LAYER, and AVPRIN settings.
        """
        command = "CYCCALC,%s,%s" % (str(fileprefix), str(fileformat))
        return self.run(command, **kwargs)

    def wmore(self, node1="", node2="", ninc="", itime="", inc="", **kwargs):
        """APDL Command: WMORE

        Adds more nodes to the starting wave list.

        Parameters
        ----------
        node1, node2, ninc
            Add another node set to the previous starting wave list.  Set is
            NODE1 to NODE2 (defaults to NODE1) in steps of NINC (defaults to
            1).  If NODE1 is negative, delete (instead of add) this node set
            from previous starting wave list.

        itime, inc
            Add other node sets to the same starting wave list by repeating the
            previous node set with NODE1 and NODE2 incremented by INC (defaults
            to 1) each time after the first.  ITIME is the total number of sets
            (defaults to 1) defined with this command.

        Notes
        -----
        Adds more nodes to (or modifies) the previous starting wave list (if
        any) [WSTART].  Repeat WMORE command to add more nodes to the previous
        starting wave list.  Up to 10,000 nodes may be defined (total, for all
        starting waves).

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "WMORE,%s,%s,%s,%s,%s" % (str(node1), str(node2), str(ninc), str(itime), str(inc))
        return self.run(command, **kwargs)

    def psdval(self, tblno="", sv1="", sv2="", sv3="", sv4="", sv5="", sv6="",
               sv7="", **kwargs):
        """APDL Command: PSDVAL

        Defines PSD values.

        Parameters
        ----------
        tblno
            Input table number being defined.

        sv1, sv2, sv3, . . . , sv7
            Spectral values corresponding to the frequency points [PSDFRQ].
            Values are interpreted as defined with the PSDUNIT command.

        Notes
        -----
        Defines PSD values to be associated with the previously defined
        frequency points.

        Repeat PSDVAL command for additional values, up to the number of
        frequency points [PSDFRQ].  Values are added after the last nonzero
        value.

        This command is also valid in PREP7.
        """
        command = "PSDVAL,%s,%s,%s,%s,%s,%s,%s,%s" % (str(tblno), str(sv1), str(sv2), str(sv3), str(sv4), str(sv5), str(sv6), str(sv7))
        return self.run(command, **kwargs)

    def sabs(self, key="", **kwargs):
        """APDL Command: SABS

        Specifies absolute values for element table operations.

        Parameters
        ----------
        key
            Absolute value key:

            0 - Use algebraic values in operations.

            1 - Use absolute values in operations.

        Notes
        -----
        Causes absolute values to be used in the SADD, SMULT, SMAX, SMIN, and
        SSUM operations.
        """
        command = "SABS,%s" % (str(key))
        return self.run(command, **kwargs)

    def plpagm(self, item="", gscale="", nopt="", **kwargs):
        """APDL Command: PLPAGM

        Displays path items along the path geometry.

        Parameters
        ----------
        item
            The path data item to be displayed on the currently active path
            (defined by the PATH command).  Valid path items are those defined
            with the PDEF or PLNEAR commands.

        gscale
            Scale factor for the offset from the path for the path data item
            displays.  Defaults to 1.0.

        nopt
            Determines how data is displayed:

            (blank) - Do not display nodes, and scale the display based on the currently selected
                      node set (default).

            NODE - Display path item data along with the currently selected set of nodes.  The
                   display geometry is scaled to the selected node set.

        Notes
        -----
        You can use the Gscale argument to scale the contour display offset
        from the path for clarity. You need to type all six characters to issue
        this command.
        """
        command = "PLPAGM,%s,%s,%s" % (str(item), str(gscale), str(nopt))
        return self.run(command, **kwargs)

    def va(self, a1="", a2="", a3="", a4="", a5="", a6="", a7="", a8="", a9="",
           a10="", **kwargs):
        """APDL Command: VA

        Generates a volume bounded by existing areas.

        Parameters
        ----------
        a1, a2, a3, . . . , a10
            List of areas defining volume.  The minimum number of areas is 4.
            If A1 = ALL, use all selected [ASEL] areas and ignore A2 to A10.
            If A1 = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI).  A component name may
            also be substituted for A1.

        Notes
        -----
        This command conveniently allows generating volumes from regions having
        more than eight keypoints (which is not allowed with the V command).
        Areas may be input in any order.  The exterior surface of a VA volume
        must be continuous, but holes may pass completely through it.
        """
        command = "VA,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(a1), str(a2), str(a3), str(a4), str(a5), str(a6), str(a7), str(a8), str(a9), str(a10))
        return self.run(command, **kwargs)

    def rthick(self, par="", iloc="", jloc="", kloc="", lloc="", **kwargs):
        """APDL Command: RTHICK

        Defines variable thickness at nodes for shell elements.

        Parameters
        ----------
        par
             Array parameter (indexed by node number) that expresses the
            function to be mapped.  For example, func (17) should be the
            desired shell thickness at node 17.

        iloc
            Position in real constant set for thickness at node I of the
            element (default 1).

        jloc
            Position in real constant set for thickness at node J of the
            element (default 2).

        kloc
            Position in real constant set for thickness at node K of the
            element (default 3).

        lloc
            Position in real constant set for thickness at node L of the
            element (default 4).

        Notes
        -----
        After RTHICK, the REAL number will match the ELEM number of each
        selected element. For example, R (ILOC) = func (I NODE), R (JLOC) =
        func (J NODE), etc.

        R(ILOC), R(JLOC), R(KLOC), and R(LLOC) on a previously defined real
        constant will be overwritten.  Any other real constants on a previously
        defined real constant set will remain unchanged. This command cannot be
        used for beam elements.
        """
        command = "RTHICK,%s,%s,%s,%s,%s" % (str(par), str(iloc), str(jloc), str(kloc), str(lloc))
        return self.run(command, **kwargs)

    def auto(self, wn="", **kwargs):
        """APDL Command: /AUTO

        Resets the focus and distance specifications to "automatically
        calculated."

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        Notes
        -----
        Focus point and distance will be automatically calculated during next
        display.  Settings may still be changed with the /FOCUS and /DIST
        commands after this command has been issued.  See also the /USER
        command.

        This command is valid in any processor.
        """
        command = "/AUTO,%s" % (str(wn))
        return self.run(command, **kwargs)

    def plotting(self, **kwargs):
        """APDL Command: PLOTTING

        Specifies "Plotting settings" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "PLOTTING," % ()
        return self.run(command, **kwargs)

    def eintf(self, toler="", k="", tlab="", kcn="", dx="", dy="", dz="",
              knonrot="", **kwargs):
        """APDL Command: EINTF

        Defines two-node elements between coincident or offset nodes.

        Parameters
        ----------
        toler
            Tolerance for coincidence (based on maximum Cartesian coordinate
            difference for node locations and on angle differences for node
            orientations). Defaults to 0.0001. Only nodes within the tolerance
            are considered to be coincident.

        k
            Only used when the type of the elements to be generated is
            PRETS179. K is the pretension node that is common to the pretension
            section that is being created. If K is not specified, it will be
            created by ANSYS automatically and will have an ANSYS-assigned node
            number. If K is specified but does not already exist, it will be
            created automatically but will have the user-specified node number.
            K cannot be connected to any existing element.

        tlab
            Nodal number ordering. Allowable values are:

            LOW - The 2-node elements are generated from the lowest numbered node to the highest
                  numbered node.

            HIGH - The 2-node elements are generated from the highest numbered node to the lowest
                   numbered node.

            REVE - Reverses the orientation of the selected 2-node element.

        kcn
            In coordinate system KCN, elements are created between node 1 and
            node 2 (= node 1 + dx dy dz).

        dx, dy, dz
            Node location increments that define the node offset in the active
            coordinate system (DR, Dθ, DZ for cylindrical and DR, Dθ, DΦ for
            spherical or toroidal).

        knonrot
            When KNONROT = 0, the nodes coordinate system is not rotated. When
            KNONROT = 1, the nodes belonging to the elements created are
            rotated into coordinate system KCN (see NROTAT command
            description).

        Notes
        -----
        Defines 2-node elements (such as gap elements) between coincident or
        offset nodes (within a tolerance). May be used, for example, to "hook"
        together elements interfacing at a seam, where the seam consists of a
        series of node pairs. One element is generated for each set of two
        coincident nodes. For more than two coincident or offset nodes in a
        cluster, an element is generated from the lowest numbered node to each
        of the other nodes in the cluster. If fewer than all nodes are to be
        checked for coincidence, use the NSEL command to select the nodes.
        Element numbers are incremented by one from the highest previous
        element number. The element type must be set [ET] to a 2-node element
        before issuing this command. Use the CPINTF command to connect nodes by
        coupling instead of by elements. Use the CEINTF command to connect the
        nodes by constraint equations instead of by elements.

        For contact element CONTA178, the tolerance is based on the maximum
        Cartesian coordinate difference for node locations only. The angle
        differences for node orientations are not checked.
        """
        command = "EINTF,%s,%s,%s,%s,%s,%s,%s,%s" % (str(toler), str(k), str(tlab), str(kcn), str(dx), str(dy), str(dz), str(knonrot))
        return self.run(command, **kwargs)

    def proein(self, name="", extension="", path="", proecomm="", **kwargs):
        """APDL Command: ~PROEIN

        Transfers a Creo Parametric part into the ANSYS program.

        Parameters
        ----------
        name
            The name of the Creo Parametric part to be imported, which cannot
            exceed 64 characters in length and must begin with an alphanumeric
            character. Special characters such as & - and * and spaces are not
            permitted in the part name.

        extension
            The general Creo Parametric extension format is prt for parts and
            asm for assemblies.

        path
            Full path name to the directory containing the part. The default is
            the current working directory.

        proecomm
            The start command for the version of Creo Parametric you are using.
            proe1 is the default command. Note that the full path name to the
            Creo Parametric command need not be used here if the path had been
            included in the PATH variable. The Creo Parametric command name is
            set by the PROE_START_CMD162 environment variable.

        Notes
        -----
        More information on importing Creo Parametric parts is available in
        Creo Parametric (formerly Pro/ENGINEER) in the Connection User's Guide.
        """
        command = "~PROEIN,%s,%s,%s,%s" % (str(name), str(extension), str(path), str(proecomm))
        return self.run(command, **kwargs)

    def cmlist(self, name="", key="", entity="", **kwargs):
        """APDL Command: CMLIST

        Lists the contents of a component or assembly.

        Parameters
        ----------
        name
            Name of the component or assembly to be listed (if blank, list all
            selected components and assemblies). If Name is specified, then
            Entity  is ignored.

        key
            Expansion key:

            0 - Do not list individual entities in the component.

            1 or EXPA - List individual entities in the component.

        entity
            If Name is blank, then the following entity types can be specified:

            VOLU - List the volume components only.

            AREA - List the area components only.

            LINE - List the line components only.

            KP - List the keypoint components only

            ELEM - List the element components only.

            NODE - List the node components only.

        Notes
        -----
        This command is valid in any processor.  For components, it lists the
        type of geometric entity. For assemblies, it lists the components
        and/or assemblies that make up the assembly.

        Examples of possible usage:
        """
        command = "CMLIST,%s,%s,%s" % (str(name), str(key), str(entity))
        return self.run(command, **kwargs)

    def cval(self, wn="", v1="", v2="", v3="", v4="", v5="", v6="", v7="",
             v8="", **kwargs):
        """APDL Command: /CVAL

        Specifies nonuniform contour values on stress displays.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        v1, v2, v3, . . . , v8
            Up to 8 contour values may be specified (in ascending order).  The
            0.0 value (if any) must not be the last value specified.  If no
            values are specified, all contour specifications are erased and
            contours are automatically calculated.

        Notes
        -----
        This command is similar to the /CONTOUR command. With /CVAL, however,
        you define the upper level of each contour band instead of having the
        contours uniformly distributed over the range. The minimum value
        (including a zero value for the first band) for a contour band cannot
        be specified. If you use both /CONTOUR and /CVAL, the last command
        issued takes precedence.

        This command is valid in any processor.
        """
        command = "/CVAL,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(wn), str(v1), str(v2), str(v3), str(v4), str(v5), str(v6), str(v7), str(v8))
        return self.run(command, **kwargs)

    def modify(self, set="", lstep="", iter="", cumit="", time="", ktitle="",
               **kwargs):
        """APDL Command: MODIFY

        Changes the listed values of the data in a set.

        Parameters
        ----------
        set
            Set of data in results file to be modified.

        lstep
            The new load step number.

        iter
            The new load substep number.

        cumit
            The new cumulative iteration.

        time
            The new time/frequency value.

        ktitle
            Indicates if the set title should be modified.

            0 - Keep the original title.

            1 - Change the title to the title specified with the most current /TITLE command.

        Notes
        -----
        Use this command to change the listed values in a data set in a results
        file. Using this command does not change any actual model data; it
        affects only the values listed in the results file.

        For example, if you start with the following results file:

        and you then issue the following commands:

        The modified results file would look like this:
        """
        command = "MODIFY,%s,%s,%s,%s,%s,%s" % (str(set), str(lstep), str(iter), str(cumit), str(time), str(ktitle))
        return self.run(command, **kwargs)

    def tshap(self, shape="", **kwargs):
        """APDL Command: TSHAP

        Defines simple 2-D and 3-D geometric surfaces for target segment
        elements.

        Parameters
        ----------
        shape
            Specifies the geometric shapes for target segment elements TARGE169
            and TARGE170.

            LINE - Straight line (2-D, 3-D) (Default for 2-D)

            PARA - Parabola (2-D, 3-D)

            ARC - Clockwise arc (2-D)

            CARC - Counterclockwise arc (2-D)

            CIRC - Complete circle (2-D)

            TRIA - Three-node triangle (3-D) (Default for 3-D)

            TRI6 - Six-node triangle (3-D)

            QUAD - Four-node quadrilateral (3-D)

            QUA8 - Eight-node quadrilateral (3-D)

            CYLI - Cylinder (3-D)

            CONE - Cone (3-D)

            SPHE - Sphere (3-D)

            PILO - Pilot node (2-D, 3-D)

            POINT - Point (rigid surface node) (2-D, 3-D)

        Notes
        -----
        Use this command to specify the target segment shapes for the rigid
        target surface associated with surface-to-surface contact (TARGE169,
        CONTA171, CONTA172 (2-D) and TARGE170, CONTA173, CONTA174 (3-D)), 3-D
        beam-to-beam contact (TARGE170 and CONTA176), and 3-D line-to-surface
        contact (TARGE170 and CONTA177).  Once you issue TSHAP, all subsequent
        target elements generated via the direct element generation technique
        will have the same shape, until you issue TSHAP again with a different
        Shape value.
        """
        command = "TSHAP,%s" % (str(shape))
        return self.run(command, **kwargs)

    def fileaux3(self, fname="", ext="", **kwargs):
        """APDL Command: FILEAUX3

        Specifies the results file to be edited.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Specifies the results file to be edited.
        """
        command = "FILEAUX3,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def image(self, label="", fname="", ext="", **kwargs):
        """APDL Command: /IMAGE

        Allows graphics data to be captured and saved.

        Parameters
        ----------
        label
            Label specifying the operation to be performed:

            CAPTURE - Capture the image from the graphics window to a new window.

            RESTORE - Restore the image from a file to a new window.

            SAVE - Save the contents of the graphic window to a file.

            DELETE - Delete the window that contains the file.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.
        """
        command = "/IMAGE,%s,%s,%s" % (str(label), str(fname), str(ext))
        return self.run(command, **kwargs)

    def spcnod(self, encl="", node="", **kwargs):
        """APDL Command: SPCNOD

        Defines a space node for radiation using the Radiosity method.

        Parameters
        ----------
        encl
            Radiating surface enclosure number.  Defaults to 1. If ENCL = STAT,
            the command lists all enclosure space nodes. If  ENCL =  DELE, the
            command deletes all enclosure space nodes.

        node
            Node defined to be the space node.

        Notes
        -----
        For open systems, an enclosure may radiate to a space node (NODE).

        Open systems may be characterized by one or more enclosures (ENCL).
        Each enclosure may radiate to a different space node (NODE).

        For a space node that is not part of the finite element model, specify
        the temperature using the D command. For the first load step, the space
        node temperature ramps from the uniform temperature specified by the
        TUNIF command to the temperature specified by the D command. For
        subsequent load steps, it ramps from the previous value of the space
        node temperature. For intermediate load steps, use the SPCNOD,DELETE
        command and specify the space node temperature again to ramp from the
        uniform temperature.

        For a space node that is part of the finite element model, the
        temperature is that calculated during the finite element solution.
        """
        command = "SPCNOD,%s,%s" % (str(encl), str(node))
        return self.run(command, **kwargs)

    def pltime(self, tmin="", tmax="", **kwargs):
        """APDL Command: PLTIME

        Defines the time range for which data are to be displayed.

        Parameters
        ----------
        tmin
            Minimum time (defaults to the first point stored).

        tmax
            Maximum time (defaults to the last point stored).

        Notes
        -----
        Defines the time (or frequency) range (within the range stored) for
        which data are to be displayed.  Time is always displayed in the Z-axis
        direction for 3-D graph displays.  If XVAR = 1, time is also displayed
        in the X-axis direction and this control also sets the abscissa scale
        range.
        """
        command = "PLTIME,%s,%s" % (str(tmin), str(tmax))
        return self.run(command, **kwargs)

    def pcirc(self, rad1="", rad2="", theta1="", theta2="", **kwargs):
        """APDL Command: PCIRC

        Creates a circular area centered about the working plane origin.

        Parameters
        ----------
        rad1, rad2
            Inner and outer radii (either order) of the circle.  A value of
            either zero or blank for either RAD1 or RAD2, or the same value for
            both RAD1 and RAD2, defines a solid circle.

        theta1, theta2
            Starting and ending angles (either order) of the circular area.
            Used for creating a circular sector.  The sector begins at the
            algebraically smaller angle, extends in a positive angular
            direction, and ends at the larger angle.  The starting angle
            defaults to 0.0° and the ending angle defaults to 360.0°.  See the
            Modeling and Meshing Guide for an illustration.

        Notes
        -----
        Defines a solid circular area or circular sector centered about the
        working plane origin.  For a solid circle of 360°, the area will be
        defined with four keypoints and four lines.  See the CYL4 and CYL5
        commands for alternate ways to create circles.
        """
        command = "PCIRC,%s,%s,%s,%s" % (str(rad1), str(rad2), str(theta1), str(theta2))
        return self.run(command, **kwargs)

    def gformat(self, ftype="", nwidth="", dsignf="", **kwargs):
        """APDL Command: /GFORMAT

        Specifies the format for the graphical display of numbers.

        Parameters
        ----------
        ftype
            FORTRAN format types (G is the default if this field is left
            blank.)

            G - Gxx.yy.  xx and yy are described below.

            F - Fxx.yy

            E - Exx.yy

        nwidth
            Total width (12 maximum) of the field (the xx in Ftype).  Defaults
            to 12.

        dsignf
            Number of digits after the decimal point (yy in F or E format) or
            number of significant digits in G format.  Range is 1 to xx-6 for
            Ftype = G or E; and 0 to xx-3 for Ftype = F.  The default is a
            function of Ftype and NWIDTH.

        Notes
        -----
        Lets you control the format of the graphical display of floating point
        numbers.   Issue /GFORMAT,STAT to display the current settings; issue
        /GFORMAT,DEFA to let ANSYS choose the format for the graphical display
        of floating numbers.

        This command is valid in any processor.
        """
        command = "/GFORMAT,%s,%s,%s" % (str(ftype), str(nwidth), str(dsignf))
        return self.run(command, **kwargs)

    def prfar(self, lab="", option="", phi1="", phi2="", nph1="", theta1="",
              theta2="", ntheta="", val1="", val2="", val3="", **kwargs):
        """APDL Command: PRFAR

        Prints pressure far fields and far field parameters.

        Parameters
        ----------
        lab
            Parameters to print:

            PRES - Acoustic parameters

            PROT - Acoustic parameters with the y-axis rotated extrusion

        option
            Print option, based on the specified print parameter type:

        phi1, phi2
            Starting and ending φ angles (degrees) in the spherical coordinate
            system. Defaults to 0.

        nphi
            Number of divisions between the starting and ending φ angles for
            data computations. Defaults to 0.

        theta1, theta2
            Starting and ending θ angles (degrees) in the spherical coordinate
            system. Defaults to 0 in 3-D and 90 in 2-D.

        ntheta
            Number of divisions between the starting and ending θ angles for
            data computations. Defaults to 0.

        val1
            Radius of the sphere surface. Used only when Option = SUMC, PHSC,
            SPLC, SPAC, PSCT, or TSCT.

        val2
            When Option = SPLC or SPAC: Reference rms sound pressure. Defaults
            to 2x10-5 Pa.

        val3
            When Lab = PRES: Thickness of 2-D model extrusion in the z
            direction (no default).

        Notes
        -----
        The PRFAR command prints pressure far fields and far field parameters
        as    determined by the equivalent source principle. Use this command
        to print pressure and acoustic    parameters. See the HFSYM command for
        the model symmetry and the     HFANG command for spatial radiation
        angles.

        To retrieve saved equivalent source data, issue the
        SET,Lstep,Sbstep,,REAL command.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "PRFAR,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(lab), str(option), str(phi1), str(phi2), str(nph1), str(theta1), str(theta2), str(ntheta), str(val1), str(val2), str(val3))
        return self.run(command, **kwargs)

    def swgen(self, ecomp="", swrd="", ncm1="", ncm2="", snd1="", snd2="",
              shrd="", dirx="", diry="", dirz="", itty="", icty="", **kwargs):
        """APDL Command: SWGEN

        Creates a new spot weld set.

        Parameters
        ----------
        ecomp
            Name to identify the new spot weld. This name will be used for the
            element component containing the new contact, target, and beam
            elements generated for the spot weld set.

        swrd
            Spot weld radius.

        ncm1
            Name of a component containing nodes on the first spot weld
            surface, or a meshed area number for the surface.

        ncm2
            Name of a component containing nodes on the second spot weld
            surface, or a meshed area number for the surface.

        snd1
            Node number of the first spot weld node corresponding to the first
            surface (NCM1). This node can be on or close to the first surface.

        snd2
            Node number of the second spot weld node corresponding to the
            second surface (NCM2).  This node can be on or close to the second
            surface. ANSYS will create the node if it is not specified.

        shrd
            Search radius. Defaults to 4 times the spot weld radius SWRD.

        dirx, diry, dirz
            Spot weld projection direction in terms of normal X, Y, and Z
            components.

        itty
            Target element type ID.

        icty
            Contact element type ID.

        Notes
        -----
        This command creates a new spot weld set. You can add more surfaces to
        the set using SWADD after the initial SWGEN command. However, the
        maximum number of allowable surfaces (including the 2 surfaces used for
        the original set) for each spot weld set is 11.

        Ecomp, SWRD, NCM1, NCM2, and SND1 must be specified. SND2, SHRD, DIRX,
        DIRY, DIRZ, ITTY, ICTY are optional inputs. If the second spot weld
        node (SND2) is specified, that node is used to determine the spot weld
        projection direction, andDIRX, DIRY and DIRZ are ignored.

        If ITTY is specified, the following corresponding target element key
        option must be set: KEYOPT(5) = 4. If ICTY is specified, the following
        corresponding contact element key options must be set: KEYOPT(2) = 2,
        KEYOPT(12) = 5.

        Use the SWLIST and SWDEL commands to list or delete spot welds. See
        Creating a Basic Spot Weld Set with SWGEN for detailed information on
        defining spot welds.
        """
        command = "SWGEN,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(ecomp), str(swrd), str(ncm1), str(ncm2), str(snd1), str(snd2), str(shrd), str(dirx), str(diry), str(dirz), str(itty), str(icty))
        return self.run(command, **kwargs)

    def satin(self, name="", extension="", path="", entity="", fmt="", nocl="",
              noan="", **kwargs):
        """APDL Command: ~SATIN

        Transfers a .SAT file into the ANSYS program.

        Parameters
        ----------
        name
            The name of a valid .SAT file, created with a supported version of
            ACIS. The first character of the file name must be an alphanumeric.
            Special characters such as & - and * and spaces are not permitted
            in the part name. See File Names in the Command Reference for more
            information about ANSYS file naming conventions.

        extension
            The extension for the file. The default extension is .sat.

        path
            The path name of the directory in which the file resides enclosed
            in single quotes. The default path name is the current working
            directory.

        entity
            Entity to be imported.

            SOLIDS - Solids only, imported as ANSYS volumes (Not implemented, imports All).

            SURFACES - Surfaces only, imported as ANSYS areas (Not implemented, imports All).

            WIREFRAME - Wireframe only, imported as ANSYS lines (Not implemented, imports All).

            ALL - All entities. Use this option when the file contains different types of
                  entities.

        fmt
            The format in which ANSYS will store the model.

            0 - Neutral format (default). Defeaturing after import is restricted.

            1 - Solid format; this allows defeaturing after import.

        nocl
            Remove tiny objects.

            0 - Remove tiny objects without checking model validity (default).

            1 - Do not remove tiny objects.

        noan
            Perform an ACIS analysis of the model.

            0 - Analyze the model (default).

            1 - Do not analyze the model.

        Notes
        -----
        More information on importing ACIS parts is available in ACIS in the
        Connection User's Guide.
        """
        command = "~SATIN,%s,%s,%s,%s,%s,%s,%s" % (str(name), str(extension), str(path), str(entity), str(fmt), str(nocl), str(noan))
        return self.run(command, **kwargs)

    def pdropt(self, rvar="", corr="", stat="", shis="", hist="", cdf="",
               sens="", cmat="", conf="", **kwargs):
        """APDL Command: PDROPT

        Specifies the options for an HTML report.

        Parameters
        ----------
        rvar
            Specifies in which form to show the definitions of random variables
            in the report.

            0 - Using tables (including name and distribution parameter) and figures (including
                a probability density function plot and a cumulative
                distribution plot) (default).

            1 - Using tables only.

            2 - Using figures only.

            3 - None.

        corr
            Specifies if a table describing the correlation between random
            variables should be included in the report.

            0 - Yes, include this table (default).

            1 - No, do not include this table.

        stat
            Specifies which statistics to include in the report. In general,
            statistics are provided in a tabular form.

            0 - Statistics of the random output parameters only (default).

            1 - Statistics of the random input variables only.

            2 - Statistics of both the random input variables and the random output parameters.

            3 - None.

        shis
            Specifies which sample history plots to include in the report. This
            option applies to the random output parameters only.

            0 - None (default).

            1 - Mean value and standard deviation as a sample plot.

            2 - Mean value, standard deviation and sample values as a sample plot.

            3 - All types of sample plots - mean value, standard deviation, minimum value,
                maximum values, and the sample values.

        hist
            Specifies which histogram plots to include in the report.

            0 - Histogram of the random output parameters only (default).

            1 - Histogram of the random input variables only.

            2 - Histogram of both the random input variables and the random output parameters.

            3 - None.

        cdf
            Specifies which cumulative distribution function (CDF) plots to
            include in the report.

            0 - CDF of the random output parameters only (default).

            1 - CDF of the random input variables only.

            2 - CDF of both the random input variables and the random output parameters.

            3 - None.

        sens
            Specifies which sensitivity plots to include in the report.

            0 - Plots the sensitivities for all random output parameters based on Spearman-
                rank-order correlation coefficient (default).

            1 - Plots the sensitivities for all random output parameters based on linear
                (Pearson) correlation coefficient.

            2 - Plots the sensitivities according to option SENS=1 and SENS=2.

            3 - None.

        cmat
            Specifies which correlation matrices to include in the report.

            0 - Correlation matrix between random output parameters and random output
                parameters only (default).

            1 - Correlation matrix between random input variables and random output parameters
                only.

            2 - Correlation matrix between random input variables and random input variables
                only.

            3 - Correlation matrices according to option CMAT=0 and CMAT=1.

            4 - Correlation matrices according to option CMAT=0 and CMAT=2.

            5 - Correlation matrices according to option CMAT=1 and CMAT=2.

            6 - Correlation matrices according to option CMAT=0, CMAT=1, and CMAT=2.

            7 - None.

        conf
            Confidence level. The confidence level is used to plot confidence
            bounds for the history value. The value for the confidence level
            must be between 0.0 and 1.0 and it defaults to 0.95 (95%).
            Confidence bound(s) plotting is suppressed for CONF  0.5. This
            option is ignored if the report does not include plots for which
            confidence bounds are applicable.

        Notes
        -----
        Specifies the options for an HTML report. An HTML report includes a
        description of the deterministic model, the probabilistic model, the
        probabilistic methods used for the analyses, and the results obtained
        from the analyses.  The deterministic model is documented in the report
        by including a link to the analysis file (see PDANL command). In
        addition, an element plot of the component is shown, if available,
        based on the current view settings. The command ALLSEL is issued
        automatically prior to the respective plot command.
        """
        command = "PDROPT,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(rvar), str(corr), str(stat), str(shis), str(hist), str(cdf), str(sens), str(cmat), str(conf))
        return self.run(command, **kwargs)

    def ensym(self, iinc="", ninc="", iel1="", iel2="", ieinc="", **kwargs):
        """APDL Command: ENSYM

        Generates elements by symmetry reflection.

        Parameters
        ----------
        iinc
            Increment to be added to element numbers in existing set.

        --
            Unused field.

        ninc
            Increment nodes in the given pattern by NINC.

        iel1, iel2, ieinc
            Reflect elements from pattern beginning with IEL1 to IEL2 (defaults
            to IEL1) in steps of IEINC (defaults to 1). If IEL1 = ALL, IEL2 and
            IEINC are ignored and pattern is all selected elements [ESEL].  If
            IEL1 = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI). A component name may
            also be substituted for IEL1 (IEL2 and IEINC are ignored).

        Notes
        -----
        This command is the same as the ESYM command except it allows
        explicitly assigning element numbers to the generated set (in terms of
        an increment IINC). Any existing elements already having these numbers
        will be redefined.

        The operation generates a new element by incrementing the nodes on the
        original element, and reversing and shifting the node connectivity
        pattern.  For example, for a 4-node 2-D element, the nodes in positions
        I, J, K and L of the original element are placed in positions J, I, L
        and K of the reflected element.

        Similar permutations occur for all other element types. For line
        elements, the nodes in positions I and J of the original element are
        placed in positions J and I of the reflected element. In releases prior
        to ANSYS 5.5, no node pattern reversing and shifting occurred for line
        elements generated by ENSYM. To achieve the same results as you did in
        releases prior to ANSYS 5.5, use the ENGEN command instead.

        See the ESYM command for additional information about symmetry
        elements.

        The ENSYM command also provides a convenient way to reverse shell
        element normals. If the IINC and NINC argument fields are left blank,
        the effect of the reflection is to reverse the direction of the outward
        normal of the specified elements. You cannot use the ENSYM command to
        change the normal direction of any element that has a body or surface
        load. We recommend that you apply all of your loads only after ensuring
        that the element normal directions are acceptable. Also note that real
        constants (such as nonuniform shell thickness and tapered beam
        constants) may be invalidated by an element reversal. See Revising Your
        Model in the Modeling and Meshing Guide for more information about
        controlling element normals.
        """
        command = "ENSYM,%s,%s,%s,%s,%s" % (str(iinc), str(ninc), str(iel1), str(iel2), str(ieinc))
        return self.run(command, **kwargs)

    def dadele(self, area="", lab="", **kwargs):
        """APDL Command: DADELE

        Deletes degree-of-freedom constraints on an area.

        Parameters
        ----------
        area
            Area for which constraints are to be deleted.  If ALL, delete for
            all selected areas [ASEL].  If AREA = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  You can substitute a component name  for AREA.

        lab
            Valid constraint labels are:

            ALL - All constraints.

            SYMM - Symmetry constraints.

            ASYM - Antisymmetry constraints.

            UX - Displacement in X direction.

            UY - Displacement in Y direction.

            UZ - Displacement in Z direction.

            ROTX - Rotation about X axis.

            ROTY - Rotation about Y axis.

            ROTZ - Rotation about Z axis.

            PRES - Pressure.

            TEMP, TBOT, TE2, TE3, . . ., TTOP - Temperature.

            MAG - Magnetic scalar potential.

            VOLT - Electric scalar potential.

            AX - Magnetic vector potential in X direction (see notes).

            AY - Magnetic vector potential in Y direction.

            AZ - Magnetic vector potential in Z direction (see notes).

            CONC - Concentration.

        Notes
        -----
        Deletes the degree of freedom constraints at an area (and all
        corresponding finite element constraints) previously specified with the
        DA command. See the DDELE command for delete details.

        If the multiple species labels have been changed to user-defined labels
        via the MSSPEC command, use the user-defined labels.

        See the DA or the DA commands for details on element applicability.

        Warning:: : On previously meshed areas, all constraints on affected
        nodes will be deleted, whether or not they were specified by the DA
        command.

        This command is also valid in PREP7.
        """
        command = "DADELE,%s,%s" % (str(area), str(lab))
        return self.run(command, **kwargs)

    def opncontrol(self, lab="", value="", numstep="", **kwargs):
        """APDL Command: OPNCONTROL

        Sets decision parameter for automatically increasing the time step
        interval.

        Parameters
        ----------
        lab
            DOF

            DOF  - Degree-of-freedom label used to base a decision for increasing the time step
                   (substep) interval in a nonlinear or transient analysis.
                   The only DOF label currently supported is TEMP.

            OPENUPFACTOR  - Factor for increasing the time step interval. Specify when AUTOTS,ON is issued
                            and specify a VALUE > 1.0 (up to 10.0). The default
                            VALUE = 1.5 (except for thermal analysis, where it
                            is 3.0). Generally, VALUE > 3.0 is not recommended.

        value, numstep
            Two values used in the algorithm for determining if the time step
            interval can be increased. Valid only when Lab = DOF.

        Notes
        -----
        This command is available only for nonlinear or full transient
        analysis.
        """
        command = "OPNCONTROL,%s,%s,%s" % (str(lab), str(value), str(numstep))
        return self.run(command, **kwargs)

    def shpp(self, lab="", value1="", value2="", **kwargs):
        """APDL Command: SHPP

        Controls element shape checking.

        Parameters
        ----------
        lab
            Shape checking option.  (When Lab = WARN, STATUS, SUMMARY, or
            DEFAULT, the remaining arguments are ignored.)

            ON - Activates element shape checking.  New elements, regardless of how they are
                 created, are tested against existing warning and error limits.
                 (The existing limits may be the default limits, or previously
                 modified limits.)  Elements that violate error limits produce
                 error messages and either (a) cause a meshing failure, or (b)
                 for element creation or storage other than AMESH or VMESH, are
                 not stored.  Elements that violate warning limits produce
                 warning messages.  If shape checking was previously turned off
                 [SHPP,OFF] and you turn it on, existing elements are marked as
                 untested; use the CHECK command to retest them.  With this
                 option, you may also specify a value for VALUE1 to turn
                 individual shape tests on.  If you do not specify a value for
                 VALUE1, all shape tests are turned on.

            WARN - Activates element shape checking; however, in contrast to SHPP,ON, elements
                   that violate error limits do not cause either a meshing or
                   element storage failure.  Instead, they produce warning
                   messages to notify you that error limits have been violated.
                   This option does not alter current shape parameter limits.
                   Since the default shape parameter error limits are set to
                   allow almost any usable element, the elements this option
                   allows, which would otherwise be forbidden, are likely to be
                   very poorly shaped.

            OFF - Deactivates element shape checking.  This setting does not alter current shape
                  parameter limits.  Use of this option is risky, since poorly
                  shaped elements can lead to analysis results that are less
                  accurate than would otherwise be expected for a given mesh
                  density.  With this option, you may also specify a value for
                  VALUE1 to turn individual shape tests off.  If you do not
                  specify a value for VALUE1, all element shape tests are
                  turned off.

            SILENT - Determines whether element shape checking runs in silent mode.  In silent mode,
                     ANSYS checks elements without issuing warnings, with the
                     exception of the generic warnings that it issues at
                     solution.  With this option, you must also specify a value
                     for VALUE1  (During the execution of certain commands,
                     ANSYS automatically runs element shape checking in silent
                     mode, then internally summarizes the shape test results
                     for all of the new or modified elements.  ANSYS does this
                     when it executes any of the following commands:  AGEN,
                     AMESH, AREFINE, ARSYM, ATRAN, CDREAD, EGEN, ENGEN, ENSYM,
                     EREAD, EREFINE, ESYM, ET, FVMESH, KREFINE, LREFINE,
                     NREFINE, TIMP, VEXT, VGEN, VIMP, VMESH, VOFFST, VROTAT,
                     VSWEEP, VSYMM, and VTRAN.)

            STATUS - Lists the shape parameter limits currently in effect, along with status
                     information about element shape checking (for example,
                     whether any individual shape tests are off, whether any of
                     the shape parameter limits have been modified, and so on).

            SUMMARY - Lists a summary of element shape test results for all selected elements.

            DEFAULT - Resets element shape parameter limits to their default values.  Also, if any
                      individual tests were turned off, turns them back on.
                      (The SHPP,DEFAULT command may be useful if any parameter
                      limits were previously altered by using the MODIFY
                      option.)

            OBJECT - Determines whether element shape test results data is stored in memory.  When
                     this option is turned on, an "object" is created for
                     storing test results in memory.  When this option is
                     turned off, no object is created and no data is stored;
                     thus, any operation that requires shape parameters for an
                     existing element (such as use of the CHECK command) causes
                     the shape parameters to be recomputed.  (Note the
                     distinction between storing the data in memory and storing
                     it in the database; regardless of whether this option is
                     turned on or off, no element shape test results data will
                     be stored in the database.  The element shape parameter
                     object is deleted automatically before any solution.)
                     This setting is independent of shape checking status, with
                     one exception--if shape checking is turned off [SHPP,OFF],
                     the object is not created.  Keep in mind that recomputing
                     shape parameters is more computationally expensive than
                     retrieving them from the object.  With this option, you
                     must also specify a value for the VALUE1 argument; the
                     VALUE2 argument is ignored.

            LSTET - Determines, for Jacobian ratio tests, whether sampling is done at integration
                    points (DesignSpace product method), or at corner nodes.
                    When this option is turned on, sampling is done at
                    integration points, and the default limits for h-element
                    Jacobian ratios are a warning tolerance of 10 and an error
                    tolerance of 40. When this option is turned off, sampling
                    is done at corner nodes, and the corresponding default
                    limits are a warning tolerance of 30 and an error tolerance
                    of 1000. Sampling at the integration points (option on)
                    results in a lower Jacobian ratio, but that ratio is also
                    subjected to a more restrictive error limit. Some elements
                    that have passed the integration point sampling criterion,
                    have failed the corner mode sampling criterion. Because of
                    this, use integration point sampling only for simple linear
                    analyses. For other types of analyses (e.g., nonlinear,
                    electromagnetic), use sampling at corner nodes, which is
                    the more conservative approach. With this option, you must
                    also specify a value for the VALUE1 argument; the VALUE2
                    argument is ignored.

            MODIFY - Indicates that you want to respecify a shape parameter limit.  With this
                     option, you must also specify values for the VALUE1 and
                     VALUE2 arguments.

            FLAT - Determines the warning and error limits used to test elements that may exhibit
                   nonzero/nonconstant Z coordinates. With this option, you
                   must also specify values for the VALUE1 and/or VALUE2
                   arguments.

        value1
            Valid for the ON, OFF, SILENT, OBJECT, LSTET, MODIFY, and FLAT
            options only.  When Lab = ON or OFF, use VALUE1 to individually
            control (that is, turn off or turn on) specific element shape
            tests.  Thus, VALUE1 can be ANGD (SHELL28 corner angle deviation
            tests), ASPECT (aspect ratio tests), PARAL (deviation from
            parallelism of opposite edges tests), MAXANG (maximum corner angle
            tests), JACRAT (Jacobian ratio tests), WARP (warping factor tests),
            or ALL (all tests). When Lab = SILENT, VALUE1 can be ON (to turn
            silent mode on) or OFF (to turn silent mode off).  When Lab =
            OBJECT, VALUE1 can be either 1, YES, or ON to turn on storage of
            element shape test data (the default); or it can be 0, NO, or OFF
            to turn off storage of element shape test data (delete the data and
            recompute as necessary). When Lab = LSTET, VALUE1 can be either 1,
            YES, or ON to choose Jacobian sampling at integration points; or it
            can be 0, NO, or OFF to choose Jacobian sampling at nodes (the
            default). When Lab = MODIFY, VALUE1 is the numeric location (within
            the shape parameter limit array) of the shape parameter limit to be
            modified.  Locations are identified in the element shape checking
            status listing [SHPP,STATUS].  For more information, see the
            examples in the Notes section. When Lab = FLAT, VALUE1 is the
            warning limit for XY element constant Z sets performed at CHECK or
        """
        command = "SHPP,%s,%s,%s" % (str(lab), str(value1), str(value2))
        return self.run(command, **kwargs)

    def nwplan(self, wn="", norig="", nxax="", nplan="", **kwargs):
        """APDL Command: NWPLAN

        Defines the working plane using three nodes.

        Parameters
        ----------
        wn
            Window number whose viewing direction will be modified to be normal
            to the working plane (defaults to 1).  If WN is a negative value,
            the viewing direction will not be modified.  If fewer than three
            points are used, the viewing direction of window WN will be used
            instead to define the normal to the working plane.

        norig
            Node number defining the origin of the working plane coordinate
            system.  If NORIG = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).

        nxax
            Node number defining the x-axis orientation (defaults to the x-axis
            being parallel to the global X-axis; or if the normal to the
            working plane is parallel to the global X-axis, then defaults to
            being parallel to the global Y-axis).

        nplan
            Node number defining the working plane (the normal defaults to the
            present display view [/VIEW] of window WN).

        Notes
        -----
        Defines a working plane to assist in picking operations using three
        nodes as an alternate to the WPLANE command.  The three nodes also
        define the working plane coordinate system.  A minimum of one node (at
        the working plane origin) is required.  Immediate mode may also be
        active.  See the WPSTYL command to set the style of the working plane
        display.

        This command is valid in any processor.
        """
        command = "NWPLAN,%s,%s,%s,%s" % (str(wn), str(norig), str(nxax), str(nplan))
        return self.run(command, **kwargs)

    def paresu(self, lab="", fname="", ext="", **kwargs):
        """APDL Command: PARESU

        Restores previously saved paths from a file.

        Parameters
        ----------
        lab
            Read operation:

            ALL - Read all paths from the selected file (default).

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        This command removes all paths from virtual memory and then reads path
        data from a file written with the PASAVE command.  All paths on the
        file will be restored.  All paths currently in memory will be deleted.
        """
        command = "PARESU,%s,%s,%s" % (str(lab), str(fname), str(ext))
        return self.run(command, **kwargs)

    def werase(self, **kwargs):
        """APDL Command: WERASE

        Erases all reordering wave lists.

        Notes
        -----
        The REORDER then STAT commands will display the current wave lists.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "WERASE," % ()
        return self.run(command, **kwargs)

    def eddc(self, option="", ctype="", cont="", targ="", **kwargs):
        """APDL Command: EDDC

        Deletes or deactivates/reactivates contact surface specifications in an
        explicit dynamic analysis.

        Parameters
        ----------
        option
            Option to be performed for contact definition specified by Ctype,
            Cont, and Targ.

            DELE - Delete the specified contact definition (default); valid only in a new
                   analysis.

            DACT - Deactivate the specified contact definition; valid only in a small restart.

            RACT - Reactivate the specified contact definition (which was previously deactivated);
                   valid only in a small restart.

        ctype
            Contact behavior label (see EDCGEN command for valid labels).

        cont
            Component name or part number [EDPART] identifying the contact
            surface.

        targ
            Component name or part number [EDPART] identifying the target
            surface.

        Notes
        -----
        This command allows you to delete or deactivate/reactivate a particular
        contact specification that was defined by EDCGEN. The contact
        definition is identified by Ctype, Cont, and Targ (Note that Cont and
        Targ may not be required for Ctype = AG, SE, ASSC, ESS, and SS). The
        delete option (Option = DELE) permanently deletes the contact from the
        database. Any additional contact parameters defined with the EDCMORE
        command for the contact definition identified on this command will also
        be deleted or deactivated/reactivated.

        You cannot delete contact specifications in an explicit dynamic small
        restart (EDSTART,2). However, you can use Option = DACT to deactivate a
        contact definition that is not needed in the small restart. That
        contact definition may then be reactivated in a subsequent small
        restart by using Option = RACT.

        To delete or deactivate/reactivate all contact specifications for the
        entire model, use EDDC,Option,ALL.

        The EDDC command is not supported in an explicit dynamic full restart
        analysis (EDSTART,3). Thus, you cannot delete, deactivate, or
        reactivate contact specifications in a full restart that were defined
        in the previous analysis.

        This command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDDC,%s,%s,%s,%s" % (str(option), str(ctype), str(cont), str(targ))
        return self.run(command, **kwargs)

    def bss1(self, val1="", val2="", t="", **kwargs):
        """APDL Command: BSS1

        Specifies the transverse shear strain and force relationship in plane
        XZ for beam sections.

        Parameters
        ----------
        val1
            Transverse shear strain component (γ1).

        val2
            Transverse shear force component (S1).

        t
            Temperature.

        Notes
        -----
        The behavior of beam elements is governed by the generalized-
        stress/generalized-strain relationship of the form:

        The BSS1 command, one of several nonlinear general beam section
        commands, specifies the transverse shear strain and transverse shear
        force relationship for plane XZ of a beam section. The section data
        defined is associated with the section most recently defined (via the
        SECTYPE command).

        Unspecified values default to zero.

        Related commands are BSAX, BSM1, BSM2, BSTQ, BSS2, BSMD, and BSTE.

        For complete information, see Using Nonlinear General Beam Sections.
        """
        command = "BSS1,%s,%s,%s" % (str(val1), str(val2), str(t))
        return self.run(command, **kwargs)

    def cmatrix(self, symfac="", condname="", numcond="", grndkey="",
                capname="", **kwargs):
        """APDL Command: CMATRIX

        Performs electrostatic field solutions and calculates the self and
        mutual capacitances between multiple conductors.

        Parameters
        ----------
        symfac
            Geometric symmetry factor.  Capacitance values are scaled by this
            factor which represents the fraction of the total device modeled.
            Defaults to 1.

        condname
            Alpha-numeric prefix identifier used in defining named conductor
            components.

        numcond
            Total Number of Components.  If a ground is modeled, it is to be
            included as a component.  If a ground is not modeled, but infinite
            elements are used to model the far-field ground, a named component
            for the far-field ground is not required.

        grndkey
            Ground key:

            0 - Ground is one of the components, which is not at infinity.

            1 - Ground is at infinity (modeled by infinite elements).

        capname
            Array name for computed capacitance matrix.  Defaults to CMATRIX.

        Notes
        -----
        To invoke the CMATRIX macro, the exterior nodes of each conductor must
        be grouped into individual components using the CM command.  Each set
        of  independent components is assigned a component name with a common
        prefix followed by the conductor number.  A conductor system with a
        ground must also include the ground nodes as a component.  The ground
        component is numbered last in the component name sequence.

        A ground capacitance matrix relates charge to a voltage vector.  A
        ground matrix cannot be applied to a circuit modeler. The lumped
        capacitance matrix is a combination of  lumped "arrangements" of
        voltage differences between conductors.  Use the lumped capacitance
        terms in a circuit modeler to represent capacitances between
        conductors.

        Enclose all name-strings in single quotes in the CMATRIX command line.

        See the Mechanical APDL Theory Reference and HMAGSOLV in the Low-
        Frequency Electromagnetic Analysis Guide for details.

        This command does not support multiframe restarts.
        """
        command = "CMATRIX,%s,%s,%s,%s,%s" % (str(symfac), str(condname), str(numcond), str(grndkey), str(capname))
        return self.run(command, **kwargs)

    def bsm1(self, val1="", val2="", t="", **kwargs):
        """APDL Command: BSM1

        Specifies the bending curvature and moment relationship in plane XZ for
        beam sections.

        Parameters
        ----------
        val1
            Curvature component (κ1).

        val2
            Bending moment component (M1).

        t
            Temperature.

        Notes
        -----
        The behavior of beam elements is governed by the generalized-
        stress/generalized-strain relationship of the form:

        The BSM1 command, one of several nonlinear general beam section
        commands, specifies the bending curvature and moment for plane XZ of a
        beam section. The section data defined is associated with the section
        most recently defined (via the SECTYPE command).

        Unspecified values default to zero.

        Related commands are BSAX, BSM2, BSTQ, BSS1, BSS2, BSMD, and BSTE.

        For complete information, see Using Nonlinear General Beam Sections.
        """
        command = "BSM1,%s,%s,%s" % (str(val1), str(val2), str(t))
        return self.run(command, **kwargs)

    def memm(self, lab="", kywrd="", **kwargs):
        """APDL Command: MEMM

        Allows the current session to keep allocated memory

        Parameters
        ----------
        lab
             When Lab = KEEP, the memory manager's ability to acquire and keep
            memory is controlled by Kywrd

        kywrd
            Turns the memory “keep” mode on or off

            ON - Keep any memory allocated during the analysis.

            OFF - Use memory dynamically and free it up to other users after use (default).

        Notes
        -----
        You can use the MEMM command to ensure that memory intensive operations
        will always have the same memory available when the operations occur
        intermittently. Normally, if a large amount of memory is allocated for
        a specific operation, it will be returned to the system once the
        operation is finished. This option always maintains the highest level
        used during the analysis until the analysis is finished.

        The MEMM command does not affect the value you specify with the -m
        switch. When you allocate memory with the -m switch, that amount will
        always be available. However, if dynamic memory allocation in excess of
        the-m value occurs, you can use the MEMM command to ensure that amount
        is retained until the end of your analysis.
        """
        command = "MEMM,%s,%s" % (str(lab), str(kywrd))
        return self.run(command, **kwargs)

    def trans(self, fname="", ext="", **kwargs):
        """APDL Command: TRANS

        Reformats File.GRPH for improved performance with plotters.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Reformats current Fname.GRPH data (based on color) for improved
        performance with pen plotters.
        """
        command = "TRANS,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def sflex(self, ffax="", ffby="", ffbz="", ffto="", fftsy="", fftsz="",
              **kwargs):
        """APDL Command: SFLEX

        Sets flexibility factors for the currently defined pipe element
        section.

        Parameters
        ----------
        ffax
            Factor to increase axial flexibility. The default value is 1.0.

        ffby
            Factor to increase bending flexibility about element y axis
            (bending in the element x-z plane). The default value is 1.0.

        ffbz
            Factor to increase bending flexibility about element z axis
            (bending in the element x-y plane). The default value is FFBY.

        ffto
            Factor to increase torsional flexibility. The default value is 1.0.

        fftsy
            Factor to increase transverse shear flexibility in the element x-z
            plane. The default value is 1.0.

        fftsz
            Factor to increase transverse shear flexibility in the element x-y
            plane. The default value is FFTSY.

        Notes
        -----
        The SFLEX command sets section-flexibility factors for sections used by
        pipe elements.

        To increase stiffness, use a flexibility factor of less than 1.0.

        The FFBY and FFTSY arguments affect motion in the element x-z plane,
        and the FFBZ and FFTSZ arguments affect motion in the element x-y
        plane. For stout pipe structures with low slenderness ratios, set both
        FFBY and FFTSY--and/or both FFBZ and FFTSZ (the related bending and
        transverse shear factors)--to the same value to obtain the expected
        flexibility effect.

        When issued, the SFLEX command applies to the pipe section most
        recently defined via the SECTYPE command.

        SFLEX is valid only for linear material properties and small strain
        analyses. The command does not support offsets, temperature loading, or
        initial state loading. While the resulting displacements and reactions
        are valid, the stresses may not be valid.
        """
        command = "SFLEX,%s,%s,%s,%s,%s,%s" % (str(ffax), str(ffby), str(ffbz), str(ffto), str(fftsy), str(fftsz))
        return self.run(command, **kwargs)

    def clabel(self, wn="", key="", **kwargs):
        """APDL Command: /CLABEL

        Specifies contour labeling.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        key
            Labeling key:

            0 or 1 - Label contours with legend or color (default).

            -1 - No contour labeling.

            N - Same as 1 except show alphabetic legend only on every Nth element.

        Notes
        -----
        Labels contours for identification with alphabetic legend for vector
        displays and color for raster displays.  Number of contours is
        automatically reduced to 9 (or fewer) for clarity.  Use /CONTOUR
        command to increase (24 maximum for alphabetic labeling; no limit for
        color labeling).

        This command is valid in any processor.
        """
        command = "/CLABEL,%s,%s" % (str(wn), str(key))
        return self.run(command, **kwargs)

    def rmcap(self, refname="", c1="", c2="", **kwargs):
        """APDL Command: RMCAP

        Defines lumped capacitance pairs between conductors C1 and C2 for a ROM
        method.

        Parameters
        ----------
        refname
            Reference name for capacitance pair definition.

        c1
            First conductor (between 1 and 5).

        c2
            Second conductor (between 1 and 5).

        Notes
        -----
        For a capacitance definition between conductor C1 and C2, node
        components COND%C1% and COND%C2% (see CM command) must be present
        containing the conductor nodes. If C1 and C2 are blank, the capacitance
        definition with RefName will be deleted.  (For example, if C1 = 1, and
        C2 = 2, then node components COND1 and COND2 must be defined).

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMCAP,%s,%s,%s" % (str(refname), str(c1), str(c2))
        return self.run(command, **kwargs)

    def celist(self, neqn1="", neqn2="", ninc="", option="", **kwargs):
        """APDL Command: CELIST

        Lists the constraint equations.

        Parameters
        ----------
        neqn1, neqn2, ninc
            List constraint equations from NEQN1 to NEQN2 (defaults to NEQN1)
            in steps of NINC (defaults to 1).  If NEQN1 = ALL (default), NEQN2
            and NINC are ignored and all constraint equations are listed.

        option
            Options for listing constraint equations:

            ANY - List equation set if any of the selected nodes are in the set (default). Only
                  externally-generated constraint equations are listed.

            ALL - List equation set only if all of the selected nodes are in the set. Only
                  externally-generated constraint equations are listed.

            INTE - List internally-generated constraint equations that are associated with MPC-
                   based contact. Constraint equations are listed only if all
                   the nodes in the set are selected.

            CONV - Convert internal constraint equations to external constraint equations.
                   Internal constraint equations are converted only if all of
                   the nodes in the set are selected.

        Notes
        -----
        This command is valid in any processor. However, the INTE and CONV
        options are only valid in the Solution processor after a SOLVE command
        has been issued.
        """
        command = "CELIST,%s,%s,%s,%s" % (str(neqn1), str(neqn2), str(ninc), str(option))
        return self.run(command, **kwargs)

    def layerp26(self, num="", **kwargs):
        """APDL Command: LAYERP26

        Specifies the element layer for which data are to be stored.

        Parameters
        ----------
        num
            Layer-processing mode:

            N - The layer number to process. The default value is 1.

        Notes
        -----
        Defines the element layer for which results data are to be stored for
        postprocessing.  Applies to stress and strain data for layered elements
        BEAM161, SHELL163, SHELL181, SOLID185, SOLID186, SOLSH190, SHELL208,
        SHELL209, SHELL281, REINF265, and ELBOW290.

        The SHELL command can be used (for shell elements) to specify a
        location (TOP, MID, BOT) within the layer for selection on the ESOL
        command. Transverse shear stresses for MID are linearly averaged from
        TOP and BOT, and do not reflect a parabolic distribution. Setting
        KEYOPT(8) = 2 for SHELL181, SHELL208, SHELL209, SHELL281, and ELBOW290
        writes the mid-surface values directly to the results file and yields
        more accurate values than linear averaging.

        That this command cannot be used for energy output, as energy is a per-
        element quantity.

        When using the LAYERP26 command with SHELL181, SOLID185, SOLID186,
        SOLSH190, SHELL208, or SHELL209, KEYOPT(8) must be set to 1 (or 2 for
        SHELL181, SHELL208, SHELL209, SHELL281, and ELBOW290) in order to store
        results for all layers.

        For the ANSYS LS-DYNA product, this command works differently than
        described above.  For SHELL163 and BEAM161, you must first use EDINT
        during the solution phase to define the integration points for which
        you want output data.  Be aware that the output location for SHELL163
        data is always at the integration point, so "top" and "bottom" refer to
        the top or bottom integration point, not necessarily the top or bottom
        surface.  For more information, see the ANSYS LS-DYNA User's Guide.

        In POST26, the ESOL data stored is based on the active LAYERP26
        specification at the time the data is stored. To store data at various
        specifications (for example, layers 2 and 5), issue a STORE command
        before each new specification.
        """
        command = "LAYERP26,%s" % (str(num))
        return self.run(command, **kwargs)

    def layer(self, num="", **kwargs):
        """APDL Command: LAYER

        Specifies the element layer for which data are to be processed.

        Parameters
        ----------
        num
            Layer-processing mode:

            N - The layer number to process. The default value is 0.

            FCMAX - Processes the layer with the largest failure criteria.

        Notes
        -----
        Specifies the element layer for which results data are to be listed,
        plotted, or otherwise processed.

        Applies to stress and strain data for layered elements SHELL163,
        SHELL181, SHELL281, ELBOW290, SOLID185, SOLID186, SOLSH190, SHELL208,
        SHELL209, REINF264, and REINF265; heat flux and heat gradient for
        SHELL131 and SHELL132.

        The SHELL command may then be used (with shell elements) to specify a
        location (TOP, MID, BOT) within the layer for output. (The SHELL
        command does not apply to thermal shell elements SHELL131 and
        SHELL132.) Transverse shear stresses for MID are linearly averaged from
        TOP and BOT, and do not reflect a parabolic distribution. Setting
        KEYOPT(8) = 2 for SHELL181, SHELL281, SHELL208, SHELL209, and ELBOW290
        writes the mid-surface values directly to the results file and yields
        more accurate values than linear averaging.

        Because energy is a per-element quantity, you cannot use this command
        for energy output.

        When using the LAYER command with SHELL181, SOLID185, SOLID186,
        SOLSH190, SHELL208, SHELL209, SHELL281, and ELBOW290, KEYOPT(8) must be
        set to 1 (or 2 for SHELL181, SHELL281, ELBOW290, SHELL208, and
        SHELL209) in order to store results for all layers.

        When NUM = FCMAX, you must provide the failure criterion input. If
        specifying input via the FC command, all structural elements are
        processed. For more information, see the documentation for the FC
        command.

        Use this command with RSYS,LSYS to display results in the layer
        coordinate system for a particular layer.

        For the ANSYS LS-DYNA product, this command works differently than
        described above.  For SHELL163, you must first use EDINT during the
        solution phase to define the integration points for which you want
        output data.  Be aware that the output location for SHELL163 data is
        always at the integration point, so "top" and "bottom" refer to the top
        or bottom integration point, not necessarily the top or bottom surface.
        For more information, see the ANSYS LS-DYNA User's Guide.
        """
        command = "LAYER,%s" % (str(num))
        return self.run(command, **kwargs)

    def edrc(self, option="", nrbf="", ncsf="", dtmax="", **kwargs):
        """APDL Command: EDRC

        Specifies rigid/deformable switch controls in an explicit dynamic
        analysis.

        Parameters
        ----------
        option
            Label identifying option to be performed.

            ADD - Define rigid/deformable controls (default).

            DELE - Delete rigid/deformable controls.

            LIST - List rigid/deformable controls.

        nrbf
            Flag to delete/activate nodal rigid bodies. If nodal rigid bodies
            or generalized weld definitions are active in the deformable bodies
            that are switched to rigid, then the definitions should be deleted
            to avoid instabilities.

            0 - No change from previous status (default).

            1 - Delete.

            2 - Activate.

        ncsf
            Flag to delete/activate nodal constraint set. If nodal
            constraint/spotweld definitions are active in the deformable bodies
            that are switched to rigid, then the definitions should be deleted
            to avoid instabilities.

            0 - No change from previous status (default).

            1 - Delete.

            2 - Activate.

        --
            Unused field.

        tdmax
            Maximum allowed time step after restart (no default).

        Notes
        -----
        This command is only valid in an explicit dynamic small restart
        analysis (EDSTART,2). Use this command when you do a rigid/deformable
        switch (EDRD command) and you want to control constraints defined by
        other means for the deformable body (such as nodal constraints or a
        weld). For example, if a deformable body has nodal constraints defined
        and it is switched to a rigid body, the nodal constraints should be
        deleted since they are invalid for the rigid body. Later on, if you
        want to switch the rigid body to deformable again and retain the nodal
        constraints, you can use EDRC to activate the constraints previously
        defined for the deformable body. Otherwise, the nodal constraints
        remain deactivated.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDRC,%s,%s,%s,%s" % (str(option), str(nrbf), str(ncsf), str(dtmax))
        return self.run(command, **kwargs)

    def sspd(self, d11="", d21="", d31="", d22="", d32="", d33="", t="",
             **kwargs):
        """APDL Command: SSPD

        Specifies a preintegrated bending stiffness for shell sections.

        Parameters
        ----------
        d11, d21, d31, d22, d32, d33
            Bending stiffness component (symmetric lower part of submatrix
            [D]).

        t
            Temperature.

        Notes
        -----
        The behavior of shell elements is governed by the generalized-
        stress/generalized-strain relationship of the form:

        The SSPD command, one of several preintegrated shell section commands,
        specifies the bending stiffness quantity (submatrix [D] data) for a
        preintegrated shell section. The section data defined is associated
        with the section most recently defined (via the SECTYPE command).

        Unspecified commands default to zero.

        Related commands are SSPA, SSPB, SSPE, SSMT, SSBT, and SSPM.

        If you are using the SHELL181 or SHELL281 element's Membrane option
        (KEYOPT(1) = 1), it is not necessary to issue this command.

        For complete information, see Using Preintegrated General Shell
        Sections.
        """
        command = "SSPD,%s,%s,%s,%s,%s,%s,%s" % (str(d11), str(d21), str(d31), str(d22), str(d32), str(d33), str(t))
        return self.run(command, **kwargs)

    def acel(self, acel_x="", acel_y="", acel_z="", **kwargs):
        """APDL Command: ACEL

        Specifies the linear acceleration of the global Cartesian reference
        frame for the analysis.

        Parameters
        ----------
        acel_x, acel_y, acel_z
            Linear acceleration of the reference frame along global Cartesian
            X, Y, and Z axes, respectively.

        Notes
        -----
        In the absence of any other loads or supports, the acceleration of the
        structure in each of the global Cartesian (X, Y, and Z) axes would be
        equal in magnitude but opposite in sign to that applied in the ACEL
        command. Thus, to simulate gravity (by using inertial effects),
        accelerate the reference frame with an ACEL command in the direction
        opposite to gravity.

        You can define the acceleration for the following analyses types:

        Static (ANTYPE,STATIC)

        Harmonic (ANTYPE,HARMIC), full or mode-superposition method

        Transient (ANTYPE,TRANS)

        Substructure (ANTYPE,SUBSTR).

        For all transient dynamic (ANTYPE,TRANS) analyses, accelerations are
        combined with the element mass matrices to form a body force load
        vector term. The element mass matrix may be formed from a mass input
        constant or from a nonzero density (DENS) property, depending upon the
        element type.

        For analysis type ANTYPE,HARMIC, the acceleration is assumed to be the
        real component with a zero imaginary component.

        Units of acceleration and mass must be consistent to give a product of
        force units.

        The ACEL command supports tabular boundary conditions (%TABNAME_X%,
        %TABNAME_Y%, and %TABNAME_Z%) for ACEL_X, ACEL_Y, and ACEL_Z input
        values (*DIM) as a function of both time and frequency for full
        transient and harmonic analyses.

        Related commands for rotational effects are CMACEL, CGLOC, CGOMGA,
        DCGOMG, DOMEGA, OMEGA, CMOMEGA, and CMDOMEGA.

        See Analysis Tools in the Mechanical APDL Theory Reference for more
        information.

        This command is also valid in /PREP7.
        """
        command = "ACEL,%s,%s,%s" % (str(acel_x), str(acel_y), str(acel_z))
        return self.run(command, **kwargs)

    def arscale(self, na1="", na2="", ninc="", rx="", ry="", rz="", kinc="",
                noelem="", imove="", **kwargs):
        """APDL Command: ARSCALE

        Generates a scaled set of areas from a pattern of areas.

        Parameters
        ----------
        na1, na2, ninc
            Set of areas, NA1 to NA2 in steps of NINC, that defines the pattern
            to be scaled.  NA2 defaults to NA1, NINC defaults to 1.  If NA1 =
            ALL, NA2 and NINC are ignored and the pattern is defined by all
            selected areas.  If NA1 = P, graphical picking is enabled and all
            remaining arguments are ignored (valid only in the GUI).  A
            component name may also be substituted for NA1 (NA2 and NINC are
            ignored).

        rx, ry, rz
            Scale factors to be applied to the X, Y, and Z keypoint coordinates
            in the active coordinate system.  (RR, R θ, RZ for cylindrical; RR,
            R θ, R Φ for spherical).  Note that the R θ and R Φ scale factors
            are interpreted as angular offsets.  For example, if CSYS = 1, RX,
            RY, RZ input of (1.5,10,3) would scale the specified keypoints 1.5
            times in the radial and 3 times in the Z direction, while adding an
            offset of 10 degrees to the keypoints.  Zero, blank, or negative
            scale factor values are assumed to be 1.0.  Zero or blank angular
            offsets have no effect.

        kinc
            Increment to be applied to keypoint numbers for generated set.  If
            zero, the lowest available keypoint numbers will be assigned
            [NUMSTR].

        noelem
            Specifies whether nodes and elements are also to be generated:

            0 - Nodes and elements associated with the original areas will be generated
                (scaled) if they exist.

            1 - Nodes and elements will not be generated.

        imove
            Specifies whether areas will be moved or newly defined:

            0 - Additional areas will be generated.

            1 - Original areas will be moved to new position (KINC and NOELEM are ignored).
                Use only if the old areas are no longer needed at their
                original positions.  Corresponding meshed items are also moved
                if not needed at their original position.

        Notes
        -----
        Generates a scaled set of areas (and their corresponding keypoints,
        lines, and mesh) from a pattern of areas.  The MAT, TYPE, REAL, and
        ESYS attributes are based on the areas in the pattern and not the
        current settings.  Scaling is done in the active coordinate system.
        Areas in the pattern could have been generated in any coordinate
        system.  However, solid modeling in a toroidal coordinate system is not
        recommended.
        """
        command = "ARSCALE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(na1), str(na2), str(ninc), str(rx), str(ry), str(rz), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def swlist(self, ecomp="", **kwargs):
        """APDL Command: SWLIST

        Lists spot weld sets.

        Parameters
        ----------
        ecomp
            Name of an existing spot weld set that was previously defined using
            SWGEN. If Ecomp = ALL (default), all spot weld sets are listed.

        Notes
        -----
        This command lists spot weld node, beam, and contact pair information
        for all defined spot weld sets, or for the specified set. To ensure
        that all defined spotwelds are listed, issue CMSEL,ALL (to select all
        components) before issuing the SWLIST command.

        When SWLIST is issued in POST1, the beam forces and moments are output.
        For the case of a deformable spot weld, the stresses are also output in
        the beam local coordinate system.
        """
        command = "SWLIST,%s" % (str(ecomp))
        return self.run(command, **kwargs)

    def pletab(self, itlab="", avglab="", **kwargs):
        """APDL Command: PLETAB

        Displays element table items.

        Parameters
        ----------
        itlab
            User-defined label, as specified with the ETABLE command, of item
            to be displayed.

        avglab
            Averaging operation:

            NOAV - Do not average element items at common nodes (default).

            AVG - Average the element items at common nodes.

        Notes
        -----
        Displays items stored in the table defined with the ETABLE command for
        the selected elements.  For display purposes, items are assumed to be
        constant over the element and assigned to each of its nodes.  Contour
        display lines (lines of constant value) are determined by linear
        interpolation within each element from the nodal values.  These nodal
        values have the option of being averaged (values are averaged at a node
        whenever two or more elements connect to the same node) or not averaged
        (discontinuous).  The discontinuity between contour lines of adjacent
        elements is an indication of the gradient across elements.

        Portions of this command are not supported by PowerGraphics
        [/GRAPHICS,POWER].
        """
        command = "PLETAB,%s,%s" % (str(itlab), str(avglab))
        return self.run(command, **kwargs)

    def rmmselect(self, nmode="", method="", dmin="", dmax="", **kwargs):
        """APDL Command: RMMSELECT

        Selects modes for the ROM method.

        Parameters
        ----------
        nmode
            Total number of modes to be selected

        method
            Method for mode selection. Valid methods are:

            TMOD - Automated selection using a test load. TMOD must be enclosed in single quotes.

        dmin
            Lower bound for total deflection range.

        dmax
            Upper bound for total deflection range.

        Notes
        -----
        Select pertinent modes for use in a ROM. Pertinent mode selection may
        be enhanced by using the deflection state of the structure
        representative of the operating nature of the device (Method = TMOD). A
        static analysis with an applied Test Load may be used.  The test load
        displacements must be extracted at the neutral plane of the device (if
        the device is stress-stiffened), or at any plane of the device (non-
        stress-stiffened). A node component "NEUN" must be defined for the
        plane of nodes, and the displacements extracted using the RMNDISP
        command prior to issuing this command. If Method = NMOD, use the first
        Nmode eigenmodes to select the pertinent modes for the ROM tool. Only
        those modes are selected that act in the operating direction of the
        structure [RMANL].

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.

        jobname.evx, jobname.evy, jobname.evz, jobname.evn, jobname.evl

        Test load and element load neutral plane displacement files:
        jobname.tld, jobname.eld
        """
        command = "RMMSELECT,%s,%s,%s,%s" % (str(nmode), str(method), str(dmin), str(dmax))
        return self.run(command, **kwargs)

    def cmacel(self, cm_name="", cmacel_x="", cmacel_y="", cmacel_z="",
               **kwargs):
        """APDL Command: CMACEL

        Specifies the translational acceleration of an element component

        Parameters
        ----------
        cm_name
            The name of the element component.

        cmacel_x, cmacel_y, cmacel_z
            Acceleration of the element component CM_NAME in the global
            Cartesian X, Y, and Z axis directions, respectively.

        Notes
        -----
        The CMACEL command specifies the translational acceleration of the
        element component in each of the global Cartesian (X, Y, and Z) axis
        directions.

        Components for which you want to specify acceleration loading must
        consist of elements only. The elements you use cannot be part of more
        than one component, and elements that share nodes cannot exist in
        different element components. You cannot apply the loading to an
        assembly of element components.

        To simulate gravity (by using inertial effects), accelerate the
        structure in the direction opposite to gravity. For example, apply a
        positive CMACELY to simulate gravity acting in the negative Y
        direction. Units are length/time2.

        You can define the acceleration for the following analyses types:

        Static (ANTYPE,STATIC)

        Harmonic (ANTYPE,HARMIC), full or mode-superposition method

        Transient (ANTYPE,TRANS), full or mode-superposition method

        Substructure (ANTYPE,SUBSTR)

        Accelerations are combined with the element mass matrices to form a
        body force load vector term. Units of acceleration and mass must be
        consistent to give a product of force units.

        In a modal harmonic or transient analysis, you must apply the load in
        the modal portion of the analysis. Mechanical APDL calculates a load
        vector and writes it to the mode shape file, which you can apply via
        the LVSCALE command.

        The CMACEL command supports tabular boundary conditions (%TABNAME_X%,
        %TABNAME_Y%, and %TABNAME_Z%) for CMACEL_X, CMACEL_Y, and CMACEL_Z
        input values (*DIM) as a function of both time and frequency for full
        transient and harmonic analyses.

        Related commands for inertia loads are ACEL, CGLOC, CGOMGA, DCGOMG,
        DOMEGA, OMEGA, CMOMEGA, and CMDOMEGA.

        See Analysis Tools in the Mechanical APDL Theory Reference for more
        information.

        This command is also valid in /PREP7.
        """
        command = "CMACEL,%s,%s,%s,%s" % (str(cm_name), str(cmacel_x), str(cmacel_y), str(cmacel_z))
        return self.run(command, **kwargs)

    def esize(self, size="", ndiv="", **kwargs):
        """APDL Command: ESIZE

        Specifies the default number of line divisions.

        Parameters
        ----------
        size
            Default element edge length on surface boundaries (i.e., lines).
            Divisions are automatically calculated (rounded upward to next
            integer) from line lengths.  If SIZE is zero (or blank), use NDIV.

        ndiv
            Default number of element divisions along region boundary lines.
            Not used if SIZE is input.

        Notes
        -----
        Specifies the default number of line divisions (elements) to be
        generated along the region boundary lines. The number of divisions may
        be defined directly or automatically calculated. Divisions defined
        directly for any line [LESIZE, KESIZE, etc.] are retained. For adjacent
        regions, the divisions assigned to the common line for one region are
        also used for the adjacent region. See the MOPT command for additional
        meshing options.

        For free meshing operations, if smart element sizing is being used
        [SMRTSIZE] and ESIZE,SIZE has been specified, SIZE will be used as a
        starting element size, but will be overridden (i.e., a smaller size may
        be used) to accommodate curvature and small features.

        This command is also valid for rezoning.
        """
        command = "ESIZE,%s,%s" % (str(size), str(ndiv))
        return self.run(command, **kwargs)

    def reswrite(self, fname="", cflag="", **kwargs):
        """APDL Command: RESWRITE

        Appends results data from the database to a results file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path). An unspecified directory
            path defaults to the working directory; in this case, you can use
            all 248 characters for the file name.

        --, --, --
            Unused fields.

        cflag
            0

            0 - The complex results flag is set to 0 in the results file header. This is the
                default option.

            1 - The complex results flag is set to 1 in the results file header.

        Notes
        -----
        The RESWRITE command appends a data set to the specified file by
        writing the results data currently in the database. If the intended
        results file does not exist, it will be created and will include the
        geometry records. The current load step, substep, and time (or
        frequency) value are maintained. All data (summable and nonsummable)
        are written.

        When complex results are appended, cFlag must be set to 1 so that the
        header is consistent with the results written on the file.

        The command is primarily intended for use in a top-down substructuring
        analysis, where the full model is resumed and the results data read
        from the use pass results file (SET), and subsequently from all
        substructure expansion pass results files (APPEND). The full set of
        data in memory can then be written out via the RESWRITE command to
        create a complete results file (as though you had run a
        nonsubstructured analysis).

        The RESWRITE command can also be used to write a global results file
        for a distributed parallel (Distributed ANSYS) solution. This should
        only be necessary if the RESCOMBINE command was used to combine results
        from local results files into the database. The RESWRITE command can
        then be used to write the combined results into a new results file.
        This new results file will essentially contain the current set of
        results data for the entire (i.e., global) model.
        """
        command = "RESWRITE,%s,%s" % (str(fname), str(cflag))
        return self.run(command, **kwargs)

    def hmagsolv(self, freq="", nramp="", cnva="", cnvv="", cnvc="", cnve="",
                 neqit="", **kwargs):
        """APDL Command: HMAGSOLV

        Specifies 2-D or axisymmetric harmonic magnetic solution options and
        initiates the solution.

        Parameters
        ----------
        freq
            Analysis frequency (Hz).

        nramp
            Number of ramped substeps for the first load step of a nonlinear
            2-D harmonic electromagnetic solution.  Defaults to 3.  If NRAMP =
            -1, ignore the ramped load step entirely.

        cnva
            Convergence tolerance on the program calculated reference value for
            the magnetic vector potential degree of freedom.  Defaults to
            0.001.

        cnvv
            Convergence tolerance on the program calculated reference value for
            the time-integrated electric potential VOLT.    Defaults to 0.001.

        cnvc
            Convergence tolerance on the program calculated reference value for
            the current degree of freedom CURR.  Defaults to 0.001.

        cnve
            Convergence tolerance on the program calculated reference value for
            the voltage drop degree of freedom EMF.  Defaults to 0.001.

        neqit
            Maximum number of equilibrium iterations per load step.  Defaults
            to 50.

        Notes
        -----
        HMAGSOLV invokes an ANSYS macro which specifies harmonic
        electromagnetic solution options and initiates the solution.  The macro
        is applicable to any ANSYS 2-D or axisymmetric linear or nonlinear
        harmonic analysis.  Results are only stored for the final converged
        solution.  (In POST1, issue *SET,LIST to identify the load step of
        solution results.)  The macro internally determines if a nonlinear
        analysis is required based on magnetic material properties defined in
        the database.

        The macro performs a two-load-step solution sequence.  The first load
        step ramps the applied loads over a prescribed number of substeps
        (NRAMP), and the second load step calculates the converged solution.
        For linear problems, only a single load step solution is performed.
        The ramped load step can be bypassed by setting NRAMP to -1.

        A 3-D harmonic electromagnetic analysis is available for linear
        solutions only and does not require this solution macro.

        The following analysis options and nonlinear options are controlled by
        this macro:  KBC, NEQIT, NSUBST, CNVTOL, OUTRES.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "HMAGSOLV,%s,%s,%s,%s,%s,%s,%s" % (str(freq), str(nramp), str(cnva), str(cnvv), str(cnvc), str(cnve), str(neqit))
        return self.run(command, **kwargs)

    def output(self, fname="", ext="", loc="", **kwargs):
        """APDL Command: /OUTPUT

        Redirects text output to a file or to the screen.

        Parameters
        ----------
        fname
            Filename and directory path (248 character maximum, including
            directory) to which text output will be redirected (defaults to
            Jobname if Ext is specified).  For interactive runs, Fname = TERM
            (or blank) redirects output to the screen.  For batch runs, Fname =
            blank (with all remaining command arguments blank) redirects output
            to the  default system output file.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        loc
            Location within a file to which output will be written:

            (blank) - Output is written starting at the top of the file (default).

            APPEND - Output is appended to the existing file.

        Notes
        -----
        Text output includes responses to every command and GUI function,
        notes, warnings, errors, and other informational messages.  Upon
        execution of /OUTPUT,Fname, Ext, ..., all subsequent text output is
        redirected to the file Fname.Ext.  To redirect output back to the
        default location, issue /OUTPUT (no arguments).

        Note:: : When using the GUI, output from list operations [NLIST, DLIST,
        etc.] is always sent to a list window regardless of the /OUTPUT
        setting.  The output can then be saved on a file or copied to the
        /OUTPUT location using the File menu in the list window.

        This command is valid in any processor.
        """
        command = "/OUTPUT,%s,%s,%s" % (str(fname), str(ext), str(loc))
        return self.run(command, **kwargs)

    def dump(self, nstrt="", nstop="", **kwargs):
        """APDL Command: DUMP

        Dumps the contents of a binary file.

        Parameters
        ----------
        nstrt, nstop
            Dump file from record NSTRT (defaults to 1) to NSTOP (defaults to
            NSTRT).  If NSTRT = HEAD, dump only record 1 of the file (NSTOP and
            the format specification are ignored).  If NSTRT = ALL, dump the
            entire file.

        Notes
        -----
        Dumps the file named on the AUX2 FILEAUX2 command according the format
        specified on the FORM command.
        """
        command = "DUMP,%s,%s" % (str(nstrt), str(nstop))
        return self.run(command, **kwargs)

    def catiain(self, name="", extension="", path="", **kwargs):
        """APDL Command: ~CATIAIN

        Transfers a CATIA model into the ANSYS program.

        Parameters
        ----------
        name
            The name of a valid CATIA model, created with CATIA 4.x or lower.
            The first character of the file name must be an alphanumeric.
            Special characters such as & - and * and spaces are not permitted
            in the part name.

        extension
            The extension for the file. The default extension is .model.

        path
            The path name of the directory in which the file resides, enclosed
            in single quotes. The default path name is the current working
            directory.

        --
            Unused field.

        --
            Unused field.

        blank
            Sets whether to import “blanked” entities.

            0 - Does not import “blanked” (suppressed) CATIA entities (default).

            1 - Imports “blanked” entities. The portions of CATIA data that were suppressed
                will be included in the import.

        --
            Unused field.

        Notes
        -----
        More information on importing CATIA parts is available in CATIA V4 in
        the Connection User's Guide.
        """
        command = "~CATIAIN,%s,%s,%s" % (str(name), str(extension), str(path))
        return self.run(command, **kwargs)

    def wpstyl(self, snap="", grspac="", grmin="", grmax="", wptol="",
               wpctyp="", grtype="", wpvis="", snapang="", **kwargs):
        """APDL Command: WPSTYL

        Controls the display and style of the working plane.

        Parameters
        ----------
        snap
            Snap increment for a locational pick (1E-6 minimum).  If -1, turn
            off snap capability.  For example, a picked location of 1.2456 with
            a snap of 0.1 gives 1.2, with 0.01 gives 1.25, with 0.001 gives
            1.246, and with 0.025 gives 1.250 (defaults to 0.05).

        grspac
            Graphical spacing between grid points.  For graphical
            representation only and not related to snap points  (defaults to
            0.1).

        grmin, grmax
            Defines the size of a square grid (if WPCTYP = 0) to be displayed
            over a portion of the working plane.  The opposite corners of the
            grid will be located at grid points nearest the working plane
            coordinates of (GRMIN,GRMIN) and (GRMAX,GRMAX).  If a polar system
            (WPCTYP = 1), GRMAX is the outside radius of grid and GRMIN is
            ignored.  If GRMIN = GRMAX, no grid will be displayed (defaults to
            -1.0 and 1.0 for GRMIN and GRMAX respectively).

        wptol
            The tolerance that an entity's location can deviate from the
            specified working plane, while still being considered on the plane.
            Used only for locational picking of vertices for polygons and
            prisms (defaults to 0.003).

        wpctyp
            Working plane coordinate system type:

            0 - Cartesian (default).  If working plane tracking is on [CSYS,4], the updated
                active coordinate system will also be Cartesian.

            1 - Polar.  If working plane tracking is on, the updated active coordinate system
                will be cylindrical.

            2 - Polar.  If working plane tracking is on, the updated active coordinate system
                will be spherical.

        grtype
            Grid type:

            0 - Grid and WP triad.

            1 - Grid only.

            2 - WP triad only (default).

        wpvis
            Grid visibility:

            0 - Do not show GRTYPE entities (grid and/or triad) (default).

            1 - Show GRTYPE entities.  Cartesian working planes will be displayed with a
                Cartesian grid, polar with a polar grid.

        snapang
            Snap angle (0--180) in degrees.  Used only if WPCTYP = 1 or 2.
            Defaults to 5 degrees.

        Notes
        -----
        Use WPSTYL,DEFA to reset the working plane to its default location and
        style.  Use WPSTYL,STAT to list the status of the working plane.  Blank
        fields will keep present settings.

        It is possible to specify SNAP and WPTOL values that will cause
        conflicts during picking operations. Check your values carefully, and
        if problems are noted, revert to the default values.

        WPSTYL with no arguments will toggle the grid on and off.  The working
        plane can be displayed in the non-GUI interactive mode only after
        issuing a /PLOPTS,WP,1 command.  See the Modeling and Meshing Guide for
        more information on working plane tracking.  See /PLOPTS command for
        control of hidden line working plane.

        This command is valid in any processor.
        """
        command = "WPSTYL,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(snap), str(grspac), str(grmin), str(grmax), str(wptol), str(wpctyp), str(grtype), str(wpvis), str(snapang))
        return self.run(command, **kwargs)

    def areas(self, **kwargs):
        """APDL Command: AREAS

        Specifies "Areas" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "AREAS," % ()
        return self.run(command, **kwargs)

    def cbtmp(self, temp="", **kwargs):
        """APDL Command: CBTMP

        Specifies a temperature for composite-beam input.

        Parameters
        ----------
        temp
            Temperature value.

        Notes
        -----
        The CBTMP command, one of several composite beam-section commands,
        specifies a temperature to be associated with the data input via
        subsequent CBMX (preintegrated cross-section stiffness), CBMD
        (preintegrated section mass), or CBTE (thermal-expansion) commands.

        The specified temperature remains active until the next CBTMP command
        is issued.

        An unspecified temperature value defaults to zero.

        For complete information, see Using Preintegrated Composite Beam
        Sections.
        """
        command = "CBTMP,%s" % (str(temp))
        return self.run(command, **kwargs)

    def imagin(self, ir="", ia="", name="", facta="", **kwargs):
        """APDL Command: IMAGIN

        Forms an imaginary variable from a complex variable.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        ia
            Reference number of the variable to be operated on.

        --, --
            Unused fields.

        name
            Thirty-two character name for identifying the variable on the
            printout and displays.  Embedded blanks are compressed upon output.

        --, --
            Unused fields.

        facta
            Scaling factor (positive or negative) applied to variable IA
            (defaults to 1.0).

        Notes
        -----
        This command forms a new variable from a complex variable by storing
        the imaginary part as the real part.  The imaginary part can then be
        used in other operations.  Used only with harmonic analyses
        (ANTYPE,HARMIC).

        Complex variables are stored in two-column arrays with the real
        component stored in the first column and the imaginary component stored
        in the second column.  This command extracts the value stored in the
        second column (i.e., imaginary component).  However, with harmonic
        analyses, all variables are stored in two-column arrays as complex
        variables.  If the variable is not complex, then the same value is
        stored in both columns.  This command will extract the variable in the
        second column of the array, even if this variable is not the imaginary
        component of a complex variable.
        """
        command = "IMAGIN,%s,%s,%s,%s" % (str(ir), str(ia), str(name), str(facta))
        return self.run(command, **kwargs)

    def ssmt(self, mt11="", mt22="", mt12="", t="", **kwargs):
        """APDL Command: SSMT

        Specifies preintegrated membrane thermal effects for shell sections.

        Parameters
        ----------
        mt11, mt22, mt12
            Membrane thermal effects component [MT].

        t
            Temperature.

        Notes
        -----
        The behavior of shell elements is governed by the generalized-
        stress/generalized-strain relationship of the form:

        The SSMT command, one of several preintegrated shell section commands,
        specifies the membrane thermal effects quantity (submatrix [MT] data)
        for a preintegrated shell section. The section data defined is
        associated with the section most recently defined (via the SECTYPE
        command).

        The [MT] quantity represents membrane stress resultants caused by a
        unit raise in temperature on a fully constrained model. For a layered
        composite shell, it is usually necessary to specify both the [MT] and
        [BT] quantities (by issuing the SSMT and SSBT commands, respectively).

        Unspecified values default to zero.

        Related commands are SSPA, SSPB, SSPD, SSPE, SSBT, and SSPM.

        For complete information, see Using Preintegrated General Shell
        Sections.
        """
        command = "SSMT,%s,%s,%s,%s" % (str(mt11), str(mt22), str(mt12), str(t))
        return self.run(command, **kwargs)

    def solve(self, action="", **kwargs):
        """APDL Command: SOLVE

        Starts a solution.

        Parameters
        ----------
        action
            Action to be performed on solve (used only for linear perturbation
            analyses).

            ELFORM  - Reform all appropriate element matrices in the first phase of a linear
                      perturbation analysis.

        Notes
        -----
        Starts the solution of one load step of a solution sequence based on
        the current analysis type and option settings. Use Action = ELFORM only
        in the first phase of a linear perturbation analysis.
        """
        command = "SOLVE,%s" % (str(action))
        return self.run(command, **kwargs)

    def nora(self, area="", ndir="", **kwargs):
        """APDL Command: NORA

        Rotates nodal coordinate systems to surface normal

        Parameters
        ----------
        area
            The area number containing the nodes to be rotated to their
            normals. If ALL, applies to all selected areas (see the ASEL
            command). If AREA = P, graphical picking is enabled.

        ndir
            Direction of the normal. If NDIR = -1, the nodal coordinate system
            is rotated in the opposite direction of the surface normal. The
            default is the same direction as the surface normal.

        Notes
        -----
        The NORA command rotates the X-axis of the nodal coordinate system to
        the surface normal. The rotated nodal coordinate systems may be
        displayed through the /PSYMB command. In case multiple areas are
        selected, there could be conflicts at the boundaries. If a node belongs
        to two areas that have a different normal, its nodal coordinate system
        will be rotated to the area normal with the lowest number. You can use
        the AREVERSE and ANORM commands to rotate the surface normals in the
        appropriate direction. Keep the following in mind when using the NORA
        command:

        If the nodal coordinate system is parallel to the global Cartesian
        system, it is not displayed through the /PSYMB command.

        Previously specified rotation on the selected nodes are overridden.
        """
        command = "NORA,%s,%s" % (str(area), str(ndir))
        return self.run(command, **kwargs)

    def plcint(self, action="", id="", node="", cont="", dtype="", **kwargs):
        """APDL Command: PLCINT

        Plots the fracture parameter (CINT) result data.

        Parameters
        ----------
        action
            PATH

            PATH - Plots CINT quantities according to path number (default).

            FRONT - Plots CINT quantities distribution along the crack front.

        id
            Crack ID number.

        node
            Crack tip node number (default = ALL).

        cont
            Contour number (Default = ALL).

        dtype
            Data type to output:

            JINT - J-integral (default)

            IIN1 - Interaction integral 1

            IIN2 - Interaction integral 2

            IIN3 - Interaction integral 3

            K1 - Mode 1 stress-intensity factor

            K2 - Mode 2 stress-intensity factor

            K3 - Mode 3 stress-intensity factor

            G1 - Mode 1 energy release rate

            G2 - Mode 2 energy release rate

            G3 - Mode 3 energy release rate

            GT - Total energy release rate

            MFTX - Total material force X

            MFTY - Total material force Y

            MFTZ - Total material force Z

            TSTRESS - T-stress

            CEXT - Crack extension

            CSTAR - C*-integral

        Notes
        -----
        The PLCINT command is not available for XFEM-based crack growth
        analyses results processing.
        """
        command = "PLCINT,%s,%s,%s,%s,%s" % (str(action), str(id), str(node), str(cont), str(dtype))
        return self.run(command, **kwargs)

    def parres(self, lab="", fname="", ext="", **kwargs):
        """APDL Command: PARRES

        Reads parameters from a file.

        Parameters
        ----------
        lab
            Read operation:

            Replace current parameter set with these parameters (default). - Extend current parameter set with these parameters, replacing any that already
                              exist.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Reads parameters from a coded file.  The parameter file may have been
        written with the PARSAV command.  The parameters read may replace or
        change the current parameter set.

        This command is valid in any processor.
        """
        command = "PARRES,%s,%s,%s" % (str(lab), str(fname), str(ext))
        return self.run(command, **kwargs)

    def stef(self, value="", **kwargs):
        """APDL Command: STEF

        Specifies Stefan-Boltzmann radiation constant.

        Parameters
        ----------
        value
            Stefan-Boltzmann constant (defaults to 0.119E-10 Btu/hr/in2/ °R4).

        Notes
        -----
        You can use this command in the general preprocessor (PREP7) and in the
        Solution processor to specify the Stefan-Boltzmann constant in analyses
        using the radiation matrix method or the radiosity solver to model
        radiation.
        """
        command = "STEF,%s" % (str(value))
        return self.run(command, **kwargs)

    def mfrstart(self, time="", **kwargs):
        """APDL Command: MFRSTART

        Specifies restart status for an ANSYS Multi-field solver analysis.

        Parameters
        ----------
        time
            Restart time

            0  -  New analysis (Default)

            -1  - Restart from the last result set from a previous run.

            n  - Specify any positive number for the actual time point from which the ANSYS
                 Multi-field solver will restart. ANSYS checks the availability
                 of the result set and database file.

        Notes
        -----
        For MFX analyses, ANSYS always passes an actual time value to CFX (zero
        for a new analysis or a positive value for a restart run) and CFX
        verifies the consistency with the initial results file. For more
        details about ANSYS restart capabilities, please see Restarting an
        Analysis in the Basic Analysis Guide.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFRSTART,%s" % (str(time))
        return self.run(command, **kwargs)

    def desize(self, minl="", minh="", mxel="", angl="", angh="", edgmn="",
               edgmx="", adjf="", adjm="", **kwargs):
        """APDL Command: DESIZE

        Controls default element sizes.

        Parameters
        ----------
        minl
            Minimum number of elements that will be attached to a line when
            using lower-order elements (defaults to 3 elements per line).  If
            MINL = DEFA, all arguments will be set back to default values.  If
            MINL = STAT, list status of command (Including on/off status).  If
            MINL = OFF, deactivate default element sizing.  If MINL = ON,
            reactivate default element sizing.

        minh
            Minimum number of elements that will be attached to a line when
            using higher-order elements. Defaults to 2 elements per line.

        mxel
            Maximum number of elements that will be attached to a single line
            (lower or higher-order elements). Defaults to 15 elements per line
            for h-elements. To deactivate this limit, specify a large number
            (such as 9999).

        angl
            Maximum spanned angle per lower-order element for curved lines.
            Defaults to 15 degrees per element.

        angh
            Maximum spanned angle per higher-order element for curved lines.
            Defaults to 28 degrees per element.

        edgmn
            Minimum element edge length. Defaults to no minimum edge length.
            The MINL or MINH argument can override this value.

        edgmx
            Maximum element edge length. Defaults to no maximum edge length.
            The MXEL argument can override this value.

        adjf
            Target aspect ratio for adjacent line.  Used only when free
            meshing. Defaults to 1.0, which attempts to create equal-sided
            h-elements.

        adjm
            Target aspect ratio for adjacent line.  Used only when map meshing.
            Defaults to 4.0, which attempts to create rectangular h-elements.

        Notes
        -----
        DESIZE settings are usually used for mapped meshing.  They are also
        used for free meshing if SmartSizing is turned off [SMRTSIZE,OFF],
        which is the default.  Even when SmartSizing is on, some DESIZE
        settings (such as maximum and minimum element edge length) can affect
        free mesh density. The default settings of the DESIZE command  are used
        only when no other element size specifications [KESIZE, LESIZE, ESIZE]
        exist for a certain line.

        This command is also valid for rezoning.
        """
        command = "DESIZE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(minl), str(minh), str(mxel), str(angl), str(angh), str(edgmn), str(edgmx), str(adjf), str(adjm))
        return self.run(command, **kwargs)

    def v(self, p1="", p2="", p3="", p4="", p5="", p6="", p7="", p8="",
          **kwargs):
        """APDL Command: V

        Defines a volume through keypoints.

        Parameters
        ----------
        p1
            Keypoint defining starting corner of volume.  If P1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).

        p2
            Keypoint defining second corner of volume.

        p3
            Keypoint defining third corner of volume.

        p4
            Keypoint defining fourth corner of volume.

        p5
            Keypoint defining fifth corner of volume.

        p6
            Keypoint defining sixth corner of volume.

        p7
            Keypoint defining seventh corner of volume.

        p8
            Keypoint defining eighth corner of volume.

        Notes
        -----
        Defines a volume (and its corresponding lines and areas) through eight
        (or fewer) existing keypoints.  Keypoints must be input in a continuous
        order.  The order of the keypoints should be around the bottom and then
        the top.  Missing lines are generated "straight" in the active
        coordinate system and assigned the lowest available numbers [NUMSTR].
        Missing areas are generated and assigned the lowest available numbers.

        Solid modeling in a toroidal coordinate system is not recommended.

        Certain faces may be condensed to a line or point by repeating
        keypoints.   For example, use V,P1,P2,P3,P3,P5,P6,P7,P7   for a
        triangular prism or V,P1,P2,P3,P3,P5,P5,P5,P5  for a tetrahedron.

        Using keypoints to produce partial sections in CSYS = 2 can generate
        anomalies; check the resulting volumes carefully.
        """
        command = "V,%s,%s,%s,%s,%s,%s,%s,%s" % (str(p1), str(p2), str(p3), str(p4), str(p5), str(p6), str(p7), str(p8))
        return self.run(command, **kwargs)

    def sed(self, sedx="", sedy="", sedz="", cname="", **kwargs):
        """APDL Command: SED

        Defines the excitation direction for response spectrum and PSD
        analyses.

        Parameters
        ----------
        sedx, sedy, sedz
            Global Cartesian coordinates of a point that defines a line
            (through the origin) corresponding to the excitation direction.
            For example: 0.0, 1.0, 0.0 defines global Y as the spectrum
            direction.

        cname
            The component name corresponding to the group of excited nodes.
            Only applies to base excitation multi-point response spectrum
            analysis (SPOPT, MPRS) and power spectral density analysis (SPOPT,
            PSD). Defaults to no component.

        Notes
        -----
        In single-point response spectrum analysis (SPOPT,SPRS), the excitation
        direction without rocking (ROCK) is normalized to one so that the SEDX,
        SEDY, and SEDZ values do not scale the spectrum.  The excitation
        direction with rocking is not normalized. The SEDX, SEDY, and SEDZ
        values must be consistent with the OMX, OMY, and OMZ values on the ROCK
        command. The calculated direction then scales the spectrum. For more
        information, see Participation Factors and Mode Coefficients.

        In multi-point response spectrum analysis (SPOPT,MPRS) and power
        spectral density analysis (SPOPT,PSD), the excitation direction is
        normalized to one so that the SEDX, SEDY, and SEDZ values do not scale
        the spectrum.  The component name (Cname) is required. The constraints
        corresponding to the excitation direction are applied to the component
        nodes.

        This command is also valid in PREP7.
        """
        command = "SED,%s,%s,%s,%s" % (str(sedx), str(sedy), str(sedz), str(cname))
        return self.run(command, **kwargs)

    def tblist(self, lab="", mat="", **kwargs):
        """APDL Command: TBLIST

        Lists the material data tables.

        Parameters
        ----------
        lab
            Data table label. (See the TB command for valid labels.)  Defaults
            to the active table.  If ALL, list data for all labels.

        mat
            Material number to be listed (defaults to the active material).  If
            ALL, list data tables for all materials.

        Notes
        -----
        This command is a utility command, valid anywhere.
        """
        command = "TBLIST,%s,%s" % (str(lab), str(mat))
        return self.run(command, **kwargs)

    def fssect(self, rho="", nev="", nlod="", kbr="", **kwargs):
        """APDL Command: FSSECT

        Calculates and stores total linearized stress components.

        Parameters
        ----------
        rho
            In-plane (X-Y) average radius of curvature of the inside and
            outside surfaces of an axisymmetric section.  If zero (or blank), a
            plane or 3-D structure is assumed.  If nonzero, an axisymmetric
            structure is assumed.  Use a suitably large number (see the
            Mechanical APDL Theory Reference) or use -1 for an axisymmetric
            straight section.

        nev
            Event number to be associated with these stresses (defaults to 1).

        nlod
            Loading number to be associated with these stresses (defaults to
            1).

        kbr
            For an axisymmetric analysis (RHO ≠ 0):

            0 - Include the thickness-direction bending stresses

            1 - Ignore the thickness-direction bending stresses

            2 - Include the thickness-direction bending stress using the same formula as the Y
                (axial direction ) bending stress. Also use the same formula
                for the shear stress.

        Notes
        -----
        Calculates and stores the total linearized stress components at the
        ends of a section path [PATH] (as defined by the first two nodes with
        the PPATH command). The path must be entirely within the selected
        elements (that is, there must not be any element gaps along the path).
        Stresses are stored according to the fatigue event number and loading
        number specified.  Locations (one for each node) are associated with
        those previously defined for these nodes [FL] or else they are
        automatically defined.  Stresses are separated into six total
        components (SX through SXZ) and six membrane-plus-bending (SX through
        SXZ) components.  The temperature at each end point and the current
        time are also stored along with the total stress components.
        Calculations are made from the stresses currently in the database (last
        SET or LCASE command).  Stresses are stored as section coordinate
        components if axisymmetric or as global Cartesian coordinate components
        otherwise, regardless of the active results coordinate system [RSYS].
        The FSLIST command may be used to list stresses.  The FS command can be
        used to modify stored stresses.  See also the PRSECT and PLSECT
        commands for similar calculations.
        """
        command = "FSSECT,%s,%s,%s,%s" % (str(rho), str(nev), str(nlod), str(kbr))
        return self.run(command, **kwargs)

    def hfsym(self, kcn="", xkey="", ykey="", zkey="", **kwargs):
        """APDL Command: HFSYM

        Indicates the presence of symmetry planes for the computation of
        acoustic fields in the near and far field domains (beyond the finite
        element region).

        Parameters
        ----------
        kcn
            Coordinate system reference number. KCN may be 0 (Cartesian), or
            any previously defined local Cartesian coordinate system number
            (>10). Defaults to 0.

        xkey
            Key for acoustic field boundary condition, as prescribed for the
            solution, corresponding to the x = constant plane:

            None - No sound soft or sound hard boundary conditions (default).

            SSB - Sound soft boundary (pressure = 0).

            SHB - Sound hard boundary (normal velocity = 0).

        ykey
            Key for acoustic field boundary condition, as prescribed for the
            solution, corresponding to the y = constant plane:

            None - No sound soft or sound hard boundary conditions (default).

            SSB - Sound soft boundary (pressure = 0).

            SHB - Sound hard boundary (normal velocity = 0).

        zkey
            Key for acoustic field boundary condition, as prescribed for the
            solution, corresponding to the z = constant plane:

            None - No sound soft or sound hard boundary conditions (default).

            SSB - Sound soft boundary (pressure = 0).

            SHB - Sound hard boundary (normal velocity = 0).

        Notes
        -----
        HFSYM uses the image principle to indicate symmetry planes (x, y, or z
        = constant plane) for acoustic field computations outside the modeled
        domain. A sound hard boundary condition must be indicated even though
        it occurs as a natural boundary condition.

        No menu paths are available for acoustic applications.
        """
        command = "HFSYM,%s,%s,%s,%s" % (str(kcn), str(xkey), str(ykey), str(zkey))
        return self.run(command, **kwargs)

    def nodes(self, **kwargs):
        """APDL Command: NODES

        Specifies "Nodes" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "NODES," % ()
        return self.run(command, **kwargs)

    def fluxv(self, **kwargs):
        """APDL Command: FLUXV

        Calculates the flux passing through a closed contour.

        Notes
        -----
        FLUXV invokes an ANSYS macro which calculates the flux passing through
        a closed contour (path) predefined by PATH.  The calculated flux is
        stored in the parameter FLUX.  In a 2-D analysis, at least two nodes
        must be defined on the path.  In 3-D, a path of nodes describing a
        closed contour must be specified (i.e., the first and last node in the
        path specification must be the same).  A counterclockwise ordering of
        nodes on the PPATH command will give the correct sign on flux.  Path
        operations are used for the calculations, and all path items are
        cleared upon completion.  This macro is only available for vector
        potential formulations.
        """
        command = "FLUXV," % ()
        return self.run(command, **kwargs)

    def efacet(self, num="", **kwargs):
        """APDL Command: /EFACET

        Specifies the number of facets per element edge for PowerGraphics
        displays.

        Parameters
        ----------
        num
            Number of facets per element edge for element plots.

            1 - Use 1 facet per edge (default for h-elements).

            2 - Use 2 facets per edge.

            4 - Use 4 facets per edge.

        Notes
        -----
        /EFACET is valid only when PowerGraphics is enabled [/GRAPHICS,POWER],
        except that it can be used in FULL graphics mode for element CONTA174.
        (See the /GRAPHICS command and element CONTA174 in the Element
        Reference for more information.) The /EFACET command is only applicable
        to element type displays.

        /EFACET controls the fineness of the subgrid that is used for element
        plots. The element is subdivided into smaller portions called facets.
        Facets are piecewise linear surface approximations of the actual
        element face. In their most general form, facets are warped planes in
        3-D space.  A greater number of facets will result in a smoother
        representation of the element surface for element plots. /EFACET may
        affect results averaging. See Contour Displays in the Basic Analysis
        Guide for more information.

        For midside node elements, use NUM = 2; if NUM = 1, no midside node
        information is output. For non-midside node elements, NUM should be set
        to 1. See the PLNSOL and PRNSOL commands for more information.

        With PowerGraphics active (/GRAPHICS,POWER), the averaging scheme for
        surface data with interior element data included (AVRES,,FULL) and
        multiple facets per edge (/EFACET,2 or /EFACET,4) will yield differing
        minimum and maximum contour values depending on the  Z-Buffering
        options (/TYPE,,6 or /TYPE,,7).  When the Section data is not included
        in the averaging schemes (/TYPE,,7), the resulting absolute value for
        the midside node is significantly smaller.

        For cyclic symmetry mode-superposition harmonic solutions, only NUM = 1
        is supported in postprocessing.

        Caution:: : If you specify /EFACET,1, PowerGraphics does not plot
        midside nodes. You must use /EFACET,2 to make the nodes visible.

        This command is valid in any processor.
        """
        command = "/EFACET,%s" % (str(num))
        return self.run(command, **kwargs)

    def felist(self, nev1="", nev2="", ninc="", **kwargs):
        """APDL Command: FELIST

        Lists the fatigue event parameters.

        Parameters
        ----------
        nev1, nev2, ninc
            List event parameters from NEV1 (defaults to 1) to NEV2 (defaults
            to NEV1) in steps of NINC (defaults to 1).  If NEV1 = ALL, NEV2 and
            NINC are ignored and all events are listed.  Fatigue event
            parameters are defined with the FE command.
        """
        command = "FELIST,%s,%s,%s" % (str(nev1), str(nev2), str(ninc))
        return self.run(command, **kwargs)

    def nsvr(self, itype="", nstv="", **kwargs):
        """APDL Command: NSVR

        Defines the number of variables for user-programmable element options.

        Parameters
        ----------
        itype
            Element type number as defined on the ET command.

        nstv
            Number of extra state variables to save (must be no more than 840).

        Notes
        -----
        Defines the number of extra variables that need to be saved for user-
        programmable (system-dependent) element options, e.g., material laws
        through user subroutine USERPL.  ITYPE must first be defined with the
        ET command.
        """
        command = "NSVR,%s,%s" % (str(itype), str(nstv))
        return self.run(command, **kwargs)

    def anpres(self, nfram="", delay="", ncycl="", refframe="", **kwargs):
        """APDL Command: ANPRES

        Produces an animated sequence of the time-harmonic pressure variation
        of an engine-order excitation in a cyclic harmonic analysis.

        Parameters
        ----------
        nfram
            Number of frame captures per cycle. Defaults to 3 times the number
            of sectors.

        delay
            Time delay (seconds) during animation. Defaults to 0.1 seconds.

        ncycl
            Number of animation cycles. Defaults to 5.

        refframe
            Reference frame for the model rotation.

            0 - Rotating reference frame (default). The model remains fixed in space and the
                pressure revolve around the model.

            1 - Stationary reference frame. The model rotates and the pressure locations remain
                fixed in space.

        Notes
        -----
        ANPRES invokes a macro which produces an animated sequence of the time-
        harmonic applied pressure in the case of a mode-superposition harmonic
        analysis (ANTYPE,HARMIC with CYCOPT,MSUP,ON). The engine-order
        excitation must also have been specified (CYCFREQ,EO). While pressure
        loads are not accepted as valid loading in a mode-superposition
        analysis (they must be applied in the modal analysis and the modal load
        vector applied in the mode-superposition analysis) you can apply them
        for the purposes of this animation.

        For RefFrame = 1 (stationary reference frame), the rotational velocity
        from the Linear Perturbation step, or the current OMEGA or CGOMGA
        value, is used to determine the rotation direction about the cyclic
        cylindrical axis, otherwise a positive rotation is assumed.

        You may use /HBC,,ON to hide overlapping pressure faces, and use
        /GLINE,,-1 to suppress the element outlines if desired.
        """
        command = "ANPRES,%s,%s,%s,%s" % (str(nfram), str(delay), str(ncycl), str(refframe))
        return self.run(command, **kwargs)

    def nlog(self, ir="", ia="", name="", facta="", factb="", **kwargs):
        """APDL Command: NLOG

        Forms the natural log of a variable.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        ia
            Reference number of the variable to be operated on.

        --, --
            Unused fields.

        name
            Thirty-two character name identifying the variable on printouts and
            displays.  Embedded blanks are compressed for output.

        --, --
            Unused fields.

        facta
            Scaling factor applied to variable IA (defaults to 1.0).

        factb
            Scaling factor (positive or negative) applied to the operation
            (defaults to 1.0).

        Notes
        -----
        Forms the natural log of a variable according to the operation:

        IR = FACTB*LN(FACTA x IA)
        """
        command = "NLOG,%s,%s,%s,%s,%s" % (str(ir), str(ia), str(name), str(facta), str(factb))
        return self.run(command, **kwargs)

    def volumes(self, **kwargs):
        """APDL Command: VOLUMES

        Specifies "Volumes" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and appear in the log file (Jobname.LOG) if status
        is requested for some items by choosing Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "VOLUMES," % ()
        return self.run(command, **kwargs)

    def cslist(self, kcn1="", kcn2="", kcinc="", **kwargs):
        """APDL Command: CSLIST

        Lists coordinate systems.

        Parameters
        ----------
        kcn1, kcn2, kcinc
            List coordinate systems from KCN1 to KCN2 (defaults to KCN1) in
            steps of KCINC (defaults to 1).  If KCN1 = ALL (default), KCN2 and
            KCINC are ignored and all coordinate systems are listed.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "CSLIST,%s,%s,%s" % (str(kcn1), str(kcn2), str(kcinc))
        return self.run(command, **kwargs)

    def secnum(self, secid="", **kwargs):
        """APDL Command: SECNUM

        Sets the element section attribute pointer.

        Parameters
        ----------
        secid
            Defines the section ID number to be assigned to the subsequently-
            defined elements.  Defaults to 1.  See SECTYPE for more information
            about the section ID number.
        """
        command = "SECNUM,%s" % (str(secid))
        return self.run(command, **kwargs)

    def seexp(self, sename="", usefil="", imagky="", expopt="", **kwargs):
        """APDL Command: SEEXP

        Specifies options for the substructure expansion pass.

        Parameters
        ----------
        sename
            The name (case-sensitive) of the superelement matrix file created
            by the substructure generation pass (Sename.SUB).  Defaults to the
            initial jobname File.  If a number, it is the element number of the
            superelement as used in the use pass.

        usefil
            The name of the file containing the superelement degree-of-freedom
            (DOF) solution created by the substructure use pass (Usefil.DSUB).

        imagky
            Key to specify use of the imaginary component of the DOF solution.
            Applicable only if the use pass is a harmonic (ANTYPE,HARMIC)
            analysis:

            OFF - Use real component of DOF solution (default).

            ON - Use imaginary component of DOF solution.

        expopt
            Key to specify whether the superelement (ANTYPE,SUBSTR) expansion
            pass (EXPASS,ON) should transform the geometry:

            OFF - Do not transform node or element locations (default).

            ON - Transform node or element locations in the FE geometry record of the .rst
                 results file.

        Notes
        -----
        Specifies options for the expansion pass of the substructure analysis
        (ANTYPE,SUBSTR).  If used in SOLUTION, this command is valid only
        within the first load step.

        If you specify geometry transformation (Expopt = ON), you must retrieve
        the transformation matrix (if it exists) from the specified .SUB file.
        The command updates the nodal X, Y, and Z coordinates to represent the
        transformed node locations. The Expopt option is useful when you want
        to expand superelements created from other superelements (via SETRAN or
        SESYMM commands). For more information, see Superelement Expansion in
        Transformed Locations and Plotting or Printing Mode Shapes.

        This command is also valid in /PREP7.
        """
        command = "SEEXP,%s,%s,%s,%s" % (str(sename), str(usefil), str(imagky), str(expopt))
        return self.run(command, **kwargs)

    def rforce(self, nvar="", node="", item="", comp="", name="", **kwargs):
        """APDL Command: RFORCE

        Specifies the total reaction force data to be stored.

        Parameters
        ----------
        nvar
            Arbitrary reference number assigned to this variable (2 to NV
            [NUMVAR]). Overwrites any existing results for this variable.

        node
            Node for which data are to be stored.  If NODE = P, graphical
            picking is enabled (valid only in the GUI).

        item
            Label identifying the item.  Valid item labels are shown in the
            table below.  Some items also require a component label.

        comp
            Component of the item (if required).  Valid component labels are
            shown in the table below.

        name
            Thirty-two character name identifying the item on printouts and
            displays. Defaults to an eight character label formed by
            concatenating the first four characters of the Item and Comp
            labels.

        Notes
        -----
        Defines the total reaction force data (static, damping, and inertial
        components) to be stored from single pass (ANTYPE,STATIC or TRANS)
        solutions or from the expansion pass of mode-superposition
        (ANTYPE,HARMIC or TRANS) solutions.

        Table: 228:: : RFORCE - Valid Item and Component Labels

        For SHELL131 and SHELL132 elements with KEYOPT(3) = 0 or 1, use the
        labels HBOT, HE2, HE3, . . ., HTOP instead of HEAT.
        """
        command = "RFORCE,%s,%s,%s,%s,%s" % (str(nvar), str(node), str(item), str(comp), str(name))
        return self.run(command, **kwargs)

    def prorb(self, **kwargs):
        """APDL Command: PRORB

        Prints the orbital motion characteristics of a rotating structure

        Notes
        -----
        When a structure is rotating and the Coriolis or gyroscopic effect is
        taken into account (CORIOLIS), nodes lying on the rotation axis
        generally exhibit an elliptical orbital motion. The PRORB command
        prints out the orbit characteristics A, B, PSI, PHI, YMAX and ZMAX of
        each rotating node, where

        Angles PSI and PHI are in degrees and within the range of -180 through
        +180. For more information about orbit definition, see Orbits in the
        Advanced Analysis Guide.

        To display the characteristics of the orbital path traversed by each
        node, issue the PLORB command.

        The PRORB command is valid for line elements (such as BEAM188, BEAM189,
        PIPE288, and PIPE289).

        Your model must also involve a rotational velocity (OMEGA or CMOMEGA)
        with Coriolis enabled in a stationary reference frame
        (CORIOLIS,,,,RefFrame = ON).

        A SET command should be issued after PRORB to ensure proper output for
        subsequent postprocessing commands.

        The coordinate system for displaying nodal results must be global
        Cartesian (RSYS,KCN = 0).
        """
        command = "PRORB," % ()
        return self.run(command, **kwargs)

    def smfor(self, **kwargs):
        """APDL Command: SMFOR

        Specifies "Forces on the solid model" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "SMFOR," % ()
        return self.run(command, **kwargs)

    def edgcale(self, nadv="", meth="", **kwargs):
        """APDL Command: EDGCALE

        Defines global ALE controls for an explicit dynamic analysis.

        Parameters
        ----------
        nadv
            Number of cycles between advection (default = 0).

        meth
            Advection method.

            0 - Donor cell + Half Index Shift (first order accurate) (default).

            1 - Van Leer + Half Index Shift (second order accurate).

        Notes
        -----
        This command sets global ALE controls in an explicit dynamic analysis.
        These ALE controls apply to all PLANE162 or SOLID164 elements in the
        model that are flagged to use the ALE formulation (KEYOPT(5) = 1). To
        activate the ALE formulation, you must specify the number of cycles
        between advection on this command and at least one smoothing weight
        factor on the EDALE command. See Arbitrary Lagrangian-Eulerian
        Formulation in the ANSYS LS-DYNA User's Guide for more information.

        To see the current EDGCALE settings, issue the command EDALE,LIST.

        The EDGCALE command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDGCALE,%s,%s" % (str(nadv), str(meth))
        return self.run(command, **kwargs)

    def lovlap(self, nl1="", nl2="", nl3="", nl4="", nl5="", nl6="", nl7="",
               nl8="", nl9="", **kwargs):
        """APDL Command: LOVLAP

        Overlaps lines.

        Parameters
        ----------
        nl1, nl2, nl3, . . . , nl9
            Numbers of lines to be overlapped.  If NL1 = ALL, NL2 to NL9 are
            ignored and all selected lines are overlapped.  If NL1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NL1.

        Notes
        -----
        Overlaps lines. Generates new lines which encompass the geometry of all
        the input lines.  The new lines are defined by the regions of
        intersection of the input lines, and by the complementary (non-
        intersecting) regions.  See the Modeling and Meshing Guide for an
        illustration.  This operation is only valid when the region of
        intersection is a line.  See the BOPTN command for an explanation of
        the options available to Boolean operations.  Element attributes and
        solid  model boundary conditions assigned to the original entities will
        not be transferred to the new entities generated.
        """
        command = "LOVLAP,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nl1), str(nl2), str(nl3), str(nl4), str(nl5), str(nl6), str(nl7), str(nl8), str(nl9))
        return self.run(command, **kwargs)

    def pds(self, **kwargs):
        """APDL Command: /PDS

        Enters the probabilistic design system.

        Notes
        -----
        Enters the Probabilistic Design System (PDS). This command is valid
        only at the Begin Level.
        """
        command = "/PDS," % ()
        return self.run(command, **kwargs)

    def vsweep(self, vnum="", srca="", trga="", lsmo="", **kwargs):
        """APDL Command: VSWEEP

        Fills an existing unmeshed volume with elements by sweeping the mesh
        from an adjacent area through the volume.

        Parameters
        ----------
        vnum
            Number identifying the volume that is to be meshed by VSWEEP.  If
            VNUM = P, graphical picking is enabled, you will be prompted to
            choose the volume or volumes based on the setting of
            EXTOPT,VSWE,AUTO.  This argument is required.

        srca
            Number identifying the source area.  This is the area whose mesh
            will provide the pattern for the volume elements.  (If you do not
            mesh the source area prior to volume sweeping, ANSYS meshes it
            internally when you initiate volume sweeping.)  ANSYS sweeps the
            pattern of the area elements through the volume to create the mesh
            of volume elements.  You cannot substitute a component name for
            SRCA.

        trga
            Number identifying the target area.  This is the area that is
            opposite the source area specified by SRCA.  You cannot substitute
            a component name for TRGA.

        lsmo
            Value specifying whether ANSYS should perform line smoothing during
            volume sweeping.  (The value of this argument controls line
            smoothing for the VSWEEP command only;  it has no effect on the
            setting of the MOPT command's LSMO option.)  This argument is
            optional.

            0 - Do not perform line smoothing.  This is the default.

            1 - Always perform line smoothing.  This setting is not recommended for large
                models due to speed considerations.

        Notes
        -----
        If the source mesh consists of quadrilateral elements, ANSYS fills the
        volume with hexahedral elements.  If the source mesh consists of
        triangles, ANSYS fills the volume with wedges.  If the source mesh
        consists of a combination of quadrilaterals and triangles, ANSYS fills
        the volume with a combination of hexahedral and wedge elements.

        In the past, you may have used the VROTAT, VEXT, VOFFST, and/or VDRAG
        commands to extrude a meshed area into a meshed volume.  However, those
        commands create the volume and the volume mesh simultaneously.  In
        contrast, the VSWEEP command is intended for use in an existing
        unmeshed volume.  This makes VSWEEP particularly useful when you have
        imported a solid model that was created in another program, and you
        want to mesh it in ANSYS.

        For related information, see the description of the EXTOPT command
        (although EXTOPT sets volume sweeping options, it does not affect
        element spacing). Also see the detailed discussion of volume sweeping
        in Meshing Your Solid Model of the Modeling and Meshing Guide.
        """
        command = "VSWEEP,%s,%s,%s,%s" % (str(vnum), str(srca), str(trga), str(lsmo))
        return self.run(command, **kwargs)

    def rigresp(self, option="", method="", val1="", val2="", **kwargs):
        """APDL Command: RIGRESP

        Specifies the rigid response calculation.

        Parameters
        ----------
        option
            Flag to activate or deactivate the rigid response calculation:

            1 (ON or YES) - Activate.

            2 (OFF or NO) - Deactivate. This value is the default.

        method
            Method used to calculate the rigid response:

            GUPTA - Gupta method.

            LINDLEY - Lindley-Yow method.

        val1
            If Method = GUPTA, Val1 represents the frequency F1 in Hertz.

        val2
            If Method = GUPTA, Val2 represents the frequency F2 in Hertz.

        Notes
        -----
        This rigid response calculation is only valid for single point response
        spectrum analysis (SPOPT, SPRS) and multiple point response spectrum
        analysis (SPOPT, MPRS) with combination methods (SRSS), complete
        quadratic (CQC) or Rosenblueth (ROSE)

        This command is also valid in PREP7.

        Only Sptype = SPRS is allowed in ANSYS Professional.
        """
        command = "RIGRESP,%s,%s,%s,%s" % (str(option), str(method), str(val1), str(val2))
        return self.run(command, **kwargs)

    def nrotat(self, node1="", node2="", ninc="", **kwargs):
        """APDL Command: NROTAT

        Rotates nodal coordinate systems into the active system.

        Parameters
        ----------
        node1, node2, ninc
            Rotate nodes from NODE1 to NODE2 (defaults to NODE1) in steps of
            NINC (defaults to 1).  If NODE1 = ALL, NODE2 and NINC are ignored
            and all selected nodes [NSEL] are rotated.  If NODE1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).  A component name may also be substituted
            for NODE1 (NODE2 and NINC are ignored).

        Notes
        -----
        Rotates nodal coordinate systems into the active coordinate system.
        Nodal coordinate systems may be automatically rotated into the active
        (global or local) coordinate system as follows:  Rotations in Cartesian
        systems will have nodal x directions rotated parallel to the Cartesian
        X direction.  Rotations in cylindrical, spherical or toroidal systems
        will have the nodal x directions rotated parallel to the R direction.
        Nodes at (or near) a zero radius location should not be rotated.  Nodal
        coordinate directions may be displayed [/PSYMB].  Nodal forces and
        constraints will also appear rotated when displayed if the nodal
        coordinate system is rotated.

        ANSYS LS-DYNA (explicit dynamics) does not support the NROTAT command.
        If you have rotated nodes in the implicit phase of an implicit-to-
        explicit sequential solution, you must rotate the nodes back to the
        global Cartesian direction before switching from implicit to explicit
        elements (ETCHG,ITE). Use the EDNROT command in the explicit run to
        maintain the same displacement constraints as were used on rotated
        nodes in the implicit run.

        Note:: : When the  nodal coordinate systems are defined, they remain
        parallel to the global Cartesian system unless subsequently rotated.

        Previously specified rotations on the specified nodes are overridden.

        See the NMODIF, NANG, and NORA commands for other rotation options.
        """
        command = "NROTAT,%s,%s,%s" % (str(node1), str(node2), str(ninc))
        return self.run(command, **kwargs)

    def xfenrich(self, enrichmentid="", compname="", matid="", **kwargs):
        """APDL Command: XFENRICH

        Defines parameters associated with crack propagation using XFEM

        Parameters
        ----------
        enrichmentid
            An alphanumeric name assigned to identify the enrichment. The name
            can contain up to 32 characters and must begin with an alphabetic
            character. Alphabetic characters, numbers, and underscores are
            valid.

        compname
            Name of the element set component for which initial cracks are
            defined and possibly propagated.

        matid
            Material ID number referring to cohesive zone material behavior on
            the initial crack. If 0 or not specified, the initial crack is
            assumed to be free of cohesive zone behavior.

        Notes
        -----
        If MatID is specified, the cohesive zone behavior is described by the
        bilinear cohesive law.

        This command is valid in PREP7 (/PREP7) only.
        """
        command = "XFENRICH,%s,%s,%s" % (str(enrichmentid), str(compname), str(matid))
        return self.run(command, **kwargs)

    def plcplx(self, key="", **kwargs):
        """APDL Command: PLCPLX

        Specifies the part of a complex variable to display.

        Parameters
        ----------
        key
            Complex variable part:

            0 - Amplitude.

            1 - Phase angle.

            2 - Real part.

            3 - Imaginary part.

        Notes
        -----
        Used only with harmonic analyses (ANTYPE,HARMIC).

        All results data are stored in the form of real and imaginary
        components and converted to amplitude and/or phase angle as specified
        via the PLCPLX command. The conversion is not  valid for derived
        results (such as principal stress/strain, equivalent stress/strain and
        USUM).
        """
        command = "PLCPLX,%s" % (str(key))
        return self.run(command, **kwargs)

    def stabilize(self, key="", method="", value="", substpopt="",
                  forcelimit="", **kwargs):
        """APDL Command: STABILIZE

        Activates stabilization for all elements that support nonlinear
        stabilization.

        Parameters
        ----------
        key
            Key for controlling nonlinear stabilization:

            OFF  -  Deactivate stabilization. This value is the default.

            CONSTANT  -  Activate stabilization. The energy-dissipation ratio or damping factor remains
                        constant during the load step.

            REDUCE  -  Activate stabilization. The energy-dissipation ratio or damping factor is
                      reduced linearly to zero at the end of the load step from
                      the specified or calculated value.

        method
            The stabilization-control method:

            ENERGY  -  Use the energy-dissipation ratio as the control. This value is the default
                      when Key ≠ OFF.

            DAMPING  -  Use the damping factor as the control.

        value
            The energy-dissipation ratio (Method = ENERGY) or damping factor
            (Method = DAMPING). This value must be greater than 0 when Method =
            ENERGY or Method = DAMPING. When Method = ENERGY, this value is
            usually a number between 0 and 1.

        substpopt
            Option for the first substep of the load step:

            NO  -  Stabilization is not activated for the first substep even when it does not
                  converge after the minimal allowed time increment is reached.
                  This value is the default when Key ≠ OFF.

            MINTIME  -  Stabilization is activated for the first substep if it still does not converge
                       after the minimal allowed time increment is reached.

            ANYTIME  -  Stabilization is activated for the first substep. Use this option if
                       stabilization was active for the previous load step via
                       Key = CONSTANT.

        forcelimit
            The stabilization force limit coefficient, such that 0 < FORCELIMIT
            < 1. The default value is 0.2. To omit a stabilization force check,
            set this value to 0.

        Notes
        -----
        Once issued, a STABILIZE command remains in effect until you reissue
        the command.

        For the energy dissipation ratio, specify VALUE = 1.0e-4 if you have no
        prior experience with the current model; if convergence problems are
        still an issue, increase the value gradually. The damping factor is
        mesh-, material-, and time-step-dependent; an initial reference value
        from the previous run (such as a run with the energy-dissipation ratio
        as input) should suggest itself.

        Exercise caution when specifying SubStpOpt = MINTIME or ANYTIME for the
        first load step; ANSYS, Inc. recommends this option only for
        experienced users. If stabilization was active for the previous load
        step via Key = CONSTANT and convergence is an issue for the first
        substep, specify SubStpOpt = ANYTIME.

        When the L2-norm of the stabilization force (CSRSS value) exceeds the
        L2-norm of the internal force multiplied by the stabilization force
        coefficient, ANSYS issues a message displaying both the stabilization
        force norm and the internal force norm. The FORCELIMIT argument allows
        you to change the default stabilization force coefficient (normally 20
        percent).

        This command stabilizes the degrees of freedom for current-technology
        elements only. Other elements can be included in the FE model, but
        their degrees of freedom are not stabilized.

        For more information about nonlinear stabilization, see Unstable
        Structures in the Structural Analysis Guide. For additional tips that
        can help you to achieve a stable final model, see Simplify Your Model
        in the Structural Analysis Guide.
        """
        command = "STABILIZE,%s,%s,%s,%s,%s" % (str(key), str(method), str(value), str(substpopt), str(forcelimit))
        return self.run(command, **kwargs)

    def psel(self, type="", pname1="", pname2="", pname3="", pname4="",
             pname5="", pname6="", pname7="", pname8="", pname9="", pname10="",
             **kwargs):
        """APDL Command: PSEL

        Selects a path or paths.

        Parameters
        ----------
        type
            Label identifying the type of select:

            S - Select a new path.

            R - Reselect a path from the current set of paths.

            A - Additionally select a path and extend the current set of paths.

            U - Unselect a path from the current set of paths.

            ALL - Restore the full set of paths.

            NONE - Unselect the full set of paths.

            INV - Invert the current set of paths (selected becomes unselected and vice versa).

        pname1, pname2, pname3, . . . , pname10
            Name of existing path(s).

        Notes
        -----
        Selects a path or multiple paths, up to ten.  Data are flagged as
        selected and unselected; no data are actually deleted from the
        database.  There is no default for this command; you must specify a
        type and pathname.
        """
        command = "PSEL,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(type), str(pname1), str(pname2), str(pname3), str(pname4), str(pname5), str(pname6), str(pname7), str(pname8), str(pname9), str(pname10))
        return self.run(command, **kwargs)

    def sbclist(self, **kwargs):
        """APDL Command: SBCLIST

        Lists solid model boundary conditions.

        Notes
        -----
        Lists all solid model boundary conditions for the selected solid model
        entities.  See also DKLIST, DLLIST, DALIST, FKLIST, SFLLIST, SFALIST,
        BFLLIST, BFALIST, BFVLIST, and BFKLIST to list items separately.

        This command is valid in any processor.
        """
        command = "SBCLIST," % ()
        return self.run(command, **kwargs)

    def slashmap(self, **kwargs):
        """APDL Command: /MAP

        Enters the mapping processor.

        Notes
        -----
        Enters the mapping processor. This processor is used to read in source
        data from an external file and map it to the existing geometry.

        The current database is saved (to BeforeMapping.DB) upon entering the
        processor, and it is resumed upon exiting (FINISH command). Any nodes
        or elements not on the target surface are deleted for easier viewing of
        the mapping quantities. A database of this mapping geometry
        (Mapping.DB) is also saved at the FINISH command.

        This command is valid only at the Begin Level.
        """
        command = "/MAP," % ()
        return self.run(command, **kwargs)

    def starset(self, par="", value="", val2="", val3="", val4="", val5="",
                val6="", val7="", val8="", val9="", val10="", **kwargs):
        """APDL Command: *SET

        Assigns values to user-named parameters.

        Parameters
        ----------
        par
            An alphanumeric name used to identify this parameter.  Par may be
            up to 32 characters, beginning with a letter and containing only
            letters, numbers, and underscores.  Examples:  ABC   A3X   TOP_END.
            ANSYS command names, function names, label names, component and
            assembly names, etc., should not be used.  Parameter names
            beginning with an underscore (e.g.,  _LOOP) are reserved for use by
            ANSYS and should be avoided.  Parameter names ending in an
            underscore are not listed by the *STATUS command.  Array parameter
            names must be followed by a subscript, and the entire expression
            must be 32 characters or less.  Examples:  A(1,1)   NEW_VAL(3,2,5)
            RESULT(1000).  There is no character parameter substitution for the
            Par field. Table parameters that are used in command fields (where
            constant values are normally given) are limited to 32 characters.

        value
            Numerical value or alphanumeric character string (up to 32
            characters enclosed in single quotes) to be assigned to this
            parameter.  Examples:  A(1,3)=7.4 B='ABC3'.  May also be a
            parameter or a parametric expression.  Examples:  C=A(1,3)
            A(2,2)=(C+4)/2.  If blank, delete this parameter.  Example:  A=
            deletes parameter A.

        val2, val3, val4, val5, val6, val7, val8, val9, val10
            If Par is an array parameter, values VAL2 through VAL10 (up to the
            last nonblank value) are sequentially assigned to the succeeding
            array elements of the column.  Example:  *SET,A(1,4),10,11 assigns
            A(1,4)=10, A(2,4)=11.  *SET,B(2,3),'file10','file11' assigns
            B(2,3)='file10', B(3,3)='file11'.

        Notes
        -----
        Assigns values to user-named parameters that may be substituted later
        in the run.  The equivalent (and recommended) format is

        Par = VALUE,VAL2,VAL3, . . . , VAL10

        which may be used in place of  *SET,Par, : ... for convenience.

        This command is valid in any processor.

        Parameters (numeric or character) may be scalars (single valued) or
        arrays (multiple valued in one, two, or three dimensions). An unlimited
        number of parameter names may be defined in any ANSYS run. For very
        large numbers of parameters, it is most efficient to define them in
        alphabetical order.

        Parameter values may be redefined at any time.  Array parameters may
        also be assigned values within a do-loop [*DO] for convenience.
        Internally programmed do-loop commands are also available with the *VXX
        commands (*VFILL).  Parameter values (except for parameters ending in
        an underscore) may be listed with the  *STATUS command, displayed with
        the *VPLOT   command (numeric parameters only), and modified with the
        *VEDIT command (numeric parameters only).

        Older ANSYS-supplied macro files may use parameter names that do not
        begin with an underscore. Using these macros embedded in your own
        macros may cause conflicts if the same parameter names are used.

        Parameters can also be resolved in comments created by the /COM command
        (see /COM for complete documentation). A parameter can be deleted by
        redefining it with a blank  VALUE.  If the parameter is an array, the
        entire array is deleted.  Parameters may also be defined by a response
        to a query with the  *ASK command or from an "ANSYS-supplied" value
        with the *GET command.

        Array parameters must be dimensioned  [*DIM] before being assigned
        values unless they are the result of an array operation or defined
        using the implied loop convention. Scalar parameters that are not
        defined are initialized to a "near" zero value.  Numeric array
        parameters are initialized to zero when dimensioned, and character
        array parameters are initialized to blank.  An existing array parameter
        must be deleted before it can be redimensioned.  Array parameter names
        must be followed by a subscript list (enclosed in parentheses)
        identifying the element of the array.  The subscript list may have one,
        two, or three values (separated by commas).  Typical array parameter
        elements are  A(1,1), NEW_VAL(3,2,5), RESULT(1000).  Subscripts for
        defining an array element must be integers (or parameter expressions
        that evaluate to integers).  Non-integer values are rounded to the
        nearest integer value.  All array parameters are stored as 3-D arrays
        with the unspecified dimensions set to 1.  For example, the 4th array
        element of a 1-dimensional array, A(4), is stored as array element
        A(4,1,1).  Arrays are patterned after standard FORTRAN conventions.

        If the parameter name Par is input in a numeric argument of a command,
        the numeric value of the parameter (as assigned with *SET, *GET, =,
        etc.) is substituted into the command at that point.  Substitution
        occurs only if the parameter name is used between blanks, commas,
        parentheses, or arithmetic operators (or any combination) in a numeric
        argument.  Substitution can be prevented by enclosing the parameter
        name Par within single quotes ( ' ), if the parameter is alone in the
        argument; if the parameter is part of an arithmetic expression, the
        entire expression must be enclosed within single quotes to prevent
        substitution.  In either case the character string will be used instead
        of the numeric value (and the string will be taken as 0.0 if it is in a
        numeric argument).

        A forced substitution is available in the text fields of the /TITLE,
        /STITLE,  /TLABEL, /AN3D, /SYP (ARG1--ARG8), and *ABBR  commands by
        enclosing the parameter within percent (%) signs.  Also, parameter
        substitution may be forced within the file name or extension fields of
        commands having these fields by enclosing the parameter within percent
        (%) signs.  Array parameters  [*DIM] must include a subscript (within
        parentheses) to identify the array element whose value is to be
        substituted, such as A(1,3).  Out-of-range subscripts result in an
        error message.  Non-integer subscripts are allowed when identifying a
        TABLE array element for substitution.  A proportional linear
        interpolation of values among the nearest array elements is performed
        before substitution.  Interpolation is done in all three dimensions.

        Note:: : Interpolation is based upon the assigned index numbers which
        must be defined when the table is filled [*DIM].

        Most alphanumeric arguments permit the use of character parameter
        substitution.  When the parameter name Par input, the alphanumeric
        value of the parameter is substituted into the command at that point.
        Substitution can be suppressed by enclosing the parameter name within
        single quotes ( ' ).  Forced substitution is available in some fields
        by enclosing the parameter name within percent (%) signs.  Valid forced
        substitution fields include command name fields, Fname (filename) or
        Ext (extension) arguments, *ABBR command (Abbr arguments), /TITLE and
        /STITLE commands (Title argument) and /TLABEL command (Text argument).
        Character parameter substitution is also available in the  *ASK, /AN3D,
        *CFWRITE,  *IF,  *ELSEIF,   *MSG,  *SET,  *USE,  *VREAD, and  *VWRITE
        commands.   Character array parameters must include a subscript (within
        parentheses) to identify the array element whose value is to be
        substituted.

        If a parameter operation expression is input in a numeric argument, the
        numeric value of the expression is substituted into the command at that
        point.  Allowable operation expressions are of the form

        E1oE2oE3: ...oE10

        where E1, E2, etc. are expressions connected by operators (o).  The
        allowable operations (o) are

        + - * / ** < >

        For example, A+B**C/D*E is a valid operation expression.  The *
        represents multiplication and the ** represents exponentiation.
        """
        command = "*SET,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(par), str(value), str(val2), str(val3), str(val4), str(val5), str(val6), str(val7), str(val8), str(val9), str(val10))
        return self.run(command, **kwargs)

    def priter(self, **kwargs):
        """APDL Command: PRITER

        Prints solution summary data.

        Notes
        -----
        Prints solution summary data (such as time step size, number of
        equilibrium iterations, convergence values, etc.) from a static or full
        transient analysis. All other analyses print zeros for the data.
        """
        command = "PRITER," % ()
        return self.run(command, **kwargs)

    def helpdisp(self, commandname="", **kwargs):
        """APDL Command: HELPDISP

        Displays help information on DISPLAY program commands.

        Parameters
        ----------
        commandname
            Any DISPLAY command.  If blank, a list of DISPLAY commands is
            produced.
        """
        command = "HELPDISP,%s" % (str(commandname))
        return self.run(command, **kwargs)

    def secoffset(self, location="", offset1="", offset2="", cg_y="", cg_z="",
                  sh_y="", sh_z="", **kwargs):
        """APDL Command: SECOFFSET

        Defines the section offset for cross sections.

        Parameters
        ----------
        location, offset1, offset2, cg-y, cg-z, sh-y, sh-z
            The location of the nodes in the section. All are dependent on the
            type. See the "Notes" section of this command description for
            details about these values for the various section types.

        Notes
        -----
        The SECOFFSET command is divided into three types: Beams, Pipes, and
        Shells.

        The offsets defined by the SECOFFSET command are associated with the
        section most recently defined using the SECTYPE command.  Not all
        SECOFFSET location values are valid for each subtype.

        For the thermal shell elements, SHELL131 and SHELL132, the node offset
        specified by SECOFFSET is used in thermal contact analyses.  Otherwise,
        the SECOFFSET command has no effect on the solution for these elements
        and is used only for visualization purposes.

        This command is not valid with thermal solid elements SOLID278 and
        SOLID279.
        """
        command = "SECOFFSET,%s,%s,%s,%s,%s,%s,%s" % (str(location), str(offset1), str(offset2), str(cg_y), str(cg_z), str(sh_y), str(sh_z))
        return self.run(command, **kwargs)

    def dof(self, lab1="", lab2="", lab3="", lab4="", lab5="", lab6="",
            lab7="", lab8="", lab9="", lab10="", **kwargs):
        """APDL Command: DOF

        Adds degrees of freedom to the current DOF set.

        Parameters
        ----------
        lab1, lab2, lab3, . . . , lab10
            Valid labels are: UX, UY, UZ (structural displacements); ROTX,
            ROTY, ROTZ (structural rotations); TEMP, TBOT, TE2, TE3, . . .,
            TTOP (temperatures);  PRES (pressure);  VOLT (voltage); MAG
            (magnetic scalar potential);  AX, AY, AZ (magnetic vector
            potentials);  CURR (current);  EMF (electromotive force drop); CONC
            (concentration); DELETE.

        Notes
        -----
        The degree of freedom (DOF) set for the model is determined from all
        element types defined. This command may be used to add to the current
        set.  The ALL label may be used on some commands to represent all
        labels of the current degree of freedom set for the model.  Issue the
        DOF command with no arguments to list the current set.  Use the DELETE
        label to delete any previously added DOFs and return to the default DOF
        set.
        """
        command = "DOF,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(lab1), str(lab2), str(lab3), str(lab4), str(lab5), str(lab6), str(lab7), str(lab8), str(lab9), str(lab10))
        return self.run(command, **kwargs)

    def aovlap(self, na1="", na2="", na3="", na4="", na5="", na6="", na7="",
               na8="", na9="", **kwargs):
        """APDL Command: AOVLAP

        Overlaps areas.

        Parameters
        ----------
        na1, na2, na3, . . . , na9
            Numbers of areas to be operated on.  If NA1 = ALL, use all selected
            areas and ignore NA2 to NA9.  If NA1 = P, graphical picking is
            enabled and all remaining arguments are ignored (valid only in the
            GUI).  A component name may also be substituted for NA1.

        Notes
        -----
        Generates new areas which encompass the geometry of all the input
        areas. The new areas are defined by the regions of intersection of the
        input areas, and by the complementary (non-intersecting) regions.  See
        Solid Modeling in the Modeling and Meshing Guide for an illustration.
        This operation is only valid when the region of intersection is an
        area.  See the BOPTN command for an explanation of the options
        available to Boolean operations.  Element attributes and solid model
        boundary conditions assigned to the original entities will not be
        transferred to the new entities generated.
        """
        command = "AOVLAP,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(na1), str(na2), str(na3), str(na4), str(na5), str(na6), str(na7), str(na8), str(na9))
        return self.run(command, **kwargs)

    def smbody(self, **kwargs):
        """APDL Command: SMBODY

        Specifies "Body loads on the solid model" as the subsequent status
        topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "SMBODY," % ()
        return self.run(command, **kwargs)

    def essolv(self, electit="", strutit="", dimn="", morphopt="", mcomp="",
               xcomp="", electol="", strutol="", mxloop="", ruseky="",
               restky="", eiscomp="", **kwargs):
        """APDL Command: ESSOLV

        Performs a coupled electrostatic-structural analysis.

        Parameters
        ----------
        electit
            Title of the electrostatics physics file as assigned by the PHYSICS
            command.

        strutit
            Title of the structural physics file as assigned by the PHYSICS
            command.

        dimn
            Model dimensionality (a default is not allowed):

            2 - 2-D model.

            3 - 3-D model.

        morphopt
            Morphing option:

            <0 - Do not perform any mesh morphing or remeshing.

            0 - Remesh the non-structural regions for each recursive loop only if mesh morphing
                fails (default).

            1 - Remesh the non-structural regions each recursive loop and bypass mesh morphing.

            2 - Perform mesh morphing only, do not remesh any non-structural regions.

        mcomp
            Component name of the region to be morphed.  For 2-D models, the
            component may be elements or areas.  For 3-D models, the component
            may be elements or volumes.  A component must be specified. You
            must enclose name-strings in single quotes in the ESSOLV command
            line.

        xcomp
            Component name of entities excluded from morphing.  In the 2-D
            case, it is the component name for the lines excluded from
            morphing.  In the 3-D case, it is component name for the areas
            excluded from morphing.  Defaults to exterior non-shared entities
            (see the DAMORPH, DVMORPH, and DEMORPH commands). You must enclose
            name-strings in single quotes in the ESSOLV command line.

        electol
            Electrostatic energy convergence tolerance.  Defaults to .005 (.5%)
            of the value computed from the previous iteration.  If less than
            zero, the convergence criteria based on electrostatics results is
            turned off.

        strutol
            Structural maximum displacement convergence tolerance.  Defaults to
            .005 (.5%) of the value computed from the previous iteration.  If
            less than zero, the convergence criteria base on structural results
            is turned off.

        mxloop
            Maximum number of allowable solution recursive loops.  A single
            pass through both an electrostatics and structural analysis
            constitutes one loop.  Defaults to 100.

        --
            Unused field.

        ruseky
            Reuse flag option:

            1 - Assumes initial run of ESSOLV using base geometry for the first electrostatics
                solution.

            >1 - Assumes ESSOLV run is a continuation of a previous ESSOLV run, whereby the
                 morphed geometry is used for the initial electrostatic
                 simulation.

        restky
            Structural restart key.

            0 - Use static solution option for structural solution.

            1 - Use static restart solution option for structural solution.

        eiscomp
            Element component name for elements containing initial stress data
            residing in file jobname.ist. The initial stress data must be
            defined prior to issuing ESSOLV (see INISTATE command).

        Notes
        -----
        ESSOLV invokes an ANSYS macro which automatically performs a coupled
        electrostatic-structural analysis.

        The macro displays periodic updates of the convergence.

        If non-structural regions are remeshed during the analysis, boundary
        conditions and loads applied to nodes and elements will be lost.
        Accordingly, it is better to assign boundary conditions and loads to
        the solid model.

        Use RUSEKY > 1 for solving multiple ESSOLV simulations for different
        excitation levels (i.e., for running a voltage sweep). Do not issue the
        SAVE command to save the database between ESSOLV calls.

        For nonlinear structural solutions, the structural restart option
        (RESTKY = 1) may improve solution time by starting from the previous
        converged structural solution.

        For solid elements, ESSOLV automatically detects the air-structure
        interface and applies a Maxwell surface flag on the electrostatic
        elements. This flag is used to initiate the transfer for forces from
        the electrostatic region to the structure. When using the ESSOLV
        command with structural shell elements (for example, SHELL181), you
        must manually apply the Maxwell surface flag on all air elements
        surrounding the shells before writing the final electrostatic physics
        file. Use the SFA command to apply the Maxwell surface flag to the
        areas representing the shell elements; doing so ensures that the air
        elements next to both sides of the shells receive the Maxwell surface
        flag.

        If lower-order structural solids or shells are used, set KEYOPT(7) = 1
        for the electrostatic element types to ensure the correct transfer of
        forces.

        Information on creating the initial stress file is documented in the
        Loading chapter in the Basic Analysis Guide.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "ESSOLV,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(electit), str(strutit), str(dimn), str(morphopt), str(mcomp), str(xcomp), str(electol), str(strutol), str(mxloop), str(ruseky), str(restky), str(eiscomp))
        return self.run(command, **kwargs)

    def rsplit(self, option="", label="", name1="", name2="", name3="",
               name4="", name5="", name6="", name7="", name8="", name9="",
               name10="", name11="", name12="", name13="", name14="",
               name15="", name16="", **kwargs):
        """APDL Command: RSPLIT

        Creates one or more results file(s) from the current results file based
        on subsets of elements.

        Parameters
        ----------
        option
            Specify which results to include for the subset of elements.

            ALL  - Write all nodal and element results based on the subset of elements (default).

            EXT  - Write only the nodal and element results that are on the exterior surface of
                   the element subset. The results data will be averaged as in
                   PowerGraphics (see AVRES) when this results file is brought
                   into POST1. Only valid for solid elements.

        label
            Define where the element subset is coming from.

            ALL  - Use all selected element components (CMSEL) (default).

            ESEL  - Use the currently selected (ESEL) set of elements. Name1 defines the results
                    file name.

            LIST - Use Name1 to Name16 to list the element component and/or assembly names (that
                   contain element components).

        name1, name2, name3, . . . , name16
            Up to 16 element component and/or assembly names (that contain
            element components).

        Notes
        -----
        Results files will be named based on the element component or assembly
        name, e.g., Cname.rst, except for the ESEL option, for which you must
        specify the results file name (no extension) using the Name1 field.
        Note that the .rst filename will be written in all uppercase letters
        (CNAME.rst) (unless using the ESEL option); when you read the file, you
        must specify the filename using all uppercase letters (i.e.,
        file,CNAME). You may repeat the RSPLIT command as often as needed. All
        results sets on the results file are processed. Use /AUX3 to produce a
        results file with just a subset of the results sets.

        Use INRES to limit the results data written to the results files.

        The subset geometry is also written so that no database file is
        required to postprocess the subset results files. You must not resume
        any database when postprocessing one of these results files. The input
        results file must have geometry written to it (i.e., do not use
        /CONFIG,NORSTGM,1).

        Applied forces and reaction forces are not apportioned if their nodes
        are shared by multiple element subsets. Their full values are written
        to each results file.

        Each results file renumbers its nodes and elements starting with 1.

        This feature is useful when working with large models. For more
        information on the advantages and uses of the RSPLIT command, see
        Splitting Large Results Files in the Basic Analysis Guide.
        """
        command = "RSPLIT,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(label), str(name1), str(name2), str(name3), str(name4), str(name5), str(name6), str(name7), str(name8), str(name9), str(name10), str(name11), str(name12), str(name13), str(name14), str(name15), str(name16))
        return self.run(command, **kwargs)

    def spoint(self, node="", x="", y="", z="", **kwargs):
        """APDL Command: SPOINT

        Defines a point for moment summations.

        Parameters
        ----------
        node
            Node number of the desired point.  If zero, use X,Y,Z to describe
            point.

        x, y, z
            Global Cartesian coordinates of the desired summation point.  Used
            if NODE is 0.  Defaults to (0,0,0).

        Notes
        -----
        Defines a point (any point other than the origin) about which the
        tabular moment summations are computed [NFORCE, FSUM].  If force
        summations are desired in other than the global Cartesian directions, a
        node number must be specified on the NODE field, and the desired
        coordinate system must be activated with RSYS.
        """
        command = "SPOINT,%s,%s,%s,%s" % (str(node), str(x), str(y), str(z))
        return self.run(command, **kwargs)

    def quot(self, ir="", ia="", ib="", name="", facta="", factb="", **kwargs):
        """APDL Command: QUOT

        Divides two variables.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        ia, ib
            Reference numbers of the two variables to be operated on.

        --
            Unused field.

        name
            Thirty-two character name identifying the variable on printouts and
            displays.  Embedded blanks are compressed for output.

        --, --
            Unused fields.

        facta, factb
            Scaling factors (positive or negative) applied to the corresponding
            variables (default to 1.0).

        Notes
        -----
        Divides two variables according to the operation:

        IR = (FACTA x IA)/(FACTB x IB)
        """
        command = "QUOT,%s,%s,%s,%s,%s,%s" % (str(ir), str(ia), str(ib), str(name), str(facta), str(factb))
        return self.run(command, **kwargs)

    def edcgen(self, option="", cont="", targ="", fs="", fd="", dc="", vc="",
               vdc="", v1="", v2="", v3="", v4="", btime="", dtime="",
               boxid1="", boxid2="", **kwargs):
        """APDL Command: EDCGEN

        Specifies contact parameters for an explicit dynamics analysis.

        Parameters
        ----------
        option
            Label identifying the contact behavior (dictates the meaning of V1
            through V4).

            AG - Automatic general contact.

            ANTS - Automatic nodes-to-surface contact.

            ASSC - Automatic single surface contact.

            ASS2D - Automatic 2-D single surface contact.

            ASTS - Automatic surface-to-surface contact.

            DRAWBEAD - Drawbead contact

            ENTS - Eroding nodes-to-surface contact.

            ESS - Eroding single surface contact.

            ESTS - Eroding surface-to-surface contact.

            FNTS - Forming nodes-to-surface contact.

            FOSS - Forming one way surface-to-surface contact.

            FSTS - Forming surface-to-surface contact.

            NTS - Nodes-to-surface contact.

            OSTS - One way surface-to-surface contact.

            RNTR - Rigid nodes to rigid body contact.

            ROTR - Rigid body to rigid body (one way) contact.

            SE - Single edge contact.

            SS - Single surface contact.

            STS - Surface-to-surface contact.

            TDNS - Tied nodes-to-surface contact.

            TSES - Tied shell edge-to-surface contact.

            TDSS - Tied surface-to-surface contact.

            TNTS - Tiebreak nodes-to-surface contact

            TSTS - Tiebreak surface-to-surface contact.

        cont
            Contact surface identified by a component name [CM] , a part ID
            number [EDPART], or an assembly ID number [EDASMP]. If a component
            name is input, the component must contain nodes that represent the
            contact surface (assemblies are not valid for a component name).
            Alternatively, a part number may be input that identifies a group
            of elements as the contact surface, or an assembly number may be
            input containing a maximum of 16 parts. The assembly ID number must
            be greater than the highest number used for the part ID. Cont is
            not required for automatic general contact, single edge contact,
            and single surface contact options (Option = AG, SE, ASSC, ESS, and
            SS). For automatic 2-D single surface contact (ASS2D), Cont must be
            defined as a part assembly. For eroding node-to-surface contact
            (ENTS), Cont must be defined as a nodal component. For eroding
            single surface contact (ESS) and eroding surface-to-surface contact
            (ESTS), Cont must be defined as a part ID or part assembly.

        targ
            Target surface identified by a component name [CM] , a part ID
            number [EDPART], or an assembly ID number [EDASMP]. If a component
            name is input, the component must contain nodes that represent the
            target surface (assemblies are not valid for a component name).
            Alternatively, a part number may be input that identifies a group
            of elements as the target surface, or an assembly number may be
            input containing a maximum of 16 parts. The assembly ID number must
            be greater than the highest number used for the part ID. Targ is
            not defined for automatic general contact, single edge contact,
            automatic single surface contact, eroding single surface contact,
            single surface contact, and automatic 2-D single surface contact
            options (Option = AG, SE, ASSC, ESS, SS, and ASS2D). For eroding
            node-to-surface contact (ENTS) and eroding surface-to-surface
            contact (ESTS), Targ must be defined as a part ID or part assembly.

        fs
            Static friction coefficient (defaults to 0).

        fd
            Dynamic friction coefficient (defaults to 0).

        dc
            Exponential decay coefficient (defaults to 0).

        vc
            Coefficient for viscous friction (defaults to 0).

        vdc
            Viscous damping coefficient in percent of critical damping
            (defaults to 0).

        v1, v2, v3, v4
            Additional input for drawbead, eroding, rigid, and tiebreak
            contact.  The meanings of V1-V4 will vary, depending on Option. See
            the table below for V1-V4 definitions.

            V1 - Load curve ID giving the bending component of the restraining force per unit
                 draw bead length as a function of draw bead displacement. V1
                 must be specified.

            V2 - Load curve ID giving the normal force per unit draw bead length as a function
                 of draw bead displacement. V2 is optional.

            V3 - Draw bead depth.

            V4 - Number of equally spaced integration points along the draw bead (default = 0,
                 in which case ANSYS LS-DYNA calculates this value based on the
                 size of the elements that interact with the draw bead).
        """
        command = "EDCGEN,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(cont), str(targ), str(fs), str(fd), str(dc), str(vc), str(vdc), str(v1), str(v2), str(v3), str(v4), str(btime), str(dtime), str(boxid1), str(boxid2))
        return self.run(command, **kwargs)

    def rmrstatus(self, refname="", **kwargs):
        """APDL Command: RMRSTATUS

        Prints status of response surface for ROM function.

        Parameters
        ----------
        refname
            Reference name of ROM function. Valid reference names are "SENE"
            for the strain energy of the mechanical domain and any capacitance
            reference names [RMCAP], for the electrostatic domain.

        Notes
        -----
        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMRSTATUS,%s" % (str(refname))
        return self.run(command, **kwargs)

    def kplot(self, np1="", np2="", ninc="", lab="", **kwargs):
        """APDL Command: KPLOT

        Displays the selected keypoints.

        Parameters
        ----------
        np1, np2, ninc
            Display keypoints from NP1 to NP2 (defaults to NP1) in steps of
            NINC (defaults to 1).  If NP1 = ALL (default), NP2 and NINC are
            ignored and all selected keypoints [KSEL] are displayed.

        lab
            Determines what keypoints are plotted (one of the following):

            (blank) - Plots all keypoints.

            HPT - Plots only those keypoints that are hard points.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "KPLOT,%s,%s,%s,%s" % (str(np1), str(np2), str(ninc), str(lab))
        return self.run(command, **kwargs)

    def smrtsize(self, sizlvl="", fac="", expnd="", trans="", angl="", angh="",
                 gratio="", smhlc="", smanc="", mxitr="", sprx="", **kwargs):
        """APDL Command: SMRTSIZE

        Specifies meshing parameters for automatic (smart) element sizing.

        Parameters
        ----------
        sizlvl
            Overall element size level for meshing.  The level value controls
            the fineness of the mesh.  (Any input in this field causes
            remaining arguments to be ignored.)   Valid inputs are:

            n - Activate SmartSizing and set the size level to n.  Must be an integer value
                from 1 (fine mesh) to 10 (coarse mesh).  Remaining arguments
                are ignored, and argument values are set as shown in
                Table 229: SMRTSIZE - Argument Values for h-elements .

            STAT - List current SMRTSIZE settings.

            DEFA - Set all SMRTSIZE settings to default values (as shown in Table 229: SMRTSIZE -
                   Argument Values for h-elements  for size level 6).

            OFF - Deactivate SmartSizing.  Current settings of DESIZE will be used.  To
                  reactivate SmartSizing, issue SMRTSIZE,n.

        fac
            Scaling factor applied to the computed default mesh sizing.
            Defaults to 1 for h-elements (size level 6), which is medium.
            Values from 0.2 to 5.0 are allowed.

        expnd
            Mesh expansion (or contraction) factor.  (This factor is the same
            as MOPT,EXPND,Value.)  EXPND is used to size internal elements in
            an area based on the size of the elements on the area's boundaries.
            For example, issuing SMRTSIZE,,,2 before meshing an area will allow
            a mesh with elements that are approximately twice as large in the
            interior of an area as they are on the boundary.   If EXPND is less
            than 1, a mesh with smaller elements on the interior of the area
            will be allowed.  EXPND should be greater than 0.5 but less than 4.
            EXPND defaults to 1 for h-elements (size level 6), which does not
            allow expansion or contraction of internal element sizes (except
            when using AESIZE element sizing).  (If EXPND is set to zero, the
            default value of 1 will be used.)  The actual size of the internal
            elements will also depend on the TRANS option or upon AESIZE or
            ESIZE sizing, if used.

        trans
            Mesh transition factor.  (This factor is the same as
            MOPT,TRANS,Value.)  TRANS is used to control how rapidly elements
            are permitted to change in size from the boundary to the interior
            of an area.  TRANS defaults to 2.0 for h-elements (size level 6),
            which permits elements to approximately double in size from one
            element to the next as they approach the interior of the area.  (If
            TRANS is set to zero, the default value will be used.)   TRANS must
            be greater than 1 and, for best results, should be less than 4.
            The actual size of the internal elements will also depend on the
            EXPND option or upon AESIZE or ESIZE sizing, if used.

        angl
            Maximum spanned angle per lower-order element for curved lines.
            Defaults to 22.5 degrees per element (size level 6).  This angle
            limit may be exceeded if the mesher encounters a small feature
            (hole, fillet, etc.).  (This value is not the same as that set by
            DESIZE,,,,ANGL.)

        angh
            Maximum spanned angle per higher-order element for curved lines.
            Defaults to 30 degrees per element (size level 6).  This angle
            limit may be exceeded if the mesher encounters a small feature
            (hole, fillet, etc.).  (This value is NOT the same as that set by
            DESIZE,,,,,ANGH.)

        gratio
            Allowable growth ratio used for proximity checking.  Defaults to
            1.5 for h-elements (size level 6).  Values from 1.2 to 5.0 are
            allowed; however, values from 1.5 to 2.0 are recommended.

        smhlc
            Small hole coarsening key, can be ON (default for size level 6) or
            OFF.  If ON, this feature suppresses curvature refinement that
            would result in very small element edges (i.e., refinement around
            small features).

        smanc
            Small angle coarsening key, can be ON (default for all levels) or
            OFF.  If ON, this feature restricts proximity refinement in areas
            where it is ill-advised (that is, in tight corners on areas,
            especially those that approach 0 degrees).

        mxitr
            Maximum number of sizing iterations (defaults to 4 for all levels).

        sprx
            Surface proximity refinement key, can be off (SPRX = 0, which is
            the default for all levels) or on via two different values (SPRX =
            1 or SPRX = 2).  If SPRX = 1, surface proximity refinement is
            performed and any shell elements that need to be modified are
            modified.  If SPRX=2, surface proximity refinement is performed but
            no shell elements are altered.

        Notes
        -----
        If a valid level number (1 (fine) to 10 (coarse)) is input on SIZLVL,
        inputs for remaining arguments are ignored, and the argument values are
        set as shown in Table: 229:: SMRTSIZE - Argument Values for h-elements
        .

        The settings shown are for h-elements. The first column contains SIZLV
        data, ranging from 10 (coarse) to 1 (fine). The default is 6 (indicated
        by the shaded row).

        Table: 229:: : SMRTSIZE - Argument Values for h-elements
        """
        command = "SMRTSIZE,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(sizlvl), str(fac), str(expnd), str(trans), str(angl), str(angh), str(gratio), str(smhlc), str(smanc), str(mxitr), str(sprx))
        return self.run(command, **kwargs)

    def seclib(self, option="", path="", **kwargs):
        """APDL Command: /SECLIB

        Sets the default section library path for the SECREAD command.

        Parameters
        ----------
        option
            READ

            READ - Sets the read path (default).

            STATUS - Reports the current section library path setting to the Jobname.LOG file.

        path
            Defines the directory path from which to read section library
            files.

        Notes
        -----
        When the SECREAD command is issued without a directory path, the
        command searches for a section library in the following order:

        The user's home directory

        The current working directory

        The path specified by the /SECLIB command


        """
        command = "/SECLIB,%s,%s" % (str(option), str(path))
        return self.run(command, **kwargs)

    def irlist(self, **kwargs):
        """APDL Command: IRLIST

        Prints inertia relief summary table.

        Notes
        -----
        Prints the inertia relief summary data, including the mass summary
        table, the total load summary table, and the inertia relief summary
        table resulting from the inertia relief calculations. These
        calculations are performed in the solution phase [SOLVE] as specified
        by the IRLF command.

        Inertia relief output is stored in the database rather than in the
        results file (Jobname.RST). When you issue IRLIST, ANSYS pulls the
        information from the database, which contains the inertia relief output
        from the most recent solution [SOLVE].

        This command is valid in any processor.
        """
        command = "IRLIST," % ()
        return self.run(command, **kwargs)

    def morph(self, option="", remeshopt="", elemset="", armax="", voch="",
              arch="", step="", time="", stropt="", **kwargs):
        """APDL Command: MORPH

        Specifies morphing and remeshing controls.

        Parameters
        ----------
        option
            OFF

            OFF - Turns off morphing for field elements (default).

            ON - Turns on morphing for field elements.

        --
            Unused field

        remeshopt
            OFF

            OFF - Do not remesh (default).

            ON - Remesh when element qualities fall below values specified by ARMAX, VOCH, or
                 ARCH as explained below. Valid only when Option is ON.

        elemset
            ALL

            ALL - Remesh all selected elements if the quality of the worst defined element falls
                  below any quality requirement (default when Remeshopt = ON).

            CompName  - Specify a component name, up to 32 characters. All elements included in this
                        component name are remeshed if the quality of the worst
                        element falls below any quality requirement.

        armax
            The maximum allowable element generalized aspect ratio. Defaults to
            5.

        voch
            The maximum allowable change of element size (area or volume).
            Defaults to 3.

        arch
            The maximum allowable element aspect ratio change.  Defaults to 3.

        step
            The frequency of element quality checking, based on time steps. A
            quality check takes place at the intervals defined by STEP.
            Defaults to 1 (quality check at every step).

        time
            A quality check takes place at the time point specified. Defaults
            to -1 (a quality check at every time point).

        stropt
            NO

            NO - There are no structural elements in the model (default).

            YES - There are no structural elements in the model and the morphing happens after
                  the structural solution.

        Notes
        -----
        MORPH is applicable to any non-structural field analysis (not including
        fluid elements). It activates displacement degrees of freedom for non-
        structural elements so that boundary conditions may be placed on the
        field mesh to constrain the movement of the non-structural mesh during
        morphing. It morphs the non-structural mesh using displacements
        transferred at the surface interface between the structural field and
        the non-structural field.  The displacements of non-structural elements
        are mesh displacements to avoid mesh distortion, but have no physical
        meaning except at the interface. MORPH does not support surface, link,
        or shell elements, or any element shape other than triangles, quads,
        tets, and bricks. Morphed fields must be in the global Cartesian system
        (CSYS = 0).

        After each remesh, new databases and results files are written with the
        extensions .rth0n and .db0n, where n is the remesh file number
        (FieldName.rth01, FieldName.rth02, ... and FieldName.db01,
        FieldName.db02, etc.).   The original database file is FieldName.dbo.
        The FieldName.db01, FieldName.db02, etc. files have elements that are
        detached from the solid model.

        Remeshing has the following restrictions:

        Valid only for the electrostatic elements (PLANE121, SOLID122, and
        SOLID123)

        Limited to triangle (2-D) and tetrahedral (3-D) options of these
        elements

         Valid only for the MFS solver

        No body loads allowed in the interior nodes of the remeshing domain

        Nodes on the boundary cannot be remeshed; remeshing will not work if
        morphing failed on the surface nodes

        Not suitable for extreme area or volume changes

        This command is also valid in SOLUTION.
        """
        command = "MORPH,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(remeshopt), str(elemset), str(armax), str(voch), str(arch), str(step), str(time), str(stropt))
        return self.run(command, **kwargs)

    def padele(self, delopt="", **kwargs):
        """APDL Command: PADELE

        Deletes a defined path.

        Parameters
        ----------
        delopt
            Path delete option (one of the following):

            ALL - Delete all defined paths.

            NAME - Delete a specific path from the list of path definitions.  (Substitute the
                   actual path name for NAME.)

        Notes
        -----
        Paths are identified by individual path names.  To review the current
        list of path names, issue the command PATH,STATUS.

        This command is valid in the general postprocessor.
        """
        command = "PADELE,%s" % (str(delopt))
        return self.run(command, **kwargs)

    def parain(self, name="", extension="", path="", entity="", fmt="",
               scale="", **kwargs):
        """APDL Command: ~PARAIN

        Transfers a Parasolid file into the ANSYS program.

        Parameters
        ----------
        name
            The name of a valid Parasolid file. The first character of the file
            name must be an alphanumeric.

        extension
            The extension for the file. The default extension is .x_t on a PC
            or .xmt_txt on a Linux system. Parasolid files are compatible
            across systems, and do not need to be renamed to be used on another
            platform.

        path
            The path name of the directory in which the file resides, enclosed
            in single quotes. The default path name is the current working
            directory.

        entity
            Entity to be imported:

            SOLIDS - Solids only, imported as ANSYS volumes (default)

            SURFACES - Surfaces only, imported as ANSYS areas.

            WIREFRAME - Wireframe only, imported as ANSYS lines.

            ALL - All entities. Use this option when the file contains more than one type of
                  entity.

        fmt
            Sets the format in which ANSYS will store the model

            0 - Neutral format (default). Defeaturing after import is restricted. Use this
                option if you need to scale a model to a specific unit of
                measure (other than meters).

            1 - Solid format; this allows defeaturing after import.

        scale
            Allows scaling for the model

            0 - Do not rescale the model; retain the default Parasolid setting of meters
                (default).

            1 - Scale the model if warranted by the model size.

        Notes
        -----
        More information on importing Parasolid parts is available in Parasolid
        in the Connection User's Guide.
        """
        command = "~PARAIN,%s,%s,%s,%s,%s,%s" % (str(name), str(extension), str(path), str(entity), str(fmt), str(scale))
        return self.run(command, **kwargs)

    def rmresume(self, fname="", ext="", **kwargs):
        """APDL Command: RMRESUME

        Resumes ROM data from a file.

        Parameters
        ----------
        fname
            Name and directory path of the ROM database file (248 character
            maximum). Default to Jobname.

        ext
            Extension of the ROM database file. Default to .rom.

        --
            Unused field.

        Notes
        -----
        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMRESUME,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def wfront(self, kprnt="", kcalc="", **kwargs):
        """APDL Command: WFRONT

        Estimates wavefront statistics.

        Parameters
        ----------
        kprnt
            Wavefront history print key:

            0 - Print current wavefront statistics.

            1 - Print current wavefront statistics but also print wavefront history (wavefront
                at each element).  Elements are listed in the reordered
                sequence.

        kcalc
            Calculation options:

            0 - Wavefront estimate assumes maximum model DOF set at each node and does not
                include the effects of master degrees of freedom and specified
                displacement constraints.

            1 - Wavefront estimate uses the actual DOF set at each node and does not include
                the effects of master degrees of freedom and specified
                displacement constraints.  More time consuming than estimated
                wavefront.  KPRNT = 1 is not available with this option.

        Notes
        -----
        Estimates wavefront statistics of the model as currently ordered.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "WFRONT,%s,%s" % (str(kprnt), str(kcalc))
        return self.run(command, **kwargs)

    def cfact(self, rfacta="", ifacta="", rfactb="", ifactb="", rfactc="",
              ifactc="", **kwargs):
        """APDL Command: CFACT

        Defines complex scaling factors to be used with operations.

        Parameters
        ----------
        rfacta
            Real portion of the complex scale factor used in place of FACTA.

        ifacta
            Imaginary portion of the complex scale factor used in place of
            FACTA.

        rfactb
            Real portion of the complex scale factor used in place of FACTB.

        ifactb
            Imaginary portion of the complex scale factor used in place of
            FACTB.

        rfactc
            Real portion of the complex scale factor used in place of FACTC.

        ifactc
            Imaginary portion of the complex scale factor used in place of
            FACTC.

        Notes
        -----
        Defines complex scale factors to be used with the operations [ADD,
        PROD, etc.].  If this command is supplied, these complex factors
        override any real factors (FACTA, FACTB, FACTC) supplied on the
        operation commands.  Factors are typically involved in scaling a
        specified variable, such as in the term FACTA x IA of the ADD command
        to scale variable IA before the ADD operation.

        When the CFACT command is active, defaults are as follows: 1) if the
        complex factor is not specified, but the variable upon which it acts
        (such as IA) is specified, the factor defaults to 1.0+i0.0;  2) if the
        variable upon which the factor operates is not specified, but the
        factor is specified, the variable defaults to 1.0 so that the term in
        the operation becomes the complex factor itself;  3) if neither the
        factor nor the variable number is supplied, the term is omitted from
        the operation.  Once the operation (such as the ADD command) has been
        processed, the CFACT command becomes inactive and must be specified
        again if it is to be used.
        """
        command = "CFACT,%s,%s,%s,%s,%s,%s" % (str(rfacta), str(ifacta), str(rfactb), str(ifactb), str(rfactc), str(ifactc))
        return self.run(command, **kwargs)

    def swdel(self, ecomp="", **kwargs):
        """APDL Command: SWDEL

        Deletes spot weld sets.

        Parameters
        ----------
        ecomp
            Name of an existing spot weld set that was previously defined using
            SWGEN. If Ecomp = ALL (default) all spot welds are deleted.

        Notes
        -----
        This command deletes spot weld sets previously defined by the SWGEN
        command.
        """
        command = "SWDEL,%s" % (str(ecomp))
        return self.run(command, **kwargs)

    def nropt(self, option1="", option2="", optval="", **kwargs):
        """APDL Command: NROPT

        Specifies the Newton-Raphson options in a static or full transient
        analysis.

        Parameters
        ----------
        option1
            Option key:

            AUTO - Let the program choose the option (default).

            FULL - Use full Newton-Raphson.

            MODI - Use modified Newton-Raphson.

            INIT - Use the previously computed matrix (initial-stiffness).

            UNSYM - Use full Newton-Raphson with unsymmetric matrices of elements where the
                    unsymmetric option exists.

        option2
            Option key:

            CRPL  - When applicable in a static creep analysis, activates modified Newton-Raphson
                    with a creep-ratio limit. Valid only when Option1 = AUTO.

        optval
            If Option2 is blank, Optval is the Adaptive Descent Key (Adptky):

            ON - Use adaptive descent (default if frictional contact exists). Explicit ON is
                 valid only if Option = FULL.

            OFF - Do not use adaptive descent (default in all other cases).

        Notes
        -----
        The NROPT command specifies the Newton-Raphson option used to solve the
        nonlinear equations in a static or full transient analysis.

        The automatic modified Newton-Raphson procedure with creep-ratio limit
        control (NROPT,AUTO,CRPL,CRLIMIT) applies to static creep analysis
        only. When the creep ratio is smaller than the value of the creep ratio
        limit specified, the modified Newton-Raphson procedure is used. If
        convergence difficulty occurs during solution, use the full Newton-
        Raphson procedure.

        The command NROPT,UNSYM is also valid in a linear non-prestressed modal
        analysis that is used to perform a brake squeal analysis. In this
        special case, the command is used only to generate the unsymmetric
        stiffness matrix; no Newton-Raphson iterations are performed.

        NROPT,MODI and NROPT,INIT are only applicable with the sparse solver
        (EQSLV,SPARSE). Thermal analyses will always use full Newton-Raphson
        irrespective of the Option1 value selected.

        See Newton-Raphson Option in the Structural Analysis Guide for more
        information.

        This command is also valid in PREP7.

        Switching Between the Symmetric and Unsymmetric Option

        Normally, switching from the symmetric Newton-Raphson option
        (NROPT,FULL) to the unsymmetric option (NROPT,UNSYM) or from the
        unsymmetric option to the symmetric option is allowed between load
        steps within the same analysis type. This is applicable to linear and
        nonlinear, static and full transient analyses.

        Under the following circumstances, the solution could be slightly
        different or inaccurate if you switch from symmetric to unsymmetric or
        vice versa:

        The underlying elements or materials are unsymmetric by their
        mathematical definition, and you switch from unsymmetric to symmetric.

        You change analysis types and also switch from symmetric to unsymmetric
        (or vise versa) at the same time. This situation could result in
        failures such as data corruption or a core dump and should therefore be
        avoided.

        In some rare cases, switching between the symmetric and unsymmetric
        options can cause a system core dump when reading/writing the .ESAV or
        .OSAV file, and the analysis terminates. Typically, this happens when
        the record length of the element nonlinear saved variables cannot be
        altered between load steps by their mathematical definition.

        If all the elements and the material are symmetric by their
        mathematical definition and you use the unsymmetric option, the
        solution accuracy is the same as the symmetric option. However, the
        analysis will run twice as slow as the symmetric case.

        If the static or full transient solution is used as the base analysis
        for a linear perturbation, be aware that switching to the unsymmetric
        Newton-Raphson option forces the program to use the UNSYM or DAMP
        eigensolver in a downstream modal analysis, which may be more expensive
        than symmetric modal analysis.
        """
        command = "NROPT,%s,%s,%s" % (str(option1), str(option2), str(optval))
        return self.run(command, **kwargs)

    def rsymm(self, option="", cs="", axis="", nsect="", condvalue="",
              **kwargs):
        """APDL Command: RSYMM

        Defines the plane of symmetry or center of rotation for the radiosity
        method.

        Parameters
        ----------
        option
            Command options:

            CLEAR  - Deletes all symmetry definitions. Other command options are ignored.

            DEFINE  - Defines the symmetry (default).

            STAT - Shows the status/listing. Other command options are ignored.

            COND - Activates or deactivates condensation in the radiosity solver for all defined
                   radiation symmetries. Condensation is the process where the
                   radiosity equation system is reduced in size. Default is
                   off. (See Figure 7: Usage Example: Option = COND .)

        cs
            Local coordinate system (11) as defined using the LOCAL or CS
            commands or a global coordinate system (0). For planar reflection,
            the coordinate system origin must be on the plane of symmetry (POS)
            and one of its axes must be normal to the POS. For cyclic
            reflection, the coordinate system origin must be coincident with
            the center of rotation (COR). Only Cartesian systems are valid.

        axis
            Axis label of the coordinate system (CS) that is normal to the POS
            for planar reflection. For 2-D model planar reflections, valid
            labels are X or Y. For 3-D model planar reflections, valid labels
            are X, Y, or Z. Must be blank for cyclic reflection. For cyclic
            reflection, it is assumed that the Z axis is aligned with the axis
            of rotation.

        nsect
            Number of cyclic reflections to be done  (1). This field must be
            blank or 0 for planar reflection. Default is blank.

        condvalue
            Condensation key. Valid only when Option = COND.

            ON - Activates condensation in the radiosity solver for all defined radiation
                 symmetries.

            OFF - Deactivates condensation in the radiosity solver for all defined radiation
                  symmetries (default).

        Notes
        -----
        This command is used to define the POS for planar reflection or the COR
        for cyclic reflection. The RSYMM command must be issued before RSURF
        and it may be issued multiple times to have more than one planar/cyclic
        reflection; however, the RSURF command processes them in the order they
        are issued.

        For planar reflection, you must define a local coordinate system  (11)
        with its origin on the POS. One of its axes must be aligned so that it
        is normal to the plane. If possible, use the existing global coordinate
        system (0).

        For cyclic reflection, you must define a local coordinate system  (11)
        with its origin coincident with the COR. Reflections occur about the
        local Z-axis in the counterclockwise direction. You must align the
        Z-axis properly. If possible, use the existing global coordinate system
        (0).

        New surface elements generated inherit the properties of the original
        elements.

        For 2-D axisymmetric models, RSYMM can be used only for symmetrization
        in the YR plane. It cannot be used for the theta direction. Use V2DOPT
        in that case.

        For 2-D axisymmetric YR models, the newly-generated nodes can have only
        positive X coordinates.

        Figure: 7:: : Usage Example: Option = COND

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RSYMM,%s,%s,%s,%s,%s" % (str(option), str(cs), str(axis), str(nsect), str(condvalue))
        return self.run(command, **kwargs)

    def type(self, itype="", **kwargs):
        """APDL Command: TYPE

        Sets the element type attribute pointer.

        Parameters
        ----------
        itype
            Assign this type number to the elements (defaults to 1).

        Notes
        -----
        Activates an element type number to be assigned to subsequently defined
        elements.  This number refers to the element type number (ITYPE)
        defined with the ET command.  Type numbers may be displayed [/PNUM].

        In some cases, ANSYS can proceed with a meshing operation even when no
        logical element type has been assigned via TYPE or XATT,,,TYPE.  For
        more information, see the discussion on setting element attributes in
        Meshing Your Solid Model in the Modeling and Meshing Guide.
        """
        command = "TYPE,%s" % (str(itype))
        return self.run(command, **kwargs)

    def midtol(self, key="", tolerb="", resfq="", **kwargs):
        """APDL Command: MIDTOL

        Sets midstep residual criterion values for structural transient
        analyses.

        Parameters
        ----------
        key
            Midstep residual criterion activation key.

            ON or 1 - Activate midstep residual criterion in a structural transient analysis
                      (default).

            OFF or 0 - Deactivate midstep residual criterion in a structural transient analysis.

            STAT  - List the current midstep residual criterion setting.

        tolerb
            Midstep residual tolerance or reference value for bisection.
            Defaults to 100 times the TOLER setting of the CNVTOL command.

        resfq
            Key to use response frequency computation along with midstep
            residual criterion for automatic time stepping (AUTOTS,ON).

            OFF or 0 - Do not calculate response frequency and do not consider it in the automatic
                       time stepping (default).

            ON or 1 - Calculate response frequency and consider it in the automatic time stepping.

        Notes
        -----
        When TOLERB is input as a tolerance value (TOLERB > 0), the typical
        force and/or moment from the regular time step is used in the midstep
        residual force and/or moment comparison.

        In a structural transient analysis, the suggested tolerance range of
        TOLERB (TOLERB > 0) is as follows:

        If the structural transient analysis is elastic and linear, and the
        load is constant or changes slowly, use a smaller value of TOLERB to
        achieve an accurate solution. If the analysis involves large amounts of
        energy dissipation, such as elastic-plastic material, TOLERB can be
        larger. If the analysis includes contact or rapidly varying loads, a
        smaller value of TOLERB should be used if high frequency response is
        important; otherwise, a larger value of TOLERB may be used to enable
        faster convergence with larger time step sizes.

        For more information on how the midstep criterion is used by the
        program, see Midstep Residual for Structural Dynamic Analysis in the
        Mechanical APDL Theory Reference.

        This command is also valid in PREP7.
        """
        command = "MIDTOL,%s,%s,%s" % (str(key), str(tolerb), str(resfq))
        return self.run(command, **kwargs)

    def tunif(self, temp="", **kwargs):
        """APDL Command: TUNIF

        Assigns a uniform temperature to all nodes.

        Parameters
        ----------
        temp
            Uniform temperature assigned to the nodes. If a TEMP value is not
            specified, the uniform temperature is set to zero.

        Notes
        -----
        TUNIF is a convenient form of the more general BFUNIF command.

        In a transient or nonlinear thermal analysis, the uniform temperature
        is used during the first iteration of a solution as follows:

        as the starting nodal temperature (except where temperatures are
        explicitly specified [D, DK]),

        to evaluate temperature-dependent material properties.

        In a structural analysis or an explicit dynamic analysis, the uniform
        temperature is used as the default temperature for thermal strain
        calculations and material property evaluation (except where body load
        temperatures are specified (BF, BFE, BFK, LDREAD). In other scalar
        field analyses, the uniform temperature is used for material property
        evaluation.

        Because TUNIF (or BFUNIF,TEMP) is step-applied in the first iteration,
        issue a BF,ALL,TEMP,Value command to ramp on a uniform temperature
        load.

        When the TUNIF command is used in an explicit dynamic analysis, you
        cannot apply temperature loading via the EDLOAD,,TEMP command.
        Furthermore, temperature loading defined by TUNIF cannot be listed or
        deleted by the EDLOAD command.

        The command default sets the uniform temperature to the reference
        temperature defined via the TREF command only (and not the MP,REFT
        command).

        If using the command default to set the uniform temperature (to the
        reference temperature set via TREF), you can convert temperature-
        dependent secant coefficients of thermal expansion (SCTEs) from the
        definition temperature to the uniform temperature. To do so, issue the
        MPAMOD command.

        This command is also valid in PREP7.
        """
        command = "TUNIF,%s" % (str(temp))
        return self.run(command, **kwargs)

    def post1(self, **kwargs):
        """APDL Command: /POST1

        Enters the database results postprocessor.

        Notes
        -----
        Enters the general database results postprocessor (POST1).  All load
        symbols (/PBC, /PSF, or /PBF) are automatically turned off with this
        command.

        This command is valid only at the Begin Level.
        """
        command = "/POST1," % ()
        return self.run(command, **kwargs)

    def slashsolu(self, **kwargs):
        """APDL Command: /SOLU

        Enters the solution processor.

        Notes
        -----
        This command is valid only at the Begin Level.
        """
        command = "/SOLU," % ()
        return self.run(command, **kwargs)

    def abbr(self, abbr="", string="", **kwargs):
        """APDL Command: *ABBR

        Defines an abbreviation.

        Parameters
        ----------
        abbr
            The abbreviation (up to 8 alphanumeric characters) used to
            represent the string String.  If Abbr is the same as an existing
            ANSYS command, the abbreviation overrides.  Avoid using an Abbr
            which is the same as an ANSYS command.

        string
            String of characters (60 maximum) represented by Abbr.  Cannot
            include a $ or any of the commands C***,  /COM,  /GOPR,  /NOPR,
            /QUIT,  /UI, or  *END.  Parameter names and commands of the *DO and
            Use the *IF groups may not be abbreviated. If String is blank, the
            abbreviation is deleted. To abbreviate multiple commands, create an
            "unknown command" macro or define String to execute a macro file
            [*USE] containing the desired commands.

        Notes
        -----
        Once the abbreviation Abbr is defined, you can issue it at the
        beginning of a command line and follow it with a blank (or with a comma
        and appended data), and the program will substitute the string  String
        for Abbr as the line is executed. Up to 100 abbreviations may exist at
        any time and are available throughout the program. Abbreviations may be
        redefined or deleted at any time.

        Use *STATUS to display the current list of abbreviations. For
        abbreviations repeated with *REPEAT, substitution occurs before the
        repeat increments are applied. There are a number of abbreviations that
        are predefined by the program (these can be deleted by using the blank
        String option described above). Note that String will be written to the
        File.LOG.

        This command is valid in any processor.
        """
        command = "*ABBR,%s,%s" % (str(abbr), str(string))
        return self.run(command, **kwargs)

    def gplot(self, **kwargs):
        """APDL Command: GPLOT

        Controls general plotting.

        Notes
        -----
        This command displays all entity types as specified via the /GTYPE
        command.  Only selected entities (NSEL, ESEL, KSEL, LSEL, ASEL, VSEL)
        will be displayed.  See the descriptions of the /GTYPE and /GCMD
        commands for methods of setting the entity types displayed.

        This command is valid in any processor.
        """
        command = "GPLOT," % ()
        return self.run(command, **kwargs)

    def nldiag(self, label="", key="", maxfile="", **kwargs):
        """APDL Command: NLDIAG

        Sets nonlinear diagnostics functionality.

        Parameters
        ----------
        label
            Diagnostic function:

            NRRE - Store the Newton-Raphson residuals information.

            EFLG - Identify or display elements or nodes that violate the criteria.

            CONT - Write contact information to a single Jobname.cnd diagnostic text file during
                   solution.

        key
            Diagnostic function characteristics:

            OFF or 0 - Suppresses writing of diagnostic information (default).

            ON or 1 - Writes diagnostic information to the Jobname.ndxxx, Jobname.nrxxx, or
                      Jobname.cnd file. (If Label = CONT, this option is the
                      same as the SUBS option described below.)

            ITER  - Writes contact diagnostic information at each iteration. Valid only when Label
                    = CONT.

            SUBS  - Writes contact diagnostic information at each substep. Valid only when Label =
                    CONT.

            LSTP  - Writes contact diagnostic information at each load step. Valid only when Label
                    = CONT.

            STAT - Lists information about the diagnostic files in the current working directory.

            DEL - Deletes all diagnostic files in the current working directory.

        maxfile
            Maximum number of diagnostic files to create. Valid values are 1
            through 999. Default = 4. Valid only when Label = NRRE or EFLG.

        Notes
        -----
        The NLDIAG command is a nonlinear diagnostics tool valid for nonlinear
        structural analyses. It is a debugging tool for use when you must
        restart after an unconverged solution. The command creates
        Jobname.ndxxx, Jobname.nrxxx, or Jobname.cnd files in the working
        directory to store the information you specify.

        For more information, see Performing Nonlinear Diagnostics.

        Issue the NLDIAG,NRRE,ON command to create Jobname.nrxxx diagnostic
        files (for each equilibrium iteration after the first) in which to
        store the relevant Newton-Raphson residual information of
        forces/moments Fx, Fy, Fz, Mx, My and Mz for the last MAXFILE
        equilibrium iterations.

        Issue a NLDPOST,NRRE,STAT command to list the load step, substep, time,
        and equilibrium iteration corresponding to each of the Jobname.nrxxx
        diagnostic files in the working directory, then issue a
        PLNSOL,NRRES,,,,FileID command to point to the file from which you want
        to create a contour plot of your Newton-Raphson residuals.

        If you restart or issue a new SOLVE command, any Jobname.nrxxx
        diagnostic files in the current (working) directory are overwritten.

        Issue a NLDIAG,EFLG,ON command to create Jobname.ndxxx  diagnostic
        files which store IDs for elements violating the following criteria:

        Too large a distortion (HDST)

        Elements contain nodes that have near zero pivots (PIVT) for nonlinear
        analyses

        Too large a plastic/creep (EPPL/EPCR) strain increment (CUTCONTROL)

        Elements for which mixed u-P constraints are not satisfied (mixed U-P
        option of 18x solid elements only) (MXUP)

        Hyperelastic element (EPHY), cohesive zone material (EPCZ), or damage
        strain (EPDM) not converged

        Radial displacement (RDSP) not converged

        MPC184 multipoint constraint elements using KEYOPT(1) = 6 through 16
        with the Lagrange multiplier option fail to satisfy constraint
        conditions (184J)

        For NLDIAG,EFLG,ON, all Jobname.ndxxx diagnostic files (for each
        equilibrium iteration after the first) in the current (working)
        directory are deleted when you issue a new SOLVE command (or restart).

        In the solution processor (/SOLU), use the STAT option to list the
        active status of this command. In the postprocessor (/POST1), issue a
        NLDPOST,EFLG,STAT command to list the load step, substep, time, and
        equilibrium iteration corresponding to each of the Jobname.ndxxx
        diagnostic files in the working directory, then issue a
        NLDPOST,EFLG,CM,FileID command to create element components that
        violate the criteria.

        Issue the NLDIAG,CONT,ON command to create a Jobname.cnd diagnostic
        file which stores contact information for all defined contact pairs at
        all substeps. Alternatively, you may issue one of the following
        commands to store contact information at a specific frequency:

        NLDIAG,CONT,ITER to write at each iteration

        NLDIAG,CONT,SUBS to write at each substep (default)

        NLDIAG,CONT,LSTP to write at each load step

        Contact diagnostic information is available for elements CONTA171
        through CONTA177; it is not available for CONTA178.

        Diagnostic file Jobname.cnd is written during solution and lists, on a
        pair-base, the following contact information:

        Contact pair ID[1]

        Number of contact elements in contact[2]

        Number of contact elements in "sticking" contact status

        Maximum chattering level

        Maximum contact penetration/Minimum gap[3]

        Maximum closed gap

        Maximum normal contact stiffness

        Minimum normal contact stiffness

        Maximum resulting pinball

        Maximum elastic slip distance

        Maximum tangential contact stiffness

        Minimum tangential contact stiffness

        Maximum sliding distance

        Maximum contact pressure

        Maximum friction stress

        Average contact depth

        Maximum closed penetration

        Number of contact points having too much penetration

        Contacting area

        Maximum contact damping pressure

        Maximum tangential contact damping stress

        Maximum total sliding distance (GSLID), including near-field

        Minimum total sliding distance (GSLID), including near-field

        Maximum fluid penetration pressure on contact surface

        Maximum fluid penetration pressure on target surface

        Total volume lost due to wear for the contact pair

        Total strain energy due to contact constraint

        Total frictional dissipation energy

        Total contact stabilization energy

        ANSYS Workbench contact pair ID[4]
        """
        command = "NLDIAG,%s,%s,%s" % (str(label), str(key), str(maxfile))
        return self.run(command, **kwargs)

    def aesize(self, anum="", size="", **kwargs):
        """APDL Command: AESIZE

        Specifies the element size to be meshed onto areas.

        Parameters
        ----------
        anum
            Area number of the area to which this element size specification
            applies. If ANUM = ALL, size applies to all selected areas. If ANUM
            = P, graphical picking is enabled. A component name may also be
            substituted for ANUM.

        size
             Desired element size.

        Notes
        -----
        AESIZE allows control over the element sizing inside any area or on the
        face(s) of a volume.

        SIZE controls element size on the interior of the area. For any line on
        the area not having its own size assignment and not controlled by
        keypoint size assignments, it specifies the element size along the line
        as well, so long as no adjacent area has a smaller size, which would
        take precedence. If the AESIZE governs the boundary and SmartSizing is
        on, the boundary size can be refined for curvature or proximity.

        This command is also valid for rezoning.
        """
        command = "AESIZE,%s,%s" % (str(anum), str(size))
        return self.run(command, **kwargs)

    def csys(self, kcn="", **kwargs):
        """APDL Command: CSYS

        Activates a previously defined coordinate system.

        Parameters
        ----------
        kcn
            Specifies the active coordinate system, as follows:

            0 (default) - Cartesian

            1 - Cylindrical with global Cartesian Z as the axis of rotation

            2 - Spherical

            4 or WP - Working Plane

            5 - Cylindrical with global Cartesian Y as the axis of rotation

            11 or greater - Any previously defined local coordinate system

        Notes
        -----
        The CSYS command activates a previously defined coordinate system for
        geometry input and generation.  The LOCAL, CLOCAL, CS, CSKP, and CSWPLA
        commands also activate coordinate systems as they are defined. To set
        the active element coordinate system attribute pointer, issue the ESYS
        command.

        The active coordinate system for files created via the CDWRITE command
        is Cartesian (CSYS,0).

        This command is valid in any processor.

        CSYS,4 (or CSYS,WP) activates working plane tracking, which updates the
        coordinate system to follow working plane changes. To deactivate
        working plane tracking, activate any other coordinate system (for
        example, CSYS,0 or CSYS,11).

        CSYS,5 is a cylindrical coordinate system with global Cartesian Y as
        the axis. The local x, y and z axes are radial, θ, and axial
        (respectively). The R-Theta plane is the global X-Z plane, as it is for
        an axisymmetric model. Thus, at θ = 0.0, CSYS,5 has a specific
        orientation: the local x is in the global +X direction, local y is in
        the global -Z direction, and local z (the cylindrical axis) is in the
        global +Y direction.
        """
        command = "CSYS,%s" % (str(kcn))
        return self.run(command, **kwargs)

    def ndele(self, node1="", node2="", ninc="", **kwargs):
        """APDL Command: NDELE

        Deletes nodes.

        Parameters
        ----------
        node1, node2, ninc
            Delete nodes from NODE1 to NODE2 (defaults to NODE1) in steps of
            NINC (defaults to 1).  If NODE1 = ALL, NODE2 and NINC are ignored
            and all selected nodes [NSEL] are deleted.  If NODE1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).  A component name may also be substituted
            for NODE1.

        Notes
        -----
        Deletes selected nodes that are not connected to elements.  Nodes may
        also be redefined instead of deleted, if desired.  Boundary conditions
        (displacements, forces, etc.) as well as any coupling or constraint
        equations containing the deleted nodes are also deleted.

        This command is also valid in the /MAP processor.
        """
        command = "NDELE,%s,%s,%s" % (str(node1), str(node2), str(ninc))
        return self.run(command, **kwargs)

    def nlmesh(self, control="", val1="", val2="", val3="", val4="", **kwargs):
        """APDL Command: NLMESH

        Controls remeshing in nonlinear adaptivity.

        Parameters
        ----------
        control
            The mesh-quality control to adjust:

            NANG  - Specifies the surface facet dihedral angle threshold. Use this option to retain
                    source mesh geometry features. The dihedral angle is
                    defined by the angle between the normal vectors from two
                    neighboring surface facet sharing an edge. If the dihedral
                    angle is larger than the specified threshold, the edge is
                    treated as soft edge so that the new nodes are forced to
                    the edge.

            VAL1 is the dihedral angle threshold (in degrees) on concave surfaces. VAL2 is the dihedral angle threshold (in degrees) on convex surfaces.  - Default: VAL1 = 15 and VAL2 = 15.

            When NLMESH,EXPL is issued, the VAL1 and VAL2 become the lower bounds of dihedral angles for mesh exploration. Use VAL3 and VAL4 to define the upper bounds of dihedral angles on concave and convex surfaces (respectively) for mesh exploration. - Generally, larger VAL1 and VAL2 values lead to better quality new meshes (and
                              may even repair local tiny facets of poor
                              quality); however, larger values may also smooth
                              out some geometric features, leading to slightly
                              different results and causing possible
                              convergence difficulty in the substeps
                              immediately following remeshing.

            AEDG  - Specifies the edge angle threshold (in degrees). Use this option to split patch
                    segments. The edge angle is the angle between adjacent
                    surface segment edges sharing a node. If the edge angle is
                    larger than the specified threshold (VAL1), the segment
                    splits and the node is automatically treated as a hard node
                    to be retained.

            Default: VAL1 = 10. - Generally, larger VAL1 values improve the quality of the new mesh, but may
                              result in fewer feature nodes. The effect is
                              similar to that of dihedral angles.

            SRAT  - Specifies the global sizing ratio for remeshing.

            Generally, set the lower value (VAL1) to >= 0.7 and the upper value (VAL2) to <= 1.5. Within this range, the model can be refined (< 1.0) or coarsened (> 1.0) up to 3x depending on the number of elements (if performing a remesh of the entire model). - Default: VAL1 = 1.0. The default value results in the new mesh having a similar
                              size as that of the source mesh.

            NLAY - Specifies the number of sculpting layers beginning with detected seed elements.
                   This option helps to detect remeshing regions from whole
                   model.

            Default: VAL1 = 2. - Generally, a larger VAL1 value leads to larger remeshing regions and tends to
                              unite isolated multiple regions. A larger value
                              also tends to result in better remeshing quality
                              (and increases mapping and solution overhead
                              accordingly).

            VAL1 = 0 is not valid, as the remeshing regions would contain only detected seed elements, resulting in many small cavities within remeshing regions (especially if the specified skewness threshold (NLADAPTIVE) is relatively large). - When NLMESH,EXPL is issued, VAL1 becomes the lower bound of mesh exploration.
                              Use VAL2 to define the upper bound for mesh
                              exploration.

            LSRT  - Specifies the local sizing ratio threshold (VAL1). If the length of adjacent
                    segments over that of surface short segments exceeds the
                    specified threshold ratio, the neighboring segments are
                    candidates for local sizing to improve target mesh quality.

            Use local sizing in cases where any of the following conditions exist: - Short edges significantly smaller than average

            Poor surface mesh (triangles) on top edges - Small surface patches composed of few triangles caused by small user-specified
                              dihedral angles.

            Valid values are VAL1 >= 1.0. Default: VAL1 = 1.0. - When NLMESH, EXPL is issued, VAL1 becomes the lower bound of mesh exploration.
                              Use VAL2 to define the upper bound for mesh
                              exploration.

            For more information about this control, see "Notes". - EXPL

            Specifies the nonlinear mesh-exploration behavior. Mesh exploration consists of trying various mesh controls to obtain the best quality mesh during remeshing process. - For more information about this control, see "Notes".

            LIST  - Lists all defined advanced control parameters.

        val1, val2, val3, val4
            Numerical input values that vary according to the specified Control
            option.

        Notes
        -----
        NLMESH is a global control command enabling mesh-quality adjustments
        for remeshing in nonlinear adaptivity. The command can be used when
        components are associated with mesh-quality criteria (NLADAPTIVE with
        Criterion = MESH).

        Issue the NLMESH command only in cases where advanced mesh-quality
        control is desirable for remeshing in nonlinear adaptivity. The
        settings specified by this command apply to all components having mesh-
        quality-based criteria defined.

        Following are LSRT usage examples to help you determine a suitable
        threshold value for the local sizing ratio:

        If the value is only slightly greater than the minimum (and default)
        value of 1.0, local sizing is imposed on all segments. Recommended:
        VAL1 > 1.1.

        If the value is large enough such that no neighboring segments have
        lengths that would cause the threshold ratio to be exceeded, all
        segments are treated as though local sizing is disabled.

        For mesh exploration (NLMESH,EXPL,VAL1):

        VAL1 = 0 -- The exception to the default behavior (no mesh exploration)
        occurs when remeshing fails to create a mesh for the user-specified
        NLMESH input parameters. In this case, mesh exploration is performed as
        though VAL1 = 1, with default NANG upper bounds of 60,60 in order to
        continue the solution, and the lower bounds being user-specified.

        VAL1 = 1 -- The NANG lower and upper bounds must be input; otherwise,
        the command is ignored. The upper bound can be input for NLAY also, but
        the exploration still triggers remeshings with the whole model as seed
        elements.

        VAL1 = 2 -- The NANG lower and upper bounds must be input; otherwise,
        the command is ignored.

        VAL1 = 3 -- An optional upper bound can be specified via LSRT. By
        default, the upper bound is set to be 30 percent more than the (user-
        specified) lower bound.

        Mesh exploration is needed only when it is difficult to obtain a good
        quality mesh via standard remeshing. It is good practice to first try
        less aggressive exploration with VAL1 = 1.
        """
        command = "NLMESH,%s,%s,%s,%s,%s" % (str(control), str(val1), str(val2), str(val3), str(val4))
        return self.run(command, **kwargs)

    def asll(self, type="", arkey="", **kwargs):
        """APDL Command: ASLL

        Selects those areas containing the selected lines.

        Parameters
        ----------
        type
            Label identifying the type of area select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        arkey
            Specifies whether all contained area lines must be selected [LSEL]:

            0 - Select area if any of its lines are in the selected line set.

            1 - Select area only if all of its lines are in the selected line set.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "ASLL,%s,%s" % (str(type), str(arkey))
        return self.run(command, **kwargs)

    def ovcheck(self, method="", frequency="", set="", **kwargs):
        """APDL Command: OVCHECK

        Checks for overconstraint among constraint equations and Lagrange
        multipliers.

        Parameters
        ----------
        method
            Method used to determine which slave DOFs will be eliminated:

            TOPO - Topological approach (default). This method only works with constraint
                   equations; it does not work with Lagrange multipliers.

            ALGE - Algebraic approach.

            NONE - Do not use overconstraint detection logic.

        frequency
            Frequency of overconstraint detection for static or full transient
            analyses:

            ITERATION - For all equilibrium iterations (default).

            SUBSTEP - At the beginning of each substep.

            LOADSTEP - At the beginning of each load step.

        set
            Set of equations:

            All - Check for overconstraint between all constraint equations (default).

            LAG - Check for overconstraint only on the set of equations that involves Lagrange
                  multipliers. This is faster than checking all sets,
                  especially when the model contains large MPC bonded contact
                  pairs.

        Notes
        -----
        The OVCHECK command checks for overconstraint among the constraint
        equations (CE/CP) and the Lagrange multipliers for the globally
        assembled stiffness matrix. If overconstrained constraint equations or
        Lagrange multipliers are detected, they are automatically removed from
        the system of equations.

        The constraint equations that are identified as redundant are removed
        from the system and printed to the output file. It is very important
        that you check the removed equations—they may lead to convergence
        issues, especially for nonlinear analyses.

        The Frequency  and Set arguments are active only for the topological
        method (Method = TOPO). If you do not issue the OVCHECK command,
        overconstraint detection is performed topologically, and the slave DOFs
        are also determined topologically.

        Overconstraint detection slows down the run. We recommend using it to
        validate that your model does not contain any overconstraints. Then,
        you can switch back to the default method (no OVCHECK command is
        needed).

        As an example, consider the redundant set of constraint equations
        defined below:

        Equation number 2 will be removed by the overconstraint detection
        logic. However, this is an arbitrary decision since equation number 1
        could be removed instead. This is an important choice as the constant
        term is not the same in these two constraint equations. Therefore, you
        must check the removed constraint equations carefully.

        For detailed information on the topological and algebraic methods of
        overconstraint detection, see Constraints: Automatic Selection of Slave
        DOFs  in the Mechanical APDL Theory Reference
        """
        command = "OVCHECK,%s,%s,%s" % (str(method), str(frequency), str(set))
        return self.run(command, **kwargs)

    def slashexpand(self, nrepeat1="", type1="", method1="", dx1="", dy1="",
                    dz1="", nrepeat2="", type2="", method2="", dx2="", dy2="",
                    dz2="", nrepeat3="", type3="", method3="", dx3="", dy3="",
                    dz3="", **kwargs):
        """APDL Command: /EXPAND

        Allows the creation of a larger graphic display than represented by the
        actual finite element analysis model.

        Parameters
        ----------
        nrepeat1, nrepeat2, nrepeat3
            The number of repetitions required for the element pattern. The
            default is 0 (no expansion).

        type1, type2, type3
            The type of expansion requested.

            RECT - Causes a Cartesian transformation of DX, DY, and DZ for each pattern (default).

            POLAR - Causes a polar transformation of DR, D-Theta and DZ for each pattern.

            AXIS - Causes 2-D axisymmetric expansion (that is, rotates a 2-D model created in the
                   X-Y plane about the Y axis to create a 3-D model).

            LRECT - Causes a Cartesian transformation of DX, DY, and DZ for each pattern about the
                    current local coordinate system (specified via the CSYS
                    command).

            LPOLAR - Causes a polar transformation of DR, D-Theta, and DZ for each pattern about the
                     local coordinate system (specified via the CSYS command).

        method1, method2, method3
            The method by which the pattern is repeated.

            FULL - Causes a normal repeat of the pattern (default).

            HALF - Uses a symmetry transformation for alternate repeats (to produce an image of a
                   complete circular gear from the image of half a tooth, for
                   example).

        dx1, dy1, dz1, dx2, dy2, dz2, dx3, dy3, dz3
            The Cartesian or polar increments between the repeated patterns.
            Also determines the reflection plane. Reflection is about the plane
            defined by the normal vector (DX, DY, DZ). If you want no
            translation, specify a small nonzero value.  For a half-image
            expansion, the increment DX, DY, or DZ is doubled so that
            POLAR,HALF, ,45 produces full images on 90° centers, and RECT,HALF,
            ,1 produces full images on 2-meter centers.

        Notes
        -----
        You can use the /EXPAND command to perform up to three symmetry
        expansions at once (that is, X, Y, and Z which is equal to going from a
        1/8 model to a full model). Polar expansions allow you to expand a
        wheel section into a half wheel, then into the half section, and then
        into the whole.

        The command displays elements/results when you issue the EPLOT command
        or postprocessing commands.

        The command works on all element and result displays, except as noted
        below. As the graphic display is created, the elements (and results)
        are repeated as many times as necessary, expanding the geometry and, if
        necessary, the displacements and stresses.

        Derived results are not supported.

        The /EXPAND command has the following limitations:

        It does not support solid model entities.

        POLAR, FULL or HALF operations are meaningful only in global
        cylindrical systems and are unaffected by the RSYS or DSYS commands.
        Cartesian symmetry or unsymmetric operations also occur about the
        global Cartesian system.

        It does not average nodal results across sector boundaries, even for
        averaged plots (such as those obtained via the PLNSOL command).

        Axisymmetric harmonic element results are not supported for Type =
        AXIS.

        The /EXPAND command differs significantly from the EXPAND command in
        several respects:

        The uses of /EXPAND are of a more general nature, whereas the EXPAND
        command is intended primarily to expand modal cyclic symmetry results.

        /EXPAND does not change the database as does the EXPAND command.

        You cannot print results displayed via /EXPAND.


        """
        command = "/EXPAND,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nrepeat1), str(type1), str(method1), str(dx1), str(dy1), str(dz1), str(nrepeat2), str(type2), str(method2), str(dx2), str(dy2), str(dz2), str(nrepeat3), str(type3), str(method3), str(dx3), str(dy3), str(dz3))
        return self.run(command, **kwargs)

    def dldele(self, line="", lab="", **kwargs):
        """APDL Command: DLDELE

        Deletes DOF constraints on a line.

        Parameters
        ----------
        line
            Line for which constraints are to be deleted.  If ALL, delete for
            all selected lines [LSEL].  If LINE = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for LINE

        lab
            Constraint label:

            ALL - All constraints.

            SYMM - Symmetry constraints.

            ASYM - Antisymmetry constraints.

            UX - Displacement in X direction.

            UY - Displacement in Y direction.

            UZ - Displacement in Z direction.

            ROTX - Rotation about X axis.

            ROTY - Rotation about Y axis.

            ROTZ - Rotation about Z axis.

            WARP - Warping magnitude.

            PRES - Pressure.

            TEMP, TBOT, TE2, TE3, . . ., TTOP - Temperature.

            VOLT - Electric scalar potential.

            AX - Magnetic vector potential in X direction.

            AY - Magnetic vector potential in Y direction.

            AZ - Magnetic vector potential in Z direction.

            CONC - Concentration.

        Notes
        -----
        Deletes the degree of freedom constraints (and all corresponding finite
        element constraints) on a line previously specified with the DL
        command.  See the DDELE command for delete details.

        Warning:: : On previously meshed lines, all constraints on affected
        nodes will also be deleted, whether or not they were specified by the
        DL command.

        This command is also valid in PREP7.
        """
        command = "DLDELE,%s,%s" % (str(line), str(lab))
        return self.run(command, **kwargs)

    def pbc(self, item="", key="", min="", max="", abs="", **kwargs):
        """APDL Command: /PBC

        Shows boundary condition (BC) symbols and values on displays.

        Parameters
        ----------
        item
            Label identifying the item:

            U - Applied translational constraints (UX, UY, UZ).

            ROT - Applied rotational constraints (ROTX, ROTY, ROTZ).

            TEMP - Applied temperatures (TEMP, TBOT, TE2, TE3, . . ., TTOP).

            PRES - Applied fluid pressures.

            V - Applied flow velocities (VX, VY, VZ).

            VOLT - Applied voltages.

            MAG - Applied scalar magnetic potentials.

            A - Applied vector magnetic potentials.

            CONC - Concentration.

            CHRG - Applied electric charge.

            F or FORC - Applied structural forces (FX, FY, FZ).

            M or MOME - Applied structural moments (MX, MY, MZ).

            HEAT - Applied heat flows (HEAT, HBOT, HE2, HE3, . . ., HTOP).

            FLOW - Applied fluid flow.

            AMPS - Applied current flow.

            FLUX - Applied magnetic flux.

            CSG - Applied magnetic current segments.

            RATE - Diffusion flow rate.

            MAST - Master degrees of freedom.

            CP - Coupled nodes.

            CE - Nodes in constraint equations.

            NFOR - POST1 nodal forces.

            NMOM - POST1 nodal moments

            RFOR - POST1 reaction forces.

            RMOM - POST1 reaction moments (MX, MY, MZ).

            PATH - Path geometry (undistorted) associated with the PATH command after a PDEF or
                   PVECT command has been issued.

            ACEL - Global acceleration (ACELX, ACELY, ACELZ vector).

            OMEG - Global angular velocity (OMEGX, OMEGY, OMEGZ vector) and acceleration (DOMEGX,
                   DOMEGY, DOMEGZ vector).

            WELD - Applied spotwelds (ANSYS LS-DYNA).

            ALL - Represents all appropriate labels.

        --
            Unused field.

        key
            Symbol key:

            0 - Do not show symbol.

            1 - Show symbol.

            2 - Plot value next to symbol.

        min
            Minimum value in a range of values plotted on screen.

        max
            Maximum value in a range of values plotted on screen.

        abs
            Absolute number.  If KEY = 2 and ABS = 0, a number falling between
            the MIN and MAX is displayed.  If ABS is not specified, it defaults
            to 0.  If KEY = 2 and ABS = 1, an absolute value falling between
            the MIN and MAX is displayed.   ABS = 1 lets you eliminate the
            display of numbers whose absolute values are less than a desired
            tolerance.  For example, if ABS = 1, MIN = 10 and MAX = 1e8, values
            such as .83646 and -5.59737 are not displayed.

        Notes
        -----
        The /PBC command adds degree of freedom constraint, force load, and
        other symbols to displays.

        Symbols are applied to the selected nodes only.  All arrow and
        arrowhead symbols are oriented in the nodal coordinate system and lie
        in two perpendicular planes.  Force arrows are scaled proportional to
        their magnitude. (If KEY =  1, use /VSCALE to change arrow length.)
        For scalar quantities, the specific component direction (i.e., x, y, or
        z) of the symbol has no meaning, but the positive or negative sense
        (e.g., positive or negative x) represents a positive or negative scalar
        value, respectively.

        The effects of the /PBC command are not cumulative (that is, the
        command does not modify an existing setting from a previously issued
        /PBC command).  If you issue multiple /PBC commands during an analysis,
        only the setting specified by the most recent /PBC command applies.

        Use /PSTATUS or /PBC,STAT to display settings.  Use /PBC,DEFA to reset
        all specifications back to default.  See the /PSF and /PBF commands for
        other display symbols.

        In a cyclic symmetry analysis, the /PBC command is deactivated when
        cyclic expansion is active (/CYCEXPAND,,ON). To view boundary
        conditions on the basic sector, deactivate cyclic expansion
        (/CYCEXPAND,,OFF) and issue this command:: : /PBC,ALL,,1

        Issuing the command /PBC,PATH, ,1 displays all defined paths.

        The /PBC command is valid in any processor.
        """
        command = "/PBC,%s,%s,%s,%s,%s" % (str(item), str(key), str(min), str(max), str(abs))
        return self.run(command, **kwargs)

    def lsdele(self, lsmin="", lsmax="", lsinc="", **kwargs):
        """APDL Command: LSDELE

        Deletes load step files.

        Parameters
        ----------
        lsmin, lsmax, lsinc
            Range of load step files to be deleted, from LSMIN to LSMAX in
            steps of LSINC.  LSMAX defaults to LSMIN, and LSINC defaults to 1.
            If LSMIN = ALL, all load step files are deleted (and LSMAX and
            LSINC are ignored).  The load step files are assumed to be named
            Jobname.Sn, where n is a number assigned by the LSWRITE command (01
            --09,10,11, etc.).  On systems with a 3-character limit on the
            extension, the "S" is dropped for numbers > 99.

        Notes
        -----
        Deletes load step files in the current directory (written by the
        LSWRITE command).

        This command is also valid in PREP7.
        """
        command = "LSDELE,%s,%s,%s" % (str(lsmin), str(lsmax), str(lsinc))
        return self.run(command, **kwargs)

    def lsbv(self, nl="", nv="", sepo="", keepl="", keepv="", **kwargs):
        """APDL Command: LSBV

        Subtracts volumes from lines.

        Parameters
        ----------
        nl
            Line (or lines, if picking is used) to be subtracted from.  If ALL,
            use all selected lines.  If NL = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).  A component name may also be substituted for NL.

        nv
            Volume (or volumes, if picking is used) to be subtracted.  If ALL,
            use all selected volumes.  A component name may also be substituted
            for NV.

        sepo
            Behavior if the intersection of the NL lines and the NV volumes is
            a keypoint or keypoints:

            (blank) - The resulting lines will share keypoint(s) where they touch.

            SEPO - The resulting lines will have separate, but coincident keypoint(s) where they
                   touch.

        keepl
            Specifies whether NL lines are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NL lines after LSBV operation (override BOPTN command settings).

            KEEP - Keep NL lines after LSBV operation (override BOPTN command settings).

        keepv
            Specifies whether NV volumes are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NV volumes after LSBV operation (override BOPTN command settings).

            KEEP - Keep NV volumes after LSBV operation (override BOPTN command settings).

        Notes
        -----
        Generates new lines by subtracting the regions common to both NL lines
        and NV volumes (the intersection) from the NL lines.  The intersection
        can be a line(s) or point(s).  If the intersection is a point and SEPO
        is blank, the NL1 line is divided at the point and the resulting lines
        will be connected, sharing a common keypoint where they touch.  If SEPO
        is set to SEPO, NL1 is divided into two unconnected lines with separate
        keypoints where they touch.  See the Modeling and Meshing Guide for an
        illustration.  See the BOPTN command for an explanation of the options
        available to Boolean operations.  Element attributes and solid model
        boundary conditions assigned to the original entities will not be
        transferred to the new entities generated.  LSBL,ALL,ALL will have no
        effect since all the lines (in NL1) will be unavailable as NL2 lines.
        """
        command = "LSBV,%s,%s,%s,%s,%s" % (str(nl), str(nv), str(sepo), str(keepl), str(keepv))
        return self.run(command, **kwargs)

    def rezone(self, option="", ldstep="", sbstep="", **kwargs):
        """APDL Command: REZONE

        Initiates the rezoning process, sets rezoning options, and rebuilds the
        database.

        Parameters
        ----------
        option
            The rezoning method to employ:

            MANUAL - Manual rezoning. You decide when to use rezoning, what region(s) to rezone, and
                     what remeshing method to use on the selected region(s).
                     This method is currently the default and only option.

        ldstep
            The load step number at which rezoning should occur. The default
            value is the highest load step number found in the Jobname.Rnnn
            files (for the current jobname and in the current directory).

        sbstep
            The substep number of the specified load step (LDSTEP) at which
            rezoning should occur. The default value is the highest substep
            number found in the specified load step in the Jobname.Rnnn files
            (for the current jobname and in the current directory).

        Notes
        -----
        The REZONE command rebuilds the database (.db file) based on the
        specified load step and substep information, and updates nodes to their
        deformed position for remeshing.

        Before issuing this command, clear the database via the /CLEAR command.

        For more information, see Rezoning in the Advanced Analysis Guide.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "REZONE,%s,%s,%s" % (str(option), str(ldstep), str(sbstep))
        return self.run(command, **kwargs)

    def modopt(self, method="", nmode="", freqb="", freqe="", cpxmod="",
               nrmkey="", modtype="", blocksize="", scalekey="", **kwargs):
        """APDL Command: MODOPT

        Specifies modal analysis options.

        Parameters
        ----------
        method
            Mode-extraction method to be used for the modal analysis.

            LANB - Block Lanczos

            LANPCG - PCG Lanczos

            SNODE - Supernode modal solver

            SUBSP - Subspace algorithm

            UNSYM - Unsymmetric matrix

            DAMP - Damped system

            QRDAMP - Damped system using QR algorithm

            VT - Variational Technology

        nmode
            The number of modes to extract. The value can depend on the value
            supplied for Method. NMODE has no default and must be specified. If
            Method = LANB, LANPCG, or SNODE, the number of modes that can be
            extracted can equal the DOFs in the model after the application of
            all boundary conditions.

        freqb
            The beginning, or lower end, of the frequency range of interest.

        freqe
            The ending, or upper end, of the frequency range of interest (in
            Hz). The default for Method = SNODE is described below. The default
            for all other methods is to calculate all modes, regardless of
            their maximum frequency.

        cpxmod
            Complex eigenmode key. (Valid only when Method = QRDAMP or Method =
            UNSYM).

            AUTO - Determine automatically if the eigensolutions are real or complex and output
                   them accordingly. This is the default for Method = UNSYM.
                   Not supported for Method = QRDAMP.

            ON or CPLX - Calculate and output complex eigenmode shapes.

            OFF or REAL - Do not calculate complex eigenmode shapes. This is required if a mode-
                          superposition analysis is intended after the modal
                          analysis for Method = QRDAMP. This is the default for
                          this method.

        nrmkey
            Mode shape normalization key:

            OFF - Normalize the mode shapes to the mass matrix (default).

            ON - Normalize the mode shapes to unity instead of to the mass matrix.  If a
                 subsequent spectrum or mode-superposition analysis is planned,
                 the mode shapes should be normalized to the mass matrix
                 (Nrmkey = OFF).

        modtype
            Type of modes calculated by the eigensolver. Only applicable to the
            unsymmetric eigensolver.

            Blank - Right eigenmodes. This value is the default.

            BOTH - Right and left eigenmodes. The left eigenmodes are written to Jobname.LMODE.
                   This option must be activated if a mode-superposition
                   analysis is intended.

        blocksize
            The block vector size to be used with the Block Lanczos or Subspace
            eigensolver (used only when Method = LANB or SUBSP). BlockSize must
            be an integer value between 0 and 16. When BlockSize = zero or
            blank, the code decides the block size internally (normally, a
            value of 8 is used for LANB and a value of 6 is used for SUBSP).
            Typically, higher BlockSize values are more efficient under each of
            the following conditions:

        --
            Unused field.

        --
            Unused field.

        scalekey
            Matrices scaling key for acoustic-structural interaction:

            OFF - Do not scale the matrices (default).

            ON - Scale the matrices.

        Notes
        -----
        Specifies modal analysis (ANTYPE,MODAL) options. Additional options
        used only for the Supernode (SNODE) eigensolver are specified by the
        SNOPTION command. Additional options used only for the Subspace (SUBSP)
        eigensolver are specified by the SUBOPT command. If Method = LANPCG,
        ANSYS automatically switches to the PCG solver internally for this
        modal analysis. You can further control the efficiency of the PCG
        solver with the PCGOPT and EQSLV commands.

        For models that involve a non-symmetric element stiffness matrix, as in
        the case of a contact element with frictional contact, the QRDAMP
        eigensolver (MODOPT, QRDAMP) extracts modes in the modal subspace
        formed by the eigenmodes from the symmetrized eigenproblem. The QRDAMP
        eigensolver symmetrizes the element stiffness matrix on the first pass
        of the eigensolution, and in the second pass, eigenmodes are extracted
        in the modal subspace of the first eigensolution pass. For such non-
        symmetric eigenproblems, you should verify the eigenvalue and eigenmode
        results using the non-symmetric matrix eigensolver  (MODOPT,UNSYM).

        The DAMP and QRDAMP options cannot be followed by a subsequent spectrum
        analysis. The UNSYM method supports spectrum analysis when
        eigensolutions are real.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: The VT extraction method is not
        supported in Distributed ANSYS. All other extraction methods are
        supported. However, PCG Lanczos, SUBSP, UNSYM, DAMP, and QRDAMP are the
        only distributed eigensolvers that will run a fully distributed
        solution. The Block Lanczos and Supernode eigensolvers are not
        distributed eigensolvers; therefore, you will not see the full
        performance improvements with these methods that you would with a fully
        distributed solution.
        """
        command = "MODOPT,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(method), str(nmode), str(freqb), str(freqe), str(cpxmod), str(nrmkey), str(modtype), str(blocksize), str(scalekey))
        return self.run(command, **kwargs)

    def cedele(self, neqn1="", neqn2="", ninc="", nsel="", **kwargs):
        """APDL Command: CEDELE

        Deletes constraint equations.

        Parameters
        ----------
        neqn1, neqn2, ninc
            Delete constraint equations from NEQN1 to NEQN2 (defaults to NEQN1)
            in steps of NINC (defaults to 1).  If NEQN1 = ALL, NEQN2  and NINC
            will be ignored all constraint equations will be deleted.

        nsel
            Additional node selection control:

            ANY  - Delete equation set if any of the selected nodes are in the set (default).

            ALL  - Delete equation set only if all of the selected nodes are in the set.
        """
        command = "CEDELE,%s,%s,%s,%s" % (str(neqn1), str(neqn2), str(ninc), str(nsel))
        return self.run(command, **kwargs)

    def mpdele(self, lab="", mat1="", mat2="", inc="", lchk="", **kwargs):
        """APDL Command: MPDELE

        Deletes linear material properties.

        Parameters
        ----------
        lab
            Material property label (see MP command for valid labels).  If ALL,
            delete properties for all applicable labels.

        mat1, mat2, inc
            Delete materials from MAT1 to MAT2 (defaults to MAT1) in steps of
            INC (defaults to 1).  If MAT1 = ALL, MAT2 and INC are ignored and
            the properties for all materials are deleted.

        lchk
            Specifies the level of element-associativity checking:

            NOCHECK - No element-associativity check occurs. This option is the default.

            WARN - When a section, material, or real constant is associated with an element, ANSYS
                   issues a message warning that the necessary entity has been
                   deleted.

            CHECK - The command terminates, and no section, material, or real constant is deleted
                    if it is associated with an element.

        Notes
        -----
        This command is also valid in SOLUTION.

        The LCHK argument is valid only when Lab = ALL.
        """
        command = "MPDELE,%s,%s,%s,%s,%s" % (str(lab), str(mat1), str(mat2), str(inc), str(lchk))
        return self.run(command, **kwargs)

    def psmat(self, fname="", ext="", matrix="", color="", **kwargs):
        """APDL Command: PSMAT

        Writes an assembled global matrix to a postscript format that
        graphically displays nonzero matrix values.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        matrix
            Specify which matrix to write to the output postscript file:

            STIFF - Write stiffness matrix to output postscript file. Valid for all types of
                    analyses that write a .FULL file.

            MASS - Write mass matrix to output postscript file. Valid for buckling, substructure,
                   and modal analyses. If the .FULL file was generated in a
                   buckling analysis, then this label will write the stress
                   stiffening matrix to the output postscript file.

            DAMP - Write damping matrix to output postscript file. Only valid for damped modal
                   analyses.

        color
            Specifies whether to display the grid in black and white or in
            color:

            BLACK  - Each nonzero coefficient is symbolized by a black square (default).

            COLOR  - Each nonzero coefficient is symbolized by a colored square. The color depends
                     on the module of the coefficient; the range is from blue
                     for the smallest values to red for the largest values. The
                     color map is:

        Notes
        -----
        This command is used to copy a matrix from the assembled global matrix
        file (.FULL file) as specified on the FILE command and write it in a
        postscript format to a new file named Fname.Ext (defaults to
        Jobname.PS). The matrix is symbolized by a grid in which the black or
        colored squares represent the nonzero coefficients of the matrix. The
        .FULL file must be available for this command to work properly.

        If the matrix is large, it may be difficult to display the postscript
        file. In this case, use Color = BLACK to reduce the postscript file
        size.

        The assembled global matrix file is created during solution depending
        on the analysis type, equation solver, and other solution options. By
        default, the assembled global matrix file is never deleted at the end
        of solution. For most analysis types, the Sparse direct solver and the
        ICCG solver write a .FULL file. All mode extraction methods used for
        buckling and modal analyses write a properly formatted .FULL file to be
        used with the PSMAT command.

        When copying the stiffness matrix for transient and harmonic analyses,
        be aware that the element mass matrix values (and possibly element
        damping matrix values) are incorporated into the globally assembled
        stiffness matrix.  Thus, the globally assembled stiffness matrix
        represents more than the stiffness of the model for these analysis
        types.  Please refer to the Mechanical APDL Theory Reference for more
        details.

        The PSMAT command is not able to display a lumped mass matrix from a
        .FULL file generated by a harmonic analysis.

        When copying a .FULL file, the rows and columns corresponding to
        specified constraints (e.g., D commands) are eliminated from the system
        of equations and therefore are not written to the .PS file. In
        addition, rows and columns corresponding to eliminated (slave) degrees
        of freedom from coupling and/or constraint equations (e.g., CE, CP
        commands) are eliminated from the system of equations and are not
        written to the .PS file. The DOFs that are eliminated from any coupling
        and/or constraint equations are determined internally by the solution
        code and may not match what you specified via the CE/CP (or similar)
        commands.

        When copying a .FULL file, only the upper triangular part of the matrix
        will be written to the .PS  file if the matrix is symmetric; the full
        matrix is written if the matrix is unsymmetric. Only matrix
        coefficients that are greater than zero will be written.

        The WRFULL command, in conjunction with the SOLVE command, can be used
        to generate the assembled global matrix file and eliminate the equation
        solution process and results output process.

        The following command sequence shows typical usage of this command.

        Below is an example of an export of the stiffness matrix to a
        postscript format using the COLOR option.

        :
        """
        command = "PSMAT,%s,%s,%s,%s" % (str(fname), str(ext), str(matrix), str(color))
        return self.run(command, **kwargs)

    def store(self, lab="", npts="", **kwargs):
        """APDL Command: STORE

        Stores data in the database for the defined variables.

        Parameters
        ----------
        lab
            Valid labels:

            MERGE - Merge data from results file for the time points in memory with the existing
                    data using current specifications (default).

            NEW - Store a new set of data, replacing any previously stored data with current
                  result file specifications and deleting any previously-
                  calculated (OPER) variables. Variables defined using the
                  ANSOL command are also deleted.

            APPEN - Append data from results file to the existing data.

            ALLOC - Allocate (and zero) space for NPTS data points.

            PSD - Create a new set of frequency points for PSD calculations (replacing any
                  previously stored data and erasing any previously calculated
                  data).

        npts
            The number of time points (or frequency points) for storage (used
            only with Lab = ALLOC or PSD).  The value may be input when using
            POST26 with data supplied from other than a results file.  This
            value is automatically determined from the results file data with
            the NEW, APPEN, and MERGE options.  For the PSD option, NPTS
            determines the resolution of the frequency vector (valid numbers
            are between 1 and 10, defaults to 5).

        Notes
        -----
        This command stores data from the results file in the database for the
        defined variables [NSOL, ESOL, SOLU, JSOL] per specification [FORCE,
        LAYERP26, SHELL].  See the Basic Analysis Guide for more information.

        The STORE,PSD command will create a new frequency vector (variable 1)
        for response PSD calculations [RPSD].  This command should first be
        issued before defining variables [NSOL, ESOL, RFORCE] for which
        response PSD's are to be calculated.
        """
        command = "STORE,%s,%s" % (str(lab), str(npts))
        return self.run(command, **kwargs)

    def starprint(self, matrix="", fname="", **kwargs):
        """APDL Command: *PRINT

        Prints the matrix values to a file.

        Parameters
        ----------
        matrix
            Name of matrix or vector to print. Must be specified.

        fname
            File name. If blank, matrix is written to the output file.

        Notes
        -----
        The matrix may be a dense matrix (*DMAT), a sparse matrix (*SMAT), or a
        vector (*VEC). Only the non-zero entries of the matrix are printed.
        """
        command = "*PRINT,%s,%s" % (str(matrix), str(fname))
        return self.run(command, **kwargs)

    def prcint(self, id="", node="", dtype="", **kwargs):
        """APDL Command: PRCINT

        Lists the fracture parameter (CINT) results data.

        Parameters
        ----------
        id
            Crack ID number.

        node
            Crack tip node number. Default = ALL. Valid only for 3-D analysis.

        dtype
            Data type to output:

            JINT - J-integral

            IIN1 - Interaction integral 1

            IIN2 - Interaction integral 2

            IIN3 - Interaction integral 3

            K1 - Mode 1 stress-intensity factor

            K2 - Mode 2 stress-intensity factor

            K3 - Mode 3 stress-intensity factor

            G1 - Mode 1 energy release rate

            G2 - Mode 2 energy release rate

            G3 - Mode 3 energy release rate

            GT - Total energy release rate

            MFTX - Total material force X

            MFTY - Total material force Y

            MFTZ - Total material force Z

            TSTRESS - T-stress

            CEXT - Crack extension

            CSTAR - C*-integral

            STTMAX - Maximum circumferential stress

            PSMAX - Maximum circumferential stress when

        Notes
        -----
        When a crack tip node is defined, the values associated with the
        specified node are listed.

        Dtype = STTMAX or PSMAX are valid for XFEM-based crack growth analyses
        only.

        In an XFEM-based analysis, issue the command using this syntax:

        PRCINT, ID, , STTMAX (or PSMAX)
        """
        command = "PRCINT,%s,%s,%s" % (str(id), str(node), str(dtype))
        return self.run(command, **kwargs)

    def moper(self, parr="", par1="", oper="", par2="", par3="", kdim="",
              kout="", limit="", **kwargs):
        """APDL Command: *MOPER

         Performs matrix operations on array parameter matrices.

        Parameters
        ----------
        parr
            The name of the resulting array parameter matrix.  See *SET for
            name restrictions.

        par1
            First array parameter matrix input to the operation. For Oper =
            MAP, this is an N x 3 array of coordinate locations at which to
            interpolate. ParR will then be an N(out) x M array containing the
            interpolated values.

        oper
            Matrix operations:

            (*MOPER, ParR, Par1, INVERT) - Square matrix invert: Inverts the n x n matrix in Par1 into ParR. The matrix
                              must be well conditioned.

            Warning:Non-independent or ill-conditioned equations can cause erroneous results. - For large matrices, use the APDL Math operation *LSFACTOR for efficiency (see
                              APDL Math).

            (*MOPER, ParR, Par1, MULT, Par2) - Matrix multiply: Multiplies Par1 by Par2.  The number of rows of Par2 must
                              equal the number of columns of Par1 for the
                              operation. If Par2 is input with a number of rows
                              greater than the number of columns of Par1,
                              matrices are still multiplied. However, the
                              operation only uses a number of rows of Par2
                              equal to the number of columns of Par1.

            (*MOPER, ParR, Par1, COVAR, Par2) - Covariance: The measure of association between two columns of the input matrix
                              (Par1).  Par1, of size m runs (rows) by n data
                              (columns) is first processed to produce a row
                              vector containing the mean of each column which
                              is transposed to a column vector (Par2) of n
                              array elements.  The Par1 and Par2 operation then
                              produces a resulting n x n matrix (ParR) of
                              covariances (with the variances as the diagonal
                              terms).

            (*MOPER, ParR, Par1, CORR, Par2) - Correlation: The correlation coefficient between two variables.  The input
                              matrix (Par1), of size m runs (rows) by n data
                              (columns), is first processed to produce a row
                              vector containing the mean of each column which
                              is then transposed to a column vector (Par2) of n
                              array elements.  The Par1 and Par2 operation then
                              produces a resulting n x n matrix (ParR) of
                              correlation coefficients (with a value of 1.0 for
                              the diagonal terms).

            (*MOPER, ParR, Par1, SOLV, Par2) - Solution of simultaneous equations:  Solves the set of n equations of n terms
                              of the form an1x1 + an2x2 + ... + annxn = bn
                              where Par1 contains the matrix of a-coefficients,
                              Par2 the vector(s) of b-values, and ParR the
                              vector(s) of x-results.  Par1 must be a square
                              matrix.  The equations must be linear,
                              independent, and well conditioned.

            Warning:Non-independent or ill-conditioned equations can cause erroneous results. - For large matrices, use the APDL Math operation *LSFACTOR for efficiency (see
                              APDL Math).

            (*MOPER, ParR, Par1, SORT, Par2, n1, n2, n3) - Matrix sort: Sorts matrix Par1 according to sort vector Par2 and places the
                              result back in Par1. Rows of Par1 are moved to
                              the corresponding positions indicated by the
                              values of Par2. Par2 may be a column of Par1 (in
                              which case it will also be reordered).
                              Alternatively, you may specify the column of Par1
                              to sort using n1 (leaving Par2 blank). A
                              secondary sort can be specified by column n2, and
                              a third sort using n3. ParR is the vector of
                              initial row positions (the permutation vector).
                              Sorting Par1 according to ParR should reproduce
                              the initial ordering.

            (*MOPER, ParR, Par1, NNEAR, Toler) - Nearest Node: Quickly determine all the nodes within a specified tolerance of a
                              given array.

            ParR is a vector of the nearest selected nodes, or 0 if no nodes are nearer than Toler. Par1 is the n x 3 array of coordinate locations. Toler defaults to 1 and is limited to the maximum model size. - (*MOPER, ParR, Par1, ENEAR, Toler)

            Nearest Element: Quickly determine the elements with centroids that are within a specified tolerance of the points in a given array. - ParR is a vector of the nearest selected elements, or 0 if no element centroids
                              are nearer than Toler. Par1 is the n x 3 array of
                              coordinate locations.

            (*MOPER, ParR, Par1, MAP, Par2, Par3, kDim, --, kOut, LIMIT) - Maps the results from another program onto your ANSYS finite element model. For
                              example, you can map pressures from a CFD
                              analysis onto your model for a structural
                              analysis.

            When you map results, the subsequent Par2 and Par3 arguments define your input values and their locations, and the arguments that follow determine the search area and interpolation schemes (see below). -  For Oper = MAP, output points are incorrect if they are not within the
                              boundaries (area or volume) set via the specified
                              input points. Also, calculations for out-of-bound
                              points require much more processing time than do
                              points that are within bounds.

        par2
            Second array parameter matrix input to the operation.  For the
            COVAR and CORR operations, this parameter must exist as a
            dimensioned array vector without specified values since its values
            (means) will be calculated as part of the operations. For MAP, this
            will be an {N(in) x M} array of values to be interpolated, where
            N(in) is the number of points to interpolate from, and M is the
            number of values at each point. For the ENEAR and NNEAR operations,
            this parameter specifies the tolerance for the search.

        par3
            Third array parameter, used for Oper = MAP. This is an N x 3 array
            of coordinate locations corresponding to the values in Par2.

        kdim
            Interpolation criteria; used for Oper = MAP:

        --
            Unused field

        kout
            Outside region results; used for Oper = MAP
        """
        command = "*MOPER,%s,%s,%s,%s,%s,%s,%s,%s" % (str(parr), str(par1), str(oper), str(par2), str(par3), str(kdim), str(kout), str(limit))
        return self.run(command, **kwargs)

    def cncheck(self, option="", rid1="", rid2="", rinc="", intertype="",
                trlevel="", cgap="", cpen="", ioff="", **kwargs):
        """APDL Command: CNCHECK

        Provides and/or adjusts the initial status of contact pairs.

        Parameters
        ----------
        option
            Option to be performed:

            DETAIL - List all contact pair properties (default).

            SUMMARY - List only the open/closed status for each contact pair.

            POST - Execute a partial solution to write the initial contact configuration to the
                   Jobname.RCN file.

            ADJUST - Physically move contact nodes to the target in order to close a gap or reduce
                     penetration. The initial adjustment is converted to
                     structural displacement values (UX, UY, UZ) and stored in
                     the Jobname.RCN file.

            RESET - Reset target element and contact element key options and real constants to
                    their default values. This option is not valid for general
                    contact.

            AUTO - Automatically sets certain real constants and key options to recommended values
                   or settings in order to achieve better convergence based on
                   overall contact pair behaviors. This option is not valid for
                   general contact.

            TRIM - Trim contact pair (remove certain contact and target elements).

            UNSE - Unselect certain contact and target elements.

        rid1, rid2, rinc
            For pair-based contact, the range of real constant pair ID's for
            which Option will be performed. If RID2 is not specified, it
            defaults to RID1. If no value is specified, all contact pairs in
            the selected set of elements are considered.

        intertype
            The type of contact interface (pair-based versus general contact)
            to be considered; or the type of contact pair to be
            trimmed/unselected/auto-set.

            (blank) - Include all contact definitions (pair-based and general contact).

            GCN - Include general contact definitions only (not valid when Option = RESET or
                  AUTO).

        trlevel
            Trimming level (used only when Option = TRIM or UNSE):

            (blank) - Normal trimming (default): remove/unselect contact and target elements which
                      are in far-field.

            AGGRE - Aggressive trimming: remove/unselect contact and target elements which are in
                    far-field, and certain elements in near-field.

        Notes
        -----
        The CNCHECK command provides information for surface-to-surface, node-
        to-surface, and line-to-line contact pairs (element types TARGE169,
        TARGE170, CONTA171, CONTA172, CONTA173, CONTA174, CONTA175, CONTA176,
        CONTA177). All contact and target elements of interest, along with the
        solid elements and nodes attached to them, must be selected for the
        command to function properly. For performance reasons, the program uses
        a subset of nodes and elements based on the specified contact regions
        (RID1, RID2, RINC) when executing the CNCHECK command.

        CNCHECK is available in both the PREP7 and SOLUTION processors, but
        only before the first solve operation (that is, only before the first
        load step or the first substep).

        If the contact and target elements were generated through mesh commands
        (AMESH, LMESH, etc.) instead of the ESURF command, you must issue
        MODMSH,DETACH before CNCHECK. Otherwise, CNCHECK will not work
        correctly.

        The following additional notes are available:

        The command CNCHECK,POST solves the initial contact configuration in
        one substep. After issuing this command, you can postprocess the
        contact result items as you would for any other converged load step;
        however, only the contact status, contact penetration or gap, and
        contact pressure will have meaningful values. Other contact quantities
        (friction stress, sliding distance, chattering) will be available but
        are not useful.

        Because Option = POST forces a solve operation, the PrepPost (PP)
        license does not work with CNCHECK,POST.

        """
        command = "CNCHECK,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(rid1), str(rid2), str(rinc), str(intertype), str(trlevel), str(cgap), str(cpen), str(ioff))
        return self.run(command, **kwargs)

    def rmsmple(self, nlgeom="", cap="", seqslv="", eeqslv="", **kwargs):
        """APDL Command: RMSMPLE

        Runs finite element solutions and obtains sample points for the ROM
        method.

        Parameters
        ----------
        nlgeom
            Specify whether a large or small deflection analysis is to be
            performed for the  mechanical domain:

            OFF (or 0) - Perform small deflection analysis (default).

        cap
            Capacitance calculation method.

            CHARGE - Compute capacitance based on the charge voltage relationship (default).

        seqslv
            Solver for structural analysis:

            SPARSE - Sparse direct equation solver (default).

        eeqslv
            Solver for electrostatic analysis:

            SPARSE - Sparse direct equation solver (default).

        Notes
        -----
        This command prepares and runs multiple finite element solutions on the
        Structural domain and the Electrostatic domain of a model to collect
        sample points of data for ROM response curve fitting. The command
        requires a model database [RMANL] and two Physics Files (Structural
        domain, titled "STRU" and an Electrostatic domain, titled "ELEC"; see
        PHYSICS command). Also required is a complete ROM database generated
        from the ROM Tools.  The Cap = CHARGE method is preferred when
        capacitance to "infinity" is not required. Capacitance conductor pairs
        are defined by the RMCAP command.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.

        Strain energy and capacitance data files  jobname_ijk.dec (mode i, j,
        k).
        """
        command = "RMSMPLE,%s,%s,%s,%s" % (str(nlgeom), str(cap), str(seqslv), str(eeqslv))
        return self.run(command, **kwargs)

    def dmprat(self, ratio="", **kwargs):
        """APDL Command: DMPRAT

        Sets a constant modal damping ratio.

        Parameters
        ----------
        ratio
            Modal damping ratio (for example, 2% is input as 0.02).

        Notes
        -----
        Sets a constant damping ratio for use in the mode-superposition
        transient (ANTYPE,TRANS) or harmonic (ANTYPE,HARMIC) analysis and the
        spectrum (ANTYPE,SPECTR) analysis.

        This command is also valid in PREP7.
        """
        command = "DMPRAT,%s" % (str(ratio))
        return self.run(command, **kwargs)

    def cdwrite(self, option="", fname="", ext="", fnamei="", exti="", fmat="",
                **kwargs):
        """APDL Command: CDWRITE

        Writes geometry and load database items to a file.

        Parameters
        ----------
        option
            Selects which data to write:

            ALL - Write all appropriate geometry, material property, load, and component data
                  (default). Two files will be produced. Fname.Ext will contain
                  all data items mentioned in "Notes", except the solid model
                  data. Fnamei.Exti will contain the solid model geometry and
                  solid model loads data in the form of IGES commands. This
                  option is not valid when CDOPT,ANF is active.

            COMB - Write all data mentioned, but to a single file, Fname.Ext. Solid model geometry
                   data will be written in either IGES or ANF format as
                   specified in the CDOPT command, followed by the remainder of
                   the data in the form of ANSYS commands. More information on
                   these (IGES/ANF) file formats is provided in "Notes".

            DB - Write all database information except the solid model and solid model loads to
                 Fname.Ext in the form of ANSYS commands. This option is not
                 valid when CDOPT,ANF is active.

            SOLID - Write only the solid model geometry and solid model load data. This output will
                    be in IGES or ANF format, as specified in the CDOPT
                    command. More information on these (IGES/ANF) file formats
                    is provided in "Notes".

            GEOM - Write only element and nodal geometry data. Neither solid model geometry nor
                   element attribute data will be written. One file, Fname.Ext,
                   will be produced. Use CDREAD,DB to read in a file written
                   with this option. Element types [ET] compatible with the
                   connectivity of the elements on the file must first be
                   defined before reading the file in with CDREAD,DB.

            CM - Write only node and element component and geometry data to Fname.Ext.

            MAT - Write only material property data (both linear and nonlinear) to Fname.Ext.

            LOAD - Write only loads for current load step to Fname.Ext.

            SECT - Write only section data to Fname.Ext. Pretension sections are not included.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        fnamei
            Name of the IGES file and its directory path (248 characters
            maximum, including directory). If you do not specify a directory
            path, it will default to your working directory and you can use all
            248 characters for the file name.

        exti
            Filename extension (eight-character maximum).

        fmat
            Format of the output file (defaults to BLOCKED).

            BLOCKED - Blocked format. This format allows faster reading of the output file. The time
                      savings is most significant when BLOCKED is used to read
                      .cdb files associated with very large models.

            UNBLOCKED - Unblocked format.

        Notes
        -----
        Load data includes the current load step only. Loads applied to the
        solid model (if any) are automatically transferred to the finite
        element model when this command is issued. CDWRITE writes out solid
        model loads for meshed models only. If the model is not meshed, the
        solid model loads cannot be saved. Component data include component
        definitions, but not assembly definitions. Appropriate NUMOFF commands
        are included at the beginning of the file; this is to avoid overlap of
        an existing database when the file is read in.

        Element order information (resulting from a WAVES command) is not
        written. The data in the database remain untouched.

        Solution control commands are typically not written to the file unless
        you specifically change a default solution setting.

        CDWRITE does not support the GSBDATA and GSGDATA commands, and these
        commands are not written to the file.

        The data may be reread (on a different machine, for example) with the
        CDREAD command. Caution: When the file is read in, the NUMOFF,MAT
        command may cause a mismatch between material definitions and material
        numbers referenced by certain loads and element real constants. See
        NUMOFF for details. Also, be aware that the files created by the
        CDWRITE command explicitly set the active coordinate system to
        Cartesian (CSYS,0).

        You should generally use the blocked format (Fmat = BLOCKED) when
        writing out model data with CDWRITE. This is a compressed data format
        that greatly reduces the time required to read large models through the
        CDREAD command. The blocked and unblocked formats are described in
        Chapter 3 of the Guide to Interfacing with ANSYS.

        If you use CDWRITE in any of the derived products (ANSYS Emag, ANSYS
        Professional), then before reading the file, you must edit the
        Jobname.cdb file to remove commands that are not available in the
        respective component product.

        The CDWRITE command writes PART information for any ANSYS LS-DYNA input
        file to the Jobname.cdb file via the EDPREAD command. (EDPREAD is not a
        documented command; it is written only when the CDWRITE command is
        issued.) The PART information can be automatically read in via the
        CDREAD command; however, if more than one Jobname.cdb file is read, the
        PART list from the last Jobname.cdb file overwrites the existing PART
        list of the total model. This behavior affects all PART-related
        commands contained in the Jobname.cdb file. You can join models, but
        not PART-related inputs, which you must modify using the newly-created
        PART numbers. In limited cases, an update of the PART list
        (EDWRITE,PUPDATE) is possible; doing so requires that no used
        combination of MAT/TYPE/REAL appears more than once in the list.

        The CDWRITE command does not support (for beam meshing) any line
        operation that relies on solid model associativity. For example,
        meshing the areas adjacent to the meshed line, plotting the line that
        contains the orientation nodes, or clearing the mesh from the line that
        contains orientation nodes may not work as expected. For more
        information about beam meshing, see Meshing Your Solid Model in the
        Modeling and Meshing Guide.

        IGES and ANF File Formats for Solid Model Geometry Information

        The format used for solid model geometry information is determined by
        the current CDOPT command setting. The default format is IGES.

        IGES option (default) to write solid model information (CDOPT, IGS):

        Before writing solid model entities, select all corresponding lower
        level entities (ALLSEL,BELOW,ALL).
        """
        command = "CDWRITE,%s,%s,%s,%s,%s,%s" % (str(option), str(fname), str(ext), str(fnamei), str(exti), str(fmat))
        return self.run(command, **kwargs)

    def fscale(self, rfact="", ifact="", **kwargs):
        """APDL Command: FSCALE

        Scales force load values in the database.

        Parameters
        ----------
        rfact
            Scale factor for the real component.  Zero (or blank) defaults to
            1.0.  Use a small number for a zero scale factor.

        ifact
            Scale factor for the imaginary component.  Zero (or blank) defaults
            to 1.0.  Use a small number for a zero scale factor.

        Notes
        -----
        Scales force load (force, heat flow, etc.) values in the database.
        Scaling applies to the previously defined values for the selected nodes
        [NSEL] and the selected force labels [DOFSEL].  Issue FLIST command to
        review results.  Solid model boundary conditions are not scaled by this
        command, but boundary conditions on the FE model are scaled.

        Note:: : Such scaled FE boundary conditions may still be overwritten by
        unscaled solid model boundary conditions if a subsequent boundary
        condition transfer occurs.

        FSCALE does not work for tabular boundary conditions.

        This command is also valid in PREP7.
        """
        command = "FSCALE,%s,%s" % (str(rfact), str(ifact))
        return self.run(command, **kwargs)

    def emis(self, mat="", evalu="", **kwargs):
        """APDL Command: EMIS

        Specifies emissivity as a material property for the Radiation Matrix
        method.

        Parameters
        ----------
        mat
            Material number associated with this emissivity (500 maximum).
            Defaults to 1.

        evalu
            Emissivity for this material (0.0 < EVALU   1.0).  Enter a very
            small number for zero.

        Notes
        -----
        Specifies emissivity as a material property for the Radiation Matrix
        method. This material property can then be associated with each
        element.
        """
        command = "EMIS,%s,%s" % (str(mat), str(evalu))
        return self.run(command, **kwargs)

    def repeat(self, ntot="", vinc1="", vinc2="", vinc3="", vinc4="", vinc5="",
               vinc6="", vinc7="", vinc8="", vinc9="", vinc10="", vinc11="",
               **kwargs):
        """APDL Command: *REPEAT

        Repeats the previous command.

        Parameters
        ----------
        ntot
            Number of times the preceding command is executed (including the
            initial execution).  Must be 2 or greater.  NTOT of 2 causes one
            repeat (for a total of 2 executions).

        vinc1, vinc2,  vinc3, . . . , vinc11
            Value increments applied to first through eleventh data fields of
            the preceding command.

        Notes
        -----
        *REPEAT must immediately follow the command that is to be repeated.
        The numeric arguments of the initial command may be incremented in the
        generated commands.  The numeric increment values may be integer or
        real, positive or negative, zero or blank.  Alphanumeric arguments
        cannot be incremented.  For large values of NTOT, consider printout
        suppression (/NOPR command) first.

        Most commands beginning with slash (/), star (*), as well as "unknown
        command" macros, cannot be repeated.  For these commands, or if more
        than one command is to be repeated, include them within a do-loop. File
        switching commands (those reading additional commands) cannot be
        repeated.  If a *REPEAT command  immediately follows another *REPEAT
        command, the repeat action only applies to the last non-*REPEAT
        command.  Also, *REPEAT should not  be used in interactive mode
        immediately after a) a command (or its log file equivalent) that uses
        picking, or b) a command that requires a response from the user.

        This command is valid in any processor.
        """
        command = "*REPEAT,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(ntot), str(vinc1), str(vinc2), str(vinc3), str(vinc4), str(vinc5), str(vinc6), str(vinc7), str(vinc8), str(vinc9), str(vinc10), str(vinc11))
        return self.run(command, **kwargs)

    def sflist(self, node="", lab="", **kwargs):
        """APDL Command: SFLIST

        Lists surface loads.

        Parameters
        ----------
        node
            Node at which surface load is to be listed.  If ALL (or blank),
            list for all selected nodes [NSEL].  If NODE = P, graphical picking
            is enabled and all remaining command fields are ignored (valid only
            in the GUI).  A component name may be substituted for NODE.

        lab
            Valid surface load label.  If ALL (or blank), use all appropriate
            labels.

        Notes
        -----
        Lists the surface loads as applied with the SF command.  Loads are
        listed only for the specified nodes on external faces of selected area
        and volume elements.  Use SFELIST for line elements. The surface loads
        listed correspond to the current database values. The database is not
        updated for surface loads in POST1. Surface loads specified in tabular
        form, however, do list their values corresponding to the current
        results set in POST1.

        For SURF151 or SURF152 elements with an extra node for radiation and/or
        convection calculations (KEYOPT(5) = 1), the bulk temperature listed is
        the temperature of the extra node. If the thermal solution does not
        converge, the extra node temperature is not available for listing.

        This command is valid in any processor.
        """
        command = "SFLIST,%s,%s" % (str(node), str(lab))
        return self.run(command, **kwargs)

    def accoption(self, activate="", **kwargs):
        """APDL Command: ACCOPTION

        Specifies GPU accelerator capability options.

        Parameters
        ----------
        activate
            Activates the GPU accelerator capability within the equation
            solvers.

            Do not use GPU accelerator. - Use GPU accelerator.

        Notes
        -----
        The GPU accelerator capability requires specific hardware to be
        installed on the machine. See the appropriate ANSYS, Inc. Installation
        Guide (Windows or Linux) for a list of supported GPU hardware. Use of
        this capability also requires HPC licensing. For more information, see
        GPU Accelerator Capability in the Parallel Processing Guide.

        The GPU accelerator capability is available for the sparse direct
        solver and the PCG and JCG iterative solvers. Static, buckling, modal,
        full harmonic, and full transient analyses are supported. For buckling
        analyses, the Block Lanczos and Subspace eigensolvers are supported.
        For modal analyses, only the Block Lanczos, PCG Lanczos, Subspace,
        Unsymmetric, and Damped eigensolvers are supported. Activating this
        capability when using other equation solvers or other analysis types
        has no effect.

        The GPU accelerator capability is supported only on the Windows 64-bit
        and Linux 64-bit platforms.
        """
        command = "ACCOPTION,%s" % (str(activate))
        return self.run(command, **kwargs)

    def calc(self, **kwargs):
        """APDL Command: CALC

        Specifies "Calculation settings" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "CALC," % ()
        return self.run(command, **kwargs)

    def sudel(self, surfname="", **kwargs):
        """APDL Command: SUDEL

        Delete geometry information as well as any mapped results for specified
        surface.

        Parameters
        ----------
        surfname
            Eight character surface name.
        """
        command = "SUDEL,%s" % (str(surfname))
        return self.run(command, **kwargs)

    def spunit(self, tblno="", type="", gvalue="", keyinterp="", **kwargs):
        """APDL Command: SPUNIT

        Defines the type of multi-point response spectrum.

        Parameters
        ----------
        tblno
            Input table number.

        type
            Label identifying the type of spectrum:

            DISP   - Displacement spectrum (SPVAL values interpreted as displacements with units of
                     length).

            VELO   - Velocity spectrum (SPVAL values interpreted as velocities with units of
                     length/time).

            ACEL   - Acceleration spectrum (SPVAL values interpreted as accelerations with units of
                     length/time2).

            ACCG   - Acceleration spectrum (SPVAL values interpreted as accelerations with units of
                     g/time2).

            FORC   - Force spectrum.

            PRES   - Pressure spectrum.

        gvalue
            Value of acceleration due to gravity in any arbitrary units for
            Type=ACCG table. Default is 386.4 in/sec2.

        keyinterp
            Key to activate or deactivate the linear interpolation between
            input response spectrum points and input response spectrum curves:

            0 (OFF or NO) - Deactivate linear and use logarithmic interpolation. This value is the default.

            1 (ON or YES) - Activate linear interpolation.

        Notes
        -----
        Defines the type of multi-point response spectrum defined by the SPFREQ
        and  SPVAL commands.

        Force (FORC) and pressure (PRES) type spectra can be used only as a
        nodal excitation.

        GVALUE is valid only when type=ACCG is specified. A zero or negative
        value cannot be used. A parameter substitution can also be performed.

        This command is also valid in PREP7.
        """
        command = "SPUNIT,%s,%s,%s,%s" % (str(tblno), str(type), str(gvalue), str(keyinterp))
        return self.run(command, **kwargs)

    def cycexpand(self, wn="", option="", value1="", value2="", **kwargs):
        """APDL Command: /CYCEXPAND

        Graphically expands displacements, stresses and strains of a cyclically
        symmetric model.

        Parameters
        ----------
        wn
            The window number to which the expansion applies. Valid values are
            1 through 5. The default value is 1. The window number applies only
            to the AMOUNT argument.

        option
            One of the following options:

            ON - Activates cyclic expansion using the previous settings (if any). If no previous
                 settings exist, this option activates the default settings.

            DEFAULT - Resets cyclic expansion to the default settings.

            OFF - Deactivates cyclic expansion. This option is the default.

            STATUS - Lists the current cyclic expansion settings.

            AMOUNT - The number of repetitions or the total angle.

            Value1 - NREPEAT

            Value2 - The number of repetitions. The default is the total number of sectors in 360
                     degrees.

            or - Value1

            ANGLE - Value2

            The total angle in degrees. The default is 360. - WHAT

            A specified portion or subset of the model to expand: - Value1

            The component name of the elements to expand. The default is all selected components. - EDGE

            Sector edge display key. - -1

            Suppresses display of edges between sectors even if the cyclic count varies between active windows. - Caution:  Plots with fewer than the maximum number of repetitions may have
                              missing element faces at the sector boundaries.

            0 or OFF - Averages stresses or strains across sector boundaries. This value is the
                       default (although the default reverts to 1 or ON if the
                       cyclic count varies between active windows).

            1 or ON - No averaging of stresses or strains occurs and sector boundaries are shown on
                      the plot.

            PHASEANG - The phase angle shift:

            Value1 - The phase angle shift in degrees. The valid range is 0 through 360. The default
                     is 0. For a full harmonic solution, this value is
                     typically the phase angle obtained via the CYCPHASE
                     command. If Value1 = AMPLITUDE (or if Value1 ≥ 360), the
                     amplitude is supplied. The amplitude solution for non-
                     component results (such as equivalent stress) are not
                     valid. For a mode-superposition harmonic solution, if
                     Value1 = SWEEP, the maximum values across a phase angle
                     sweep are supplied.

        Notes
        -----
        In preprocessing, the /CYCEXPAND command verifies a cyclically
        symmetric model by graphically expanding it partially or through the
        full 360 degrees.

        For the postprocessing plot nodal solution (PLNSOL) operation, the
        command graphically expands displacements, stresses and strains of a
        cyclically symmetric model partially or though the full 360 degrees by
        combining the real (original nodes and elements) and imaginary
        (duplicate nodes and elements) parts of the solution.

        For the print nodal solution (PRNSOL) operation, the command expands
        the printed output of displacements or stresses on a sector-by-sector
        basis.

        Use of the /CYCEXPAND command does not change the database. The command
        does not modify the geometry, nodal displacements or element stresses.

        The command affects element and result plots only. It has no effect on
        operations other than plot element solution (PLESOL), plot nodal
        solution (PLNSOL), print nodal solution (PRNSOL), and calculate
        harmonic solution (CYCCALC). Operations other than PLESOL, PLNSOL,
        PRNSOL, or CYCCALC work on the unprocessed real and imaginary parts of
        a cyclic symmetry solution

        If you issue a /CYCEXPAND,,OFF command, you cannot then expand the
        model by simply issuing another  /CYCEXPAND command  (for example, to
        specify an NREPEAT value for the number of repetitions). In such a
        case, you must specify /CYCEXPAND,,ON, which activates expansion using
        the previous settings (if any) or the default settings.

        The command requires PowerGraphics and will turn PowerGraphics on
        (/GRAPHICS,POWER) if not already active. Any setting which bypasses
        PowerGraphics (for example, /PBF) also bypasses cyclic expansion; in
        such cases, the /CYCEXPAND command displays unprocessed real and
        imaginary results.

        The CYCPHASE command uses full model graphics (/GRAPHICS,FULL) to
        compute peak values. Because of this, there may be slight differences
        between max/min values obtained with CYCPHASE, and those obtained via
        /CYCEXPAND, which uses power graphics (/GRAPHICS,POWER).

        For PHASEANG = AMPLITUDE (or 360) with a cyclic full harmonic solution,
        the only appropriate coordinate system is the solution coordinate
        system (RSYS,SOLU)

        To learn more about analyzing a cyclically symmetric structure, see the
        Cyclic Symmetry Analysis Guide.
        """
        command = "/CYCEXPAND,%s,%s,%s,%s" % (str(wn), str(option), str(value1), str(value2))
        return self.run(command, **kwargs)

    def ptr(self, loc="", b_ase="", **kwargs):
        """APDL Command: PTR

        Dumps the record of a binary file.

        Parameters
        ----------
        loc, base
            Dump the file record starting at pointer LOC. BASE is the base
            pointer, and would be used if LOC is a relative pointer.

        Notes
        -----
        Dumps the record of the file named on the AUX2 FILEAUX2 command
        according the format specified on the FORM command.
        """
        command = "PTR,%s,%s" % (str(loc), str(b_ase))
        return self.run(command, **kwargs)

    def udoc(self, wind="", cl_ass="", key="", **kwargs):
        """APDL Command: /UDOC

        Determines position and content for the multi-legend options.

        Parameters
        ----------
        wind
            The window number to which the command applies. (defaults to 1)

        class
            The type (and relative importance) of legend item being displayed:

            CNTR - Contour legend. This legend item is controlled separately from the other legend
                   items (see note below).

            DATE - The items in the DATE class include the date and time, or the ANSYS graphical
                   logo (/PLOPTS,LOGO,1). This item is shown by default in all
                   plots.

            GWIN - The items in the GWIN class include the entity acronyms that appear in the
                   legend of a multiplot of entities (Nodes, Elements,
                   Keypoints, Lines, Areas, Volumes). GWIN items are shown by
                   default for all GPLOT displays.

            TYPE - Items in the TYPE class include the plot type (e.g. ELEMENTS, MATERIALS, NODAL
                   SOLUTIONS, etc.). TYPE items are shown by default in all
                   plots.

            TYP2 - Items in the TYP2 class include supplementary type information, such as DMAX
                   and SMAX for nodal solutions. TYP2 items are shown by
                   default in all plots.

            INUM - Items in the INUM class include the number labels generated by the /PNUM
                   command. This class is displayed by default in all plots
                   that contain /PNUM information.

            BCDC - The items in the BCDC class include labels created by the /PBC  command. This
                   class is shown by default in all plots which contain /PBC
                   information.

            VECT - Items in the VECT class include labels created by the PLVECT command. This
                   class is shown by default for all PLVECT plots.

            SURF - The items in the SURF class include labels from the /PSF legend. This class is
                   shown by default on all plots of surface boundary
                   conditions.

            BODY - Items from the BODY class include labels from the /PBF legend. This class is
                   shown by default in all plots of body forces.

            PSTA - Items from the PSTA class include stress scaling statistics, such as the
                   /SSCALE setting. This class is not shown as the default for
                   any type of plot, and must be specifically referenced to
                   display the included data.

            VIEW - The items in the VIEW class include view statistics. This class is not shown as
                   the default for any type of plot, and must be specifically
                   referenced to display the included data.

            MISC - The items in the MISC class include supplementary labels like /EXPANDED and
                   Stress Section Cross Section. This class is not shown as the
                   default for any type of plot, and must be specifically
                   referenced to display the included data.

        key
            Switch:

        Notes
        -----
        The legend classes conform to the controls specified in the window
        options panel (PlotCtrls> Window Controls> Window Options). In many
        instances, the legend controls specified with the /PLOPTS command will
        take precedence and override /UDOC specifications. For instance:

        /PLOPTS,LEG1,OFF will disable the TYPE, TYP2, INUM, and MISC classes,
        regardless of the /UDOC settings.

        /PLOPTS,LEG2,OFF will disable the VIEW class, regardless of the /UDOC
        settings.

        /PLOPTS,LEG3,OFF will disable the PSTA class, regardless of the /UDOC
        settings.

        All items in a class are listed with the same X coordinate (except for
        contours). The contents of the text classes are dumped onto the display
        window from top to bottom, in order of class importance.

        The font specification for text items that are included in the user-
        specified legends are controlled with the /DEVICE command (PlotCtrls>
        Font Controls> Anno/Graph Font).

        The floating point values for the data presented in the legend(s) are
        controlled by the /GFORMAT command.
        """
        command = "/UDOC,%s,%s,%s" % (str(wind), str(cl_ass), str(key))
        return self.run(command, **kwargs)

    def sfelist(self, elem="", lab="", **kwargs):
        """APDL Command: SFELIST

        Lists the surface loads for elements.

        Parameters
        ----------
        elem
            Element at which surface load is to be listed.  If ALL (or blank),
            list loads for all selected elements [ESEL].  If ELEM = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may be
            substituted for ELEM.

        lab
            Valid surface load label.  If ALL (or blank), use all appropriate
            labels.

        Notes
        -----
        The surface loads listed correspond to the current database values. The
        database is not updated for surface loads in POST1. Surface loads
        specified in tabular form, however, do list their values corresponding
        to the current results set in POST1.

        For SURF151 or SURF152 elements with an extra node for radiation and/or
        convection calculations (KEYOPT(5) = 1), the bulk temperature listed is
        the temperature of the extra node. If the thermal solution does not
        converge, the extra node temperature is not available for listing.

        Film effectiveness and free stream temperatures specified by the SFE
        command (Lab = CONV) can only be listed by this command. The command
        lists film coefficients and bulk temperatures first and then film
        effectiveness and free stream temperatures below those values.

        Distributed ANSYS Restriction: In Distributed ANSYS within the SOLUTION
        processor, SFELIST support is not available for elements SURF151 and
        SURF152 when surface loading is applied via extra nodes (KEYOPT(5 > 0).
        If the command is issued under these circumstances, the resulting
        surface loads shown are not reliable.

        This command is valid in any processor.
        """
        command = "SFELIST,%s,%s" % (str(elem), str(lab))
        return self.run(command, **kwargs)

    def edterm(self, option="", lab="", num="", stop="", maxc="", minc="",
               **kwargs):
        """APDL Command: EDTERM

        Specifies termination criteria for an explicit dynamic analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed.

            ADD - Define termination criteria (default).

            DELE - Delete termination criteria.

            LIST - List termination criteria.

        lab
            Label identifying the type of termination (no default).

            NODE - Terminate solution based on nodal point coordinates. The analysis terminates
                   when the current position of the specified node reaches
                   either the maximum or minimum coordinate value (STOP = 1, 2,
                   or 3), or when the node picks up force from any contact
                   surface (STOP = 4).

            PART - Terminate solution based on rigid body (part) displacements. The analysis
                   terminates when the displacement of the center of mass of
                   the specified rigid body reaches either the maximum or
                   minimum value (STOP = 1, 2, or 3), or when the displacement
                   magnitude of the center of mass is exceeded (STOP = 4).

        num
            Node number (if Lab = NODE) or rigid body Part ID (if Lab = PART).
            (No default.)

        stop
            Criterion for stopping the solution (no default).

            1 - Global X-direction.

            2 - Global Y-direction.

            3 - Global Z-direction.

            4 - For Lab = NODE, stop the solution if contact occurs. For Lab = PART, stop the
                solution if the displacement magnitude is exceeded for the
                specified rigid body (use MAXC to define the displacement
                magnitude).

        maxc
            Maximum (most positive) coordinate value (Lab = NODE) or
            displacement (Lab = PART). MAXC defaults to 1.0e21

        minc
            Minimum (most negative) coordinate value (Lab = NODE) or
            displacement (Lab = PART). MINC defaults to -1.0e21.

        Notes
        -----
        You may specify multiple termination criteria using EDTERM; the
        solution will terminate when any one of the criteria is satisfied, or
        when the solution end time (specified on the TIME command) is reached.

        In an explicit dynamic small restart analysis (EDSTART,2) or full
        restart analysis (EDSTART,3), the termination criteria set in the
        previous analysis (the original analysis or the previous restart) are
        carried over to the restart. If the previous analysis terminated due to
        one of these criteria, that specific criterion must be modified so that
        it will not cause the restart to terminate prematurely. In particular,
        if a termination condition based on nodal contact (Lab = NODE, STOP =
        4) is satisfied, this condition must be deleted and replaced with a
        condition based on nodal coordinates for that same node. (If a
        condition based on nodal coordinates already exists for that node, the
        replacement is not necessary.) In the restart, the number of
        termination criteria specified using EDTERM cannot exceed a maximum of
        10 or the number specified in the original analysis.

        Note that the termination criteria set by EDTERM are not active during
        dynamic relaxation (EDDRELAX).

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDTERM,%s,%s,%s,%s,%s,%s" % (str(option), str(lab), str(num), str(stop), str(maxc), str(minc))
        return self.run(command, **kwargs)

    def susave(self, lab="", fname="", fext="", fdir="", **kwargs):
        """APDL Command: SUSAVE

        Saves surface definitions to a file.

        Parameters
        ----------
        lab
            Eight-character surface name.

        fname
            File name and directory path (248 character maximum, including
            directory). If you do not specify a directory path, the default is
            your working directory and you can use all 248 characters for the
            file name. The file name defaults to the jobname.

        fext
            File name extension (eight-character maximum). The extension
            defaults to “surf”.

        fdir
            Optional path specification.

        Notes
        -----
        The SUSAVE command saves surface definitions (geometry
        information)--and any result items mapped onto the surfaces--to a file.

        Issuing the SUSAVE command has no effect on the database. The database
        remains unchanged.

        Subsequent executions of the SUSAVE command overwrite previous data in
        the file.

        To read the contents of the file created via the SUSAVE command, issue
        the SURESU command.
        """
        command = "SUSAVE,%s,%s,%s,%s" % (str(lab), str(fname), str(fext), str(fdir))
        return self.run(command, **kwargs)

    def slashline(self, x1="", y1="", x2="", y2="", **kwargs):
        """APDL Command: /LINE

        Creates annotation lines (GUI).

        Parameters
        ----------
        x1
            Line X starting location (-1.0 < X < 2.0).

        y1
            Line Y starting location (-1.0 < Y < 1.0).

        x2
            Line X ending location (-1.0 < X < 2.0).

        y2
            Line Y ending location (-1.0 < Y < 1.0).

        Notes
        -----
        Defines annotation lines to be written directly onto the display at a
        specified location.  This is a command generated by the Graphical User
        Interface (GUI) and will appear in the log file (Jobname.LOG) if
        annotation is used.  This command is not intended to be typed in
        directly in an ANSYS session (although it can be included in an input
        file for batch input or for use with the /INPUT command).

        All lines are shown on subsequent displays unless the annotation is
        turned off or deleted.  Use the /LSPEC command to set the attributes of
        the line.

        This command is valid in any processor.
        """
        command = "/LINE,%s,%s,%s,%s" % (str(x1), str(y1), str(x2), str(y2))
        return self.run(command, **kwargs)

    def normal(self, wn="", key="", **kwargs):
        """APDL Command: /NORMAL

        Allows displaying area elements by top or bottom faces.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        key
            Display key:

            0 - No face distinction.

            1 - Show only area elements having their positive normals directed toward the
                viewing point.

            -1 - Show only area elements having their positive normals directed away from the
                 viewing point.

        Notes
        -----
        /NORMAL allows you to select area elements and area plots by the top or
        bottom faces.  It is useful for checking the normal directions on shell
        elements.  The positive normal (element Z direction) is defined by the
        right-hand rule following the node I, J, K, L input direction.  This
        command is available only with raster or hidden-line displays, for
        WIN32 or X11 2-D displays only.

        This command is valid in any processor.
        """
        command = "/NORMAL,%s,%s" % (str(wn), str(key))
        return self.run(command, **kwargs)

    def gslist(self, lab="", **kwargs):
        """APDL Command: GSLIST

        When using generalized plane strain, lists the input data or solutions.

        Parameters
        ----------
        lab
            Specify the content to be listed.

            GEOMETRY - List the data input using GSGDATA

            BC - List the data input using GSBDATA.

            REACTIONS - When the command is issued in POST1, list the reaction force at the ending
                        point,

             and the moment about X and Y if the corresponding constraints were applied. - RESULTS

            When the command is issued in POST1, list the change of fiber length at the ending point during deformation and the rotation of the ending plane about X and Y during deformation. - ALL

        Notes
        -----
        This command can be used to list the initial position of the ending
        plane, the applied load or displacements in the fiber direction, the
        resulting position of the ending plane after deformation, and the
        available reaction forces and moments at the ending point.

        All inputs and outputs are in the global Cartesian coordinate system.
        For more information about the generalized plane strain feature, see
        Generalized Plane Strain Option of Current-Technology Solid Elements in
        the Element Reference.

        This command is valid in any processor.
        """
        command = "GSLIST,%s" % (str(lab))
        return self.run(command, **kwargs)

    def sfadele(self, area="", lkey="", lab="", **kwargs):
        """APDL Command: SFADELE

        Deletes surface loads from areas.

        Parameters
        ----------
        area
            Area to which surface load deletion applies.  If ALL, delete load
            from all selected areas [ASEL].  If AREA = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may be substituted for AREA.

        lkey
            Load key associated with surface load (defaults to 1).  See the SFA
            command for details.

        lab
            Valid surface load label.  If ALL, use all appropriate labels.  See
            the SFA command for labels.

        Notes
        -----
        Deletes surface loads (and all corresponding finite element loads) from
        selected areas.

        This command is also valid in PREP7.
        """
        command = "SFADELE,%s,%s,%s" % (str(area), str(lkey), str(lab))
        return self.run(command, **kwargs)

    def igesout(self, fname="", ext="", att="", **kwargs):
        """APDL Command: IGESOUT

        Writes solid model data to a file in IGES Version 5.1 format.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        att
            Attribute key:

            0 - Do not write assigned numbers and attributes of the solid model entities to the
                IGES file (default).

            1 - Write assigned numbers and attributes of solid model entities (keypoints,
                lines, areas, volumes) to the IGES file.  Attributes include
                MAT, TYPE, REAL, and ESYS specifications as well as associated
                solid model loads and meshing (keypoint element size, number of
                line divisions and spacing ratio) specifications.

        Notes
        -----
        Causes the selected solid model data to be written to a coded file in
        the IGES Version 5.1 format.  Previous data on this file, if any, are
        overwritten.  Keypoints that are not attached to any line are written
        to the output file as IGES entity 116 (Point).  Lines that are not
        attached to any area are written to the output file as either IGES
        Entity 100 (Circular Arc), 110 (Line), or 126 (Rational B-Spline Curve)
        depending upon whether the ANSYS entity was defined as an arc, straight
        line, or spline.  Areas are written to the output file as IGES Entity
        144 (Trimmed Parametric Surface).  Volumes are written to the output
        file as IGES entity 186 (Manifold Solid B-Rep Object).  Solid model
        entities to be written must have all corresponding lower level entities
        selected (use ALLSEL,BELOW,ALL) before issuing command.  Concatenated
        lines and areas are not written to the IGES file; however, the entities
        that make up these concatenated entities are written.

        Caution:: : Section properties assigned to areas, lines and other solid
        model entities will not be maintained when the model is exported using
        IGESOUT.

        If you issue the IGESOUT command after generating a beam mesh with
        orientation nodes, the orientation keypoints that were specified for
        the line (LATT) are no longer associated with the line and are not
        written out to the IGES file.  The line does not recognize that
        orientation keypoints were ever assigned to it, and the orientation
        keypoints do not "know" that they are orientation keypoints.  Thus the
        IGESOUT command does not support (for beam meshing) any line operation
        that relies on solid model associativity.  For example, meshing the
        areas adjacent to the meshed line, plotting the line that contains the
        orientation nodes, or clearing the mesh from the line that contains
        orientation nodes may not work as expected.  See Meshing Your Solid
        Model in the Modeling and Meshing Guide for more information about beam
        meshing.
        """
        command = "IGESOUT,%s,%s,%s" % (str(fname), str(ext), str(att))
        return self.run(command, **kwargs)

    def nsel(self, type="", item="", comp="", vmin="", vmax="", vinc="",
             kabs="", **kwargs):
        """APDL Command: NSEL

        Selects a subset of nodes.

        Parameters
        ----------
        type
            Label identifying the type of select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

            ALL - Restore the full set.

            NONE - Unselect the full set.

            INVE - Invert the current set (selected becomes unselected and vice versa).

            STAT - Display the current select status.

        Notes
        -----
        Selects a subset of nodes.  For example, to select a new set of nodes
        based on node numbers 1 through 7, use NSEL,S,NODE,,1,7.  The subset is
        used when the ALL label is entered (or implied) on other commands, such
        as NLIST,ALL.  Only data identified by node number are selected.  Data
        are flagged as selected and unselected; no data are actually deleted
        from the database.

        When selecting nodes by results, the full graphics value is used,
        regardless of whether PowerGraphics is on.

        Solution result data consists of two types, 1) nodal degree of freedom
        --results initially calculated at the nodes (such as displacement,
        temperature, pressure, etc.), and 2) element--results initially
        calculated elsewhere (such as at an element integration point or
        thickness location) and then recalculated at the nodes (such as
        stresses, strains, etc.).  Various element results also depend upon the
        recalculation method and the selected results location [AVPRIN, RSYS,
        FORCE, LAYER and SHELL].

        You must have all the nodes (corner and midside nodes) on the external
        face of the element selected to use Item = EXT.

        This command is valid in any processor.

        For Selects based on non-integer numbers (coordinates, results, etc.),
        items that are within the range VMIN-Toler and VMAX+Toler are selected.
        The default tolerance Toler is based on the relative values of VMIN and
        VMAX as follows:

        If VMIN = VMAX, Toler = 0.005 x VMIN.

        If VMIN = VMAX = 0.0, Toler = 1.0E-6.

         If VMAX ≠ VMIN, Toler = 1.0E-8 x (VMAX-VMIN).

        Use the SELTOL command to override this default and specify Toler
        explicitly.

        Table: 208:: : NSEL - Valid Item and Component Labels

        Table: 209:: : NSEL - Valid Item and Component Labels for Nodal DOF
        Result Values
        """
        command = "NSEL,%s,%s,%s,%s,%s,%s,%s" % (str(type), str(item), str(comp), str(vmin), str(vmax), str(vinc), str(kabs))
        return self.run(command, **kwargs)

    def slashreset(self, **kwargs):
        """APDL Command: /RESET

        Resets display specifications to their initial defaults.

        Notes
        -----
        Resets slash display specifications (/WINDOW, /TYPE, /VIEW, etc.) back
        to their initial default settings (for convenience).  Also resets the
        focus location to the geometric center of the object.

        This command is valid in any processor.
        """
        command = "/RESET," % ()
        return self.run(command, **kwargs)

    def eddamp(self, part="", lcid="", valdmp="", **kwargs):
        """APDL Command: EDDAMP

        Defines mass weighted (Alpha) or stiffness weighted (Beta) damping for
        an explicit dynamics model.

        Parameters
        ----------
        part
            PART number [EDPART] identifying the group of elements to which
            damping should be applied. If PART = ALL (default), damping is
            applied to the entire model.

        lcid
            Load curve ID (previously defined with the EDCURVE command)
            identifying the damping coefficient versus time curve. If time-
            dependent damping is defined, an LCID is required.

        valdmp
            Constant system damping coefficient or a scale factor applied to
            the curve defining damping coefficient versus time.

        Notes
        -----
        Mass-weighted (Alpha) or stiffness-weighted (Beta) damping can be
        defined with the EDDAMP command. Generally, stiffness proportional or
        beta damping is effective for oscillatory motion at high frequencies.
        This type of damping is orthogonal to rigid body motion and so will not
        damp out rigid body motion. On the other hand, mass proportional or
        alpha damping is more effective for low frequencies and will damp out
        rigid body motion. The different possibilities are described below:

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.

        Mass-weighted or Alpha damping

        When PART = (blank) or ALL (default), mass-weighted global damping can
        be defined in the following two ways. In this case, the same damping is
        applied for the entire structure.

        When the damping coefficient versus time curve (LCID) is specified
        using the EDCURVE command, VALDMP is ignored by LS-DYNA (although it is
        written in the LS-DYNA input file Jobname.K).  The damping force
        applied to each node in the model is given by fd = d(t)mv, where d(t)
        is the damping coefficient as a function of time defined by the EDCURVE
        command, m is the mass, and v is the velocity.

        When the LCID is 0 or blank (default), a constant mass-weighted system
        damping coefficient can be specified using VALDMP.

        The constant and time-dependent damping, described above, cannot be
        defined simultaneously. The last defined global damping will overwrite
        any previously defined global damping.

        Mass-weighted or Alpha damping

        When both a valid PART number is specified and the damping coefficient
        versus time curve (LCID) is specified using the EDCURVE command, mass-
        weighted time-dependent damping will be defined for the particular
        PART.  In this case, VALDMP will act as a scaling factor for the
        damping versus time curve (if VALDMP is not specified, it will default
        to 1). A valid PART number must be specified to define this type of
        damping. For example, use PART =1 (and not blank) when the entire model
        consists of only one PART.  Issue the command repeatedly with different
        PART numbers in order to specify alpha damping for different PARTS.

        Stiffness-weighted or Beta damping

        When a valid PART number is specified with LCID = 0 or (blank)
        (default), a stiffness-weighted (Beta) constant damping coefficient for
        this particular PART can be defined by VALDMP. The stiffness-weighted
        value corresponds to the percentage of damping in the high frequency
        domain. For example, 0.1 roughly corresponds to 10% damping in the high
        frequency domain. Recommended values range from 0.01 to 0.25. Values
        lower than 0.01 may have little effect. If a value larger than 0.25 is
        used, it may be necessary to lower the time step size significantly
        (see the EDCTS command). Issue the command repeatedly with different
        PART numbers in order to specify beta damping for different PARTS.
        Time-dependent stiffness-weighted damping is not available in ANSYS LS-
        DYNA.

        The mass-weighted and stiffness-weighted damping, described above,
        cannot be defined simultaneously for a particular PART number. The last
        defined damping for the particular PART number will overwrite any
        previously defined mass-weighted or stiffness-weighted damping for this
        PART.

        In order to define the mass-weighted and stiffness-weighted damping
        simultaneously, you can use the MP,BETD command (instead of the
        EDDAMP,PART, ,VALDMP command) to define stiffness-weighted (Beta)
        constant damping coefficient. However, do not use both of these
        commands together to define stiffness-weighted (Beta) constant damping
        coefficient for a particular PART. If you do, duplicate stiffness-
        weighted (Beta) constant damping coefficients for this PART will be
        written to the LS-DYNA input file Jobname.K.  The last defined value
        will be used by LS-DYNA. Also, note that the MP,BETD command is applied
        on the MAT number, and not on the PART number. Since a group of
        elements having the same MAT ID may belong to more than one PART (the
        opposite is not true), you need to issue the MP,BETD command only once
        for this MAT ID and the stiffness-weighted (Beta) damping coefficients
        will be automatically defined for all the PARTs with that MAT ID.

        Mass-weighted and stiffness-weighted damping can be defined
        simultaneously using the EDDAMP command only when mass-weighted damping
        (constant or time-dependent) is defined as global damping (EDDAMP, ALL,
        LCID, VALDMP) and stiffness-weighted damping is defined for all
        necessary PARTs (EDDAMP,PART, ,VALDMP).

        To remove defined global damping, reissue the EDDAMP, ALL command with
        LCID and VALDMP set to 0. To remove damping defined for a particular
        PART, reissue EDDAMP, PART, where PART is the PART number, with LCID
        and VALDMP set to 0. There is no default for the EDDAMP command, i.e.,
        issuing the EDDAMP command with PART = LCID = VALDMP = 0 will result in
        an error. Stiffness-weighted damping defined by the MP,BETD command can
        be deleted using MPDELE, BETD, MAT.

        In an explicit dynamic small restart (EDSTART,2) or full restart
        analysis (EDSTART,3), you can only specify global alpha damping. This
        damping will overwrite any alpha damping input in the original
        analysis. If you do not input global alpha damping in the restart, the
        damping properties input in the original analysis will carry over to
        the restart.

        Damping specified by the EDDAMP command can be listed, along with other
        explicit dynamics specifications, by typing the command string
        EDSOLV$STAT into the ANSYS input window. Beta damping specified by the
        MP,BETD command can be listed by MPLIST, MAT command.

        This command is also valid in PREP7.
        """
        command = "EDDAMP,%s,%s,%s" % (str(part), str(lcid), str(valdmp))
        return self.run(command, **kwargs)

    def slashexit(self, slab="", fname="", ext="", **kwargs):
        """APDL Command: /EXIT

        Stops the run and returns control to the system.

        Parameters
        ----------
        slab
            Mode for saving the database:

            MODEL - Save the model data (solid model, finite element model, loadings, etc.) only
                    (default).

            SOLU - Save the model data and the solution data (nodal and element results).

            ALL - Save the model data, solution data and post data (element tables, path results,
                  etc.)

            NOSAVE - Do not save any data on File.DB (an existing DB file will not be overwritten).

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        The current database information may be written on File.DB or a named
        file. If File.DB already exists, a backup file (File.DBB) will also be
        written whenever a new File.DB is written.

        This command is valid in any processor. Issuing this command at any
        point will exit the program.
        """
        command = "/EXIT,%s,%s,%s" % (str(slab), str(fname), str(ext))
        return self.run(command, **kwargs)

    def agen(self, itime="", na1="", na2="", ninc="", dx="", dy="", dz="",
             kinc="", noelem="", imove="", **kwargs):
        """APDL Command: AGEN

        Generates additional areas from a pattern of areas.

        Parameters
        ----------
        itime
            Do this generation operation a total of ITIMEs, incrementing all
            keypoints in the given pattern automatically (or by KINC) each time
            after the first.  ITIME must be more than 1 for generation to
            occur.

        na1, na2, ninc
            Generate areas from the pattern of areas NA1 to NA2 (defaults to
            NA1) in steps of NINC (defaults to 1).  If NA1 = ALL, NA2 and NINC
            are ignored and the pattern is all selected areas [ASEL].  If NA1 =
            P, graphical picking is enabled and all remaining arguments are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NA1 (NA2 and NINC are ignored).

        dx, dy, dz
            Keypoint location increments in the active coordinate system (--,
            D θ, DZ for cylindrical;  --, D θ, -- for spherical).

        kinc
            Keypoint number increment between generated sets.  If zero, the
            lowest available keypoint numbers are assigned [NUMSTR].

        noelem
            Specifies if elements and nodes are also to be generated:

            0 - Generate nodes and elements associated with the original areas, if they exist.

            1 - Do not generate nodes and elements.

        imove
            Specifies whether to redefine the existing areas:

            0 - Generate new areas as requested with the ITIME argument.

            1 - Move original areas to new position, retaining the same keypoint numbers
                (ITIME, KINC, and NOELEM are ignored).  If the original areas
                are needed in the original position (e.g.,  they may be
                attached to a volume), they are not moved, and new areas are
                generated instead.  Meshed items corresponding to moved areas
                are also moved if not needed at their original position.

        Notes
        -----
        Generates additional areas (and their corresponding keypoints, lines
        and mesh) from a given area pattern.  The MAT, TYPE, REAL, ESYS, and
        SECNUM attributes of the new areas are based upon the areas in the
        pattern and not upon the current settings of the pointers.  End slopes
        of the generated lines remain the same (in the active coordinate
        system) as those of the given pattern.  For example, radial slopes
        remain radial.  Generations which produce areas of a size or shape
        different from the pattern (i.e., radial generations in cylindrical
        systems, radial and phi generations in spherical systems, and theta
        generations in elliptical systems) are not allowed.  Solid modeling in
        a toroidal coordinate system is not recommended.  Area and line numbers
        are automatically assigned, beginning with the lowest available values
        [NUMSTR].
        """
        command = "AGEN,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(itime), str(na1), str(na2), str(ninc), str(dx), str(dy), str(dz), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def autots(self, key="", **kwargs):
        """APDL Command: AUTOTS

        Specifies whether to use automatic time stepping or load stepping.

        Parameters
        ----------
        key
            Automatic time stepping key:

            OFF - Do not use automatic time stepping.

            ON - Use automatic time stepping (default).

            AUTO - The program determines whether to use automatic time stepping (used by
                   Workbench).

        Notes
        -----
        Specifies whether to use automatic time stepping (or load stepping)
        over this load step. If Key = ON, both time step prediction and time
        step bisection will be used.

        You cannot use automatic time stepping [AUTOTS], line search [LNSRCH],
        or the DOF solution predictor [PRED] with the arc-length method
        [ARCLEN, ARCTRM]. If you activate the arc-length method after you set
        AUTOTS, LNSRCH, or PRED, a warning message appears. If you choose to
        proceed with the arc-length method, the program disables your automatic
        time stepping, line search, and DOF predictor settings, and the time
        step size is controlled by the arc-length method internally.

        This command is also valid in PREP7.
        """
        command = "AUTOTS,%s" % (str(key))
        return self.run(command, **kwargs)

    def ocdelete(self, datatype="", zonename="", **kwargs):
        """APDL Command: OCDELETE

        Deletes a previously defined ocean load.

        Parameters
        ----------
        datatype
            Ocean data type to delete. Valid values are BASIC, CURRENT, WAVE,
            ZONE, and ALL.

        zonename
            The name of the ocean zone to delete. If no name is specified, all
            defined ocean zones are deleted. Valid only when DataType = ZONE.

        Notes
        -----
        The OCDELETE command deletes previously specified ocean data from the
        database.

        This command is also valid in PREP7.
        """
        command = "OCDELETE,%s,%s" % (str(datatype), str(zonename))
        return self.run(command, **kwargs)

    def rdele(self, nset1="", nset2="", ninc="", lchk="", **kwargs):
        """APDL Command: RDELE

        Deletes real constant sets.

        Parameters
        ----------
        nset1, nset2, ninc
            Delete real constant sets from NSET1 to NSET2 (defaults to NSET1)
            in steps of NINC (defaults to 1).  If NSET1 = ALL, ignore NSET2 and
            NINC and all real constant sets are deleted.

        lchk
            Specifies the level of element-associativity checking:

            NOCHECK - No element-associativity check occurs. This option is the default.

            WARN - When a section, material, or real constant is associated with an element, ANSYS
                   issues a message warning that the necessary entity has been
                   deleted.

            CHECK - The command terminates, and no section, material, or real constant is deleted
                    if it is associated with an element.

        Notes
        -----
        Deletes real constant sets defined with the R command.

        This command is also valid in SOLUTION.
        """
        command = "RDELE,%s,%s,%s,%s" % (str(nset1), str(nset2), str(ninc), str(lchk))
        return self.run(command, **kwargs)

    def dofsel(self, type="", dof1="", dof2="", dof3="", dof4="", dof5="",
               dof6="", **kwargs):
        """APDL Command: DOFSEL

        Selects a DOF label set for reference by other commands.

        Parameters
        ----------
        type
            Label identifying the type of select:

            S - Select a new set of labels.

            A - Add labels to the current set.

            U - Unselect (remove) labels from the current set.

            ALL - Restore the full set of labels.

            STAT - Display the current select status.

        dof1, dof2, dof3, . . . , dof6
            Used only with Type = S, A, or U.  Valid structural labels:  UX,
            UY, or UZ (displacements); U (UX, UY, and UZ);  ROTX, ROTY, or ROTZ
            (rotations); ROT (ROTX, ROTY, and ROTZ);  DISP (U and ROT); HDSP
            (Hydrostatic pressure). Valid thermal labels: TEMP, TBOT, TE2, TE3,
            . . ., TTOP (temperature).  Valid acoustic labels:  PRES
            (pressure); UX, UY, or UZ (displacements for FSI coupled elements).
            Valid electric labels:  VOLT (voltage); EMF (electromotive force
            drop); CURR (current).  Valid magnetic labels:  MAG (scalar
            magnetic potential); AX, AY or AZ (vector magnetic potentials); A
            (AX, AY and AZ); CURR (current).  Valid structural force labels:
            FX, FY, or FZ (forces); F (FX, FY, and FZ); MX, MY, or MZ
            (moments); M (MX, MY, and MZ);  FORC (F and M); DVOL (fluid mass
            flow rate).  Valid thermal force labels:  HEAT, HBOT, HE2, HE3, . .
            ., HTOP (heat flow).  Valid fluid flow force labels:  FLOW (fluid
            flow).  Valid electric force labels:  AMPS (current flow); CHRG
            (electric charge).  Valid magnetic force labels:  FLUX (scalar
            magnetic flux); CSGX, CSGY, or CSGZ (magnetic current segments);
            CSG (CSGX, CSGY, and CSGZ). Valid diffusion labels: CONC
            (concentration); RATE (diffusion flow rate).

        Notes
        -----
        Selects a degree of freedom label set for reference by other commands.
        The label set is used on certain commands where ALL is either input in
        the degree of freedom label field or implied.  The active label set has
        no effect on the solution degrees of freedom.  Specified labels which
        are not active in the model (from the ET or DOF command) are ignored.
        As a convenience, a set of force labels corresponding to the degree of
        freedom labels is also selected.  For example, selecting UX also causes
        FX to be selected (and vice versa).  The force label set is used on
        certain commands where ALL is input in the force label field.

        This command is valid in any processor.
        """
        command = "DOFSEL,%s,%s,%s,%s,%s,%s,%s" % (str(type), str(dof1), str(dof2), str(dof3), str(dof4), str(dof5), str(dof6))
        return self.run(command, **kwargs)

    def window(self, wn="", xmin="", xmax="", ymin="", ymax="", ncopy="",
               **kwargs):
        """APDL Command: /WINDOW

        Defines the window size on the screen.

        Parameters
        ----------
        wn
            Window reference number (1 to 5).  Defaults to 1.  This number, or
            ALL (for all active windows), may be used on other commands.

        xmin, xmax, ymin, ymax
            Screen coordinates defining window size.  Screen coordinates are
            measured as -1.0 to 1.67 with the origin at the screen center.  For
            example, (-1,1.67,-1,1) is full screen, (-1,0,-1,0) is the left
            bottom quadrant.  If XMIN = OFF, deactivate this previously defined
            window; if ON, reactivate this previously defined window.  If FULL,
            LEFT, RIGH, TOP, BOT, LTOP, LBOT, RTOP, RBOT, form full, half, or
            quarter window.  If SQUA, form largest square window within the
            current graphics area.  If DELE, delete this window (cannot be
            reactivated with ON).

        ncopy
            Copies the current specifications from window NCOPY (1 to 5) to
            this window.  If NCOPY = 0 (or blank), no specifications are
            copied.

        Notes
        -----
        Defines the window size on the screen.  Windows may occupy a separate
        section of the screen or they may overlap.  Requested displays are
        formed in all windows according to the selected window specifications.

        This command is valid in any processor.
        """
        command = "/WINDOW,%s,%s,%s,%s,%s,%s" % (str(wn), str(xmin), str(xmax), str(ymin), str(ymax), str(ncopy))
        return self.run(command, **kwargs)

    def psearch(self, pname="", **kwargs):
        """APDL Command: /PSEARCH

        Specifies a directory to be searched for "unknown command" macro files.

        Parameters
        ----------
        pname
            Path name (64 characters maximum, and must include the final
            delimiter) of the middle directory to be searched.  Defaults to the
            user home directory.  If Pname = OFF, search only the ANSYS and
            current working directories.  If Pname = STAT, list the current
            middle directory and show the ANSYS_MACROLIB setting.

        Notes
        -----
        Specifies the pathname of a directory for file searches when reading
        "unknown command" macro files.  The search for the files is typically
        from the ANSYS directory, then from the user home directory, and then
        from the current working directory.  This command allows the middle
        directory searched to be other than the user home directory.

        This command is valid only at the Begin Level.
        """
        command = "/PSEARCH,%s" % (str(pname))
        return self.run(command, **kwargs)

    def wrfull(self, ldstep="", **kwargs):
        """APDL Command: WRFULL

        Stops solution after assembling global matrices.

        Parameters
        ----------
        ldstep
            Specify action to take:

            OFF or 0 - Turn off feature (default)

            N - Turn on feature and set it to stop after assembling the global matrices and
                writing the .FULL file for load step N.

        Notes
        -----
        This command is used in conjunction with the SOLVE command to generate
        the assembled matrix file (.FULL file) only.  The element matrices are
        assembled into the relevant global matrices for the particular analysis
        being performed and the .FULL file is written.  Equation solution and
        the output of data to the results file are skipped.  To dump the
        matrices written on the .FULL file into Harwell-Boeing format, use the
        HBMAT command in /AUX2. To copy the matrices to a postscript format
        that can be viewed graphically, use the PSMAT command.

        To use the LSSOLVE macro with this command, you may need to modify the
        LSSOLVE macro to properly stop at the load step of interest.

        This command only valid for linear static, full harmonic, and full
        transient analyses when the sparse direct solver is selected.  This
        command is also valid for buckling or modal analyses with any mode
        extraction method.  This command is not valid for nonlinear analyses.
        It is not supported in a linear perturbation analysis.

        In general, the assembled matrix file .FULL contains stiffness, mass,
        and damping matrices. However, the availability of the matrices depends
        on the analysis type chosen when the file is written.
        """
        command = "WRFULL,%s" % (str(ldstep))
        return self.run(command, **kwargs)

    def wpave(self, x1="", y1="", z1="", x2="", y2="", z2="", x3="", y3="",
              z3="", **kwargs):
        """APDL Command: WPAVE

        Moves the working plane origin to the average of specified points.

        Parameters
        ----------
        x1, y1, z1
            Coordinates (in the active coordinate system) of the first point.
            If X1 = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI).

        x2, y2, z2
            Coordinates (in the active coordinate system) of the second point.

        x3, y3, z3
            Coordinates (in the active coordinate system) of the third point.

        Notes
        -----
        Moves the origin of the working plane to the average of the specified
        points.  A point is considered specified only if at least one of its
        coordinates is non-blank, and at least one point (1, 2, or 3) must be
        specified.  Blank coordinates of a specified point are assumed to be
        zero.  Averaging is based on the active coordinate system.

        This command is valid in any processor.
        """
        command = "WPAVE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(x1), str(y1), str(z1), str(x2), str(y2), str(z2), str(x3), str(y3), str(z3))
        return self.run(command, **kwargs)

    def immed(self, key="", **kwargs):
        """APDL Command: IMMED

        Allows immediate display of a model as it is generated.

        Parameters
        ----------
        key
            Immediate mode key:

            0 - Display only upon request, i.e., no immediate display (default with the GUI
                off).

            1 - Display immediately as model is generated (default with the GUI on).

        Notes
        -----
        Allows immediate display of a model (as it is generated) without a
        screen erase or a display request.  Available only during an
        interactive session at a graphics display terminal.  A valid graphics
        device name must first be specified on the /SHOW command.

        The IMMED command allows you to control whether or not the model is
        displayed immediately as it is generated in an interactive session.  By
        default in the GUI, your model will immediately be displayed in the
        Graphics Window as you create new entities (such as areas, keypoints,
        nodes, elements, local coordinate systems, boundary conditions, etc.).
        This is called immediate mode graphics.  Also note that symbols (such
        as boundary conditions, local coordinate system triads, etc.) are shown
        immediately and will be present on subsequent displays unless you "turn
        off" the appropriate symbol using the GUI plot controls function or the
        appropriate graphics specification command.

        An immediate image will also be automatically scaled to fit nicely
        within the Graphics Window -- a feature called automatic scaling.  The
        new scaling is usually apparent on the automatic replot associated with
        immediate mode.  To suppress automatic replot, issue /UIS,REPLOT,0.
        (With automatic replot suppressed, the immediate image may not always
        be automatically scaled correctly.)

        Note:: : An immediate display in progress should not be aborted with
        the usual system "break" feature (or else the ANSYS session itself will
        be aborted).  When you run the ANSYS program interactively without
        using the GUI, immediate mode is off by default.

        This command is valid only in PREP7.
        """
        command = "IMMED,%s" % (str(key))
        return self.run(command, **kwargs)

    def prism(self, z1="", z2="", **kwargs):
        """APDL Command: PRISM

        Creates a prism volume based on working plane coordinate pairs.

        Parameters
        ----------
        z1, z2
            Working plane Z coordinates of the top and bottom of the prism.

        Notes
        -----
        Defines a prism volume based on the working plane. The top and bottom
        areas will each be defined with NPT keypoints and NPT lines, where NPT
        (must be at least 3) is the number of coordinate pairs defined with
        PTXY command.  Also, a line will be defined between each point pair on
        the top and bottom face.  See the RPRISM and RPR4 commands for other
        ways to create prisms.
        """
        command = "PRISM,%s,%s" % (str(z1), str(z2))
        return self.run(command, **kwargs)

    def tbmodif(self, row="", col="", value="", **kwargs):
        """APDL Command: TBMODIF

        Modifies data for the material data table (GUI).

        Parameters
        ----------
        row, col
            The row and column numbers of the table entry to be modified.

        value
            The new value to be used in the ROW, COL location.

        Notes
        -----
        The TBMODIF command modifies data for the table specified on the last
        TB command.

        For temperature-dependent data, the temperature specified on the last
        TBTEMP command is used.

        TBMODIF is a command generated by the Graphical User Interface (GUI).
        It appears in the log file (Jobname.LOG) if a TB material data table is
        graphically edited in spreadsheet fashion.

        The TBMODIF command is not intended to be typed in directly during an
        analysis session (although it can be included in an input file for
        batch input or for use with the /INPUT command).

        This command is also valid in SOLUTION.
        """
        command = "TBMODIF,%s,%s,%s" % (str(row), str(col), str(value))
        return self.run(command, **kwargs)

    def lcfact(self, lcno="", fact="", **kwargs):
        """APDL Command: LCFACT

        Defines scale factors for load case operations.

        Parameters
        ----------
        lcno
            Load case pointer number.  If ALL, apply to all selected load cases
            [LCSEL].

        fact
            Scale factor applied to load case LCNO.  Blank defaults to 1.0.

        Notes
        -----
        Defines scale factors to be used in the load case operations [LCASE or
        LCOPER].  Scale factors are applied after an absolute value operation
        [LCABS] and are applied only to defined load cases [LCDEF].
        """
        command = "LCFACT,%s,%s" % (str(lcno), str(fact))
        return self.run(command, **kwargs)

    def lsdump(self, enginename="", filename="", **kwargs):
        """APDL Command: *LSDUMP

        Dumps a linear solver engine to a binary File.

        Parameters
        ----------
        enginename
            Name used to identify this engine. Must have been previously
            created using *LSENGINE and factorized using *LSFACTOR.

        filename
            Name of the file to create.

        Notes
        -----
        Dumps a previously factorized linear solver system to a binary file.
        Only LAPACK and BCS linear solvers can be used with this feature. The
        Linear Solver can later be restored with the *LSRESTORE command.

        A BCS Sparse Solver can be dumped only if uses the INCORE memory option
        (see BCSOPTION).
        """
        command = "*LSDUMP,%s,%s" % (str(enginename), str(filename))
        return self.run(command, **kwargs)

    def snoption(self, rangefact="", blocksize="", robustlev="", compute="",
                 solve_info="", **kwargs):
        """APDL Command: SNOPTION

         Specifies Supernode (SNODE) eigensolver options.

        Parameters
        ----------
        rangefact
            Factor used to control the range of eigenvalues computed for each
            supernode. The value of RangeFact must be a number between 1.0 and
            5.0. By default the RangeFact value is set to 2.0, which means that
            all eigenvalues between 0 and 2*FREQE are computed for each
            supernode (where FREQE is the upper end of the frequency range of
            interest as specified on the MODOPT command). As the RangeFact
            value increases, the eigensolution for the SNODE solver becomes
            more accurate and the computational time increases.

        blocksize
            BlockSize to be used when computing the final eigenvectors. The
            value of Blocksize must be either MAX or a number between 1 and
            NMODE, where NMODE is the number of modes to be computed as set on
            the MODOPT command. Input a value of MAX to force the algorithm to
            allocate enough memory to hold all of the final eigenvectors in
            memory and, therefore, only read through the file containing the
            supernode eigenvectors once. Note that this setting is ONLY
            recommended when there is sufficient physical memory on the machine
            to safely hold all of the final eigenvectors in memory.

        robustlev
            Parameter used to control the robustness of the SNODE eigensolver.
            The value of RobustLev must be a number between 0 and 10.  Lower
            values of RobustLev allow the eigensolver to run in the most
            efficient manner for optimal performance.  Higher values of
            RobustLev often slow down the performance of the eigensolver, but
            can increase the robustness; this may be desirable if a problem is
            detected with the eigensolver or its eigensolution.

        compute
            Key to control which computations are performed by the Supernode
            eigensolver:

            EVALUE - The eigensolver computes only the eigenvalues.

            EVECTOR - The eigensolver computes only the eigenvectors (must be preceded by a modal
                      analysis where the eigenvalues were computed using the
                      Supernode eigensolver).

            BOTH - The eigensolver computes both the eigenvalues and eigenvectors in the same pass
                   (default).

        --
            Unused field

        solve_info
            Solver output option:

            OFF - Turns off additional output printing from the Supernode eigensolver (default).

            PERFORMANCE - Turns on additional output printing from the Supernode eigensolver, including a
                          performance summary and a summary of file I/O for the
                          Supernode eigensolver. Information on memory usage
                          during assembly of the global matrices (that is,
                          creation of the Jobname.FULL file) is also printed
                          with this option.

        Notes
        -----
        This command specifies options for the Supernode (SNODE) eigensolver.

        Setting RangeFact to a value greater than 2.0 will improve the accuracy
        of the computed eigenvalues and eigenvectors, but will often increase
        the computing time of the SNODE eigensolver. Conversely, setting
        RangeFact to a value less than 2.0 will deteriorate the accuracy of the
        computed eigenvalues and eigenvectors, but will often speedup the
        computing time of the SNODE eigensolver.  The default value of 2.0 has
        been set as a good blend of accuracy and performance.

        The SNODE eigensolver reads the eigenvectors and related information
        for each supernode from a file and uses that information to compute the
        final eigenvectors.  For each eigenvalue/eigenvector requested by the
        user, the program must do one pass through the entire file that
        contains the supernode eigenvectors.  By choosing a BlockSize value
        greater than 1, the program can compute BlockSize number of final
        eigenvectors for each pass through the file.  Therefore, smaller values
        of BlockSize result in more I/O, and larger values of BlockSize result
        in less I/O.  Larger values of  BlockSize also result in significant
        additional memory usage, as BlockSize number of final eigenvectors must
        be stored in memory. The default Blocksize of min(NMODE,40) is normally
        a good choice to balance memory and I/O usage.

        The RobustLev field should only be used when a problem is detected with
        the accuracy of the final solution or if the Supernode eigensolver
        fails while computing the eigenvalues/eigenvectors. Setting RobustLev
        to a value greater than 0 will cause the performance of the eigensolver
        to deteriorate. If the performance deteriorates too much or if the
        eigensolver continues to fail when setting the RobustLev field to
        higher values, then switching to another eigensolver such as Block
        Lanczos or PCG Lanczos is recommended.

        Setting Compute = EVALUE causes the Supernode eigensolver to compute
        only the requested eigenvalues.  During this process a Jobname.SNODE
        file is written; however, a Jobname.MODE file is not written. Thus,
        errors will likely occur in any downstream computations that require
        the Jobname.MODE file (for example, participation factor computations,
        mode superpostion transient/harmonic analysis, PSD analysis). Setting
        Compute = EVECTOR causes the Supernode eigensolver to compute only the
        corresponding eigenvectors. The Jobname.SNODE file and the associated
        Jobname.FULL file are required when requesting these eigenvectors. In
        other words, the eigenvalues must have already been computed for this
        model before computing the eigenvectors. This field can be useful in
        order to separate the two steps (computing eigenvalues and computing
        eigenvectors).
        """
        command = "SNOPTION,%s,%s,%s,%s,%s" % (str(rangefact), str(blocksize), str(robustlev), str(compute), str(solve_info))
        return self.run(command, **kwargs)

    def areverse(self, anum="", noeflip="", **kwargs):
        """APDL Command: AREVERSE

        Reverses the normal of an area, regardless of its connectivity or mesh
        status.

        Parameters
        ----------
        anum
            Area number of the area whose normal is to be reversed.  If ANUM =
            ALL, the normals of all selected areas will be reversed.  If ANUM =
            P, graphical picking is enabled.  A component name may also be
            substituted for ANUM.

        noeflip
            Indicates whether you want to change the normal direction of the
            existing elements on the reversed area(s) so that they are
            consistent with each area's new normal direction.

            0 - Make the normal direction of existing elements on the reversed area(s)
                consistent with each area's new normal direction (default).

            1 - Do not change the normal direction of existing elements on the reversed
                area(s).

        Notes
        -----
        You cannot use the AREVERSE command to change the normal direction of
        any element that has a body or surface load.  We recommend that you
        apply all of your loads only after ensuring that the element normal
        directions are acceptable. Also, you cannot use this command to change
        the normal direction for areas attached to volumes because IGES and ANF
        data is unchanged by reversal. Reversed areas that are attached to
        volumes need to be reversed again when imported.

        Real constants (such as nonuniform shell thickness and tapered beam
        constants) may be invalidated by an element reversal.

        See Revising Your Model in the Modeling and Meshing Guide for more
        information.
        """
        command = "AREVERSE,%s,%s" % (str(anum), str(noeflip))
        return self.run(command, **kwargs)

    def cplane(self, key="", **kwargs):
        """APDL Command: /CPLANE

        Specifies the cutting plane for section and capped displays.

        Parameters
        ----------
        key
            Specifies the cutting plane:

            0 - Cutting plane is normal to the viewing vector [/VIEW] and passes through the
                focus point [/FOCUS] (default).

            1 - The working plane [WPLANE] is the cutting plane.

        Notes
        -----
        Defines the cutting plane to be used for section and capped displays
        [/TYPE,,(1, 5, or 7)].

        This command is valid in any processor.
        """
        command = "/CPLANE,%s" % (str(key))
        return self.run(command, **kwargs)

    def anstoaqwa(self, fname="", vertaxis="", gc="", rho="", hwl="",
                  diffkey="", symxkey="", symykey="", **kwargs):
        """APDL Command: ANSTOAQWA

        Creates an AQWA-LINE input file from the current ANSYS model.

        Parameters
        ----------
        fname
            AQWA file name. Defaults to Jobname.

        vertaxis
            Axis in the vertical direction:

            Y (or 2)  - Global Y axis.

            Z (or 3)  - Global Z axis (default).

        gc
            Gravitational acceleration. Defaults to 9.81.

        rho
            Density of water. Defaults to 1025.0.

        hwl
            Waterline height in model coordinates. Defaults to 0.0.

        diffkey
            Diffracting model key:

            0 - Create a non-diffracting AQWA model.

            1 - Create a diffracting AQWA model (default).

        symxkey
            Key indicating if model is symmetric about the global XZ plane:

            0 - No symmetry about XZ plane (default).

            1 - Use symmetry about XZ plane. Only include (or select) half the model.

        symykey
            Key indicating if model is symmetric about the global YZ plane:

            0 - No symmetry about YZ plane (default).

            1 - Use symmetry about YZ plane. Only include (or select) half the model.

        Notes
        -----
        This command creates the input file Fname.aqwa for the ANSYS Aqwa
        Multi-Body Hydrodynamics System for diffraction analysis in AQWA-LINE
        from the model currently in the database, based on the currently
        selected set of elements. The selected set must only include the hull
        envelope; no internal structure should be selected.

        There should be a line of nodes defined at the waterline. Only those
        elements that are entirely below the waterline will be specified as
        diffracting. If there are no waterline nodes, there will be no
        diffracting elements at the waterline, which will severely reduce the
        accuracy of the diffraction analysis.

        The translator maps PLANE42, SHELL41, SHELL63, and SHELL181 elements to
        PANELs, and maps PIPE16 and PIPE59 elements to TUBEs. It does not
        recognize any other element types. Any material or geometric properties
        can be used for the shell elements, as AQWA does not need any
        properties at all and the command does not use them. All the shell
        elements below the water must have their normals pointing outward.

        TUBE elements in AQWA have material density, outside diameter, wall
        thickness, added mass, and drag coefficients, so appropriate properties
        should be used in the ANSYS model. PIPE59 elements can have added mass
        and damping coefficients; these will be written to the file. The ANSYS
        program uses the inertia coefficient CM, whereas AQWA uses the added
        mass coefficient CA, where CM = (1 + CA). This correction is made
        automatically.

        In AQWA the vertical axis is always the Z-axis. The command can convert
        a model built with either the Y or Z-axis vertical, but the X-axis must
        be horizontal and should preferably be along the fore/aft axis of the
        vessel.  If the structure is symmetric and you wish to use the symmetry
        options, you must only select one half or one quarter of the model, as
        appropriate. If you model a complete vessel and specify X symmetry, the
        AQWA model will contain two sets of coincident elements.

        If you are working from a model created for a structural analysis, it
        will probably be necessary to remesh the model as the structural mesh
        is most likely finer than needed for a diffraction analysis.

        If you enter this command interactively (with the GUI active) and no
        data is provided for the command options, you will be prompted for
        their values.

        You must verify the completeness and accuracy of the data written.
        """
        command = "ANSTOAQWA,%s,%s,%s,%s,%s,%s,%s,%s" % (str(fname), str(vertaxis), str(gc), str(rho), str(hwl), str(diffkey), str(symxkey), str(symykey))
        return self.run(command, **kwargs)

    def bfl(self, line="", lab="", val1="", val2="", val3="", val4="",
            **kwargs):
        """APDL Command: BFL

        Defines a body force load on a line.

        Parameters
        ----------
        line
            Line to which body load applies.  If ALL, apply to all selected
            lines [LSEL]. A component name may also be substituted for Line.

        lab
            Valid body load label. Load labels are listed under "Body loads" in
            the input table for each element type in the Element Reference.

        val1, val2, val3
            Value associated with the Lab item or a table name for specifying
            tabular boundary conditions.  Use only VAL1 for TEMP, FLUE, HGEN,
            and CHRGD. For acoustics, if Lab = JS,  use VAL1 for mass source in
            a harmonic analysis or mass source rate in a transient analysis,
            and ignoreVAL2 and VAL3. When specifying a table name, you must
            enclose the table name in percent signs (%), e.g.,
            BFL,Line,Lab,%tabname%.  Use the *DIM command to define a table.

        val4
            If Lab = JS, VAL4 is the phase angle in degrees.

        Notes
        -----
        Defines a body force load (such as temperature in a structural
        analysis, heat generation rate in a thermal analysis, etc.) on a line.
        Body loads may be transferred from lines to line elements (or to nodes
        if line elements do not exist) with the BFTRAN or SBCTRAN commands.

        You can specify a table name only when using temperature (TEMP) and
        heat generation rate (HGEN) body load labels.

        Body loads specified by the BFL command can conflict with other
        specified body loads.  See Resolution of Conflicting Body Load
        Specifications in the Basic Analysis Guide for details.

        Graphical picking is available only via the listed menu paths.

        This command is also valid in PREP7.
        """
        command = "BFL,%s,%s,%s,%s,%s,%s" % (str(line), str(lab), str(val1), str(val2), str(val3), str(val4))
        return self.run(command, **kwargs)

    def ksln(self, type="", **kwargs):
        """APDL Command: KSLN

        Selects those keypoints associated with the selected nodes.

        Parameters
        ----------
        type
            Label identifying the type of keypoint select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        Notes
        -----
        Valid only if the nodes were generated by a meshing operation [KMESH,
        LMESH, AMESH, VMESH] on a solid model that contains the associated
        keypoints.

        This command is valid in any processor.
        """
        command = "KSLN,%s" % (str(type))
        return self.run(command, **kwargs)

    def bfe(self, elem="", lab="", stloc="", val1="", val2="", val3="",
            val4="", **kwargs):
        """APDL Command: BFE

        Defines an element body force load.

        Parameters
        ----------
        elem
            The element to which body load applies.  If ALL, apply to all
            selected elements (ESEL). A component name may also be substituted
            for Elem.

        lab
            Valid body load label. Valid labels are also listed for each
            element type in the Element Reference under "Body Loads" in the
            input table.

        stloc
            Starting location for entering VAL data, below.  For example, if
            STLOC = 1, data input in the VAL1 field applies to the first
            element body load item available for the element type, VAL2 applies
            to the second element item, etc. If STLOC = 5, data input in the
            VAL1 field applies to the fifth element item, etc.  Defaults to 1.

        val1, val2, val3, val4
            For Lab = TEMP, FLUE, DGEN, HGEN, and CHRGD, VAL1--VAL4 represent
            body load values at the starting location and subsequent locations
            (usually nodes) in the element.  VAL1 can also represent a table
            name for use with tabular boundary conditions. Enter only VAL1 for
            a uniform body load across the element.  For nonuniform loads, the
            values must be input in the same order as shown in the input table
            for the element type.  Values initially default to the BFUNIF value
            (except for CHRGD which defaults to zero).  For subsequent
            specifications, a blank leaves a previously specified value
            unchanged; if the value was not previously specified, the default
            value as described in the Element Reference is used.

        Notes
        -----
        Defines an element body force load (such as temperature in a structural
        analysis, heat generation rate in a thermal analysis, etc.). Body loads
        and element specific defaults are described for each element type in
        the Element Reference. If both the BF and BFE commands are used to
        apply a body load to an element, the BFE command takes precedence.

        For heat-generation (HGEN) loading on layered thermal solid elements
        SOLID278 / SOLID279 (KEYOPT(3) = 1 or 2), or layered thermal shell
        elements SHELL131 / SHELL132 (KEYOPT(3) = 1), STLOC refers to the layer
        number (not the node). In such cases, use VAL1 through VAL4 to specify
        the heat-generation values for the appropriate layers. Heat generation
        is constant over the layer.

        Specifying a Table

        You can specify a table name (VAL1) when using temperature (TEMP),
        diffusing substance generation rate (DGEN), heat generation rate
        (HGEN), and current density (JS) body load labels.

        Enclose the table name (tabname) in percent signs (%), as shown:

        BFE,Elem, Lab,STLOC,%tabname%

        Use the *DIM command to define a table.

        For Lab = TEMP, each table defines NTEMP temperatures, as follows:

        For layered elements, NTEMP is the number of layer interface corners
        that allow temperature input.

        For non-layered elements, NTEMP is the number of corner nodes.

        The temperatures apply to element items with a starting location of
        STLOC + n, where n is the value field location (VALn) of the table name
        input.

        For layered elements, a single BFE command returns temperatures for one
        layer interface. Multiple BFE commands are necessary for defining all
        layered temperatures.

        For beam, pipe and elbow elements that allow multiple temperature
        inputs per node, define the tabular load for the first node only (Node
        I), as loads on the remaining nodes are applied automatically. For
        example, to specify a tabular temperature load on a PIPE288 element
        with the through-wall-gradient option (KEYOPT(1) = 0), the BFE command
        looks like this:

        BFE,Elem,TEMP,1,%tabOut%, %tabIn%

        When a tabular function load is applied to an element, the load does
        not vary according to the positioning of the element in space.

        Graphical picking is available only via the listed menu paths.

        This command is also valid in PREP7.
        """
        command = "BFE,%s,%s,%s,%s,%s,%s,%s" % (str(elem), str(lab), str(stloc), str(val1), str(val2), str(val3), str(val4))
        return self.run(command, **kwargs)

    def ceqn(self, **kwargs):
        """APDL Command: CEQN

        Specifies "Constraint equations" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "CEQN," % ()
        return self.run(command, **kwargs)

    def ce(self, neqn="", const="", node1="", lab1="", c1="", node2="",
           lab2="", c2="", node3="", lab3="", c3="", **kwargs):
        """APDL Command: CE

        Defines a constraint equation relating degrees of freedom.

        Parameters
        ----------
        neqn
            Set equation reference number:

            n - Arbitrary set number.

            HIGH - The highest defined constraint equation number. This option is especially
                   useful when adding nodes to an existing set.

            NEXT - The highest defined constraint equation number plus one. This option
                   automatically numbers coupled sets so that existing sets are
                   not modified.

        const
            Constant term of equation.

        node1
            Node for first term of equation.  If -NODE1, this term is deleted
            from the equation.

        lab1
            Degree of freedom label for first term of equation.  Structural
            labels:  UX, UY, or UZ (displacements); ROTX, ROTY, or ROTZ
            (rotations, in radians).  Thermal labels: TEMP, TBOT, TE2, TE3, . .
            ., TTOP (temperature).  Electric labels:  VOLT (voltage).  Magnetic
            labels:  MAG (scalar magnetic potential); AX, AY, or AZ (vector
            magnetic potentials). Diffusion label: CONC (concentration).

        c1
            Coefficient for first node term of equation.  If zero, this term is
            ignored.

        node2, lab2, c2
            Node, label, and coefficient for second term.

        node3, lab3, c3
            Node, label, and coefficient for third term.

        Notes
        -----
        Repeat the CE command to add additional terms to the same equation.  To
        change only the constant term, repeat the command with no node terms
        specified.  Only the constant term can be changed during solution, and
        only with the CECMOD command.

        Linear constraint equations may be used to relate the degrees of
        freedom of selected nodes in a more general manner than described for
        nodal coupling [CP].  The constraint equation is of the form:

        where U(I) is the degree of freedom (displacement, temperature, etc.)
        of term (I).  The following example is a set of two constraint
        equations, each containing three terms:

        0.0 = 3.0* (1 UX) + 3.0* (4 UX) + (-2.0)* (4 ROTY)

        2.0 = 6.0* (2 UX) + 10.0* (4 UY) + 1.0* (3 UZ)

        The first unique degree of freedom in the equation is eliminated in
        terms of all other degrees of freedom in the equation.  A unique degree
        of freedom is one which is not specified in any other constraint
        equation, coupled node set, specified displacement set, or master
        degree of freedom set.  It is recommended that the first term of the
        equation be the degree of freedom to be eliminated.  The first term of
        the equation cannot contain a master degree of freedom, and no term can
        contain coupled degrees of freedom.  The same degree of freedom may be
        specified in more than one equation but care must be taken to avoid
        over-specification (over-constraint).

        The degrees of freedom specified in the equation (i.e., UX, UY, ROTZ,
        etc.) must also be included in the model (as determined from the
        element types [ET]).  Also, each node in the equation must be defined
        on an element (any element type containing that degree of freedom will
        do).

        For buckling and modal analyses, the constant term of the equation will
        not be taken into account (that is, CONST is always zero).

        Note that under certain circumstances a constraint equation generated
        by CE may be modified during the solution. See Program Modification of
        Constraint Equations for more information.
        """
        command = "CE,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(neqn), str(const), str(node1), str(lab1), str(c1), str(node2), str(lab2), str(c2), str(node3), str(lab3), str(c3))
        return self.run(command, **kwargs)

    def con4(self, xcenter="", ycenter="", rad1="", rad2="", depth="",
             **kwargs):
        """APDL Command: CON4

        Creates a conical volume anywhere on the working plane.

        Parameters
        ----------
        xcenter, ycenter
            Working plane X and Y coordinates of the center axis of the cone.

        rad1, rad2
            Radii of the faces of the cone.  RAD1 defines the bottom face and
            will be located on the working plane.  RAD2 defines the top face
            and is parallel to the working plane.  A value of zero or blank for
            either RAD1 or RAD2 defines a degenerate face at the center axis
            (i.e., the vertex of the cone).  The same value for both RAD1 and
            RAD2 defines a cylinder instead of a cone.

        depth
            The perpendicular distance (either positive or negative based on
            the working plane Z direction) from the working plane representing
            the depth of the cone.  DEPTH cannot be zero (see "Notes" below).

        Notes
        -----
        Defines a solid conical volume with either the vertex or a face
        anywhere on the working plane.  The cone must have a spatial volume
        greater than zero.  (i.e., this volume primitive command cannot be used
        to create a degenerate volume as a means of creating an area.)  The
        face or faces will be circular (each area defined with four lines), and
        they will be connected with two areas (each spanning 180°).  See the
        CONE command for an alternate way to create cones.
        """
        command = "CON4,%s,%s,%s,%s,%s" % (str(xcenter), str(ycenter), str(rad1), str(rad2), str(depth))
        return self.run(command, **kwargs)

    def filldata(self, ir="", lstrt="", lstop="", linc="", value="", dval="",
                 **kwargs):
        """APDL Command: FILLDATA

        Fills a variable by a ramp function.

        Parameters
        ----------
        ir
            Define data table as variable IR (2 to NV [NUMVAR]).

        lstrt
            Start at location LSTRT (defaults to 1).

        lstop
            Stop at location LSTOP (defaults to maximum location as determined
            from data previously stored.

        linc
            Fill every LINC location between LSTRT and LSTOP (defaults to 1).

        value
            Value assigned to location LSTRT.

        dval
            Increment value of previous filled location by DVAL and assign sum
            to next location to be filled (may be positive or negative.)

        Notes
        -----
        Locations may be filled continuously or at regular intervals (LINC).
        Previously defined data at a location will be overwritten.
        """
        command = "FILLDATA,%s,%s,%s,%s,%s,%s" % (str(ir), str(lstrt), str(lstop), str(linc), str(value), str(dval))
        return self.run(command, **kwargs)

    def rbe3(self, m_aster="", dof="", slaves="", wtfact="", **kwargs):
        """APDL Command: RBE3

        Distributes the force/moment applied at the master node to a set  of
        slave nodes, taking into account the geometry of the slave nodes as
        well as weighting factors.

        Parameters
        ----------
        master
            Node at which the force/moment to be distributed will be applied.
            This node must be associated with an element for the master node to
            be included in the DOF solution.

        dof
            Refers to the master node degrees of freedom to be used in
            constraint equations. Valid labels are: UX, UY, UZ, ROTX, ROTY,
            ROTZ, UXYZ, RXYZ, ALL

        slaves
            The name of an array parameter that contains a list of slave nodes.
            Must specify the starting index number. ALL can be used for
            currently selected set of nodes. The slave nodes may not be
            colinear, that is, not be all located on the same straight line
            (see Notes below).

        wtfact
            The name of an array parameter that contains a list of weighting
            factors corresponding to each slave node above. Must have the
            starting index number. If not specified, the weighting factor for
            each slave node defaults to 1.

        Notes
        -----
        The force is distributed to the slave nodes proportional to the
        weighting factors. The moment is distributed as forces to the slaves;
        these forces are proportional to the distance from the center of
        gravity of the slave nodes times the weighting factors.  Only the
        translational degrees of freedom of the slave nodes are used for
        constructing the constraint equations. Constraint equations are
        converted to distributed forces/moments on the slave nodes during
        solution.

        RBE3 creates constraint equations such that the motion of the master is
        the average of the slaves. For the rotations, a least-squares approach
        is used to define the "average rotation" at the master from the
        translations of the slaves. If the slave nodes are colinear, then one
        of the master rotations that is parallel to the colinear direction can
        not be determined in terms of the translations of the slave nodes.
        Therefore, the associated moment component on the master node in that
        direction can not be transmitted. When this case occurs, a warning
        message is issued and the constraint equations created by RBE3 are
        ignored.

        Applying this command to a large number of slave nodes may result in
        constraint equations with a large number of coefficients. This may
        significantly increase the peak memory required during the process of
        element assembly. If real memory or virtual memory is not available,
        consider reducing the number of slave nodes.

        As an alternative to the RBE3 command, you can apply a similar type of
        constraint using contact elements and the internal multipoint
        constraint (MPC) algorithm. See Surface-based Constraints for more
        information.

        This command is also valid in SOLUTION.
        """
        command = "RBE3,%s,%s,%s,%s" % (str(m_aster), str(dof), str(slaves), str(wtfact))
        return self.run(command, **kwargs)

    def asba(self, na1="", na2="", sepo="", keep1="", keep2="", **kwargs):
        """APDL Command: ASBA

        Subtracts areas from areas.

        Parameters
        ----------
        na1
            Area (or areas, if picking is used) to be subtracted from.  If ALL,
            use all selected areas.  Areas specified in this argument are not
            available for use in the NA2 argument.  If P, graphical picking is
            enabled (valid only in the GUI) and remaining fields are ignored.
            A component name may also be substituted for NA1.

        na2
            Area (or areas, if picking is used) to subtract.  If ALL, use all
            selected areas (except those included in the NA1 argument).    A
            component name may also be substituted for NA2.

        sepo
            Behavior if the intersection of the NA1 areas and the NA2 areas is
            a line or lines:

            (blank) - The resulting areas will share line(s) where they touch.

            SEPO - The resulting areas will have separate, but coincident line(s) where they
                   touch.

        keep1
            Specifies whether NA1 areas are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NA1 areas after ASBA operation (override BOPTN command settings).

            KEEP - Keep NA1 areas after ASBA operation (override BOPTN command settings).

        keep2
            Specifies whether NA2 areas are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NA2 areas after ASBA operation (override BOPTN command settings).

            KEEP - Keep NA2 areas after ASBA operation (override BOPTN command settings).

        Notes
        -----
        Generates new areas by subtracting the regions common to both NA1 and
        NA2 areas (the intersection) from the NA1 areas.  The intersection can
        be an area(s) or line(s).  If the intersection is a line and SEPO is
        blank, the NA1 area is divided at the line and the resulting areas will
        be connected, sharing a common line where they touch.  If SEPO is set
        to SEPO, NA1 is divided into two unconnected areas with separate lines
        where they touch.  See Solid Modeling in the Modeling and Meshing Guide
        for an illustration.  See the BOPTN command for an explanation of the
        options available to Boolean operations.  Element attributes and solid
        model boundary conditions assigned to the original entities will not be
        transferred to the new entities generated.  ASBA,ALL,ALL will have no
        effect since all the areas (in NA1) will be unavailable as NA2 areas.
        """
        command = "ASBA,%s,%s,%s,%s,%s" % (str(na1), str(na2), str(sepo), str(keep1), str(keep2))
        return self.run(command, **kwargs)

    def vscale(self, wn="", vratio="", key="", **kwargs):
        """APDL Command: /VSCALE

        Scales the length of displayed vectors.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        vratio
            Ratio value applied to the automatically calculated scale factor
            (defaults to 1.0, i.e., use scale factor as automatically
            calculated).

        key
            Relative scaling key:

            0 - Use relative length scaling among vectors based on magnitudes.

            1 - Use uniform length scaling for all vector lengths.

        Notes
        -----
        Allows scaling of the vector length displayed with the PLVECT command
        of POST1 and the /PBC and /PSF commands.  Also allows the scaling of
        the  element (i.e., /PSYMB,ESYS) and the nodal (i.e., /PSYMB,NDIR)
        coordinate system symbols.

        This command is valid in any processor.
        """
        command = "/VSCALE,%s,%s,%s" % (str(wn), str(vratio), str(key))
        return self.run(command, **kwargs)

    def cylind(self, rad1="", rad2="", z1="", z2="", theta1="", theta2="",
               **kwargs):
        """APDL Command: CYLIND

        Creates a cylindrical volume centered about the working plane origin.

        Parameters
        ----------
        rad1, rad2
            Inner and outer radii (either order) of the cylinder.  A value of
            zero or blank for either RAD1 or RAD2, or the same value for both
            RAD1 and RAD2,  defines a solid cylinder.

        z1, z2
            Working plane Z coordinates of the cylinder.  If either Z1 or Z2 is
            zero, one of the faces of the cylinder will be coplanar with the
            working plane.

        theta1, theta2
            Starting and ending angles (either order) of the cylinder.  Used
            for creating a cylindrical sector.  The sector begins at the
            algebraically smaller angle, extends in a positive angular
            direction, and ends at the larger angle.  The starting angle
            defaults to 0.0° and the ending angle defaults to 360.0°.   See the
            Modeling and Meshing Guide for an illustration.

        Notes
        -----
        Defines a cylindrical volume centered about the working plane origin.
        The top and bottom faces are parallel to the working plane but neither
        face need be coplanar with (i.e., "on") the working plane.  The
        cylinder must have a spatial volume greater than zero. (i.e., this
        volume primitive command cannot be used to create a degenerate volume
        as a means of creating an area.)  For a solid cylinder of 360°, the top
        and bottom faces will be circular (each area defined with four lines),
        and they will be connected with two areas (each spanning 180°.)  See
        the CYL4 and CYL5 commands for alternate ways to create cylinders.
        """
        command = "CYLIND,%s,%s,%s,%s,%s,%s" % (str(rad1), str(rad2), str(z1), str(z2), str(theta1), str(theta2))
        return self.run(command, **kwargs)

    def ddaspec(self, keyref="", shptyp="", mountloc="", deftyp="", amin="",
                **kwargs):
        """APDL Command: DDASPEC

        Specifies the shock spectrum computation constants for DDAM analysis.

        Parameters
        ----------
        keyref
            Key for reference catalog:

            1 - The spectrum computation constants are based on NRL-1396 (default). For more
                information, see Dynamic Design Analysis Method in the
                Mechanical APDL Theory Reference

        shptyp
            Select the ship type:

            SUBM - Submarine

            SURF - Surface ship

        mountloc
            Select the mounting location:

            HULL - Hull mounting location. These structures are mounted directly to basic hull
                   structures like frames, structural bulkheads below the water
                   line, and shell plating above the water line.

            DECK - Deck mounting location. These structures are mounted directly to decks, non-
                   structural bulkheads, or to structural bulkheads above the
                   water line.

            SHEL - Shell plating mounting location. These structures are mounted directly to shell
                   plating below the water line without intervening
                   foundations.

        deftyp
            Select the deformation type:

            ELAS - Elastic deformation (default)

            PLAS - Elastic-plastic deformation

        amin
            Minimum acceleration value in inch/sec2. It defaults to 2316
            inch/sec2 which equals 6g, where g is the acceleration due to
            gravity (g = 386 in/sec2).

        Notes
        -----
        The excitation direction is required to calculate the spectrum
        coefficients. Issue the SED command before issuing DDASPEC.

        ADDAM and VDDAM may alternatively be used to calculate spectrum
        coefficients.

        This command is also valid in PREP7.
        """
        command = "DDASPEC,%s,%s,%s,%s,%s" % (str(keyref), str(shptyp), str(mountloc), str(deftyp), str(amin))
        return self.run(command, **kwargs)

    def sph4(self, xcenter="", ycenter="", rad1="", rad2="", **kwargs):
        """APDL Command: SPH4

        Creates a spherical volume anywhere on the working plane.

        Parameters
        ----------
        xcenter, ycenter
            Working plane X and Y coordinates of the center of the sphere.

        rad1, rad2
            Inner and outer radii (either order) of the sphere.   A value of
            zero or blank for either RAD1 or RAD2 defines a solid sphere.

        Notes
        -----
        Defines either a solid or hollow spherical volume anywhere on the
        working plane.  The sphere must have a spatial volume greater than
        zero.  (i.e., this volume primitive command cannot be used to create a
        degenerate volume as a means of creating an area.)  A sphere of 360°
        will be defined with two areas, each consisting of a hemisphere.  See
        the SPHERE and SPH5 commands for other ways to create spheres.

        When working with a model imported from an IGES file (DEFAULT import
        option), you can create only solid spheres.  If you enter a value for
        both RAD1 and RAD2 the command is ignored.
        """
        command = "SPH4,%s,%s,%s,%s" % (str(xcenter), str(ycenter), str(rad1), str(rad2))
        return self.run(command, **kwargs)

    def l2ang(self, nl1="", nl2="", ang1="", ang2="", phit1="", phit2="",
              **kwargs):
        """APDL Command: L2ANG

        Generates a line at an angle with two existing lines.

        Parameters
        ----------
        nl1
            Number of the first line to be hit (touched by the end of the new
            line).  If negative, assume P1 (see below) is the second keypoint
            of the line instead of the first.  If NL1 = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).

        nl2
            Number of the second line to be hit.  If negative, assume P3 is the
            second keypoint of the line instead of the first.

        ang1
            Angle of intersection (usually zero or 180) of generated line with
            tangent to first line.

        ang2
            Angle of intersection (usually zero or 180) of generated line with
            tangent to second line.

        phit1
            Number to be assigned to keypoint generated at hit location on
            first line (defaults to lowest available keypoint number [NUMSTR]).

        phit2
            Number to be assigned to keypoint generated at hit location on
            second line (defaults to lowest available keypoint number
            [NUMSTR]).

        Notes
        -----
        Generates a straight line (PHIT1-PHIT2) at an angle (ANG1) with an
        existing line NL1 (P1-P2)  and which is also at an angle (ANG2) with
        another existing line NL2 (P3-P4).  If the angles are zero the
        generated line is tangent to the two lines.  The PHIT1 and PHIT2
        locations on the lines are automatically calculated.  Line P1-P2
        becomes P1-PHIT1, P3-P4 becomes P3-PHIT2, and new lines PHIT1-P2,
        PHIT2-P4, and PHIT1-PHIT2 are generated.  Line divisions are set to
        zero (use LESIZE, etc. to modify).
        """
        command = "L2ANG,%s,%s,%s,%s,%s,%s" % (str(nl1), str(nl2), str(ang1), str(ang2), str(phit1), str(phit2))
        return self.run(command, **kwargs)

    def ucmd(self, cmd="", srnum="", **kwargs):
        """APDL Command: /UCMD

        Assigns a user-defined command name.

        Parameters
        ----------
        cmd
            User-defined command name.  Only the first four characters are
            significant.  Must not conflict with any ANSYS command name or any
            user "unknown command" macro name.

        srnum
            User subroutine number (1 to 10) programmed for this command.  For
            example, the command /UCMD,MYCMD,3 will execute subroutine USER03
            whenever the command MYCMD is entered.  Use a blank command name to
            disassociate SRNUM from its command.  For example, /UCMD,,3 removes
            MYCMD as a command.

        Notes
        -----
        Assigns a user-defined command name to a user-programmable (system-
        dependent) subroutine.  This feature allows user-defined commands to be
        programmed into the ANSYS program.  Once programmed, this command can
        be input to the program like other commands, and can also be included
        in the ANSYS start-up file.  See *ULIB for another way of defining user
        commands.

        Up to 10 subroutines are available for user-defined commands (USER01 to
        USER10).  Users must have system permission, system access, and
        knowledge to write, compile, and link the appropriate subprocessors
        into the ANSYS program at the site where it is to be run.  All routines
        should be written in FORTRAN. For more information on FORTRAN compilers
        please refer to either the ANSYS, Inc. Windows Installation Guide or
        the ANSYS, Inc. Linux Installation Guide for details specific to your
        platform or operating system. The USER01 routine is commented and
        should be listed from the distribution media (system dependent) for
        more details.  Issue /UCMD,STAT to list all user-defined command names.
        Since a user-programmed command is a nonstandard use of the program,
        the verification of any ANSYS run incorporating these commands is
        entirely up to the user.  In any contact with ANSYS customer support
        regarding the performance of a custom version of the ANSYS program, you
        should explicitly state that a user programmable feature has been used.
        See the Advanced Analysis Guide for a general description of user-
        programmable features and Guide to User-Programmable Features for a
        detailed description of these features.

        This command is valid only at the Begin Level.
        """
        command = "/UCMD,%s,%s" % (str(cmd), str(srnum))
        return self.run(command, **kwargs)

    def pbf(self, item="", key="", **kwargs):
        """APDL Command: /PBF

        Shows magnitude of body force loads on displays.

        Parameters
        ----------
        item
            Label identifying the item:

            TEMP - Applied temperatures.

            FLUE - Applied fluences.

            HGEN - Applied heat generation rates.

            JS - Applied current density magnitude.

            JSX - X-component of current density.

            JSY - Y-component of current density.

            JSZ - Z-component of current density.

            PHASE - Phase angle of applied load.

            MVDI - Applied magnetic virtual displacements flag.

            CHRGD - Applied electric charge density.

            VLTG - Applied voltage drop.

        --
            Unused field.

        key
            Symbol key:

            0 - Do not show body force load contours.

            1 - Show body force load contours.

            2 - Show current density as a vector (not a contour).

        Notes
        -----
        Shows body force loads as contours on displays for the selected
        elements.

        The effects of the /PBF command are not cumulative (that is, the
        command does not modify an existing setting from a previously issued
        /PBF command).  If you issue multiple /PBF commands during an analysis,
        only the setting specified by the most recent /PBF command applies.

        Use /PSTATUS or /PBF,STAT to display settings.  Use /PBF,DEFA to reset
        all specifications back to default.  See also the /PSF and /PBC command
        for other display contours.

        Portions of this command are not supported by PowerGraphics
        [/GRAPHICS,POWER].

        This command is valid in any processor.
        """
        command = "/PBF,%s,%s" % (str(item), str(key))
        return self.run(command, **kwargs)

    def fssparm(self, port1="", port2="", **kwargs):
        """APDL Command: FSSPARM

        Calculates reflection and transmission properties of a frequency
        selective surface.

        Parameters
        ----------
        port1
            Port number of input port. Defaults to 1.

        port2
            Port number of output port. Defaults to 1.

        Notes
        -----
        FSSPARM calculates reflection and transmission coefficients, power
        reflection and transmission coefficients, and return and insertion
        losses of a frequency selective surface.
        """
        command = "FSSPARM,%s,%s" % (str(port1), str(port2))
        return self.run(command, **kwargs)

    def rstoff(self, lab="", offset="", **kwargs):
        """APDL Command: RSTOFF

        Offsets node or element IDs in the FE geometry record.

        Parameters
        ----------
        lab
            The offset type:

            NODE  - Offset the node IDs.

            ELEM  - Offset the element IDs.

        offset
            A positive integer value specifying the offset value to apply. The
            value must be greater than the number of nodes or elements in the
            existing superelement results file.

        Notes
        -----
        The RSTOFF command offsets node or element IDs in the FE geometry
        record saved in the .rst results file. Use the command when expanding
        superelements in a bottom-up substructuring analysis (where each
        superelement is generated individually in a generation pass, and all
        superelements are assembled together in the use pass).

        With appropriate offsets, you can write results files with unique node
        or element IDs and thus display the entire model even if the original
        superelements have overlapping element or node ID sets. (Such results
        files are incompatible with the .db database file saved at the
        generation pass.)

        The offset that you specify is based on the original superelement node
        or element numbering, rather than on any offset specified via a SESYMM
        or SETRAN command. When issuing an RSTOFF command, avoid specifying an
        offset that creates conflicting node or element numbers for a
        superelement generated via a SESYMM or SETRAN command.

        If you issue the command to set non-zero offsets for node or element
        IDs, you must bring the geometry into the database via the SET command
        so that ANSYS can display the results. You must specify appropriate
        offsets to avoid overlapping node or element IDs with other
        superelement results files.

        The command is valid only in the first load step of a superelement
        expansion pass.
        """
        command = "RSTOFF,%s,%s" % (str(lab), str(offset))
        return self.run(command, **kwargs)

    def octable(self, val1="", val2="", val3="", val4="", val5="", val6="",
                val7="", **kwargs):
        """APDL Command: OCTABLE

        Defines an ocean load using table data.

        Parameters
        ----------
        val1, val2, val3, . . . , val6
            Values describing the basic ocean load, a current condition, or a
            wave condition.

        Notes
        -----
        The OCTABLE specifies table data that defines the ocean load. The terms
        VAL1, VAL2, etc. are specialized according to the input set required
        for the given ocean load.

        The program interprets the data input via the OCTABLE command within
        the context of the most recently issued OCTYPE command.

        There is no limit to the number of data input.

        Input values in the order indicated.

        This command is also valid in PREP7.

        You can define the following ocean data types:

        If the current is constant, only one OCTABLE command is necessary and
        Dep  is not required.

        For waves, the current profile is stretched or compressed linearly up
        to 10 percent.

        The first Dep value (representing the mean sea level) must be zero. The
        last Dep value (representing the mud line) must be equal to the DEPTH
        value input on the OCDATA command.

        The Cartesian Z values used to locate nodes, etc. decrease as one moves
        from the ocean surface to the sea floor, but the Dep values increase.
        See Figure: 5:: Basic Ocean Data Type Components .

        Dep is not affected by changes to Zmsl on the OCDATA command, as that
        value simply relocates the origin.

        When specifying an ocean wave type, issue the OCTABLE command to input
        either wave location data or wave spectrum data.

        Hints for Wave Location Input:

        The TIME command is not used, except perhaps to identify the load case.

                The phase shift (Ps) determines the wave position (that is, the
        point at which the load is to be applied).

        When using the Stokes fifth-order (KWAVE = 2) or stream function (KWAVE
        = 3) wave type, issue only one OCTABLE command.

        The valid range of the order of the stream function (NORDER) is 3
        through 50. If no value is specified, the program determines a value
        automatically.

        When using the diffracted wave type (KWAVE = 8), an OCREAD command is
        also required to read in the hydrodynamic data from the hydrodynamic
        analysis.
        """
        command = "OCTABLE,%s,%s,%s,%s,%s,%s,%s" % (str(val1), str(val2), str(val3), str(val4), str(val5), str(val6), str(val7))
        return self.run(command, **kwargs)

    def esym(self, ninc="", iel1="", iel2="", ieinc="", **kwargs):
        """APDL Command: ESYM

        Generates elements from a pattern by a symmetry reflection.

        Parameters
        ----------
        --
            Unused field.

        ninc
            Increment nodes in the given pattern by NINC.

        iel1, iel2, ieinc
            Reflect elements from pattern beginning with IEL1 to IEL2 (defaults
            to IEL1) in steps of IEINC (defaults to 1). If IEL1 = ALL, IEL2 and
            IEINC are ignored and pattern is all selected elements [ESEL].  If
            IEL1 = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI). A component name may
            also be substituted for IEL1 (IEL2 and IEINC are ignored).

        Notes
        -----
        Generates additional elements from a given pattern (similar to EGEN)
        except with a "symmetry" reflection. The operation generates a new
        element by incrementing the nodes on the original element, and
        reversing and shifting  the node connectivity pattern. For example, for
        a 4-node 2-D element, the nodes in positions I, J, K, and L of the
        original element are placed in positions J, I, L, and K of the
        reflected element.

        Similar permutations occur for all other element types. For line
        elements, the nodes in positions I and J of the original element are
        placed in positions J and I of the reflected element. In releases prior
        to ANSYS 5.5, no node pattern reversing and shifting occurred for line
        elements generated by ESYM. To achieve the same results with ANSYS 5.5
        as you did in prior releases, use the EGEN command instead.

        It is recommended that symmetry elements be displayed and graphically
        reviewed.

        If the nodes are also reflected (as with the NSYM command) this pattern
        is such that the orientation of the symmetry element remains similar to
        the original element (i.e., clockwise elements are generated from
        clockwise elements).

        For a non-reflected node pattern, the reversed orientation has the
        effect of reversing the outward normal direction (clockwise elements
        are generated from counterclockwise elements).

        Note:: : Since nodes may be defined anywhere in the model independently
        of this command, any orientation of the "symmetry" elements is
        possible. See also the ENSYM command for modifying existing elements.
        """
        command = "ESYM,%s,%s,%s,%s" % (str(ninc), str(iel1), str(iel2), str(ieinc))
        return self.run(command, **kwargs)

    def undo(self, kywrd="", **kwargs):
        """APDL Command: UNDO

        Allows the user to modify or save commands issued since the last RESUME
        or SAVE command.

        Parameters
        ----------
        kywrd


            NEW - Create an editable GUI window that allows the user to alter the commands issued
                  since the most recent SAVE or RESUME operations (GUI only).

        Notes
        -----
         The UNDO command brings up the session editor, a text window that
        displays all of the program operations since the last SAVE or RESUME
        command. You can modify command parameters, delete whole sections of
        text and even save a portion of the command string to a separate file.
        The file is named jobname000.cmds, with each subsequent save operation
        incrementing the filename by one digit.

        Note:: : The session editor file can be changed only by the session
        editor. If you rename your database file outside of ANSYS and then
        resume that database, the session editor will display the old filename.

        For more information on the session editor, see Using the Session
        Editor in the Operations Guide.
        """
        command = "UNDO,%s" % (str(kywrd))
        return self.run(command, **kwargs)

    def gthk(self, label="", thick="", **kwargs):
        """APDL Command: /GTHK

        Sets line thicknesses for graph lines.

        Parameters
        ----------
        label
            Apply thicknesses as selected from the following labels:

            AXIS - Modify thickness of ordinate and abscissa axes on graph displays.

            GRID - Modify thickness of grid lines on graph displays.

            CURVE - Modify thickness of curve lines (when no area fill [/GROPT]).

        thick
            Thickness ratio (whole numbers only, from -1 to 10):

            -1 - Do not draw the curve, but show only the markers specified by /GMARKER.

            0 or 1 - Thin lines.

            2 - The default thickness.

            3 - 1.5 times the default thickness.

            etc. - (up to 10)

        Notes
        -----
        Sets line thicknesses for graph lines (in raster mode only).  Use
        /GTHK,STAT to show settings.

        This command is valid in any processor.
        """
        command = "/GTHK,%s,%s" % (str(label), str(thick))
        return self.run(command, **kwargs)

    def an3d(self, kywrd="", key="", **kwargs):
        """APDL Command: /AN3D

        Specifies 3-D annotation functions

        Parameters
        ----------
        num
            Unique number assigned as each annotation is applied to a model.
            These numbers are applied sequentially, although when an annotation
            entity is deleted, its number is reassigned.

        type
            Annotation internal type number (101 = text, 102 = line, 103 =
            point, 104 = area, 105 = arrow, 106 = symbol, 108 = bitmap).

        xhot, yhot, zhot
            X, Y, Z coordinates for hot spot location.

        Notes
        -----
        Because 3-D annotation is applied in relation to the XYZ coordinates of
        the anchor, you can transform your model, and the annotation will
        maintain the spatial relationship with the model. This works within
        reason, and there are instances where changing the perspective or the
        size of the model will change the apparent relationship between the
        annotation and the model.

         The overall 3-D dimensions of your model are defined by a bounding
        box.  If portions of your model's bounding box lie outside of the
        visible area of your graphics window (if you are zoomed in on a
        specific area of your model), it can affect the placement of your 3-D
        annotations.  Zooming out will usually overcome this problem.

        3-D annotation is valid for the Cartesian (CSYS,0) coordinate system
        only. If you want to annotate a model you created in another coordinate
        system, use 2-D annotation (note that 2-D annotations do not remain
        anchored for dynamic rotations or transformations).

        When you apply user defined bitmaps, the size of the annotation can
        vary. Use the options menu of the 3-D annotation widget to adjust the
        size and placement of your bitmaps.

        You cannot use the “!” and “$” characters in ANSYS text annotation.

        The GUI generates this command during 3-D annotation operations and
        inserts the command into the log file (Jobname.LOG). You should NOT
        type this command directly during an ANSYS session (although the
        command can be included in an input file for batch input or for use
        with the /INPUT command).
        """
        command = "/AN3D,%s,%s" % (str(kywrd), str(key))
        return self.run(command, **kwargs)

    def sftran(self, **kwargs):
        """APDL Command: SFTRAN

        Transfer the solid model surface loads to the finite element model.

        Notes
        -----
        Surface loads are transferred only from selected lines and areas to all
        selected elements.  The SFTRAN operation is also done if the SBCTRAN
        command is issued or automatically done upon initiation of the solution
        calculations [SOLVE].

        This command is also valid in PREP7.
        """
        command = "SFTRAN," % ()
        return self.run(command, **kwargs)

    def fkdele(self, kpoi="", lab="", **kwargs):
        """APDL Command: FKDELE

        Deletes force loads at a keypoint.

        Parameters
        ----------
        kpoi
            Keypoint at which force is to be deleted.  If ALL, delete forces at
            all selected keypoints [KSEL].  If KPOI = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for KPOI.

        lab
            Valid force label.  If ALL, use all appropriate labels.  See the
            FDELE command for labels.

        Notes
        -----
        Deletes force loads (and all corresponding finite element loads) at a
        keypoint.  See the FDELE command for details.

        This command is also valid in PREP7.
        """
        command = "FKDELE,%s,%s" % (str(kpoi), str(lab))
        return self.run(command, **kwargs)

    def varnam(self, ir="", name="", **kwargs):
        """APDL Command: VARNAM

        Names (or renames) a variable.

        Parameters
        ----------
        ir
            Reference number of the variable (2 to NV [NUMVAR]).

        name
            Thirty-two character name for identifying variable on printouts and
            displays.  Embedded blanks are compressed for output.
        """
        command = "VARNAM,%s,%s" % (str(ir), str(name))
        return self.run(command, **kwargs)

    def cmgrp(self, aname="", cnam1="", cnam2="", cnam3="", cnam4="", cnam5="",
              cnam6="", cnam7="", cnam8="", **kwargs):
        """APDL Command: CMGRP

        Groups components and assemblies into an assembly.

        Parameters
        ----------
        aname
            An alphanumeric name used to identify this assembly.  Aname may be
            up to 32 characters, beginning with a letter and containing only
            letters, numbers, and underscores.  Overwrites a previously defined
            Aname (and removes it from higher level assemblies, if any).

        cnam1, cnam2, cnam3, . . . , cnam8
            Names of existing components or other assemblies to be included in
            this assembly.

        Notes
        -----
        Groups components and other assemblies into an assembly identified by a
        name.  CMGRP is used for the initial definition of an assembly.  An
        assembly is used in the same manner as a component.  Up to 5 levels of
        assemblies within assemblies may be used.

        An assembly is a convenient grouping of previously defined components
        and other assemblies.  Assemblies may contain components only, other
        assemblies, or any combination.  A component may belong to any number
        of assemblies.  Up to 5 levels of nested assemblies may be defined.
        Components and assemblies may be added to or deleted from an existing
        assembly by the CMEDIT command.  Once defined, an assembly may be
        listed, deleted, selected, or unselected using the same commands as for
        a component.  Assemblies are automatically updated to reflect deletions
        of one or more of their components or lower-level assemblies.
        Assemblies are not automatically deleted when all their components or
        subassemblies are deleted.

        This command is valid in any processor.
        """
        command = "CMGRP,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(aname), str(cnam1), str(cnam2), str(cnam3), str(cnam4), str(cnam5), str(cnam6), str(cnam7), str(cnam8))
        return self.run(command, **kwargs)

    def antype(self, antype="", status="", ldstep="", substep="", action="",
               **kwargs):
        """APDL Command: ANTYPE

        Specifies the analysis type and restart status.

        Parameters
        ----------
        antype
            Analysis type (defaults to the previously specified analysis type,
            or to STATIC if none specified):

            STATIC or 0 - Perform a static analysis.  Valid for all degrees of freedom.

            BUCKLE or 1 - Perform a buckling analysis.  Implies that a previous static solution was
                          performed with prestress effects calculated
                          (PSTRES,ON).  Valid for structural degrees of freedom
                          only.

            MODAL or 2 - Perform a modal analysis.  Valid for structural and fluid degrees of freedom.

            HARMIC or 3 - Perform a harmonic analysis.  Valid for structural, fluid, magnetic, and
                          electrical degrees of freedom.

            TRANS or 4 - Perform a transient analysis.  Valid for all degrees of freedom.

            SUBSTR or 7 - Perform a substructure analysis.  Valid for all degrees of freedom.

            SPECTR or 8 - Perform a spectrum analysis.  Implies that a previous modal analysis was
                          performed.  Valid for structural degrees of freedom
                          only.

        status
            Specifies the status of the analysis (new or restart):

            NEW - Specifies a new analysis (default). If NEW, the remaining fields on this
                  command are ignored.

            RESTART - Specifies a restart of a previous analysis. Valid for static, modal, and
                      transient (full or mode-superposition method) analyses.
                      For more information about restarting static and
                      transient analyses, see Multiframe Restart in the Basic
                      Analysis Guide. For more information on restarting a
                      modal analysis, see Modal Analysis Restart in the Basic
                      Analysis Guide.

            Multiframe restart is also valid for harmonic analysis, but is limited to 2-D magnetic analysis only. - A substructure analysis (backsubstitution method only) can be restarted for the
                              purpose of generating additional load vectors.
                              For more information, see the SEOPT command and
                              Applying Loads and Creating the Superelement
                              Matrices in the Substructuring Analysis Guide.

            VTREST - Specifies the restart of a previous VT Accelerator analysis. Valid only with
                     Antype = STATIC, HARMIC, or TRANS. For more information,
                     see VT Accelerator Re-run in the Basic Analysis Guide.

        ldstep
            Specifies the load step at which a multiframe restart begins.

        substep
            Specifies the substep at which a multiframe restart begins.

        action
            Specifies the manner of a multiframe restart.

            CONTINUE - The program continues the analysis based on the specified LDSTEP and SUBSTEP
                       (default). The current load step is continued. If the
                       end of the load step is encountered in the .Rnnn file, a
                       new load step is started. The program deletes all .Rnnn
                       files, or .Mnnn files for mode-superposition transient
                       analyses, beyond the point of restart and updates the
                       .LDHI file if a new load step is encountered.

            ENDSTEP - At restart, force the specified load step (LDSTEP) to end at the specified
                      substep (SUBSTEP), even though the end of the current
                      load step has not been reached. At the end of the
                      specified substep, all loadings are scaled to the level
                      of the current ending and stored in the .LDHI file. A run
                      following this ENDSTEP starts a new load step. This
                      capability allows you to change the load level in the
                      middle of a load step. The program updates the .LDHI file
                      and deletes all .Rnnn files, or .Mnnn files for mode-
                      superposition transient analyses, beyond the point of
                      ENDSTEP. The .Rnnn or .Mnnn file at the point of ENDSTEP
                      are rewritten to record the rescaled load level.

            RSTCREATE - At restart, retrieve information to be written to the results file for the
                        specified load step (LDSTEP) and substep (SUBSTEP). Be
                        sure to use   OUTRES to write the results to the
                        results file. This action does not affect the .LDHI or
                        .Rnnn files. Previous items stored in the results file
                        at and beyond the point of RSTCREATE are deleted. This
                        option cannot be used to restart a mode-superposition
                        transient analysis.

            PERTURB - At restart, a linear perturbation analysis (static, modal, buckling, or full
                      harmonic) is performed for the specified load step
                      (LDSTEP) and substep (SUBSTEP). This action does not
                      affect the .LDHI, .Rnnn, or .RST files.

        Notes
        -----
        If using the ANTYPE command to change the analysis type in the same
        SOLVE session, the program issues the following message: “Some analysis
        options have been reset to their defaults. Please verify current
        settings or respecify as required.” Typically, the program resets
        commands such as NLGEOM and EQSLV to their default values.

        The analysis type (Antype) cannot be changed if a restart is specified.
        Always save parameters before doing a restart. For more information on
        the different types of restart, see Restarting an Analysis in the Basic
        Analysis Guide.

        This command is also valid in PREP7.

        The ANSYS Professional - Nonlinear Structural (PRN) product supports
        the Antype = TRANS option for mode-superposition (TRNOPT,MSUP) analyses
        only.
        """
        command = "ANTYPE,%s,%s,%s,%s,%s" % (str(antype), str(status), str(ldstep), str(substep), str(action))
        return self.run(command, **kwargs)

    def katt(self, mat="", real="", type="", esys="", **kwargs):
        """APDL Command: KATT

        Associates attributes with the selected, unmeshed keypoints.

        Parameters
        ----------
        mat, real, type, esys
            Material number, real constant set number, type number, and
            coordinate system number to be associated with selected, unmeshed
            keypoints.

        Notes
        -----
        Keypoints subsequently generated from the keypoints will also have
        these attributes.  These element attributes will be used when the
        keypoints are meshed.  If a keypoint does not have attributes
        associated with it (by this command) at the time it is meshed, the
        attributes are obtained from the then current MAT, REAL,TYPE, and ESYS
        command settings.  Reissue the KATT command (before keypoints are
        meshed) to change the attributes.  A zero (or blank) argument removes
        the corresponding association.

        If any of the arguments MAT, REAL, TYPE, or ESYS are defined as -1,
        then that value will be left unchanged in the selected set.

        In some cases, ANSYS can proceed with a keypoint meshing operation even
        when no logical element type has been assigned via KATT,,,TYPE or TYPE.
        For more information, see the discussion on setting element attributes
        in Meshing Your Solid Model in the Modeling and Meshing Guide.
        """
        command = "KATT,%s,%s,%s,%s" % (str(mat), str(real), str(type), str(esys))
        return self.run(command, **kwargs)

    def rescontrol(self, action="", ldstep="", frequency="", maxfiles="",
                   **kwargs):
        """APDL Command: RESCONTROL

        Controls file writing for multiframe restarts.

        Parameters
        ----------
        action
             Command action. Valid options are:

            DEFINE - Issuing the command specifies how frequently the .Xnnn restart files are
                     written for a load step (default).

            FILE_SUMMARY - Issuing the command prints the substep and load step information for all .Xnnn
                           files for the current jobname in the current
                           directory. If this option is specified, all other
                           arguments are ignored.

            STATUS - Issuing the command lists the current status in the tables of restart controls
                     specified previously by RESCONTROL. If this option is
                     specified, all other arguments are ignored.

            NORESTART - Issuing the command cleans up some of the restart files after a Distributed
                        ANSYS solution. The host process will not have the
                        following files in the working directory at the end of
                        the run: .ESAV, .OSAV, .Xnnn, .RDB,  .LDHI. The slave
                        processes will not have the following files in the
                        working directory at the end of the run: .ESAV, .OSAV,
                        .Xnnn, .RST (or .RTH, etc.). Some of the restart files
                        are never written, some are removed upon leaving /SOLU
                        (for example, upon FINISH), and some are removed upon
                        exiting the program.

            This option is useful for cleaning up files written by all of the Distributed ANSYS processes, particularly when you know that these restart files will not be needed later on. If this option is specified, all other arguments are ignored. - If this option is used in shared-memory parallel ANSYS, most of the restart
                              files in the working directory are removed. It
                              has the same effect as issuing RESCONTROL,,NONE.

            LINEAR - Issuing the command specifies the same actions as Action = DEFINE. However,
                     this option is intended for linear static applications.
                     For a linear static analysis, the restart capability is
                     normally not needed. However, it is typically needed when
                     a subsequent linear perturbation analysis is desired. By
                     default, none of the restart files are written for a
                     linear static analysis.

            DELETE - Delete the restart control specification corresponding to the Ldstep label on a
                     previous RESCONTROL,DEFINE command.

        ldstep
            Specifies how the .Xnnn files are written for the specified load
            steps. This option also affects how often the load history
            information is written to the .LDHI file.

            ALL - Write the .Xnnn files at the same substep Frequency for all load steps; write
                  the load history information to the .LDHI file for all load
                  steps.

            LAST - Write the .Xnnn files for the last load step only; write load history
                   information to the .LDHI file for the last load step only.
                   This option is the default for nonlinear static and full
                   transient analyses. The remaining arguments are ignored.

            N - Number that indicates how often the .Xnnn file is written.

             Input a positive number to write the .Xnnn files at the substep Frequency indicated only for load step N. Other load steps will be written at the default substep frequency or at a frequency defined by a previous RESCONTROL specification. Load history information is written to the .LDHI file only for load steps N. - Input a negative number (-N) to write the .Xnnn files for every Nth load step
                              at the specified substep Frequency. The load
                              history information is written to the .LDHI file
                              every Nth load step. This option is suitable for
                              restart applications in which more than a few
                              hundred load steps are required. Compared to the
                              ALL and positive N options, it can save disk
                              space since the .LDHI file is smaller and fewer
                              .Xnnn files are written.

            If Ldstep = -N, all other Ldstep options specified by RESCONTROL are ignored and the program follows the -N option (write load history information every Nth load step). If you want to change this pattern, issue RESCONTROL,DELETE, -N and then issue another RESCONTROL command with the desired Ldstep option. - NONE

            No multiframe restart files (.RDB [restart database file], .LDHI [load history file], .Xnnn) are created. This option is the default for mode-superposition analyses. The remaining arguments are ignored.  - For nonlinear static, linear static, and full transient analyses, this option
                              allows a restart to be done at the last or abort
                              point using the same procedure as in ANSYS 5.5 or
                              earlier (using the .EMAT, .ESAV or .OSAV, and .DB
                              files).

        frequency
            Frequency at which the .Xnnn files are written at the substep
            level.

            NONE - Do not write any .Xnnn files for this load step.

            LAST - Write the .Xnnn files for the last substep of the load step only (default for
                   nonlinear static and full transient analyses).

            N - If N is positive, write the .Xnnn file every Nth substep of a load step. If N
                is negative, write N equally spaced .Xnnn files within a load
                step.

            In nonlinear static and full transient analyses, negative N is valid only when AUTOTS,ON. - In mode-superposition analyses, negative N is always valid.

        maxfiles
            Maximum number of .Xnnn files to save for Ldstep.

            -1 - Overwrite existing .Xnnn files (default). The total maximum number of .Xnnn
                 files for one run is 999. If this number is reached before the
                 analysis is complete, the program will reset the .Xnnn file
                 numbering back to 1 and continue to write .Xnnn files; the
                 program keeps the newest 999 restart files and overwrites the
                 oldest restart files.

            0 - Do not overwrite any existing .Xnnn files. The total maximum number of .Xnnn
                files for one run is 999. If this number is reached before the
                analysis is complete, the analysis continues but no longer
                writes any .Xnnn files.
        """
        command = "RESCONTROL,%s,%s,%s,%s" % (str(action), str(ldstep), str(frequency), str(maxfiles))
        return self.run(command, **kwargs)

    def febody(self, **kwargs):
        """APDL Command: FEBODY

        Specifies "Body loads on elements" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "FEBODY," % ()
        return self.run(command, **kwargs)

    def tee(self, label="", fname="", ext="", **kwargs):
        """APDL Command: /TEE

        Writes a list of commands to a specified file at the same time that the
        commands are being executed.

        Parameters
        ----------
        label
            Indicates how ANSYS is to interpret this /TEE command:

            Signals the beginning of the command text that is to be written to Fname. If Fname already exists, specifying NEW causes the contents of Fname to be overwritten. - Indicates that you want to append to Fname the command text that follows.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        You can use the /TEE command to record a macro to a specified file at
        the same time that the macro is being executed. It is similar to the
        Linux tee command.

        For more information about the /TEE command, see the Introducing APDL
        of the ANSYS Parametric Design Language Guide.

        The following example illustrates the use of the /TEE command. If you
        issue these commands:

        the content of myfile.mac is:

        This command is valid in any processor, but only during an interactive
        run.
        """
        command = "/TEE,%s,%s,%s" % (str(label), str(fname), str(ext))
        return self.run(command, **kwargs)

    def hrout(self, reimky="", clust="", mcont="", **kwargs):
        """APDL Command: HROUT

        Specifies the harmonic analysis output options.

        Parameters
        ----------
        reimky
            Real/Imaginary print key:

            ON - Print complex displacements as real and imaginary components (default).

            OFF - Print complex displacements as amplitude and phase angle (degrees).

        clust
            Cluster option (for HROPT,MSUP):

            OFF - Uniform spacing of frequency solutions (default).

            ON - Cluster frequency solutions about natural frequencies.

        mcont
            Mode contributions key (for HROPT,MSUP):

            OFF - No print of mode contributions at each frequency (default).

            ON - Print mode contributions at each frequency.

        Notes
        -----
        Specifies the harmonic analysis (ANTYPE,HARMIC) output options.  If
        used in SOLUTION, this command is valid only within the first load
        step. OUTPR,NSOL must be specified to print mode contributions at each
        frequency.

        This command is ignored if the HROPT command has been issued with
        Method = VT, VTPA, or VTRU. Displacements are not available at expanded
        frequencies with these solution methods.

        For cyclic symmetry mode-superposition harmonic solutions, the cluster
        option is not available.

        This command is also valid in PREP7.
        """
        command = "HROUT,%s,%s,%s" % (str(reimky), str(clust), str(mcont))
        return self.run(command, **kwargs)

    def show(self, fname="", option="", vect="", ncpl="", **kwargs):
        """APDL Command: /SHOW

        Specifies the device and other parameters for graphics displays.

        Parameters
        ----------
        fname
            Device name, file name, or keyword, as listed below:

            <device name> - Any valid graphics display device name (e.g., X11, 3-D etc.).  Defaults to X11
                            for most systems.  See Getting Started with
                            Graphics in the Basic Analysis Guide for details.
                            A device name must be defined before activating the
                            Graphical User Interface (GUI).  Once the GUI is
                            activated, the device name cannot be changed for
                            that session, except for switching between X11 and
                            X11C.

            <filename> - Name of graphics file to which graphics displays are to be diverted (248
                         characters maximum).  Should not be the same as a
                         valid device name or any other Fname option. Plots are
                         written to the file Filename.Ext (or just Filename.Ext
                         if Ext is left blank) in the working directory. This
                         file can be appended only during the same session;
                         reissuing the same file name in a new session will
                         overwrite existing file names from previous sessions.
                         Although multiple file names can be used within one
                         session, only the last file created or accessed will
                         be appended.  Issuing /SHOW, CLOSE, or starting a new
                         session will prevent access to any previously created
                         files.

            TERM - Graphics displays are switched back to the last-specified device name.

            CLOSE - This option purges the graphics file buffer. The CLOSE option should be issued
                    any time you are changing graphics devices or file output
                    types during a session. Graphics displays are switched back
                    to the last-specified device name, and any open graphics
                    files are closed. The CLOSE option is similar to the TERM
                    option, however, with the CLOSE option, another process,
                    such as the DISPLAY program, can access the data in the
                    graphics file. The CLOSE option causes graphics file
                    buffers to be flushed to the graphics file.

            FILE - Graphics displays are switched back to the last-specified file name.

            OFF - Graphics display requests are ignored.

            (blank) - If blank in interactive mode, graphics will be displayed on screen as requested
                      by display commands (no file written);  If blank in batch
                      mode, graphics data will be written to Jobname.GRPH.

            PSCR - Creates PostScript graphic files that are named Jobnamennn.eps, where nnn is a
                   numeric value that is incremented by one as each additional
                   file is created; that is, Jobname000.eps, Jobname001.eps,
                   Jobname002.eps, and so on .  (See the PSCR command for
                   options.)  Ignores the Ext and NCPL fields.

            HPGL - Creates Hewlett-Packard Graphics Language files that are named Jobnamennn.hpgl,
                   where nnn is a numeric value that is incremented by one as
                   each additional file is created; that is, Jobname000.hpgl,
                   Jobname001.hpgl, Jobname002.hpgl, and so on.  (See the HPGL
                   command for options.)  Ignores the Ext and NCPL fields.

            HPGL2 - Creates Hewlett-Packard Graphics Language files that are named Jobnamennn.hpgl,
                    where nn is a numeric value that is incremented by one as
                    each additional file is created; that is, Jobname000.hpgl,
                    Jobname001.hpgl, Jobname02.hpgl, and so on.  The HPGL2
                    files have enhanced color.  (See the HPGL command for
                    options.)  Ignores the Ext field.

            JPEG - Creates JPEG files that are named Jobnamennn.jpg, where nnn is a numeric value
                   that is incremented by one as each additional file is
                   created; that is, Jobname000.jpg, Jobname001.jpg,
                   Jobname002.jpg, and so on. Ignores the Ext field.

            TIFF - Creates tagged image format files that are named Jobnamennn.tif, where nnn is a
                   numeric value that is incremented by one as each additional
                   file is created; that is, Jobname000.tif, Jobname001.tif,
                   Jobname002.tif, and so on. This value for the Fname argument
                   ignores the Ext field. (See the TIFF command for options.)

            PNG - Creates PNG (Portable Network Graphics) files that are named Jobnamennn.png,
                  where nnn is a numeric value that is incremented by one as
                  each additional file is created; that is, Jobname000.png,
                  Jobname001.png, Jobname002.png, and so on. This value for the
                  Fname argument ignores the Ext field. (See the PNGR command
                  for options.)

            VRML - Creates Virtual Reality Meta Language files named Jobname000.wrl that can be
                   displayed on 3-D Internet web browsers.  Ignores the Ext and
                   NCPL fields.

        option
            Assign a file name extension or specify reverse video output:

            Ext -  File name extension (eight-character maximum).

            REV - Reverse background/image (black/white) colors. Valid with Fname = PNG
                  (recommended), JPEG, PSCR, TIFF, and HPGL. This option is
                  ignored if a previously specified color map table  (/CMAP or
                  /RGB) is in effect.

        vect
            Specifies raster or vector display mode.  This affects area,
            volume, and element displays, as well as geometric results displays
            such as contour plots.  See the /DEVICE command for an alternate
            way to toggle between raster and vector mode.  Changing VECT also
            resets the /TYPE command to its default.

            0 - Raster display (color filled entities; default)

            1 - Vector display (outlined entities; i.e., "wireframe")

        ncpl
            Sets the number of color planes (4 to 8).  Default is device-
            dependent.  NCPL is not supported by all graphics devices.

        Notes
        -----
        Specifies the device to be used for graphics displays, and specifies
        other graphics display parameters.  Display may be shown at the time of
        generation (for interactive runs at a graphics display terminal) or
        diverted to a file for later processing with the DISPLAY program.
        Issue /PSTATUS for display status.

        Batch runs do not have access to the fonts available on your system.
        The Courier and Helvetica font files used for JPEG, PNG and TIFF batch
        output are copyrighted by Adobe Systems Inc. and Digital Equipment
        Corp. Permission to use these trademarks is hereby granted only in
        association with the images described above. Batch run JPEG output is
        produced at the default  quality index value of 75, unless specified
        otherwise.

        Interactive displays default to eight color planes (NCPL = 8) for most
        monitors, while graph file output defaults to eight color planes for
        VRML output, and four color planes for PSCR, HPGL, HPGL2, JPEG, PNG,
        TIFF and FILE33.

        This command is valid in any processor.
        """
        command = "/SHOW,%s,%s,%s,%s" % (str(fname), str(option), str(vect), str(ncpl))
        return self.run(command, **kwargs)

    def ldiv(self, nl1="", ratio="", pdiv="", ndiv="", keep="", **kwargs):
        """APDL Command: LDIV

        Divides a single line into two or more lines.

        Parameters
        ----------
        nl1
            Number of the line to be divided.  If negative, assume P1 (see
            below) is the second keypoint of the line instead of the first for
            RATIO.  If ALL, divide all selected lines [LSEL].  If NL1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NL1.

        ratio
            Ratio of line length P1-PDIV to line length P1-P2.  Must be between
            0.0 and 1.0. Input ignored if NDIV > 2.

        pdiv
            Number to be assigned to keypoint generated at division location
            (defaults to lowest available keypoint number [NUMSTR]).  Input
            ignored if NL1 = ALL or NDIV > 2.  If PDIV already exists and lies
            on line NL1, divide line at PDIV (RATIO must also be 0.0).  If PDIV
            already exists and does not lie on line NL1, PDIV is projected and
            moved to the nearest point on line NL1 (if possible). PDIV cannot
            be attached to another line, area, or volume.

        ndiv
            The number of new lines to be generated from old line (defaults to
            2).

        keep
            Specifies whether to keep the input entities:

            0 - Modify old line to use new keypoints and slopes.

            1 - Do not modify old line.  New lines will overlay old line and have unique
                keypoints.

        Notes
        -----
        Divides a single line NL1 (defined from keypoint P1 to keypoint P2)
        into two or more lines.  Line NL1 becomes the new line beginning with
        keypoint P1 and new lines are generated ending at keypoint P2.  If the
        line is attached to an area, the area will also be updated.  Line
        divisions are set to zero (use LESIZE, etc. to modify).
        """
        command = "LDIV,%s,%s,%s,%s,%s" % (str(nl1), str(ratio), str(pdiv), str(ndiv), str(keep))
        return self.run(command, **kwargs)

    def bfldele(self, line="", lab="", **kwargs):
        """APDL Command: BFLDELE

        Deletes body force loads on a line.

        Parameters
        ----------
        line
            Line at which body load is to be deleted.  If ALL, delete for all
            selected lines [LSEL].  A component name may also be substituted
            for LINE.

        lab
            Valid body load label. If ALL, use all appropriate labels. Load
            labels are listed under "Body Loads" in the input table for each
            element type in the Element Reference. See the BFL command for
            labels.

        Notes
        -----
        Deletes body force loads (and all corresponding finite element loads)
        for a specified line and label.  Body loads may be defined on a line
        with the BFL command.

        Graphical picking is available only via the listed menu paths.

        This command is also valid in PREP7.
        """
        command = "BFLDELE,%s,%s" % (str(line), str(lab))
        return self.run(command, **kwargs)

    def cesgen(self, itime="", inc="", nset1="", nset2="", ninc="", **kwargs):
        """APDL Command: CESGEN

        Generates a set of constraint equations from existing sets.

        Parameters
        ----------
        itime, inc
            Do this generation operation a total of ITIMEs, incrementing all
            nodes in the existing sets by INC each time after the first.  ITIME
            must be >1 for generation to occur.

        nset1, nset2, ninc
            Generate sets from sets beginning with NSET1 to NSET2 (defaults to
            NSET1) in steps of NINC (defaults to 1).  If NSET1 is negative,
            NSET2 and NINC are ignored and the last |NSET1| sets (in sequence
            from maximum set number) are used as the sets to be repeated.

        Notes
        -----
        Generates additional sets of constraint equations (with same labels)
        from existing sets.  Node numbers between sets may be uniformly
        incremented.
        """
        command = "CESGEN,%s,%s,%s,%s,%s" % (str(itime), str(inc), str(nset1), str(nset2), str(ninc))
        return self.run(command, **kwargs)

    def fft(self, type="", inputdata="", outputdata="", dim1="", dim2="",
            resultformat="", **kwargs):
        """APDL Command: *FFT

        Computes the fast Fourier transformation of a specified matrix or
        vector.

        Parameters
        ----------
        type
            Type of FFT transformation:

            Forward FFT computation (default). - Backward FFT computation.

        inputdata
            Name of matrix or vector for which the FFT will be computed. This
            can be a dense matrix (created by the *DMAT command) or a vector
            (created by the *VEC command). Data can be real or complex values.
            There is no default value for this argument.

        outputdata
            Name of matrix or vector where the FFT results will be stored. The
            type of this argument must be consistent with InputData (see table
            below). There is no default value for this argument.

        dim1
            The number of terms to consider for a vector, or the number of rows
            for a matrix. Defaults to the whole input vector or all the rows of
            the matrix.

        dim2
            The number of columns to consider for a matrix. Defaults to all the
            columns of the matrix. (Valid only for matrices.)

        resultformat
            Specifies the result format:

            Returns the full result. That is, the result matches the dimension specified on this command (DIM1, DIM2). - Returns partial results. For real input data, there is a symmetry in the
                              results of the Fourier transform as some
                              coefficients are conjugated. The partial format
                              uses this symmetry to optimize the storage of the
                              results. (Valid only for real data.)

        Notes
        -----
        In the example that follows, the fast Fourier transformation is used to
        filter frequencies from a noisy input signal.
        """
        command = "*FFT,%s,%s,%s,%s,%s,%s" % (str(type), str(inputdata), str(outputdata), str(dim1), str(dim2), str(resultformat))
        return self.run(command, **kwargs)

    def view(self, wn="", xv="", yv="", zv="", **kwargs):
        """APDL Command: /VIEW

        Defines the viewing direction for the display.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        xv, yv, zv
            The object is viewed along the line from point XV,YV,ZV (in the
            global coordinate system) to the global coordinate system origin.
            For section displays, the cutting plane is assumed to be
            perpendicular to this line.  If XV = WP, modify view to be normal
            to the currently defined working plane.  Defaults to (0,0,1).

        Notes
        -----
        The view line is always normal to the screen.  The view is selected by
        defining a point (in the global Cartesian coordinate system)
        representing a point along the viewing line.  This point, and the
        global Cartesian coordinate system origin, define the line along which
        the object is viewed while looking toward the origin.  Any point along
        the view line may be used, i.e., (1,1,1) and (2,2,2) give the same
        view.  The display orientation may be changed as desired [/ANGLE].  The
        display coordinate system type may be changed (from Cartesian to
        cylindrical, spherical, toroidal, etc.) with the DSYS command.

        This command is valid in any processor.
        """
        command = "/VIEW,%s,%s,%s,%s" % (str(wn), str(xv), str(yv), str(zv))
        return self.run(command, **kwargs)

    def map2dto3d(self, action="", ldstep="", sbstep="", option="", **kwargs):
        """APDL Command: MAP2DTO3D

        Initiates a 2-D to 3-D analysis and maps variables.

        Parameters
        ----------
        action
            The 2-D to 3-D action to perform:

            START - Start the analysis process by rebuilding the 2-D analysis database (.db) based
                    on the specified load step and substep information, and
                    update nodes to their deformed positions in the 2-D mesh.

            FINISH - Maps solution variables from the 2-D mesh to the extruded 3-D mesh.

        ldstep
            The load step number at which 2-D to 3-D analysis should occur. The
            default value is the highest load step number found in the
            Jobname.Rnnn files (for the current jobname and in the current
            directory).

        sbstep
            The substep number of the specified load step (LDSTEP) at which the
            2-D to 3-D analysis should occur. The default value is the highest
            substep number found in the specified load step in the Jobname.Rnnn
            files (for the current jobname and in the current directory).

        option
            Mapping option:

            (Blank) - Transfer and map all applied boundary conditions, nodal temperatures, loads,
                      and surface pressures from the 2-D mesh to the extruded
                      3-D mesh. This behavior is the default.

            NOBC - No applied boundary conditions or loads are transferred from the 2-D mesh to
                   the extruded 3-D mesh. Nodal temperatures (defined via the
                   BF,TEMP command) are transferred.

        Notes
        -----
        The MAP2DTO3D command initiates the 2-D to 3-D analysis process, sets
        analysis options, rebuilds the database, and maps the solution
        variables from the 2-D mesh to the 3-D mesh.

        Before issuing this command, clear the database (/CLEAR).

        The LDSTEP and SBSTEP values apply only when Action = START.

        For more information, see 2-D to 3-D Analysis in the Advanced Analysis
        Guide.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MAP2DTO3D,%s,%s,%s,%s" % (str(action), str(ldstep), str(sbstep), str(option))
        return self.run(command, **kwargs)

    def kbetw(self, kp1="", kp2="", kpnew="", type="", value="", **kwargs):
        """APDL Command: KBETW

        Creates a keypoint between two existing keypoints.

        Parameters
        ----------
        kp1
            First keypoint.  If KP1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).

        kp2
            Second keypoint.

        kpnew
            Number assigned to the new keypoint.  Defaults to the lowest
            available keypoint number.

        type
            Type of input for VALUE.

            RATIO - Value is the ratio of the distances between keypoints as follows:
                    (KP1-KPNEW)/(KP1-KP2).

            DIST - Value is the absolute distance between KP1 and KPNEW (valid only if current
                   coordinate system is Cartesian).

        value
            Location of new keypoint, as defined by Type (defaults to 0.5).  If
            VALUE is a ratio (Type = RATIO) and is less than 0 or greater than
            1, the keypoint is created on the extended line.  Similarly, if
            VALUE is a distance (Type = DIST) and is less than 0 or greater
            than the distance between KP1 and KP2, the keypoint is created on
            the extended line.

        Notes
        -----
        Placement of the new keypoint depends on the currently active
        coordinate system [CSYS].  If the coordinate system is Cartesian, the
        keypoint will lie on a straight line between KP1 and KP2.  If the
        system is not Cartesian (e.g., cylindrical, spherical, etc.), the
        keypoint will be located as if on a line (which may not be straight)
        created in the current coordinate system between KP1 and KP2.  Note
        that solid modeling in a toroidal coordinate system is not recommended.
        """
        command = "KBETW,%s,%s,%s,%s,%s" % (str(kp1), str(kp2), str(kpnew), str(type), str(value))
        return self.run(command, **kwargs)

    def usrdof(self, action="", dof1="", dof2="", dof3="", dof4="", dof5="",
               dof6="", dof7="", dof8="", dof9="", dof10="", **kwargs):
        """APDL Command: USRDOF

        Specifies the degrees of freedom for the user-defined element USER300.

        Parameters
        ----------
        action
            One of the following command operations:

            DEFINE - Specify the degrees of freedom (DOFs). This value is the default.

            LIST - List all previously specified DOFs.

            DELETE -  Delete all previously specified DOFs.

        dof1, dof2, dof3, . . . , dof10
            The list of DOFs.

        Notes
        -----
        The USRDOF command specifies the degrees of freedom for the user-
        defined element USER300.

        Although you can intersperse other commands as necessary for your
        analysis, issue the USRDOF command as part of the following general
        sequence of commands:

        Issue the ET command for element USER300, followed by the related TYPE
        command.

        Issue both the USRELEM and USRDOF commands (in either order).

        Define your element using USER300.

        The DOF list (DOF1 through DOF10) can consist of up to 10 DOFs. Use any
        valid and appropriate DOF (such as UX, UY, UZ, ROTX, ROTY, ROTZ, AX,
        AY, AZ, VX, VY, VZ, PRES, WARP, TEMP, VOLT, MAG, EMF, and CURR).

        You can specify a maximum of 10 DOFs per USRDOF command. To define
        additional DOFs, issue the command again.

        The maximum number of DOFs for a user-defined element--the number of
        nodes times the number of DOFs per node--cannot exceed 480.

        To learn more about user-defined elements, see Creating a New Element
        in the Programmer's Reference.
        """
        command = "USRDOF,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(action), str(dof1), str(dof2), str(dof3), str(dof4), str(dof5), str(dof6), str(dof7), str(dof8), str(dof9), str(dof10))
        return self.run(command, **kwargs)

    def ldread(self, lab="", lstep="", sbstep="", time="", kimg="", fname="",
               ext="", **kwargs):
        """APDL Command: LDREAD

        Reads results from the results file and applies them as loads.

        Parameters
        ----------
        lab
            Valid load label:

            TEMP - Temperatures from a thermal analysis are applied as body force nodal loads (BF)
                   in a structural analysis, an explicit dynamic analysis, or
                   other type of analysis.

            If the thermal analysis uses SHELL131 or SHELL132, temperatures are applied as body force element loads (BFE). In most cases, only the top and bottom temperatures from SHELL131 and SHELL132 are used by the structural shell elements; any interior temperatures are ignored.  - All temperatures are used for SHELL181 using section input, and SHELL281 using
                              section input; for these elements, therefore, the
                              number of temperature points at a node generated
                              in the thermal model must match the number of
                              temperature points at a node needed by the
                              structural model.

            When using SHELL131 or SHELL132 information for the LDREAD operation, all element types should specify the same set of thermal degrees of freedom. - When used in conjunction with KIMG=1 and KIMG=2, temperatures can be applied to
                              a subsequent thermal analysis as nodal loads (D)
                              or initial conditions (IC), respectively.

            FORC - Forces from an electromagnetic analysis are applied as force loads (F) in a
                   structural analysis. LDREAD,FORC reads coupling forces. See
                   the discussion on force computation in the Low-Frequency
                   Electromagnetic Analysis Guide.

              For a full harmonic magnetic analysis, FORC represents the time-averaged force (use in conjunction with KIMG = 2).  Values are in the nodal coordinate system for the force loads (F). - HGEN

            Heat generations from an electromagnetic analysis are applied as body force loads (BFE) in a thermal analysis.  For a full harmonic analysis, HGEN represents the time-averaged heat generation load (use in conjunction with KIMG = 2). - JS

            Source current density from a current-conduction analysis are applied as body force loads (BFE).  Values are in the global Cartesian coordinate system. - EF

            Electric field element centroid values from an electrostatic analysis are applied as body force loads (BFE) in a magnetic analysis. Values are in the global Cartesian coordinate system. - REAC

            Reaction loads from any analysis are applied as force loads (F) in any analysis.  Values are in the nodal coordinate system. - CONC

        lstep
            Load step number of the data set to be read.  Defaults to 1.  If
            LAST, ignore SBSTEP and TIME and read the last data set.

        sbstep
            Substep number (within LSTEP).  If zero (or blank), LSTEP
            represents the last substep of the load step.

        time
            Time-point identifying the data set to be read.  Used only if both
            LSTEP and SBSTEP are zero (or blank).  If TIME is between two
            solution time points on the results file, a linear interpolation is
            done between the two data sets.  If TIME is beyond the last time
            point on the file, use the last time point.

        kimg
            When used with results from harmonic analyses (ANTYPE,HARMIC) KIMG
            establishes which set of data to read:

            0 - Read the real part of the solution.  Valid also for Lab = EHFLU to read in
                time-average heat flux.

            1 - Read the imaginary part of the solution.

            2 - Calculate and read the time-average part. Meaningful for Lab = HGEN or FORC.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        The LDREAD command reads results data from the results file and applies
        them as loads.

        The command can also apply results from an analysis defined with one
        physics environment as loads on a second analysis using a different
        physics environment. Results values are applied as loads for field-
        coupling effects (for example, output temperatures from a thermal
        analysis as input to a structural analysis).

        The command works based on the assumption that the meshes have not
        changed.

        Nodal loads are applied only to selected nodes. Element loads are
        applied only to selected elements. Element surface loads are applied
        only to selected elements where all face nodes for that surface are
        selected.

        To assure proper distribution of the surface loads, select only the
        nodes on the element face where the surface load is to be applied.

        Scaling and accumulation specifications are applied as the loads are
        read via the following commands:

        BFCUM for body force loads. (Heat-generation loads are not
        accumulated.)
        """
        command = "LDREAD,%s,%s,%s,%s,%s,%s,%s" % (str(lab), str(lstep), str(sbstep), str(time), str(kimg), str(fname), str(ext))
        return self.run(command, **kwargs)

    def timint(self, key="", lab="", **kwargs):
        """APDL Command: TIMINT

        Turns on transient effects.

        Parameters
        ----------
        key
            Transient effects key:

            OFF - No transient effects (static or steady-state).

            ON - Include transient (mass or inertia) effects.

        lab
            Degree of freedom label:

            ALL - Apply this key to all appropriate labels (default).

            STRUC - Apply this key to structural DOFs.

            THERM - Apply this key to thermal DOFs.

            ELECT - Apply this key to electric DOFs.

            MAG - Apply this key to magnetic DOFs.

            FLUID - Apply this key to fluid DOFs.

            DIFFU - Apply this key to concentration of DOFs.

        Notes
        -----
        Indicates whether this load step in a full transient analysis should
        use time integration, that is, whether it includes transient effects
        (e.g. structural inertia, thermal capacitance) or whether it is a
        static (steady-state) load step for the indicated DOFs.  Transient
        initial conditions are introduced at the load step having Key = ON.
        Initial conditions are then determined from the previous two substeps.
        Zero initial velocity and acceleration are assumed if no previous
        substeps exist.  See the Structural Analysis Guide, the Thermal
        Analysis Guide, and the Low-Frequency Electromagnetic Analysis Guide
        for details.

        This command is also valid in PREP7.
        """
        command = "TIMINT,%s,%s" % (str(key), str(lab))
        return self.run(command, **kwargs)

    def poly(self, **kwargs):
        """APDL Command: POLY

        Creates a polygonal area based on working plane coordinate pairs.

        Notes
        -----
        Defines a polygonal area on the working plane.  The area will be
        defined with NPT keypoints and NPT lines, where NPT (must be at least
        3) is the number of coordinate pairs defined with the PTXY command.
        See the RPOLY and RPR4 commands for other ways to create polygons.
        """
        command = "POLY," % ()
        return self.run(command, **kwargs)

    def vddam(self, vf="", va="", vb="", vc="", **kwargs):
        """APDL Command: VDDAM

        Specifies the velocity spectrum computation constants for the analysis
        of shock resistance of shipboard structures.

        Parameters
        ----------
        vf
            Direction-dependent velocity coefficient for elastic or elastic-
            plastic analysis option (Default = 0).

        va, vb, vc
            Coefficients for the DDAM velocity spectrum equations.  See Dynamic
            Design Analysis Method in the Mechanical APDL Theory Reference.
            Default for these coefficients is zero.

        Notes
        -----
        This command specifies velocity coefficients to analyze shock
        resistance of shipboard equipment.  These coefficients are used to
        compute mode coefficients according to the equations given in Dynamic
        Design Analysis Method in the Mechanical APDL Theory Reference.  The
        form of these equations is based on the Naval NRL Dynamic Design
        Analysis Method.  This command, along with the ADDAM and SED commands,
        is used with the spectrum (ANTYPE,SPECTR) analysis as a special purpose
        alternative to the SV, FREQ, and SVTYP commands.  The mass and length
        units of the model must be in pounds and inches, respectively.

        DDASPEC may alternatively be used to calculate spectrum coefficients.

        This command is also valid in PREP7.
        """
        command = "VDDAM,%s,%s,%s,%s" % (str(vf), str(va), str(vb), str(vc))
        return self.run(command, **kwargs)

    def plorb(self, **kwargs):
        """APDL Command: PLORB

        Displays the orbital motion of a rotating structure

        Notes
        -----
        When a structure is rotating and the Coriolis or gyroscopic effect is
        taken into account (CORIOLIS), nodes lying on the rotation axis
        generally exhibit an elliptical orbital motion. The PLORB command
        displays the orbit of each rotating node as well as the deformed shape
        at time t = 0 (the real part of the solution).

        To print the characteristics of the orbital path traversed by each
        node, issue the PRORB command.

        The PLORB command is valid for line elements (such as BEAM188, BEAM189,
        PIPE288, and PIPE289).

        Your model must also involve a rotational velocity (OMEGA or CMOMEGA)
        with Coriolis enabled in a stationary reference frame
        (CORIOLIS,,,,RefFrame = ON).

        A SET command should be issued after PLORB to ensure proper output for
        subsequent postprocessing commands.

        The coordinate system for displaying nodal results must be global
        Cartesian (RSYS,KCN = 0).
        """
        command = "PLORB," % ()
        return self.run(command, **kwargs)

    def abbres(self, lab="", fname="", ext="", **kwargs):
        """APDL Command: ABBRES

        Reads abbreviations from a coded file.

        Parameters
        ----------
        lab
            Label that specifies the read operation:

            Replace current abbreviation set with these abbreviations (default). - Extend current abbreviation set with these abbreviations, replacing any of the
                              same name that already exist.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        The abbreviation file may have been written with the ABBSAV command. Do
        not issue ABBRES,NEW while inside an executing abbreviation. Doing so
        will cause all data for the executing abbreviation to be deleted.

        This command is valid in any processor.
        """
        command = "ABBRES,%s,%s,%s" % (str(lab), str(fname), str(ext))
        return self.run(command, **kwargs)

    def arefine(self, na1="", na2="", ninc="", level="", depth="", post="",
                retain="", **kwargs):
        """APDL Command: AREFINE

        Refines the mesh around specified areas.

        Parameters
        ----------
        na1, na2, ninc
            Areas (NA1 to NA2 in increments of NINC) around which the mesh is
            to be refined.  NA2 defaults to NA1, and NINC defaults to 1.  If
            NA1 = ALL, NA2 and NINC are ignored and all selected areas are used
            for refinement.  If NA1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  A
            component name may also be substituted for NA1 (NA2 and NINC are
            ignored).

        level
            Amount of refinement to be done.  Specify the value of LEVEL as an
            integer from 1 to 5, where a value of 1 provides minimal
            refinement, and a value of 5 provides maximum refinement (defaults
            to 1).

        depth
            Depth of mesh refinement in terms of the number of elements outward
            from the indicated areas (defaults to 1).

        post
            Type of postprocessing to be done after element splitting, in order
            to improve element quality:

            OFF - No postprocessing will be done.

            SMOOTH - Smoothing will be done.  Node locations may change.

            CLEAN - Smoothing and cleanup will be done.  Existing elements may be deleted, and node
                    locations may change (default).

        retain
            Flag indicating whether quadrilateral elements must be retained in
            the refinement of an all-quadrilateral mesh.  (The ANSYS program
            ignores the RETAIN argument when you are refining anything other
            than a quadrilateral mesh.)

            ON - The final mesh will be composed entirely of quadrilateral elements, regardless
                 of the element quality (default).

            OFF - The final mesh may include some triangular elements in order to maintain
                  element quality and provide transitioning.

        Notes
        -----
        AREFINE performs local mesh refinement around the specified areas.  By
        default, the indicated elements are split to create new elements with
        1/2 the edge length of the original elements (LEVEL = 1).

        AREFINE refines all area elements and tetrahedral volume elements that
        are adjacent to the specified areas.  Any volume elements that are
        adjacent to the specified areas, but are not tetrahedra (for example,
        hexahedra, wedges, and pyramids), are not refined.

        You cannot use mesh refinement on a solid model that contains initial
        conditions at nodes [IC], coupled nodes [CP family of commands],
        constraint equations [CE family of commands], or boundary conditions or
        loads applied directly to any of its nodes or elements.  This applies
        to nodes and elements anywhere in the model, not just in the region
        where you want to request mesh refinement.  See Revising Your Model in
        the Modeling and Meshing Guide for additional restrictions on mesh
        refinement.

        This command is also valid for rezoning.
        """
        command = "AREFINE,%s,%s,%s,%s,%s,%s,%s" % (str(na1), str(na2), str(ninc), str(level), str(depth), str(post), str(retain))
        return self.run(command, **kwargs)

    def edcpu(self, cputime="", **kwargs):
        """APDL Command: EDCPU

        Specifies CPU time limit for an explicit dynamics analysis.

        Parameters
        ----------
        cputime
            CPU time limit (in seconds) for the current phase of the analysis
            (defaults to 0). If CPUTIME = 0, no CPU time limit is set. CPUTIME
            values below 0 are not allowed.

        Notes
        -----
        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDCPU,%s" % (str(cputime))
        return self.run(command, **kwargs)

    def pfact(self, tblno="", excit="", parcor="", **kwargs):
        """APDL Command: PFACT

        Calculates participation factors for the PSD or multi-point response
        spectrum table.

        Parameters
        ----------
        tblno
            Input PSD (Power Spectral Density) table number for which
            participation factors are to be calculated.

        excit
            Label defining the location of excitation:

            BASE - Base excitation (default).

            NODE - Nodal excitation.

        parcor
            Label defining excitation type (applies only to SPOPT,PSD
            analysis).  Used only when partially correlated excitation is due
            to wave propagation or spatial correlation.  Defaults to partially
            correlated excitation as defined by COVAL and QDVAL commands.

            WAVE - Excitation defined by PSDWAV command.

            SPAT - Excitation defined by PSDSPL command.

        Notes
        -----
        Calculates the participation factors for a particular PSD or multi-
        point response spectrum table defined with the PSDVAL or SPVAL command.
        The Jobname.DB file must contain modal solution data in order for this
        command to calculate the participation factor.  There must be a PFACT
        command for each excitation spectrum. You are limited to 300
        excitations.

        This command is also valid in PREP7.
        """
        command = "PFACT,%s,%s,%s" % (str(tblno), str(excit), str(parcor))
        return self.run(command, **kwargs)

    def kcenter(self, type="", val1="", val2="", val3="", val4="", kpnew="",
                **kwargs):
        """APDL Command: KCENTER

        Creates a keypoint at the center of a circular arc defined by three
        locations.

        Parameters
        ----------
        type
            Type of entity used to define the circular arc.  The meaning of
            VAL1 through VAL4 will vary depending on Type.  If Type = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).

            KP - Arc is defined by keypoints.

            LINE - Arc is defined by locations on a line.

        val1, val2, val3, val4
            Values used to specify three locations on the arc (see table
            below).

        kpnew
            Number assigned to new keypoint.  Defaults to the lowest available
            keypoint number.

        Notes
        -----
        KCENTER should be used in the Cartesian coordinate system (CSYS,0)
        only.  This command provides three methods to define a keypoint at the
        center of three locations.  As shown below, the center point can be
        calculated based on a) three keypoints, b) three keypoints and a
        radius, or c) three locations on a line.  Note that for method c, if a
        circular line is specified by VAL1, VAL2 through VAL4 are not needed.
        """
        command = "KCENTER,%s,%s,%s,%s,%s,%s" % (str(type), str(val1), str(val2), str(val3), str(val4), str(kpnew))
        return self.run(command, **kwargs)

    def fcdele(self, mat="", **kwargs):
        """APDL Command: FCDELE

        Deletes previously defined failure criterion data for the given
        material.

        Parameters
        ----------
        mat
            Material number. Deletes all FC command input for this material.

        Notes
        -----
        This command is also valid in POST1.
        """
        command = "FCDELE,%s" % (str(mat))
        return self.run(command, **kwargs)

    def lcsel(self, type="", lcmin="", lcmax="", lcinc="", **kwargs):
        """APDL Command: LCSEL

        Selects a subset of load cases.

        Parameters
        ----------
        type
            Label identifying the type of select:

            S - Select a new set.

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

            ALL - Restore the full set.

            NONE - Unselect the full set.

            INVE - Invert the current set (selected becomes unselected and vice versa).

            STAT - Display the current select status.

        lcmin
            Minimum value of load case pointer range.

        lcmax
            Maximum value of load case pointer range.  LCMAX defaults to LCMIN.

        lcinc
            Value increment within range.  Defaults to 1.  LCINC cannot be
            negative.

        Notes
        -----
        Selects a subset of load cases for other operations.  For example, to
        select a new set of load cases based on load cases 1 through 7, use
        LCSEL,S,1,7.  The subset is used when the ALL label is entered (or
        implied) on other commands, such as LCFACT, LCABS, LCOPER, etc.  Load
        cases are flagged as selected and unselected; no load case pointers
        [LCDEF, LCWRITE, LCFILE] are actually deleted from the database.
        """
        command = "LCSEL,%s,%s,%s,%s" % (str(type), str(lcmin), str(lcmax), str(lcinc))
        return self.run(command, **kwargs)

    def shell(self, loc="", **kwargs):
        """APDL Command: SHELL

        Selects a shell element or shell layer location for results output.

        Parameters
        ----------
        loc
            Location within shell element (or layer) to obtain stress results:

            TOP - Top of shell element (or layer) (default).

            MID - Middle of shell element (or layer). The default method averages the TOP and BOT
                  values to obtain a mid value. Setting KEYOPT(8) = 2 for
                  SHELL181, SHELL208, SHELL209, and ELBOW290 uses MID results
                  obtained directly from the results file.

            BOT - Bottom of shell element (or layer).

        Notes
        -----
        Selects the location within a shell element (or a shell layer) for
        results output (nodal stresses, strains, etc.).  Applies to POST1
        selects, sorts, and output [NSEL, NSORT, PRNSOL, PLNSOL, PRPATH,
        PLPATH, etc.], and is used for storage with the POST26 ESOL command.
        For example, SHELL,TOP causes item S of the POST1 PRNSOL command or the
        POST26 ESOL command to be the stresses at the top of the shell
        elements.  For layered shell elements, use the LAYER (POST1) or
        LAYERP26 (POST26) command to select the layer. The SHELL command does
        not apply to the layered thermal shell elements, SHELL131 and SHELL132.

        For PowerGraphics [/GRAPHICS,POWER], the SHELL,MID command affects both
        the printed output and the displayed results, while the SHELL (TOP or
        BOT) command prints and displays both the top and bottom layers
        simultaneously. Note that /CYCEXPAND,ON automatically turns on
        PowerGraphics; however, for cyclic mode-superposition harmonic
        postprocessing (CYCFILES), the SHELL command prints and displays only
        the requested layer.

        In POST26, the ESOL data stored is based on the active SHELL
        specification at the time the data is stored. To store data at various
        specifications (for example, stresses at the top and bottom locations),
        issue a STORE command before each new specification.
        """
        command = "SHELL,%s" % (str(loc))
        return self.run(command, **kwargs)

    def mprint(self, key="", **kwargs):
        """APDL Command: MPRINT

        Specifies that radiation matrices are to be printed.

        Parameters
        ----------
        key
            Print key:

            0 - Do not print matrices.

            1 - Print matrices.

        Notes
        -----
        Specifies that the element and node radiation matrices are to be
        printed when the WRITE command is issued.  If KEY = 1, form factor
        information for each element will also be printed.
        """
        command = "MPRINT,%s" % (str(key))
        return self.run(command, **kwargs)

    def slashstatus(self, lab="", **kwargs):
        """APDL Command: /STATUS

        Lists the status of items for the run.

        Parameters
        ----------
        lab
            Items to list status for:

            ALL - List all below (default).

            TITLE - List only titles, Jobname, and revision number.

            UNITS - List only units.

            MEM - List only memory data statistics.

            DB - List only database statistics

            CONFIG - List only configuration parameters.

            GLOBAL - Provides a global status summary.

            SOLU - Provides a solution status summary.

            PROD - Provides a product summary.

        Notes
        -----
        Displays various items active for the run (such as the ANSYS revision
        number, Jobname, titles, units, configuration parameters, database
        statistics, etc.).

        This command is valid in any processor.
        """
        command = "/STATUS,%s" % (str(lab))
        return self.run(command, **kwargs)

    def nlopt(self, **kwargs):
        """APDL Command: NLOPT

        Specifies "Nonlinear analysis options" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "NLOPT," % ()
        return self.run(command, **kwargs)

    def init(self, name="", method="", val1="", val2="", val3="", **kwargs):
        """APDL Command: *INIT

        Initializes a vector or dense matrix.

        Parameters
        ----------
        name
            Vector or matrix which will be initialized. This can be a vector
            (created by the *VEC command) or a dense matrix (created by the
            *DMAT command).

        method
            Initialization method to use:

            Fill the vector/matrix with zeros (default). - Fill the vector/matrix with a constant value.

            Fill the vector/matrix with random values. - Fill the nth diagonal of the matrix with a constant value. Other values are not
                              overwritten.

        val1, val2, val3
            Additional input. The meaning of Val1 through Val3 will vary
            depending on the specified Method. See details below.

        Notes
        -----
        This command initializes a previously defined vector (*VEC) or dense
        matrix (*DMAT).
        """
        command = "*INIT,%s,%s,%s,%s,%s" % (str(name), str(method), str(val1), str(val2), str(val3))
        return self.run(command, **kwargs)

    def adrag(self, nl1="", nl2="", nl3="", nl4="", nl5="", nl6="", nlp1="",
              nlp2="", nlp3="", nlp4="", nlp5="", nlp6="", **kwargs):
        """APDL Command: ADRAG

        Generates areas by dragging a line pattern along a path.

        Parameters
        ----------
        nl1, nl2, nl3, . . . , nl6
            List of lines in the pattern to be dragged (6 maximum if using
            keyboard entry).  Lines should form a continuous pattern (no more
            than two lines connected to any one keypoint.  If NL1 = P,
            graphical picking is enabled and all remaining arguments are
            ignored (valid only in the GUI).  If NL1 = ALL, all selected lines
            (except those that define the drag path) will be swept along the
            path.  A component name may also be substituted for NL1.

        nlp1, nlp2, nlp3, . . . , nlp6
            List of lines defining the path along which the pattern is to be
            dragged (6 maximum if using keyboard entry).  Must be a continuous
            set of lines.

        Notes
        -----
        Generates areas (and their corresponding keypoints and lines) by
        sweeping a given line pattern along a characteristic drag path.  If the
        drag path consists of multiple lines, the drag direction is determined
        by the sequence in which the path lines are input (NLP1, NLP2, etc.).
        If the drag path is a single line (NLP1), the drag direction is  from
        the keypoint on the drag line that is closest to the first keypoint of
        the given line pattern to the other end of the drag line.

        The magnitude of the vector between the keypoints of the given pattern
        and the first path keypoint remains constant for all generated keypoint
        patterns and the path keypoints.  The direction of the vector relative
        to the path slope also remains constant so that patterns may be swept
        around curves.

        Keypoint, line, and area numbers are automatically assigned (beginning
        with the lowest available values [NUMSTR]).  Adjacent lines use a
        common keypoint.  Adjacent areas use a common line.  For best results,
        the entities to be dragged should be orthogonal to the start of the
        drag path.  Drag operations that produce an error message may create
        some of the desired entities prior to terminating.
        """
        command = "ADRAG,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nl1), str(nl2), str(nl3), str(nl4), str(nl5), str(nl6), str(nlp1), str(nlp2), str(nlp3), str(nlp4), str(nlp5), str(nlp6))
        return self.run(command, **kwargs)

    def edsolv(self, **kwargs):
        """APDL Command: EDSOLV

        Specifies "explicit dynamics solution" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command. Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDSOLV," % ()
        return self.run(command, **kwargs)

    def rmnevec(self, **kwargs):
        """APDL Command: RMNEVEC

        Extracts neutral plane eigenvectors from a modal analysis for the ROM
        method.

        Notes
        -----
        This command extracts the eigenvectors at a neutral plane of a model
        from a modal analysis.  The modal analysis must have expanded modes
        [MXPAND] in order to process the data. Only the first 9 modes are
        considered.  The command requires a node component named "NEUN" to be
        defined. These nodes represent the nodes at the neutral plane of a
        structure (in the case of a stress-stiffened structure), or at any
        plane in the structure (non stress-stiffened case).

        This command is only valid in POST1.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.

        jobname.evx, jobname.evy, jobname.evz, jobname.evn, jobname.evl
        """
        command = "RMNEVEC," % ()
        return self.run(command, **kwargs)

    def geometry(self, **kwargs):
        """APDL Command: GEOMETRY

        Specifies "Geometry" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "GEOMETRY," % ()
        return self.run(command, **kwargs)

    def subset(self, lstep="", sbstep="", fact="", kimg="", time="", angle="",
               nset="", **kwargs):
        """APDL Command: SUBSET

        Reads results for the selected portions of the model.

        Parameters
        ----------
        lstep
            Load step number of the data set to be read (defaults to 1):

            N - Read load step N.

            FIRST - Read the first data set (SBSTEP and TIME are ignored).

            LAST - Read the last data set (SBSTEP and TIME are ignored).

            NEXT - Read the next data set (SBSTEP and TIME are ignored).  If at the last data set,
                   the first data set will be read as the next.

            NEAR - Read the data set nearest to TIME (SBSTEP is ignored).  If TIME is blank, read
                   the first data set.

            LIST - Scan the results file and list a summary of each load step.  (FACT, KIMG, TIME
                   and ANGLE are ignored.)

        sbstep
            Substep number (within Lstep).   For the buckling (ANTYPE,BUCKLE)
            analysis or the modal (ANTYPE,MODAL) analysis, the substep
            corresponds to the mode number.  Defaults to last substep of load
            step (except for ANTYPE,BUCKLE or MODAL).  If Lstep = LIST, SBSTEP
            = 0 or 1 lists the basic step information, whereas SBSTEP = 2 also
            lists the load step title, and labels imaginary data sets if they
            exist.

        fact
            Scale factor applied to data read from the file.  If zero (or
            blank), a value of 1.0 is used.  Harmonic velocities or
            accelerations may be calculated from the displacement results from
            a modal (ANTYPE,MODAL) or harmonic (ANTYPE,HARMIC) analyses.  If
            FACT = VELO, the harmonic velocities (v) are calculated from the
            displacements (d) at a particular frequency (f) according to the
            relationship v = 2 πfd.  Similarly, if FACT = ACEL, the harmonic
            accelerations (a) are calculated as a = (2 πf)2d.

        kimg
            Used only with results from complex analyses:

            0 - Store real part of complex solution

            1 - Store imaginary part.

        time
            Time-point identifying the data set to be read.  For harmonic
            analyses, time corresponds to the frequency.  For the buckling
            analysis, time corresponds to the load factor.  Used only in the
            following cases:  If Lstep is NEAR, read the data set nearest to
            TIME.   If both Lstep and SBSTEP are zero (or blank), read data set
            at time = TIME.  If TIME is between two solution time points on the
            results file, a linear interpolation is done between the two data
            sets.  Solution items not written to the results file [OUTRES] for
            either data set will result in a null item after data set
            interpolation.  If TIME is beyond the last time point on the file,
            use the last time point.

        angle
            Circumferential location (0.0 to 360°).  Defines the
            circumferential location for the harmonic calculations used when
            reading from the results file.  The harmonic factor (based on the
            circumferential angle) is applied to the harmonic elements
            (PLANE25, PLANE75, PLANE78, PLANE83, and SHELL61) of the load case.
            See the Mechanical APDL Theory Reference for details.  Note that
            factored values of applied constraints and loads will overwrite any
            values existing in the database.

        nset
            Data set number of the data set to be read.  If a positive value
            for NSET is entered, Lstep, SBSTEP, KIMG, and TIME are ignored.
            Available set numbers can be determined by *SET,LIST.

        Notes
        -----
        Reads a data set from the results file into the database for the
        selected portions of the model only.  Data that has not been specified
        for retrieval from the results file by the INRES command will be listed
        as having a zero value.  Each time that the SUBSET command is issued,
        the data currently in the database will be overwritten with a new set
        of data.  Various operations may also be performed during the read
        operation.  The database must have the model geometry available (or
        used the RESUME command before the SUBSET command to restore the
        geometry from File.DB).
        """
        command = "SUBSET,%s,%s,%s,%s,%s,%s,%s" % (str(lstep), str(sbstep), str(fact), str(kimg), str(time), str(angle), str(nset))
        return self.run(command, **kwargs)

    def starvput(self, parr="", entity="", entnum="", item1="", it1num="",
                 item2="", it2num="", kloop="", **kwargs):
        """APDL Command: *VPUT

         Restores array parameter values into the ANSYS database.

        Parameters
        ----------
        parr
            The name of the input vector array parameter.  See *SET for name
            restrictions.  The parameter must exist as a dimensioned array
            [*DIM] with data input.

        entity
            Entity keyword.  Valid keywords are shown for Entity = in the table
            below.

        entnum
            The number of the entity (as shown for ENTNUM= in the table below).

        item1
            The name of a particular item for the given entity.  Valid items
            are as shown in the Item1 columns of the table below.

        it1num
            The number (or label) for the specified Item1 (if any).  Valid
            IT1NUM values are as shown in the IT1NUM columns of the table
            below.  Some Item1 labels do not require an IT1NUM value.

        item2, it2num
            A second set of item labels and numbers to further qualify the item
            for which data is to be stored.  Most items do not require this
            level of information.

        kloop
            Field to be looped on:

            Loop on the ENTNUM field (default). - Loop on the Item1 field.

            Loop on the IT1NUM field.  Successive items are as shown with IT1NUM. - Loop on the Item2 field.

        Notes
        -----
        The *VPUT command is not supported for PowerGraphics displays.
        Inconsistent results may be obtained if this command is not used in
        /GRAPHICS, FULL.

        Plot and print operations entered via the GUI (Utility Menu> Pltcrtls,
        Utility Menu> Plot) incorporate the AVPRIN command. This means that the
        principal and equivalent values are recalculated. If you use *VPUT to
        put data back into the database, issue the plot commands from the
        command line to preserve your data.

        This operation is basically the inverse of the *VGET operation.  Vector
        items are put directly (without any coordinate system transformation)
        into the ANSYS database.  Items can only replace existing items of the
        database and not create new items.  Degree of freedom results that are
        replaced in the database are available for all subsequent
        postprocessing operations.  Other results are changed temporarily and
        are available mainly for the immediately following print and display
        operations.  The vector specification *VCUM does not apply to this
        command.  The valid labels for the location fields (Entity, ENTNUM,
        Item1, and IT1NUM) are listed below.  Item2 and IT2NUM are not
        currently used.  Not all items from the *VGET list are allowed on *VPUT
        since putting values into some locations could cause the database to be
        inconsistent.

        This command is valid in any processor.

        Table: 250:: : *VPUT - POST1 Items

        X, Y, or Z fluid velocity. X, Y, or Z nodal velocity in a transient
        structural analysis (LS-DYNA analysis or analysis with ANTYPE,TRANS).

        X, Y, or Z magnetic vector potential. X, Y, or Z nodal acceleration in
        a transient structural analysis (LS-DYNA analysis or analysis with
        ANTYPE,TRANS).
        """
        command = "*VPUT,%s,%s,%s,%s,%s,%s,%s,%s" % (str(parr), str(entity), str(entnum), str(item1), str(it1num), str(item2), str(it2num), str(kloop))
        return self.run(command, **kwargs)

    def tlabel(self, xloc="", yloc="", text="", **kwargs):
        """APDL Command: /TLABEL

        Creates annotation text (GUI).

        Parameters
        ----------
        xloc
            Text X starting location (-1.0 < X < 1.6).

        yloc
            Text Y starting location (-1.0 < Y < 1.0).

        text
            Text string (60 characters maximum).  Parameter substitution may be
            forced within the text by enclosing the parameter name or
            parametric expression within percent (%) signs.

        Notes
        -----
        Defines annotation text to be written directly onto the display at a
        specified location.  This is a command generated by the Graphical User
        Interface (GUI) and will appear in the log file (Jobname.LOG) if
        annotation is used.  This command is not intended to be typed in
        directly in an ANSYS session (although it can be included in an input
        file for batch input or for use with the /INPUT command).

        All text is shown on subsequent displays unless the annotation is
        turned off or deleted.  Use the /TSPEC command to set the attributes of
        the text.

        This command is valid in any processor.
        """
        command = "/TLABEL,%s,%s,%s" % (str(xloc), str(yloc), str(text))
        return self.run(command, **kwargs)

    def vdgl(self, nv1="", nv2="", ninc="", **kwargs):
        """APDL Command: VDGL

        Lists keypoints of a volume that lie on a parametric degeneracy.

        Parameters
        ----------
        nv1, nv2, ninc
            List keypoints that lie on a parametric degeneracy on volumes from
            NV1 to NV2 (defaults to NV1) in steps of NINC (defaults to 1).  If
            NV1 = ALL (default), NV2 and NINC will be ignored and keypoints on
            all selected volumes [VSEL] will be listed.  If NV1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).  You may also substitute a component name
            for NV1 (ignore NV2 and NINC).

        Notes
        -----
        See the Modeling and Meshing Guide for details about parametric
        degeneracies.

        This command is valid in any processor.
        """
        command = "VDGL,%s,%s,%s" % (str(nv1), str(nv2), str(ninc))
        return self.run(command, **kwargs)

    def dspoption(self, reord_option="", memory_option="", memory_size="",
                  solve_info="", **kwargs):
        """APDL Command: DSPOPTION

         Sets memory option for the distributed sparse solver.

        Parameters
        ----------
        reord_option
            Reordering option:

            DEFAULT - Use the default reordering scheme.

            SEQORDER - Use a sequential equation reordering scheme within the distributed sparse
                       solver. Relative to PARORDER, this option typically
                       results in longer equation ordering times and therefore
                       longer overall solver times. Occasionally, however, this
                       option will produce better quality orderings which
                       decrease the matrix factorization times and improve
                       overall solver performance.

            PARORDER - Use a parallel equation reordering scheme within the distributed sparse solver.
                       Relative to SEQORDER, this option typically results in
                       shorter equation ordering times and therefore shorter
                       overall solver times. Occasionally, however, this option
                       will produce lower quality orderings which increase the
                       matrix factorization times and degrade overall solver
                       performance.

        memory_option
            Memory allocation option:

            DEFAULT - Use the default memory allocation strategy for the distributed sparse solver.
                      The default strategy attempts to run in the INCORE memory
                      mode. If there is not enough physical memory available
                      when the solver starts to run in the INCORE memory mode,
                      the solver will then attempt to run in the OUTOFCORE
                      memory mode.

            INCORE -  Use a memory allocation strategy in the distributed sparse solver that will
                     attempt to obtain enough memory to run with the entire
                     factorized matrix in memory. This option uses the most
                     amount of memory and should avoid doing any I/O. By
                     avoiding I/O, this option achieves optimal solver
                     performance. However, a significant amount of memory is
                     required to run in this mode, and it is only recommended
                     on machines with a large amount of memory. If the
                     allocation for in-core memory fails, the solver will
                     automatically revert to out-of-core memory mode.

            OUTOFCORE - Use a memory allocation strategy in the distributed sparse solver that will
                        attempt to allocate only enough work space to factor
                        each individual frontal matrix in memory, but will
                        share the entire factorized matrix on disk. Typically,
                        this memory mode results in poor performance due to the
                        potential bottleneck caused by the I/O to the various
                        files written by the solver.

            FORCE - This option, when used in conjunction with the Memory_Size option, allows you
                    to force the distributed sparse solver to run with a
                    specific amount of memory. This option is only recommended
                    for the advanced user who understands distributed sparse
                    solver memory requirements for the problem being solved,
                    understands the physical memory on the system, and wants to
                    control the distributed sparse solver memory usage.

        memory_size
            Initial memory size allocation for the sparse solver in MB. The
            Memory_Size setting should always be well within the physical
            memory available, but not so small as to cause the distributed
            sparse solver to run out of memory. Warnings and/or errors from the
            distributed sparse solver will appear if this value is set too low.
            If the FORCE memory option is used, this value is the amount of
            memory allocated for the entire duration of the distributed sparse
            solver solution.

        --, --
            Unused fields

        solve_info
            Solver output option:

            OFF - Turns off additional output printing from the distributed sparse solver
                  (default).

            PERFORMANCE - Turns on additional output printing from the distributed sparse solver,
                          including a performance summary and a summary of file
                          I/O for the distributed sparse solver. Information on
                          memory usage during assembly of the global matrix
                          (that is, creation of the Jobname.FULL file) is also
                          printed with this option.

        Notes
        -----
        This command controls options related to the distributed sparse solver
        in all analysis types where the distributed sparse solver can be used.

        The amount of memory required for the distributed sparse solver is
        unknown until the matrix structure is preprocessed, including equation
        reordering. The amount of memory allocated for the distributed sparse
        solver is then dynamically adjusted to supply the solver what it needs
        to compute the solution.

        If you have a large memory system, you may want to try selecting the
        INCORE memory mode for larger jobs to improve performance. Also, when
        running the distributed sparse solver with many processors on the same
        machine or on a machine with very slow I/O performance (e.g., slow hard
        drive speed), you may want to try using the INCORE memory mode to
        achieve better performance. However, doing so may require much more
        memory compared to running in the OUTOFCORE memory mode.

        Running with the INCORE memory mode is best for jobs which comfortably
        fit within the limits of the physical memory on a given system. If the
        distributed sparse solver workspace exceeds physical memory size, the
        system will be forced to use virtual memory (or the system page/swap
        file). In this case, it is typically more efficient to run with the
        OUTOFCORE memory mode.
        """
        command = "DSPOPTION,%s,%s,%s,%s" % (str(reord_option), str(memory_option), str(memory_size), str(solve_info))
        return self.run(command, **kwargs)

    def aglue(self, na1="", na2="", na3="", na4="", na5="", na6="", na7="",
              na8="", na9="", **kwargs):
        """APDL Command: AGLUE

        Generates new areas by "gluing" areas.

        Parameters
        ----------
        na1, na2, na3, . . . , na9
            Numbers of the areas to be glued.  If NA1 = ALL, all selected areas
            will be glued (NA2 to NA9 will be ignored).  If NA1 = P, graphical
            picking is enabled and all remaining arguments are ignored (valid
            only in the GUI).  A component name may also be substituted for
            NA1.

        Notes
        -----
        Use of the AGLUE command generates new areas by "gluing" input areas.
        The glue operation redefines the input areas so that they share lines
        along their common boundaries.  The new areas encompass the same
        geometry as the original areas.  This operation is only valid if the
        intersection of the input areas are lines along the boundaries of those
        areas.  See the Modeling and Meshing Guide for an illustration.  See
        the BOPTN command for an explanation of the options available to
        Boolean operations.  Element attributes and solid model boundary
        conditions assigned to the original entities will not be transferred to
        new entities generated.

        The AGLUE command results in the merging of lines and keypoints at the
        common area boundaries. The lines and keypoints of the lower numbered
        area will be kept. This means one must be aware of area numbering when
        multiple AGLUE commands are applied to avoid any “ungluing” of
        geometry.
        """
        command = "AGLUE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(na1), str(na2), str(na3), str(na4), str(na5), str(na6), str(na7), str(na8), str(na9))
        return self.run(command, **kwargs)

    def k(self, npt="", x="", y="", z="", **kwargs):
        """APDL Command: K

        Defines a keypoint.

        Parameters
        ----------
        npt
            Reference number for keypoint.  If zero, the lowest
            available number is assigned [NUMSTR].

        x, y, z
            Keypoint location in the active coordinate system (may be
            R, θ, Z or R, θ, Φ).  If X = P, graphical picking is
            enabled and all other fields (including NPT) are ignored
            (valid only in the GUI).

        Returns
        -------
        result : int
            Returns the Keypoint number of the created Keypoint or
            None, if something went wrong.

        Notes
        -----
        Defines a keypoint in the active coordinate system [CSYS] for
        line, area, and volume descriptions.  A previously defined
        keypoint of the same number will be redefined.  Keypoints may
        be redefined only if it is not yet attached to a line or is
        not yet meshed.  Solid modeling in a toroidal system is not
        recommended.
        """
        command = "K,%s,%s,%s,%s" % (str(npt), str(x), str(y), str(z))
        return self.run(command, **kwargs)

    def batch(self, lab="", **kwargs):
        """APDL Command: /BATCH

        Sets the program mode to "batch."

        Parameters
        ----------
        lab
            Specifies listing mode during a batch run:

            LIST - The batch output will include a listing of the input file.

            (blank) - Suppress input data listing.

        Notes
        -----
        Sets the program mode to "batch" when included as the first line on an
        input file of ANSYS commands.  For convenience, this command is
        automatically recorded on the log file (Jobname.LOG) at the beginning
        of an interactive ANSYS session so that the log file can be reused
        later for batch input.

        Caution:: : This command  should not be entered directly in an
        interactive ANSYS session since all subsequent keyboard input is simply
        copied to a file, without further processing or prompts from the
        program (use the "system break" to exit the ANSYS program if this
        occurs).

        The recommended method for choosing batch mode, rather than using the
        /BATCH command, is to select the Batch simulation environment from the
        ANSYS Product Launcher  task in the ANSYS launcher, or the batch mode
        entry option on the ANSYS execution command when entering the program.

        This command is valid only at the Begin Level.
        """
        command = "/BATCH,%s" % (str(lab))
        return self.run(command, **kwargs)

    def voffst(self, narea="", dist="", kinc="", **kwargs):
        """APDL Command: VOFFST

        Generates a volume, offset from a given area.

        Parameters
        ----------
        narea
            Area from which generated volume is to be offset.  If NAREA = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).

        dist
            Distance normal to given area at which keypoints for generated
            volume are to be located.  Positive normal is determined from the
            right-hand rule keypoint order.

        kinc
            Increment to be applied to the keypoint numbers between sets.  If
            zero, keypoint numbers will be automatically assigned beginning
            with the lowest available value [NUMSTR].

        Notes
        -----
        Generates a volume (and its corresponding keypoints, lines, and areas)
        by offsetting from an area.  The direction of the offset varies with
        the given area normal.  End slopes of the generated lines remain the
        same as those of the given pattern.

        If element attributes have been associated with the input area via the
        AATT command, the opposite area generated by the VOFFST operation will
        also have those attributes (i.e., the element attributes from the input
        area are copied to the opposite area).  Note that only the area
        opposite the input area will have the same attributes as the input
        area; the areas adjacent to the input area will not.

        If the areas are meshed or belong to meshed volumes, a 3-D mesh can be
        extruded with this command.  Note that the NDIV argument on the ESIZE
        command should be set before extruding the meshed areas.
        """
        command = "VOFFST,%s,%s,%s" % (str(narea), str(dist), str(kinc))
        return self.run(command, **kwargs)

    def fmagbc(self, cnam1="", cnam2="", cnam3="", cnam4="", cnam5="",
               cnam6="", cnam7="", cnam8="", cnam9="", **kwargs):
        """APDL Command: FMAGBC

        Applies force and torque boundary conditions to an element component.

        Parameters
        ----------
        cnam1, cnam2, cnam3, . . . , cnam9
            Names of existing element components (CM command).  Must be
            enclosed in single quotes (e.g., `Cnam1') when the command is
            manually typed in.

        Notes
        -----
        FMAGBC invokes a predefined ANSYS macro to apply Maxwell and virtual
        work force and torque boundary conditions to an element component.
        These boundary conditions are used for subsequent force and torque
        calculations during solution.  Magnetic virtual displacements (MVDI =
        1) are applied to nodes of elements in the components, and  Maxwell
        surface flags (MXWF) are applied to air elements adjoining the element
        components.  Incorrect force and torque calculations will occur for
        components sharing adjacent air elements.   Companion macros FMAGSUM
        and TORQSUM can be used in POST1 to summarize the force and torque
        calculations, respectively.  Torque calculations are valid for 2-D
        planar analysis only.  For 2-D harmonic analysis, force and torque
        represent time-average values.

         If using elements PLANE121, SOLID122, SOLID123, PLANE233, SOLID236 and
        SOLID237 (static analyses only), use EMFT to summarize electromagnetic
        force and torque. If you do use FMAGSUM, you do not need to first set
        either the Maxwell or the virtual work force flags via FMAGBC.
        """
        command = "FMAGBC,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(cnam1), str(cnam2), str(cnam3), str(cnam4), str(cnam5), str(cnam6), str(cnam7), str(cnam8), str(cnam9))
        return self.run(command, **kwargs)

    def wpoffs(self, xoff="", yoff="", zoff="", **kwargs):
        """APDL Command: WPOFFS

        Offsets the working plane.

        Parameters
        ----------
        xoff, yoff, zoff
            Offset increments defined in the working plane coordinate system.
            If only ZOFF is used, the working plane will be redefined parallel
            to the present plane and offset by ZOFF.

        Notes
        -----
        Changes the origin of the working plane by translating the working
        plane along its coordinate system axes.

        This command is valid in any processor.
        """
        command = "WPOFFS,%s,%s,%s" % (str(xoff), str(yoff), str(zoff))
        return self.run(command, **kwargs)

    def al(self, l1="", l2="", l3="", l4="", l5="", l6="", l7="", l8="", l9="",
           l10="", **kwargs):
        """APDL Command: AL

        Generates an area bounded by previously defined lines.

        Parameters
        ----------
        l1, l2, l3, . . . , l10
            List of lines defining area.  The minimum number of lines is 3.
            The positive normal of the area is controlled by the direction of
            L1 using the right-hand rule.  A negative value of L1 reverses the
            normal direction.  If L1 = ALL, use all selected lines with L2
            defining the normal (L3 to L10 are ignored and L2 defaults to the
            lowest numbered selected line).  If L1 = P, graphical picking is
            enabled and all remaining arguments are ignored (valid only in the
            GUI).  A component name may also be substituted for L1.

        Returns
        -------
        result : int
            Returns the area number of the created area or None,
            if something went wrong.

        Notes
        -----
        Lines may be input (once each) in any order and must form a simply
        connected closed curve.  If the area is defined with more than four
        lines, the lines must also lie in the same plane or on a constant
        coordinate value in the active coordinate system (such as a plane or a
        cylinder).

        Note:: : Solid modeling in a toroidal coordinate system is not
        recommended.  Areas may be redefined only if not yet attached to a
        volume.

        This command is valid in any processor.
        """
        command = "AL,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(l1), str(l2), str(l3), str(l4), str(l5), str(l6), str(l7), str(l8), str(l9), str(l10))
        return self.run(command, **kwargs)

    def torqc2d(self, rad="", numn="", lcsys="", **kwargs):
        """APDL Command: TORQC2D

        Calculates torque on a body in a magnetic field based on a circular
        path.

        Parameters
        ----------
        rad
            Radius of the circular path.  The nodes for the path are created at
            this radius.

        numn
            Number of nodes to be created for the circular path.  The greater
            the number of nodes, the higher the accuracy of the torque
            evaluation.  Defaults to 18.

        lcsys
            (Optional) Local coordinate system number to be used for defining
            the circular arc of nodes and the path.  Defaults to 99.  (If a
            local system numbered 99 already exists, it will be overwritten by
            this default.)

        Notes
        -----
        TORQC2D invokes an ANSYS macro which calculates the mechanical torque
        on a body using a circular path.  It is used for a circular or
        cylindrical body such as a rotor in an electric machine.  The body must
        be centered about the global origin and must be surrounded by air
        elements.  The air elements surrounding the path at radius RAD must be
        selected, and elements with a high-permeability material should be
        unselected prior to using the macro.  The macro is valid for 2-D planar
        analyses only.  For a harmonic analysis, the macro calculates the time-
        average torque.  Radial symmetry models are allowed, i.e., the model
        need not be a full 360° model.

        The calculated torque is stored in the parameter TORQUE.  If the model
        is not a full 360° model, TORQUE should be multiplied by the
        appropriate factor (such as 4.0 for a 90° sector) to obtain the total
        torque.  A node plot showing the path is produced in interactive mode.

        The torque is calculated via a circular path integral of the Maxwell
        stress tensor.  The circular path and the nodes for the path are
        created by the macro at the specified radius RAD.  Path operations are
        used for the calculation, and all path items are cleared upon
        completion.  See the TORQ2D command for torque calculation based on an
        arbitrary, non-circular path.
        """
        command = "TORQC2D,%s,%s,%s" % (str(rad), str(numn), str(lcsys))
        return self.run(command, **kwargs)

    def ancut(self, nfram="", delay="", ncycl="", qoff="", ktop="", topoff="",
              node1="", node2="", node3="", **kwargs):
        """APDL Command: ANCUT

        Produces an animated sequence of Q-slices.

        Parameters
        ----------
        nfram
            Number of frames captures (defaults to 5).

        delay
            Time delay during animation (defaults to 0.1 seconds).

        ncycl
            Number of animation cycles (defaults to 5).  Available in non-UI
            mode only.

        qoff
            Q-slice working plane increment (defaults to .1 half screens).

        ktop
            Topological effect on or off (YES or NO; default is NO).

        topoff
            Topological offset (default is .1 half screens).

        node1
            Node 1 for start of the Q-slice.

        node2
            Node 2 for direction of the Q-slice.

        node3
            Node 3 for plane of the Q-slice.

        Notes
        -----
        ANCUT involves an ANSYS macro which produces an animation of Q-slices
        of the last plot action command.  This command operates only on graphic
        display platforms supporting the /SEG command.  After executing ANCUT,
        you can replay the animated sequence by issuing the ANIM command.

        The command functions only in the postprocessor.
        """
        command = "ANCUT,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nfram), str(delay), str(ncycl), str(qoff), str(ktop), str(topoff), str(node1), str(node2), str(node3))
        return self.run(command, **kwargs)

    def edfplot(self, key="", **kwargs):
        """APDL Command: EDFPLOT

        Allows plotting of explicit dynamics forces and other load symbols.

        Parameters
        ----------
        key
            Load symbol plotting key.

            ON or 1 - Turn display of load symbols on (default).

            OFF or 0 - Turn display of load symbols off.

        Notes
        -----
        You must issue EDFPLOT,ON to display explicit dynamics load symbols.
        The explicit load symbols are erased automatically upon a subsequent
        plot command.

        An explicit load symbol always indicates a positive load direction
        (e.g., positive X direction for FX load), even if the load value is
        negative. The load symbol does not reflect the load magnitude. You can
        use standard ANSYS symbol controls to control the appearance of the
        load symbol. No load symbol is displayed for temperature loads.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDFPLOT,%s" % (str(key))
        return self.run(command, **kwargs)

    def gapf(self, nvar="", num="", name="", **kwargs):
        """APDL Command: GAPF

        Defines the gap force data to be stored in a variable.

        Parameters
        ----------
        nvar
            Arbitrary reference number assigned to this variable (2 to NV
            [NUMVAR]).  Overwrites any existing results for this variable.

        num
            Number identifying gap number for which the gap force is to be
            stored.  Issue the GPLIST command to display gap numbers.

        name
            Thirty-two character name for identifying the item on the printout
            and displays (defaults to the name GAPF).

        Notes
        -----
        Defines the gap force data to be stored in a variable. Applicable only
        to the expansion pass of the mode-superposition linear transient
        dynamic (ANTYPE,TRANS) analysis. The data is usually on Fname.RDSP.
        """
        command = "GAPF,%s,%s,%s" % (str(nvar), str(num), str(name))
        return self.run(command, **kwargs)

    def mfwrite(self, fname="", ext="", **kwargs):
        """APDL Command: MFWRITE

        Writes an ANSYS master input file for MFX multiple code coupling.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        Notes
        -----
        When working interactively, you need to issue this command as the last
        step in your setup process. This command will write out the input file
        that you will then use to submit the MFX analysis. This file will
        include the /SOLU, SOLVE, and FINISH commands.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.
        """
        command = "MFWRITE,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def mgen(self, itime="", inc="", node1="", node2="", ninc="", **kwargs):
        """APDL Command: MGEN

        Generates additional MDOF from a previously defined set.

        Parameters
        ----------
        itime, inc
            Do this generation operation a total of ITIMEs, incrementing all
            nodes in the set by INC each time after the first.  ITIME must be >
            1 for generation to occur.  All previously defined master degree of
            freedom directions are included in the set.  A component name may
            also be substituted for ITIME.

        node1, node2, ninc
            Generate master degrees of freedom from set beginning with NODE1 to
            NODE2 (defaults to NODE1) in steps of NINC (defaults to 1).  If
            NODE1 = ALL, NODE2 and NINC are ignored and set is all selected
            nodes [NSEL].  If NODE1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).

        Notes
        -----
        Generates additional master degrees of freedom from a previously
        defined set.  If used in SOLUTION, this command is valid only within
        the first load step.

        This command is also valid in PREP7.
        """
        command = "MGEN,%s,%s,%s,%s,%s" % (str(itime), str(inc), str(node1), str(node2), str(ninc))
        return self.run(command, **kwargs)

    def lreverse(self, lnum="", noeflip="", **kwargs):
        """APDL Command: LREVERSE

        Reverses the normal of a line, regardless of its connectivity or mesh
        status.

        Parameters
        ----------
        lnum
            Line number of the line whose normal direction is to be reversed.
            If LNUM = ALL, the normals of all selected lines will be reversed.
            If LNUM = P, graphical picking is enabled.  A component name may
            also be substituted for LNUM.

        noeflip
            Indicates whether you want to change the normal direction of the
            existing elements on the reversed line(s) so that they are
            consistent with each line's new normal direction.

            0 - Make the normal direction of existing elements on the reversed line(s)
                consistent with each line's new normal direction (default).

            1 - Do not change the normal direction of existing elements on the reversed
                line(s).

        Notes
        -----
        You cannot use the LREVERSE command to change the normal direction of
        any element that has a body or surface load.  We recommend that you
        apply all of your loads only after ensuring that the element normal
        directions are acceptable.

        Real constants (such as nonuniform shell thickness and tapered beam
        constants) may be invalidated by an element reversal.

        For more information, see Revising Your Model in the Modeling and
        Meshing Guide.
        """
        command = "LREVERSE,%s,%s" % (str(lnum), str(noeflip))
        return self.run(command, **kwargs)

    def rsprnt(self, rslab="", yname="", xout="", **kwargs):
        """APDL Command: RSPRNT

        Print a response surface.

        Parameters
        ----------
        rslab
            Response Surface set label. Identifies the response surfaces
            generated by the RSFIT command.

        yname
            Parameter name. The parameter must have been previously defined as
            a random output parameter with the PDVAR command. Identifies the
            parameter for which a response surface has been generated by the
            RSFIT command.

        xout
            An option if an extended print-out of more feedback about goodness-
            of-fit and the details of the regression analysis of the response
            surface is requested.

            No - Use the standard print-out (default).

            Yes - Use the extended print-out.

        Notes
        -----
        Prints the results and details of a response surface analysis generated
        by the RSFIT command. For the specified output parameter Yname, the
        fitting details such as the individual terms of the response surface
        model and their corresponding coefficients are listed. The command also
        produces a comparison of the original values of Yname used for the
        fitting process and the approximate values derived from the fitting,
        and some goodness of fit measures.

        If Xout = Yes, then more information about the regression analysis of
        the response surface will be printed. For example, the confidence
        intervals on the regression coefficients and the correlation between
        the regression coefficients among others.
        """
        command = "RSPRNT,%s,%s,%s" % (str(rslab), str(yname), str(xout))
        return self.run(command, **kwargs)

    def stitle(self, nline="", title="", **kwargs):
        """APDL Command: /STITLE

        Defines subtitles.

        Parameters
        ----------
        nline
            Subtitle line number (1 to 4).  Defaults to 1.

        title
            Input up to 70 alphanumeric characters.  Parameter substitution may
            be forced within the title by enclosing the parameter name or
            parametric expression within percent (%) signs.  If Title is blank,
            this subtitle is deleted.

        Notes
        -----
        Subtitles (4 maximum) are displayed in the output along with the main
        title [/TITLE].  Subtitles do not appear in GUI windows or in ANSYS
        plot displays.  The first subtitle is also written to various ANSYS
        files along with the main title.  Previous subtitles may be overwritten
        or deleted.  Issue /STATUS to display titles.

        This command is valid in any processor.
        """
        command = "/STITLE,%s,%s" % (str(nline), str(title))
        return self.run(command, **kwargs)

    def file(self, fname="", ext="", **kwargs):
        """APDL Command: FILE

        Specifies the data file where results are to be found.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Specifies the ANSYS data file where the results are to be found for
        postprocessing.
        """
        command = "FILE,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def bfelist(self, elem="", lab="", **kwargs):
        """APDL Command: BFELIST

        Lists the element body force loads.

        Parameters
        ----------
        elem
            Element at which body load is to be listed.  If ALL (or blank),
            list for all selected elements [ESEL].  If ELEM = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).  A component name may also be substituted
            for ELEM.

        lab
            Valid body load label. If ALL (or blank), use all appropriate
            labels. See BFE command for labels.

        Notes
        -----
        Lists the element body force loads for the specified element and label.
        Element body loads may be defined with the BFE command.

        This command is valid in any processor.
        """
        command = "BFELIST,%s,%s" % (str(elem), str(lab))
        return self.run(command, **kwargs)

    def format(self, ndigit="", ftype="", nwidth="", dsignf="", line="",
               char="", **kwargs):
        """APDL Command: /FORMAT

        Specifies format controls for tables.

        Parameters
        ----------
        ndigit
            Number of digits (3 to 32) in first table column (usually the node
            or element number).  Initially defaults to 7.

        ftype
            FORTRAN format types (initially defaults to G):

            G - Gxx.yy.  xx and yy are described below.

            F - Fxx.yy

            E - Exx.yy

        nwidth
            Total width (9 to 32) of the field (the xx in Ftype).  Initially
            defaults to 12.

        dsignf
            Number of digits after the decimal point (yy in F or E format) or
            number of significant digits in G format.  Range is 2 to xx-7 for
            Ftype = G or E; and 0 to xx-4 for Ftype = F.  Initially defaults to
            5.

        line
            Number of lines (11 minimum) per page.  Defaults to ILINE or BLINE
            from the /PAGE command.

        char
            Number of characters (41 to 240, system-dependent) per line before
            wraparound.  Defaults to ICHAR or BCHAR from the /PAGE command.

        Notes
        -----
        Specifies various format controls for tables printed with the POST1
        PRNSOL, PRESOL, PRETAB, PRRSOL, PRPATH, and CYCCALC commands.  A blank
        (or out-of-range) field on the command retains the current setting.
        Issue /FORMAT,STAT to display the current settings.  Issue /FORMAT,DEFA
        to reestablish the initial default specifications.

        For the POST26 PRVAR command, the Ftype, NWIDTH, and DSIGNF fields
        control the time output format.

        This command is valid in any processor.
        """
        command = "/FORMAT,%s,%s,%s,%s,%s,%s" % (str(ndigit), str(ftype), str(nwidth), str(dsignf), str(line), str(char))
        return self.run(command, **kwargs)

    def bfscale(self, lab="", fact="", tb_ase="", **kwargs):
        """APDL Command: BFSCALE

        Scales body force loads at nodes.

        Parameters
        ----------
        lab
            Valid body load label.  If ALL, use all appropriate labels.

        fact
            Scale factor for the nodal body load values.  Zero (or blank)
            defaults  to 1.0.  Use a small number for a zero scale factor.  The
            scale factor is not applied to body load phase angles.

        tbase
            Base temperature for temperature difference.  Used only with Lab =
            TEMP.  Scale factor is applied to the temperature difference (T -
            TBASE)  and then added to TBASE.  T is the current temperature.

        Notes
        -----
        Scales body force loads in the database on the selected nodes.  Issue
        the BFLIST command to list the nodal body loads.  Solid model boundary
        conditions are not scaled by this command, but boundary conditions on
        the FE model are scaled.

        Note:: : Such scaled FE boundary conditions may still be overwritten by
        unscaled solid model boundary conditions if a subsequent boundary
        condition transfer occurs.

        BFSCALE does not work for tabular boundary conditions.

        This command is also valid in PREP7.
        """
        command = "BFSCALE,%s,%s,%s" % (str(lab), str(fact), str(tb_ase))
        return self.run(command, **kwargs)

    def reorder(self, **kwargs):
        """APDL Command: REORDER

        Specifies "Model reordering" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "REORDER," % ()
        return self.run(command, **kwargs)

    def rgb(self, kywrd="", pred="", pgrn="", pblu="", n1="", n2="", ninc="",
            ncntr="", **kwargs):
        """APDL Command: /RGB

        Specifies the RGB color values for indices and contours.

        Parameters
        ----------
        kywrd
            Determines how RGB modifications will be applied.

            INDEX - Specifies that subsequent color values apply to ANSYS color indices (0-15).

            CNTR - Specifies that subsequent color values apply to contours (1-128).  Applies to
                   C-option devices only (i.e. X11C or Win32C).

        pred
            Intensity of the color red, expressed as a percentage.

        pgrn
            Intensity of the color green, expressed as a percentage.

        pblu
            Intensity of the color blue, expressed as a percentage.

        n1
            First index (0-15), or contour (1-128) to which the designated RGB
            values apply.

        n2
            Final index (0-15), or contour (1-128) to which the designated RGB
            values apply.

        ninc
            The step increment between the values N1 and N2 determining which
            contours or indices will be controlled by the specified RGB values.

        ncntr
            The new maximum number of contours (1-128).

        Notes
        -----
        Issuing the /CMAP command (with no filename) will restore the default
        color settings.
        """
        command = "/RGB,%s,%s,%s,%s,%s,%s,%s,%s" % (str(kywrd), str(pred), str(pgrn), str(pblu), str(n1), str(n2), str(ninc), str(ncntr))
        return self.run(command, **kwargs)

    def cmrotate(self, cm_name="", rotatx="", rotaty="", rotatz="", x1="",
                 y1="", z1="", x2="", y2="", z2="", **kwargs):
        """APDL Command: CMROTATE

        Specifies the rotational velocity of an element component in a brake
        squeal analysis.

        Parameters
        ----------
        cm_name
            The name of the element component.

        rotatx, rotaty, rotatz
            If the X2, Y2, Z2 fields are not defined, ROTATX, ROTATY, and
            ROTATZ specify the components of the rotational angle vector in the
            global Cartesian X, Y, Z directions.

        x1, y1, z1
            If the X2, Y2, Z2 fields are defined, X1, Y1, and Z1 define the
            coordinates of the beginning point of the rotational axis vector.
            Otherwise, X1, Y1, and Z1 are the coordinates of a point through
            which the rotational axis passes.

        x2, y2, z2
            The coordinates of the end point of the rotational axis vector.

        Notes
        -----
        The CMROTATE command specifies the rotational motion velocity
        components ROTATX, ROTATY, and ROTATZ of an element component CM_Name
        about a user-defined rotational axis. The rotational axis can be
        defined either as a vector passing through a single point or a vector
        connecting two points. CMROTATE can be used in static analyses
        (ANTYPE,STATIC) and modal analyses (ANTYPE,MODAL).

        This command sets the constant rotational velocity on the nodes of the
        specified element component, despite any deformation at the nodes. This
        feature is primarily used for generating sliding contact at frictional
        contact interfaces in a brake squeal analysis. This type of analysis
        typically involves surface-to-surface contact between the brake pad and
        the rotating disk. The applicable contact elements, therefore, are
        CONTA173, CONTA174, and CONTA175.

        A brake squeal analysis generally involves a linear perturbation modal
        analysis subsequent to a large-deformation static analysis with the
        Newton-Raphson option set as NROPT,UNSYM. Therefore, CMROTATE is not
        applicable for multiple load step solves using the LSSOLVE command.

        This command is also valid in PREP7.
        """
        command = "CMROTATE,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(cm_name), str(rotatx), str(rotaty), str(rotatz), str(x1), str(y1), str(z1), str(x2), str(y2), str(z2))
        return self.run(command, **kwargs)

    def lmesh(self, nl1="", nl2="", ninc="", **kwargs):
        """APDL Command: LMESH

        Generates nodes and line elements along lines.

        Parameters
        ----------
        nl1, nl2, ninc
            Mesh lines from NL1 to NL2 (defaults to NL1) in steps of NINC
            (defaults to 1).  If NL1 = ALL, NL2 and NINC are ignored and all
            selected lines [LSEL] are meshed.  If NL1 = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for NL1 (NL2
            and NINC are ignored).

        Notes
        -----
        Generates nodes and line elements along lines.  Missing nodes required
        for the generated elements are created and assigned the lowest
        available numbers.
        """
        command = "LMESH,%s,%s,%s" % (str(nl1), str(nl2), str(ninc))
        return self.run(command, **kwargs)

    def mfelem(self, fnumb="", itype1="", itype2="", itype3="", itype4="",
               itype5="", itype6="", itype7="", itype8="", itype9="",
               itype10="", **kwargs):
        """APDL Command: MFELEM

        Defines a field by grouping element types.

        Parameters
        ----------
        fnumb
            Field number for a group of element types.

        itype1, itype2, itype3, . . . , itype10
            Element types defined by the ET command.

        Notes
        -----
        You can define up to ten element types per field.

        Define only element types that contain elements in the field. Do not
        include MESH200 because it is a “mesh-only” element that does not
        contribute to the solution.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFELEM,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(fnumb), str(itype1), str(itype2), str(itype3), str(itype4), str(itype5), str(itype6), str(itype7), str(itype8), str(itype9), str(itype10))
        return self.run(command, **kwargs)

    def spctemp(self, encl="", temp="", **kwargs):
        """APDL Command: SPCTEMP

        Defines a free-space ambient temperature for radiation using the
        Radiosity method.

        Parameters
        ----------
        encl
            Radiating surface enclosure number. Defaults to 1. If ENCL = STAT,
            the command lists all enclosure space temperatures.  If ENCL =
            DELE, the command deletes all enclosure space temperatures.

        temp
            Temperature of free-space in the reference temperature system.  The
            temperature will be offset by the value specified in the TOFFST
            command for internal calculations.

        Notes
        -----
        For open systems, an enclosure may radiate to the free-space ambient
        temperature (TEMP).

        Open systems may be characterized by one or more enclosures (ENCL).
        Each enclosure may radiate to a different free-space ambient
        temperature  (TEMP).

        For the first load step, the space temperature ramps from the uniform
        temperature specified by the TUNIF command to the temperature specified
        by the SPCTEMP command. For subsequent load steps, it ramps from the
        previous value of the space temperature. For intermediate load steps,
        use the SPCTEMP,DELETE command and specify the space temperature again
        to ramp from the uniform temperature.

        If using SPCTEMP with the ANSYS Multi-field solver (MFS),  you must
        capture this command in the command file using MFCMMAND. This step is
        necessary because at the end of each field computation, this command is
        unset.
        """
        command = "SPCTEMP,%s,%s" % (str(encl), str(temp))
        return self.run(command, **kwargs)

    def edhtime(self, nstep="", dt="", **kwargs):
        """APDL Command: EDHTIME

        Specifies the time-history output interval for an explicit dynamics
        analysis.

        Parameters
        ----------
        nstep
            Number of steps at which output is written to the time-history
            file, Jobname.HIS, and the ASCII output files. Defaults to 1000.
            The time increment between output is TIME / NSTEP, where TIME is
            the analysis end-time specified on the TIME command.

        dt
            Time interval at which output is written to the time-history file,
            Jobname.HIS, and the ASCII output files. If NSTEP is input, DT is
            ignored.

        Notes
        -----
        EDHTIME controls the number of steps at which output will be written to
        the time-history file, Jobname.HIS (see the EDHIST command), and any
        ASCII files requested on the EDOUT command. You can use NSTEP or DT to
        specify the output interval. You should not specify both quantities; if
        both are input, NSTEP will be used.

        In an explicit dynamic small restart (EDSTART,2) or full restart
        analysis (EDSTART,3), the EDHTIME setting will default to the NSTEP or
        DT value used in the original analysis. You can issue EDHTIME in the
        restart to change this setting.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDHTIME,%s,%s" % (str(nstep), str(dt))
        return self.run(command, **kwargs)

    def sfedele(self, elem="", lkey="", lab="", **kwargs):
        """APDL Command: SFEDELE

        Deletes surface loads from elements.

        Parameters
        ----------
        elem
            Element to which surface load deletion applies.  If ALL, delete
            load from all selected elements [ESEL].  If ELEM = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).  A component name may be substituted for
            ELEM.

        lkey
            Load key associated with surface load (defaults to 1).  If ALL,
            delete surface loads for all load keys.

        lab
            Valid surface load label.  If ALL, use all appropriate labels.  See
            the SFE command for labels.

        Notes
        -----
        Deletes surface loads from selected elements.  See the SFDELE command
        for an alternate surface load deletion capability based upon selected
        nodes.

        This command is also valid in PREP7.
        """
        command = "SFEDELE,%s,%s,%s" % (str(elem), str(lkey), str(lab))
        return self.run(command, **kwargs)

    def senergy(self, opt="", antype="", **kwargs):
        """APDL Command: SENERGY

        Determines the stored magnetic energy or co-energy.

        Parameters
        ----------
        opt
            Item to be calculated:

            0 - Stored magnetic energy.

            1 - Stored magnetic co-energy.

        antype
            Analysis type:

            0 - Static or transient.

            1 - Harmonic.

        Notes
        -----
        SENERGY invokes an ANSYS macro which calculates the stored magnetic
        energy or co-energy for all selected elements.  (For a harmonic
        analysis, the macro calculates a time-averaged (rms) stored energy.)  A
        summary table listing the energy by material number is produced.  The
        energy density is also calculated and stored on a per-element basis in
        the element table [ETABLE] with the label MG_ENG (energy density) or
        MG_COENG (co-energy density).  The macro erases all other items in the
        element table [ETABLE] and only retains the energy density or co-energy
        density.  Use the PLETAB and PRETAB commands to plot and list the
        energy density.  The macro is valid for static and low-frequency
        magnetic field formulations.  The macro will not calculate stored
        energy and co-energy for the following cases:

        Orthotropic nonlinear permanent magnets.

        Orthotropic nonlinear permeable materials.

        Temperature dependent materials.

        SENERGY is restricted to MKSA units.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "SENERGY,%s,%s" % (str(opt), str(antype))
        return self.run(command, **kwargs)

    def map(self, kdim="", kout="", limit="", **kwargs):
        """APDL Command: MAP

        Maps pressures from source points to target surface elements.

        Parameters
        ----------
        --
            Unused field.

        kdim
            Interpolation key:

            0 or 2 - Interpolation is done on a surface (default).

            3 - Interpolation is done within a volume. This option is useful if the supplied
                source data is volumetric field data rather than surface data.

        --
            Unused field.

        kout
            Key to control how pressure is applied when a target node is
            outside of the source region:

            0 - Use the pressure(s) of the nearest source point for target nodes outside of the
                region (default).

            1 - Set pressures outside of the region to zero.

        limit
            Number of nearby points considered for interpolation. The minimum
            is 5; the default is 20. Lower values reduce processing time.
            However, some distorted or irregular meshes will require a higher
            LIMIT value to find the points encompassing the target node in
            order to define the region for interpolation.

        Notes
        -----
        Maps pressures from source points to target surface elements.
        """
        command = "MAP,%s,%s,%s" % (str(kdim), str(kout), str(limit))
        return self.run(command, **kwargs)

    def smbc(self, mode="", **kwargs):
        """APDL Command: /SMBC

        Controls the display of solid model boundary condition symbols and
        labels.

        Parameters
        ----------
        mode
            CENT

            CENT - Solid model boundary condition symbols and labels appear at the centroid of the
                   solid model entity (default).

            TESS - Solid model boundary condition symbols and labels appear inside each
                   constituent element of the tessellation.

        Notes
        -----
        Mode = CENT is designed to reduce the clutter of boundary condition
        symbols in solid model plots. For example, if you have assigned normal
        pressure loads to an area, you may choose to display the pressures as
        arrows with the /PSF command using /PSF,PRES,NORM,2. When Mode = CENT,
        the pressure arrow is displayed at the centroid of the area. When Mode
        = TESS, a pressure arrow is displayed at the centroid of each polygon
        of the area's tessellation.

        This command is valid in any processor.
        """
        command = "/SMBC,%s" % (str(mode))
        return self.run(command, **kwargs)

    def sucalc(self, rsetname="", lab1="", oper="", lab2="", fact1="",
               fact2="", const="", **kwargs):
        """APDL Command: SUCALC

        Create new result data by operating on two existing result data sets on
        a given surface.

        Parameters
        ----------
        rsetname
            Eight character name for new result data.

        lab1
            First  result data upon which to operate.

        oper
            Mathematical operation to perform.

            ADD - (lab1 + lab2 + const)

            SUB - (lab1 - lab2 + const)

            MULT - (lab1 * lab2 + const)

            DIV - (lab1 / lab2 + const)

            EXP - (lab1 ^ fact1 + lab2 ^ fact2 + const)

            COS - (cos (lab1) + const)

            SIN - (sin (lab1) + const)

            ACOS - (acos (lab1) + const)

            ASIN - (asin (lab1) + const)

            ATAN - (atan (lab1) + const)

            ATA2 - (atan2 (lab1 / lab2) + const)

            LOG - (log (lab1) + const)

            ABS - (abs (lab1) + const)

            ZERO - (0 + const)

        lab2
            Second result data upon which to operate.

        fact1
            First scaling factor (for EXP option only).

        fact2
            Second scaling factor (for EXP option only).

        const
            Constant added to the values in the resulting data.
        """
        command = "SUCALC,%s,%s,%s,%s,%s,%s,%s" % (str(rsetname), str(lab1), str(oper), str(lab2), str(fact1), str(fact2), str(const))
        return self.run(command, **kwargs)

    def edcmore(self, option="", num="", val1="", val2="", **kwargs):
        """APDL Command: EDCMORE

        Specifies additional contact parameters for a given contact definition
        in an explicit dynamic analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed.

            ADD - Define contact parameters for the contact entity specified by NUM (default).

            DELE - Delete contact parameters (VAL1 and VAL2) for the contact entity specified by
                   NUM. If NUM = ALL, all contact parameters previously defined
                   by EDCMORE are deleted.

        num
            Contact entity number. This contact entity must have been
            previously defined with the EDCGEN command. Use EDCLIST to obtain a
            list of contact entity numbers.

        --
            Unused field.

        val1
            Penalty scale factor for slave (contact) surface (SFS); default =
            1.

        val2
            Penalty scale factor for master (target) surface (SFM); default =
            1.

        Notes
        -----
        You can use the EDCMORE command to specify two additional contact
        parameters (SFS and SFM) for a specific contact definition. These
        parameters will apply only to the contact entity number entered on the
        NUM field. Use the EDCLIST command to obtain a list of contact
        definitions and their corresponding contact entity numbers. The listing
        produced by EDCLIST will include any contact parameters specified with
        the EDCMORE command.

        When you use the EDDC command to delete a contact definition, any
        parameters you specified with EDCMORE for that contact definition will
        also be deleted. To delete only the parameters specified by EDCMORE for
        a given contact definition, use the command EDCMORE,DELE,NUM.

        Note:: : When you delete a contact definition with the EDDC command,
        the contact entity numbers will be renumbered for the remaining contact
        definitions. Therefore, you should always issue EDCLIST to obtain a
        current list of contact entity numbers before adding or deleting
        contact parameters with the EDCMORE command.

        The EDCMORE command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDCMORE,%s,%s,%s,%s" % (str(option), str(num), str(val1), str(val2))
        return self.run(command, **kwargs)

    def noorder(self, lab="", **kwargs):
        """APDL Command: NOORDER

        Re-establishes the original element ordering.

        Parameters
        ----------
        lab
            Turns element reordering on or off.

            ON (or blank) - Re-establishes original element ordering (default).

            OFF - Original ordering is not used and program establishes its own ordering at the
                  beginning of the solution phase.

        Notes
        -----
        If Lab = ON, the original element ordering is re-established and no
        automatic reordering occurs at the beginning of the solution phase.
        Use Lab = OFF only to remove the effect of a previous NOORDER command.
        This command affects only those elements that were defined up to the
        point that this command is issued. See the WSORT and WAVES commands for
        reordering.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "NOORDER,%s" % (str(lab))
        return self.run(command, **kwargs)

    def rlist(self, nset1="", nset2="", ninc="", **kwargs):
        """APDL Command: RLIST

        Lists the real constant sets.

        Parameters
        ----------
        nset1, nset2, ninc
            List real constant sets from NSET1 to NSET2 (defaults to NSET1) in
            steps of NINC (defaults to 1).  If NSET1 = ALL (default), ignore
            NSET2  and NINC and list all real constant sets [R].

        Notes
        -----
        The real constant sets listed contain only those values specifically
        set by the user.  Default values for real constants set automatically
        within the various elements are not listed.

        This command is valid in any processor.
        """
        command = "RLIST,%s,%s,%s" % (str(nset1), str(nset2), str(ninc))
        return self.run(command, **kwargs)

    def anisos(self, nfram="", delay="", ncycl="", **kwargs):
        """APDL Command: ANISOS

        Produces an animated sequence of an isosurface.

        Parameters
        ----------
        nfram
            Number of frames captures (defaults to 9).

        delay
            Time delay during animation (defaults to 0.1 seconds).

        ncycl
            Number of animation cycles (defaults to 5).  Available in non-UI
            mode only.

        Notes
        -----
        ANISOS involves an ANSYS macro which produces an animation of an
        isosurface  of the last plot action command (for example,
        PLNSOL,S,EQV).  The ANISOS command operates only on graphic display
        platforms supporting the /SEG command.  After executing ANISOS, you can
        replay the animated sequence by issuing the ANIM command.

        This command functions only in the postprocessor.
        """
        command = "ANISOS,%s,%s,%s" % (str(nfram), str(delay), str(ncycl))
        return self.run(command, **kwargs)

    def rsurf(self, options="", delopts="", etnum="", **kwargs):
        """APDL Command: RSURF

        Generates the radiosity surface elements (SURF251/SURF252) and stores
        them in the database.

        Parameters
        ----------
        options
            Command options:

            CLEAR  - Deletes radiosity surface elements and nodes. The set of elements and nodes to
                     be deleted is defined by Delopts. ETNUM is ignored.

            DEFINE  - Creates the radiosity surface elements and nodes (default).

            STAT - Shows the status/listing. Other command options are ignored.

        delopts
            Deletion options

            ALL  - Deletes all radiosity surface elements and nodes.

            LAST  - Deletes radiosity surface elements and nodes created by the last RSURF command.

        etnum
            Element type number. Leave blank to indicate the next available
            number.

        Notes
        -----
        This command generates the radiosity surface elements based on the
        RSYMM and RDEC parameters and stores them in the database. It works
        only on the faces of selected underlying elements that have RDSF flags
        on them and all corner nodes selected. You can issue multiple RSURF
        commands to build the radiosity model. However, all RSURF commands must
        be issued after issuing the RSYMM, and after the model is complete
        (i.e., after all meshing operations are complete).

        If you do issue multiple RSURF commands for different regions, you must
        first mesh the different regions, and then generate the radiosity
        surface elements on each meshed region individually. Use RSURF,,,ETNUM
        to assign a separate element type number to each region. This procedure
        allow you to identify the individual regions later in the multi-field
        analysis.

        If the underlying solid elements are higher order, the radiosity
        surface elements are always lower order (4- or 3-node in 3-D or 2-node
        in 2-D). Decimation will always occur before any symmetry operations.

        For 2-D axisymmetric YR models, the newly-generated nodes can have only
        positive Y coordinates.

        If you have already issued RSURF for a surface and you issue RSURF
        again, the program creates a new set of radiosity surface elements and
        nodes over the existing set, resulting in an erroneous solution.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.

        This is an action command (that creates or deletes surface meshes) and
        is serial in nature. Even if Distributed ANSYS is running, the RSURF
        command runs serially
        """
        command = "RSURF,%s,%s,%s" % (str(options), str(delopts), str(etnum))
        return self.run(command, **kwargs)

    def cmsfile(self, option="", fname="", ext="", cmskey="", **kwargs):
        """APDL Command: CMSFILE

        Specifies a list of component mode synthesis (CMS) results files for
        plotting results on the assembly.

        Parameters
        ----------
        option
            Specifies the command operation:

            ADD - Add the specified component results file (Fname) to the list of files to plot.
                  This option is the default.

            DELETE - Remove the specified component results file (Fname) from the list of files to
                     plot.

            LIST - List all specified component results files.

            CLEAR - Clear all previous files added.

            ALL - Add all component results (.rst) files from the working directory to the list
                  of files to plot.

        fname
            The file name (with full directory path) of the component results
            file. The default file name is the Jobname (specified via the
            /FILNAME command).

        ext
            The file name (Fname) extension. The default extension is .rst.

        cmskey
            Valid only when adding a results file (Option = ADD or ALL), this
            key specifies whether or not to check the specified .rst file to
            determine if it was created via a CMS expansion pass:

            ON - Check (default).

            OFF - Do not check.

        Notes
        -----
        The CMSFILE command specifies the list of component mode synthesis
        (CMS) results files to include when plotting the mode shape of an
        assembly.

        During postprocessing (/POST1) of a CMS analysis, issue the CMSFILE
        command to point to component results files of interest. (You can issue
        the command as often as needed to include all or some of the component
        results files.) Issue the SET command to acquire the frequencies and
        mode shapes from substeps for all specified results files. Execute a
        plot (PLNSOL) or print (PRNSOL) operation to display the mode shape of
        the entire assembly.

        When you specify a results file to add to the plot list, the default
        behavior of the command (CmsKey = ON) is to first verify that the file
        is from a CMS analysis and that the frequencies of the result sets on
        the file match the frequencies on the first file in the list. If CmsKey
        = OFF, you can add any .rst file to the list of files to plot, even if
        the file was not expanded via a CMS expansion pass.

        If CmsKey = ON (default), output from the command appears as: ADD CMS
        FILE = filename.rst. : If CmsKey = OFF, output from the command appears
        as: ADD FILE = filename.rst.

        If Option = DELETE or CLEAR, you must clear the database (/CLEAR), then
        re-enter the postprocessor (/POST1) and issue a SET command for the
        change to take effect on subsequent plots.

        Clearing the database does not clear the list of files specified via
        the CMSFILE command. Specify Option = CLEAR to clear the list of files.
        """
        command = "CMSFILE,%s,%s,%s,%s" % (str(option), str(fname), str(ext), str(cmskey))
        return self.run(command, **kwargs)

    def pdprob(self, rlab="", name="", relation="", limit="", conf="",
               **kwargs):
        """APDL Command: PDPROB

        Prints a probability result.

        Parameters
        ----------
        rlab
            Result set label. Identifies the result set to be used for
            postprocessing. A result set label can be the solution set label
            you defined in a PDEXE command (if you are directly postprocessing
            Monte Carlo Simulation results), or the response surface set label
            defined in an RSFIT command (for Response Surface Analyses).

        name
            Parameter name. The parameter must have been previously defined as
            a random input variable or a random output parameter using the
            PDVAR command.

        relation
            Relation label for the relation between probabilistic design
            parameter Name and the limit value LIMIT:

            LT - Less than (default).

            GT - Greater than.

        limit
            Limit value.

        --
            Unused field.

        conf
            Confidence level. The confidence level is used to print the
            confidence bounds on the probability. The value for the confidence
            level must be between 0.0 and 1.0 and it defaults to 0.95 (95%).
            Printing of confidence bound is suppressed for CONF  0.5. This
            parameter is ignored for response surface methods results
            postprocessing.

        Notes
        -----
        Prints the probability that the probabilistic design input or output
        variable denoted with Name is smaller or larger than a certain limit
        value.

        If Rlab is left blank, then the result set label is inherited from the
        last PDEXE command (Slab), RSFIT command (RSlab), or the most recently
        used PDS postprocessing command where a result set label was explicitly
        specified.

        Use the relation label Relation to specify if you want to print a
        traditional probability value (LT) or the exceedence probability (GT).
        The LIMIT directly specifies at which value of Name (the design
        parameter) the probability should be evaluated. If LIMIT is between two
        sample values of Name the resulting probability is linearly
        interpolated between the sample values. If LIMIT is smaller than all
        sample values of Name the probability is 0.0 for Relation = LT and 1.0
        for Relation = GT. If LIMIT is greater than all sample values for Name
        the probability is 1.0 for Relation = LT and 0.0 for Relation = GT.

        The confidence level is a probability expressing the confidence that
        the value for the requested probability is in fact between the
        confidence bounds. The larger the confidence level, the wider the
        confidence bounds. Printing the confidence bounds only makes sense for
        postprocessing Monte Carlo simulation results, where the confidence
        bounds represent the accuracy of the results. With increasing sample
        sizes, the width of the confidence bounds gets smaller for the same
        confidence level. For response surface analysis methods, the number of
        simulations done on the response surface is usually very large;
        therefore, the accuracy of the results is determined by the response
        surface fit and not by the confidence level.

        The PDPROB command cannot be used to postprocess the results in a
        solution set that is based on Response Surface Methods, only Monte
        Carlo Simulations.
        """
        command = "PDPROB,%s,%s,%s,%s,%s" % (str(rlab), str(name), str(relation), str(limit), str(conf))
        return self.run(command, **kwargs)

    def numvar(self, nv="", **kwargs):
        """APDL Command: NUMVAR

        Specifies the number of variables allowed in POST26.

        Parameters
        ----------
        nv
            Allow storage for NV variables.  200 maximum are allowed.  Defaults
            to 10 (except for an explicit dynamics analysis, which defaults to
            30).  TIME (variable 1) should also be included in this number.

        Notes
        -----
        Specifies the number of variables allowed for data read from the
        results file and for data resulting from an operation (if any).  For
        efficiency, NV should not be larger than necessary.  NV cannot be
        changed after data storage begins.
        """
        command = "NUMVAR,%s" % (str(nv))
        return self.run(command, **kwargs)

    def pdsens(self, rlab="", name="", chart="", type="", slevel="", **kwargs):
        """APDL Command: PDSENS

        Plots the probabilistic sensitivities.

        Parameters
        ----------
        rlab
            Result set label. Identifies the result set to be used for
            postprocessing. A result set label can be the solution set label
            you defined in a PDEXE command (if you are directly postprocessing
            Monte Carlo Simulation results), or the response surface set label
            defined in an RSFIT command (for Response Surface Analyses). The
            PDSENS command cannot be used to postprocess the results in a
            solution set that is based on Response Surface Methods, only Monte
            Carlo Simulations.

        name
            Parameter name. The parameter must have been previously defined as
            a random output parameter using the PDVAR command.

        chart
            Keyword for the type of chart to be plotted.

            BAR - Bar chart of the absolute sensitivities.

            PIE - Pie chart of relative and normalized sensitivities.

            BOTH - Both pie and bar charts plotted side by side (default).

        type
            Keyword for the type of correlation coefficients used to evaluate
            the sensitivities.

            RANK - Spearman rank-order correlation coefficient (default).

            LIN - Pearson linear correlation coefficient.

        slevel
            Significance level. The value for the significance level must be
            between 0.0 and 1.0 and it defaults to 0.025 (2.5%).

        Notes
        -----
        Plots the probabilistic sensitivities.

        If Rlab is left blank, then the result set label is inherited from the
        last PDEXE command (Slab), RSFIT command (RSlab), or the most recently
        used PDS postprocessing command where a result set label was explicitly
        specified.

        Evaluation of the probabilistic sensitivities is based on the
        correlation coefficients between all random input variables and the
        random output parameter specified by Name. You can chose which
        correlation coefficient should be used for that evaluation using the
        Corr option. For all sensitivity values, the probabilistic design tool
        evaluates the probability that the sensitivity can be neglected, based
        on statistical test theory. If this probability exceeds the
        significance level as specified by the SLEVEL parameter, the
        sensitivity value should be regarded as negligible or insignificant.
        The higher the significance level (SLEVEL) the more sensitivities are
        considered as significant. The sensitivity plot includes the
        significant sensitivities only and lists the insignificant ones
        separately.
        """
        command = "PDSENS,%s,%s,%s,%s,%s" % (str(rlab), str(name), str(chart), str(type), str(slevel))
        return self.run(command, **kwargs)

    def ptxy(self, x1="", y1="", x2="", y2="", x3="", y3="", x4="", y4="",
             **kwargs):
        """APDL Command: PTXY

        Defines coordinate pairs for use in polygons and prisms.

        Parameters
        ----------
        x1, y1, x2, y2, x3, y3, x4, y4
            X and Y coordinate pairs on the working plane.

        Notes
        -----
        Defines coordinate pairs for use in polygons and prisms [POLY, RPRISM].
        The coordinates must be in the Cartesian coordinate system.  The
        coordinate pairs must be input in a continuous order.  PTXY  may be
        repeated (up to 100 pairs) until the required pairs have been defined.
        The pairs will be saved until either the POLY or PRISM command is
        entered.  Use PTXY,STAT to list the saved coordinate pairs.  Use
        PTXY,DELE to delete all the saved coordinate pairs.  See the RPOLY,
        RPRISM, and RPR4 commands for other ways to create polygons and prisms.
        """
        command = "PTXY,%s,%s,%s,%s,%s,%s,%s,%s" % (str(x1), str(y1), str(x2), str(y2), str(x3), str(y3), str(x4), str(y4))
        return self.run(command, **kwargs)

    def msg(self, lab="", val1="", val2="", val3="", val4="", val5="", val6="",
            val7="", val8="", **kwargs):
        """APDL Command: *MSG

        Writes an output message via the ANSYS message subroutine.

        Parameters
        ----------
        lab
            Label for output and termination control:

            Writes the message with no heading (default). - Writes the message with a "NOTE" heading.

            Writes the message with a "WARNING" heading.  Also writes the message to the errors file, Jobname.ERR. - Writes the message with a "ERROR" heading and causes run termination (if batch)
                              at earliest "clean exit" point.  Also writes the
                              message to the errors file, Jobname.ERR.

            Writes the message with a "FATAL ERROR" heading and causes run termination immediately.  Also writes the message to the errors file, Jobname.ERR. - Writes the message with a "NOTE" heading and displays it in the message dialog
                              box.  This option is most useful in GUI mode.

        val1, val2, val3, . . . , val8
            Numeric or alphanumeric character values to be included in message.
            Values may be the results of parameter evaluations.  All numeric
            values are assumed to be double precision. The FORTRAN nearest
            integer (NINT) function is used to form integers for the %I
            specifier.

        Notes
        -----
        Allows writing an output message via the ANSYS message subroutine.
        Also allows run termination control.  This command is used only when
        contained in a prepared file read into the ANSYS program (i.e.,
        *USE,/INPUT, etc.).  A message format must immediately follow the *MSG
        command (on a separate line, without parentheses, as described below).

        The message format may be up to 80 characters long, consisting of text
        strings and predefined "data descriptors" between the strings where
        numeric or alphanumeric character data are to be inserted.  The normal
        descriptors are %I for integer data, %G for double precision data, %C
        for alphanumeric character data, and %/ for a line break.  The
        corresponding FORTRAN data descriptors are I9, 1PG16.9 and A8,
        respectively.  Each descriptor must be preceded by a blank.  There must
        be one data descriptor for each specified value (8 maximum) in the
        order of the specified values.

        Enhanced descriptions may also be used:

        Do not begin *MSG format lines with *IF, *ELSE , *ELSEIF , or *ENDIF .
        If the last nonblank character of the message format is an ampersand
        (&), a second line will also be read as a continuation of the format.
        Up to nine continuations (ten total lines) may be read.  If normal
        descriptions are used, then consecutive blanks are condensed into one
        blank upon output, and a period is appended.  Up to ten lines of output
        of 72 characters each may be produced (using the %/ descriptor).  Two
        examples follow.

        Here is an example of the *MSG command and a format to print a message
        with two integer values and one real value:

        The output line is:

        Here is an example illustrating multiline displays in GUI message
        windows:

        Note:: : The /UIS,MSGPOP command controls which messages are displayed
        in the message dialog box when the GUI is active.  All messages
        produced by the *MSG command are subject to the /UIS specification,
        with one exception,  If Lab = UI, the message will be displayed in the
        dialog box regardless of the /UIS specification.

        This command is valid in any processor.
        """
        command = "*MSG,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(lab), str(val1), str(val2), str(val3), str(val4), str(val5), str(val6), str(val7), str(val8))
        return self.run(command, **kwargs)

    def edpl(self, ldnum="", **kwargs):
        """APDL Command: EDPL

        Plots a time dependent load curve in an explicit dynamic analysis.

        Parameters
        ----------
        ldnum
             Load number.

        Notes
        -----
        EDPL invokes an ANSYS macro which produces a load vs. time graph for a
        load defined with the EDLOAD command. Only one load curve can be
        plotted at a time. Use EDLOAD,LIST to obtain a list of loads and
        corresponding load numbers.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDPL,%s" % (str(ldnum))
        return self.run(command, **kwargs)

    def gfile(self, size="", **kwargs):
        """APDL Command: /GFILE

        Specifies the pixel resolution on Z-buffered graphics files.

        Parameters
        ----------
        size
            Pixel resolution.  Defaults to a pixel resolution of 800.  Valid
            values are from 256 to 2400.

        Notes
        -----
        Defines the pixel resolution on subsequently written graphics files
        (Jobname.GRPH) for software Z-buffered displays [/TYPE].  Lowering the
        pixel resolution produces a "fuzzier" image; increasing the resolution
        produces a "sharper" image but takes a little longer.

        This command is valid in any processor.
        """
        command = "/GFILE,%s" % (str(size))
        return self.run(command, **kwargs)

    def hrocean(self, type="", nph_ase="", **kwargs):
        """APDL Command: HROCEAN

        Perform the harmonic ocean wave procedure (HOWP).

        Parameters
        ----------
        type
            Specifies how to include ocean wave information in a harmonic
            analysis:

            HARMONIC - Performs a harmonic analysis using both real and imaginary load vectors
                       calculated via the harmonic ocean wave procedure (HOWP).
                       This behavior is the default. This option performs a
                       harmonic analysis running at a frequency determined by
                       the wave period (specified via OCTABLE command input).

            STATIC - Performs a static analysis using both real and imaginary load vectors
                     (calculated via HOWP). This option works by performing a
                     harmonic analysis running at a frequency of 0.0.

            OFF - Deactivates a previously activated HOWP and performs a standard harmonic
                  analysis.

        nphase
            Positive number specifying the number of phases to calculate
            forces. This value must be at least 8. The default value is 20.

        Notes
        -----
        The HROCEAN command applies ocean wave information (obtained via the
        OCDATA and OCTABLE commands) in a harmonic analysis (ANTYPE,HARMIC) as
        real and imaginary forces.

        You can apply only one ocean load at a time.

        The applied frequency in the harmonic (Type = HARMONIC) analysis is
        based on the wave period input on the OCTABLE command (and not on
        HARFRQ command input, which cannot be used). Phase-shift input on the
        OCTABLE command is ignored.

        HOWP does not generate a damping matrix. If you require a damping
        matrix, you must add it separately.

        The command applies to regular wave types only (Airy with one wave
        component, Wheeler with one wave component, Stokes, and stream
        function). Irregular wave types are not supported. For information
        about wave types, see Hydrodynamic Loads in the Mechanical APDL Theory
        Reference.

        The program calculates the forces on each load component of each
        element at NPHASE solutions, spread evenly over one wave cycle. Then,
        the minimum and maximum, and the phase between them, are calculated.
        The command uses the resulting information to generate the real and
        imaginary loads.

        HOWP cannot be used with stress stiffening.

        HOWP works with the full harmonic analysis method (HROPT,FULL) only.

        For more information, see Harmonic Ocean Wave Procedure (HOWP) in the
        Mechanical APDL Theory Reference.

        This command is also valid in PREP7.
        """
        command = "HROCEAN,%s,%s" % (str(type), str(nph_ase))
        return self.run(command, **kwargs)

    def pcgopt(self, lev_diff ="", reduceio="", strmck="", wrtfull="",
               memory="", lm_key="", **kwargs):
        """APDL Command: PCGOPT

        Controls PCG solver options.

        Parameters
        ----------
        lev_diff
            Indicates the level of difficulty of the analysis. Valid settings
            are AUTO or 0 (default), 1, 2, 3, 4, or 5. This option applies to
            both the PCG solver when used in static and full transient analyses
            and to the PCG Lanczos method in modal analyses. Use AUTO to let
            ANSYS automatically choose the proper level of difficulty for the
            model. Lower values (1 or 2) generally provide the best performance
            for well-conditioned problems. Values of 3 or 4 generally provide
            the best performance for ill-conditioned problems; however, higher
            values may increase the solution time for well-conditioned
            problems. Higher level-of-difficulty values typically require more
            memory. Using the highest value of 5 essentially performs a
            factorization of the global matrix (similar to the sparse solver)
            and may require a very large amount of memory. If necessary, use
            Memory to reduce the memory usage when using  Lev_Diff = 5.
            Lev_Diff = 5 is generally recommended for small- to medium-sized
            problems when using the PCG Lanczos mode extraction method.

        --
            Unused field.

        reduceio
             Controls whether the PCG solver will attempt to reduce I/O
            performed during equation solution:

            AUTO  - Automatically chooses whether to reduce I/O or not (default).

            YES  - Reduces I/O performed during equation solution in order to reduce total solver
                   time.

            NO  - Does NOT reduce I/O performed during equation solution.

        strmck
             Controls whether or not a Sturm sequence check is performed:

            OFF  - Does NOT perform Sturm sequence check (default).

            ON  - Performs Sturm sequence check

        wrtfull
            Controls whether or not the .FULL file is written.

            ON  - Write .FULL file (default)

            OFF  - Do not write .FULL file.

        memory
             Controls whether to run using in-core or out-of-core mode when
            using Lev_Diff = 5.

            AUTO  - Automatically chooses which mode to use (default).

            INCORE  - Run using in-core mode.

            OOC  - Run using out-of-core mode.

        lm_key
             Controls use of the PCG solver for MPC184 Lagrange multiplier
            method elements. This option applies only to the PCG solver when
            used in static and full transient analyses.

            OFF  - Do not use the PCG solver for the MPC184 Lagrange multiplier method (default).

            ON  - Allow use of the PCG solver for the MPC184 Lagrange multiplier method.

        Notes
        -----
        ReduceIO works independently of the MSAVE command in the PCG solver.
        Setting ReduceIO to YES can significantly increase the memory usage in
        the PCG solver.

        To minimize the memory used by the PCG solver with respect to the
        Lev_Diff option only, set  Lev_Diff = 1 if you do not have sufficient
        memory to run the PCG solver with  Lev_Diff = AUTO.

        The MSAVE,ON command is not valid when using  Lev_Diff = 5. In this
        case, the  Lev_Diff value will automatically be reset to 2. The
        MSAVE,ON command is also not valid with the StrmCk   option. In this
        case, StrmCk   will be set to OFF.

        Distributed ANSYS Restriction: The Memory option and the LM_Key option
        are not supported in Distributed ANSYS.
        """
        command = "PCGOPT,%s,%s,%s,%s,%s,%s" % (str(lev_diff ), str(reduceio), str(strmck), str(wrtfull), str(memory), str(lm_key))
        return self.run(command, **kwargs)

    def lina(self, nl="", na="", **kwargs):
        """APDL Command: LINA

        Finds the intersection of a line with an area.

        Parameters
        ----------
        nl
            Number of line to be intersected.  If NL = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).

        na
            Number of area to be intersected.

        Notes
        -----
        Finds the intersection of a line with an area.  New lines will be
        generated where the lines intersect the areas.  If the regions of
        intersection are only points, new keypoints will be generated instead.
        See the Modeling and Meshing Guide for an illustration.  See the BOPTN
        command for the options available to Boolean operations.  Element
        attributes and solid model boundary conditions assigned to the original
        entities will not be transferred to the new entities generated.
        """
        command = "LINA,%s,%s" % (str(nl), str(na))
        return self.run(command, **kwargs)

    def edpvel(self, option="", pid="", vx="", vy="", vz="", omegax="",
               omegay="", omegaz="", xc="", yc="", zc="", angx="", angy="",
               angz="", **kwargs):
        """APDL Command: EDPVEL

        Applies initial velocities to parts or part assemblies in an explicit
        dynamic analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed.

            VGEN - Define initial velocities for the part or part assembly based on translational
                   velocities (relative to global Cartesian) and the rotational
                   velocity about an arbitrary axis. For this option, use the
                   fields VX, VY, VZ to specify the translational velocities,
                   and use OMEGAX, XC, YC, ZC, ANGX, ANGY, ANGZ to specify the
                   rotational velocity and the axis of rotation.

            VELO - Define initial velocity for the part or part assembly based on translational
                   velocities and nodal rotational velocities input relative to
                   the global Cartesian axes. For this option, use the
                   following fields to define the initial velocity: VX, VY, VZ,
                   OMEGAX, OMEGAY, OMEGAZ.

            LIST - List initial velocity for the part or part assembly specified by PID. If PID is
                   blank, all initial velocities defined on parts and part
                   assemblies are listed. Remaining fields are ignored for this
                   option.

            DELE - Delete initial velocity defined for the part or part assembly specified by PID.
                   If PID is blank, all initial velocities defined on parts and
                   part assemblies are deleted. Remaining fields are ignored
                   for this option.

        pid
            Part ID or part assembly ID to which the initial velocity is to be
            applied. The part or assembly ID must be defined (EDPART or EDASMP)
            before issuing this command.

        vx
            Initial velocity in X direction. Defaults to 0.

        vy
            Initial velocity in Y direction. Defaults to 0.

        vz
            Initial velocity in Z direction. Defaults to 0.

        omegax
            For Option = VGEN, OMEGAX is the initial rotational velocity of the
            part or part assembly about the specified rotational axis. For
            Option = VELO, OMEGAX is the initial nodal rotational velocity
            about the X-axis. OMEGAX defaults to 0.

        omegay
            Initial nodal rotational velocity about the Y-axis (used only if
            Option = VELO). Defaults to 0.

        omegaz
            Initial nodal rotational velocity about the Z-axis (used only if
            Option = VELO). Defaults to 0.

        Notes
        -----
        You cannot mix the two methods of initial velocity input (Option = VELO
        and Option = VGEN) in the same analysis. You must use only one method
        for all initial velocity definitions.

        The VGEN and VELO methods differ in how the rotational velocity is
        defined. Use Option = VGEN to input the initial velocities of a
        rotating part or part assembly. Use Option = VELO to apply the
        rotations directly to the nodes' rotation degrees of freedom. Since
        only shell and beam elements have rotation degrees of freedom, the
        rotations input with Option = VELO are only applicable to SHELL163 and
        BEAM161 elements. The rotational velocities input with Option = VELO
        are ignored for nodes not having rotational degrees of freedom (such as
        nodes attached to a SOLID164 or SOLID168 element).

        It is normally acceptable to mix nodes belonging to deformable bodies
        and rigid bodies in the part assembly used in an initial velocity
        definition. However, when defining initial velocities in an implicit-
        to-explicit sequential solution, this is not an acceptable practice. In
        order for the initial velocities to be defined correctly in this type
        of analysis, you must define the initial velocities on the deformable
        body nodes separately from the initial velocities on the rigid body
        nodes.

        Issuing the EDPVEL command again for the same part or part assembly
        (PID) will overwrite previous initial velocities defined for that part
        or part assembly.

        To set the initial velocities to zero, issue the EDPVEL command with
        only the Option (use VELO or VGEN) and PID fields specified.

        In a small restart analysis (EDSTART,2), you can only use the Option =
        VELO method to change initial velocities. When used in a small restart,
        the command EDPVEL,VELO changes the velocity of the specified part or
        part assembly. If you don't change the velocity of the parts and
        assemblies, their velocity at the beginning of the restart will be the
        same as the velocity at the end of the previous analysis.

        Except for the LIST option, the EDPVEL command is not supported in a
        full restart analysis (EDSTART,3). You can list initial velocities
        defined in the previous analysis with the command EDPVEL,LIST. However,
        you cannot change initial velocities for parts that existed in the
        previous analysis; their velocity at the beginning of the analysis will
        be the same as the velocity at the end of the previous analysis. In
        addition, you cannot define initial velocities for any parts that are
        added in the full restart; the velocity of new parts will be zero.

        To apply initial velocities to node components or nodes, use the EDVEL
        command.

        You can use EDPVEL and EDVEL in the same analysis. If a node or node
        component input on the EDVEL command shares common nodes with a part or
        part assembly input on the EDPVEL command, the initial velocities
        defined on the common nodes will be determined by the last command
        input.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDPVEL,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(pid), str(vx), str(vy), str(vz), str(omegax), str(omegay), str(omegaz), str(xc), str(yc), str(zc), str(angx), str(angy), str(angz))
        return self.run(command, **kwargs)

    def edrst(self, nstep="", dt="", **kwargs):
        """APDL Command: EDRST

        Specifies the output interval for an explicit dynamic analysis.

        Parameters
        ----------
        nstep
            Number of steps at which output is written to the results file
            (Jobname.RST). Defaults to 100. When you specify NSTEP, NSTEP+2
            results are written to the Jobname.RST file. The time interval
            between output is TIME / NSTEP, where TIME is the analysis end-time
            specified on the TIME command. Do not specify a value of NSTEP = 0.

        dt
            Time interval at which output is written to the results file
            (Jobname.RST). If NSTEP is input, DT is ignored.

        Notes
        -----
        You can use NSTEP or DT to specify the output interval to be used for
        Jobname.RST. You should not specify both quantities; if both are input,
        NSTEP will be used.

        In an explicit dynamic small restart (EDSTART,2) or full restart
        analysis (EDSTART,3), the EDRST setting will default to the NSTEP or DT
        value used in the original analysis. You can issue EDRST in the restart
        to change this setting.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDRST,%s,%s" % (str(nstep), str(dt))
        return self.run(command, **kwargs)

    def cfclos(self, **kwargs):
        """APDL Command: *CFCLOS

        Closes the "command" file.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "*CFCLOS," % ()
        return self.run(command, **kwargs)

    def assign(self, ident="", fname="", ext="", lgkey="", **kwargs):
        """APDL Command: /ASSIGN

        Reassigns a file name to an ANSYS file identifier.

        Parameters
        ----------
        ident
            ANSYS file name identifier.  Valid identifiers are: CMS, EMAT,
            EROT,  ESAV, FULL, LN07, LN09, LN11, LN20, LN21, LN22, LN25, LN31,
            LN32, MODE, OSAV, RDSP, RFRQ, RMG, RST, RSTP, RTH, SELD, and SSCR.
            See File Management and Files for file descriptions.  If blank,
            list currently reassigned files.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        lgkey
            Key to specify local or global file name control for the specified
            file identifier in a distributed-memory parallel processing
            (Distributed ANSYS) run. For more information on local and global
            files, see File Handling Conventions in the Parallel Processing
            Guide.

            BOTH - Reassign the file name for both the local and global files (default).

            LOCAL - Reassign the file name for only the local files.

            GLOBAL - Reassign the file name for only the global file.

        Notes
        -----
        The reassignment of file names is valid only if it is done before the
        file is used.  All file reassignments are retained (not cleared) even
        if the database is cleared [/CLEAR] or the Jobname is changed
        [/FILNAME].  Assigned files may be overwritten.  If file name arguments
        (Fname, Ext, --) are blank, the default ANSYS assignment is restored.
        Use SEOPT for SUB files and SEEXP for DSUB files.

        This command is valid only at the Begin Level.

        This command also checks to ensure that the path/file is valid and can
        be written by the user. If it is not valid, an error message will be
        returned. Ensure that the directory exists prior to using /ASSIGN
        command.
        """
        command = "/ASSIGN,%s,%s,%s,%s" % (str(ident), str(fname), str(ext), str(lgkey))
        return self.run(command, **kwargs)

    def krefine(self, np1="", np2="", ninc="", level="", depth="", post="",
                retain="", **kwargs):
        """APDL Command: KREFINE

        Refines the mesh around specified keypoints.

        Parameters
        ----------
        np1, np2, ninc
            Keypoints (NP1 to NP2 in increments of NINC) around which the mesh
            is to be refined.  NP2 defaults to NP1, and NINC defaults to 1.  If
            NP1 = ALL, NP2 and NINC are ignored and all selected keypoints are
            used for refinement.  If NP1 = P, graphical picking is enabled and
            all remaining command fields are ignored (valid only in the GUI).
            A component name may also be substituted for NP1 (NP2 and NINC are
            ignored).

        level
            Amount of refinement to be done.  Specify the value of LEVEL as an
            integer from 1 to 5, where a value of 1 provides minimal
            refinement, and a value of 5 provides maximum refinement (defaults
            to 1).

        depth
            Depth of mesh refinement in terms of the number of elements outward
            from the indicated keypoints (defaults to 1).

        post
            Type of postprocessing to be done after element splitting, in order
            to improve element quality:

            OFF - No postprocessing will be done.

            SMOOTH - Smoothing will be done.  Node locations may change.

            CLEAN - Smoothing and cleanup will be done.  Existing elements may be deleted, and node
                    locations may change (default).

        retain
            Flag indicating whether quadrilateral elements must be retained in
            the refinement of an all-quadrilateral mesh.  (The ANSYS program
            ignores the RETAIN argument when you are refining anything other
            than a quadrilateral mesh.)

            ON - The final mesh will be composed entirely of quadrilateral elements, regardless
                 of the element quality (default).

            OFF - The final mesh may include some triangular elements in order to maintain
                  element quality and provide transitioning.

        Notes
        -----
        KREFINE performs local mesh refinement around the specified keypoints.
        By default, the indicated elements are split to create new elements
        with 1/2 the edge length of the original elements (LEVEL = 1).

        KREFINE refines all area elements and tetrahedral volume elements that
        are adjacent to the specified keypoints.  Any volume elements that are
        adjacent to the specified keypoints, but are not tetrahedra (for
        example, hexahedra, wedges, and pyramids), are not refined.

        You cannot use mesh refinement on a solid model that contains initial
        conditions at nodes [IC], coupled nodes [CP family of commands],
        constraint equations [CE family of commands], or boundary conditions or
        loads applied directly to any of its nodes or elements.  This applies
        to nodes and elements anywhere in the model, not just in the region
        where you want to request mesh refinement.  See Revising Your Model in
        the Modeling and Meshing Guide for additional restrictions on mesh
        refinement.

        This command is also valid for rezoning.
        """
        command = "KREFINE,%s,%s,%s,%s,%s,%s,%s" % (str(np1), str(np2), str(ninc), str(level), str(depth), str(post), str(retain))
        return self.run(command, **kwargs)

    def sqrt(self, ir="", ia="", name="", facta="", **kwargs):
        """APDL Command: SQRT

        Forms the square root of a variable.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        ia
            Reference number of the variable to be operated on.

        --, --
            Unused fields.

        name
            Thirty-two character name identifying the variable on printouts and
            displays.  Embedded blanks are compressed for output.

        --, --
            Unused fields.

        facta
            Scaling factor (positive or negative) applied to variable IA
            (defaults to 1.0).

        Notes
        -----
        Forms the square root of a variable according to the operation:
        """
        command = "SQRT,%s,%s,%s,%s" % (str(ir), str(ia), str(name), str(facta))
        return self.run(command, **kwargs)

    def vardel(self, nvar="", **kwargs):
        """APDL Command: VARDEL

        Deletes a variable (GUI).

        Parameters
        ----------
        nvar
            The reference number of the variable to be deleted.  NVAR is as
            defined by NSOL, ESOL, etc.

        Notes
        -----
        Deletes a POST26 solution results variable.  This is a command
        generated by the Graphical User Interface (GUI).  It will appear in the
        log file (Jobname.LOG) if a POST26 variable is deleted from the
        "Defined Time-History Variables" dialog box.  This command is not
        intended to be typed in directly in an ANSYS session (although it can
        be included in an input file for batch input or for use with the /INPUT
        command).
        """
        command = "VARDEL,%s" % (str(nvar))
        return self.run(command, **kwargs)

    def rdec(self, option ="", reduc ="", nplace ="", **kwargs):
        """APDL Command: RDEC

        Defines the decimation parameters.

        Parameters
        ----------
        option
            Command options:

            DEFINE  - Defines the decimation parameters (default).

            STAT - Shows the status/listing. Other command options are ignored.

        reduc
            Approximate reduction in the number of surface elements. Valid
            range is from 0.0 (no decimation, the default) to 1.0. This number
            is a factor applied to the initial number of element radiosity
            surfaces.

        --
            Unused field.

        nplace
            Node placement algorithm

            OPTI  - Optimal placement. An edge is collapsed by moving both nodes (I and J in the
                    figure below) to a new location.

            SUBS  - Subset placement. An edge is collapsed by moving one node to another one. In
                    the figure below, node I is moved to node J.

        Notes
        -----
        Decimation is the process of simplifying a fine surface mesh into a
        coarse one. This process is accomplished by a sequence of edge
        collapses.

        The maximum degree of decimation (1.0) is unreachable. The real degree
        of decimation is always less than 1.0 because the decimated mesh must
        always consist of at least one element.
        """
        command = "RDEC,%s,%s,%s" % (str(option ), str(reduc ), str(nplace ))
        return self.run(command, **kwargs)

    def ernorm(self, key="", **kwargs):
        """APDL Command: ERNORM

        Controls error estimation calculations.

        Parameters
        ----------
        key
            Control key:

            ON - Perform error estimation (default). This option is not valid for PowerGraphics.

            OFF - Do not perform error estimation.

        Notes
        -----
        Especially for thermal analyses, program speed increases if error
        estimation is suppressed.  Therefore, it might be desirable to use
        error estimation only when needed.  The value of the ERNORM key is not
        saved on file.db. Consequently, you need to reissue the ERNORM key
        after a RESUME if you wish to deactivate error estimation again.
        """
        command = "ERNORM,%s" % (str(key))
        return self.run(command, **kwargs)

    def edis(self, option="", pidn="", pido="", **kwargs):
        """APDL Command: EDIS

        Specifies stress initialization in an explicit dynamic full restart
        analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed.

            ADD - Define stress initialization between parts (default).

        pidn
            New part ID or part assembly ID in the full restart analysis
            (defaults to all parts in the model).

        pido
            Old part ID or part assembly ID in the previous analysis, (default
            to PIDN).

        Notes
        -----
        The EDIS command is only valid in an explicit dynamic full restart
        analysis (EDSTART,3). (EDIS is ignored if it is not preceded by the
        EDSTART,3 command.) Use EDIS to specify which parts and/or part
        assemblies should undergo stress initialization in the restart based on
        the stresses from the previous analysis. You can specify stress
        initialization for multiple parts (or part assemblies) by issuing EDIS
        multiple times. If you issue EDIS with no arguments, stress
        initialization is performed for all parts in the restart analysis that
        have a corresponding part (having the same part ID) in the previous
        analysis.

        In a full restart analysis, the complete database is written as an LS-
        DYNA input file, Jobname_nn.K. When the LS-DYNA solution begins, LS-
        DYNA performs the stress initialization using file Jobname_nn.K and the
        restart dump file (d3dumpnn specified on the EDSTART command) from the
        previous analysis. At the end of initialization, all the parts that
        were specified by the EDIS commands are initialized from the data saved
        in the restart dump file. In order for the stress initialization to be
        performed successfully, the new parts in the full restart analysis and
        the old parts in the previous analysis must have the same number of
        elements, same element order, and same element topology. (The parts may
        have different identifying numbers.) If this is not the case, the
        stresses cannot be initialized. If part assemblies are used, the part
        assemblies must contain the same number of parts. (See A Full Restart
        in the ANSYS LS-DYNA User's Guide for more details).

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDIS,%s,%s,%s" % (str(option), str(pidn), str(pido))
        return self.run(command, **kwargs)

    def ratio(self, wn="", ratox="", ratoy="", **kwargs):
        """APDL Command: /RATIO

        Distorts the object geometry.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        ratox
            Distort object in the window X direction by this factor (defaults
            to 1.0).

        ratoy
            Distort object in the window Y direction by this factor (defaults
            to 1.0).

        Notes
        -----
        Distorts the object geometry in a particular direction.  An example of
        this command's use would be to allow long narrow sections to be
        distorted to a more square area for better display visualization.

        This command is valid in any processor.
        """
        command = "/RATIO,%s,%s,%s" % (str(wn), str(ratox), str(ratoy))
        return self.run(command, **kwargs)

    def thopt(self, refopt="", reformtol="", ntabpoints="", tempmin="",
              tempmax="", algo="", **kwargs):
        """APDL Command: THOPT

        Specifies nonlinear transient thermal solution options.

        Parameters
        ----------
        refopt
            Matrix reform option.

            FULL - Use the full Newton-Raphson solution option (default). All subsequent input
                   values are ignored.

            QUASI - Use a selective reform solution option based on REFORMTOL.

        reformtol
            Property change tolerance for Matrix Reformation (.05 default). The
            thermal matrices are reformed if the maximum material property
            change in an element (from the previous reform time) is greater
            than the reform tolerance. Valid only when Refopt = QUASI.

        ntabpoints
            Number of points in Fast Material Table (64 default). Valid only
            when Refopt = QUASI.

        tempmin
            Minimum temperature for Fast Material Table. Defaults to the
            minimum temperature defined by the MPTEMP command for any material
            property defined. Valid only when Refopt = QUASI.

        tempmax
            Maximum temperature for Fast Material Table. Defaults to the
            maximum temperature defined by the MPTEMP command for any material
            property defined. Valid only when Refopt = QUASI.

        --
            Reserved field.

        algo
            Specifies which solution algorithm to apply:

            0 - Multipass (default).

            1 - Iterative.

        Notes
        -----
        The QUASI matrix reform option is supported by the ICCG, JCG, and
        sparse solvers only (EQSLV).

        For Refopt = QUASI:

        Results from a restart may be different than results from a single run
        because the stiffness matrices are always recreated in a restart run,
        but may or may not be in a single run (depending on the behavior
        resulting from the REFORMTOL setting). Additionally, results may differ
        between two single runs as well, if the matrices are reformed as a
        result of the REFORMTOL setting.

        Midside node temperatures are not calculated if 20-node thermal solid
        elements (SOLID90 or SOLID279) are used.

        For more information, see Solution Algorithms Used in Transient Thermal
        Analysis in the Thermal Analysis Guide.
        """
        command = "THOPT,%s,%s,%s,%s,%s,%s" % (str(refopt), str(reformtol), str(ntabpoints), str(tempmin), str(tempmax), str(algo))
        return self.run(command, **kwargs)

    def esll(self, type="", **kwargs):
        """APDL Command: ESLL

        Selects those elements associated with the selected lines.

        Parameters
        ----------
        type
            Label identifying the type of element select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        Notes
        -----
        Selects line elements belonging to meshed [LMESH], selected [LSEL]
        lines.

        This command is valid in any processor.
        """
        command = "ESLL,%s" % (str(type))
        return self.run(command, **kwargs)

    def cmdomega(self, cm_name="", domegax="", domegay="", domegaz="", x1="",
                 y1="", z1="", x2="", y2="", z2="", **kwargs):
        """APDL Command: CMDOMEGA

        Specifies the rotational acceleration of an element component about a
        user-defined rotational axis.

        Parameters
        ----------
        cm_name,
            The name of the element component.

        domegax, domegay, domegaz
            If the X2, Y2, Z2 fields are not defined, DOMEGAX, DOMEGAY, and
            DOMEGAZ specify the components of the rotational acceleration
            vector in the global Cartesian X, Y, Z directions.

        x1, y1, z1
            If the X2, Y2, Z2 fields are defined, X1, Y1, and Z1 define the
            coordinates of the beginning point of the rotational axis vector.
            Otherwise, X1, Y1, and Z1 are the coordinates of a point through
            which the rotational axis passes.

        x2, y2, z2
            The coordinates of the end point of the rotational axis vector.

        Notes
        -----
        Specifies the rotational acceleration components DOMEGAX, DOMEGAY, and
        DOMEGAZ of an element component CM_NAME about a user-defined rotational
        axis. The rotational axis can be defined either as a vector passing
        through a single point, or a vector connecting two points.

        You can define the rotational acceleration and rotational axis with the
        CMDOMEGA command for STATIC, HARMIC, TRANS, and SUBSTR analyses.
        Rotational velocities are combined with the element mass matrices to
        form a body force load vector term. Units are radians/time2.

        The CMDOMEGA command supports tabular boundary conditions (%TABNAME_X%,
        %TABNAME_Y%, and %TABNAME_Z%) for CMDOMEGA_X, CMDOMEGA_Y, and
        CMDOMEGA_Z input values (*DIM) for full transient and harmonic
        analyses.

        Related commands are ACEL, CGLOC, CGLOC, OMEGA, CMOMEGA, DCGOMG,
        DOMEGA.

        See Analysis Tools in the Mechanical APDL Theory Reference for more
        information.

        You can use the CMDOMEGA command in conjunction with any one of the
        following two groups of commands, but not with both groups
        simultaneously:

        Components for which you want to specify rotational loading must
        consist of elements only. The elements you use cannot be part of more
        than one component, and elements that share nodes cannot exist in
        different element components. You cannot apply the loading to an
        assembly of element components.

        In a modal harmonic or transient analysis, you must apply the load in
        the modal portion of the analysis. Mechanical APDL calculates a load
        vector and writes it to the mode shape file, which you can apply via
        the LVSCALE command.

        See Acceleration Effect in the Mechanical APDL Theory Reference for
        more information.

        This command is also valid in PREP7.
        """
        command = "CMDOMEGA,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(cm_name), str(domegax), str(domegay), str(domegaz), str(x1), str(y1), str(z1), str(x2), str(y2), str(z2))
        return self.run(command, **kwargs)

    def cerig(self, m_aste="", slave="", ldof="", ldof2="", ldof3="", ldof4="",
              ldof5="", **kwargs):
        """APDL Command: CERIG

        Defines a rigid region.

        Parameters
        ----------
        maste
            Retained (or master) node for this rigid region.  If MASTE = P,
            then graphical picking of the master and slave nodes is enabled
            (first node picked will be the master node, and subsequent nodes
            picked will be slave  nodes), and subsequent fields are ignored
            (valid only in GUI).

        slave
            Removed (or slave) node for this rigid region.  If ALL, slave nodes
            are all selected nodes.

        ldof
            Degrees of freedom associated with equations:

            ALL - All applicable degrees of freedom (default).  If 3-D, generate 6 equations
                  based on UX, UY, UZ, ROTX, ROTY, ROTZ;  if 2-D, generate 3
                  equations based on UX, UY, ROTZ.

            UXYZ - Translational degrees of freedom.  If 3-D, generate 3 equations based on the
                   slave nodes' UX, UY, and UZ DOFs and the master node's UX,
                   UY, UZ, ROTX, ROTY, and ROTZ DOFs;  if 2-D, generate 2
                   equations based on the slave nodes UX and UY DOFs and the
                   master nodes UX, UY, and ROTZ DOFs.  No equations are
                   generated for the rotational coupling.

            RXYZ - Rotational degrees of freedom.  If 3-D, generate 3 equations based on ROTX,
                   ROTY, ROTZ;  if 2-D, generate 1 equation based on ROTZ.  No
                   equations are generated for the translational coupling.

            UX - Slave translational UX degree of freedom only.

            UY - Slave translational UY degree of freedom only.

            UZ - Slave translational UZ degree of freedom only.

            ROTX - Slave rotational ROTX degree of freedom only.

            ROTY - Slave rotational ROTY degree of freedom only.

            ROTZ - Slave rotational ROTZ degree of freedom only.

        ldof2, ldof3, ldof4, ldof5
            Additional degrees of freedom.  Used only if more than one degree
            of freedom required and Ldof is not ALL, UXYZ, or RXYZ.

        Notes
        -----
        Defines a rigid region (link, area or volume) by automatically
        generating constraint equations to relate nodes in the region.  Nodes
        in the rigid region must be assigned a geometric location before this
        command is used.  Also, nodes must be connected to elements having the
        required degree of freedom set (see Ldof above).  Generated constraint
        equations are based on small deflection theory.  Generated constraint
        equations are numbered beginning from the highest previously defined
        equation number (NEQN) plus 1.  Equations, once generated, may be
        listed [CELIST] or modified [CE] as desired.  Repeat CERIG command for
        additional rigid region equations.

        This command will generate the constraint equations needed for defining
        rigid lines in 2-D or 3-D space.  Multiple rigid lines relative to a
        common point are used to define a rigid area or a rigid volume.  In 2-D
        space, with Ldof = ALL, three equations are generated for each pair of
        constrained nodes.  These equations define the three rigid body motions
        in global Cartesian space, i.e., two in-plane translations and one in-
        plane rotation.  These equations assume the X-Y plane to be the active
        plane with UX, UY, and ROTZ degrees of freedom available at each node.
        Other types of equations can be generated with the appropriate Ldof
        labels.

        Six equations are generated for each pair of constrained nodes in 3-D
        space (with Ldof = ALL).  These equations define the six rigid body
        motions in global Cartesian space.  These equations assume that UX, UY,
        UZ, ROTX, ROTY, and ROTZ degrees of freedom are available at each node.

        The UXYZ label allows generating a partial set of rigid region
        equations.  This option is useful for transmitting the bending moment
        between elements having different degrees of freedom at a node.  With
        this option only two of the three equations are generated for each pair
        of constrained nodes in 2-D space.  In 3-D space, only three of the six
        equations are generated.  In each case the rotational coupling
        equations are not generated.  Similarly, the RXYZ label allows
        generating a partial set of equations with the translational coupling
        equations omitted.

        Applying this command to a large number of slave nodes may result in
        constraint equations with a large number of coefficients. This may
        significantly increase the peak memory required during the process of
        element assembly. If real memory or virtual memory is not available,
        consider reducing the number of slave nodes.

        Note that under certain circumstances the constraint equations
        generated by CERIG may be modified during the solution. See Program
        Modification of Constraint Equations for more information.

        As an alternative to the CERIG command, you can define a similar type
        of rigid region using contact elements and the internal multipoint
        constraint (MPC) algorithm. See Surface-Based Constraints for more
        information.

        CERIG cannot be deleted using CEDELE,ALL and then regenerated in the
        second or higher load steps if the LSWRITE  and LSSOLVE procedure is
        used. CERIG writes constraint equations directly into load step files.
        Deleting constraint equations (CEDELE,ALL) cannot always maintain the
        consistency among load steps.
        """
        command = "CERIG,%s,%s,%s,%s,%s,%s,%s" % (str(m_aste), str(slave), str(ldof), str(ldof2), str(ldof3), str(ldof4), str(ldof5))
        return self.run(command, **kwargs)

    def gmarker(self, curve="", key="", incr="", **kwargs):
        """APDL Command: /GMARKER

        Specifies the curve marking style.

        Parameters
        ----------
        curve
            Curve number markers will be applied on (integer value between 1
            and 10).

        key
            Marker key:

            0 - No markers will be applied (default).

            1 - TRIANGLES will be applied.

            2 - SQUARES will be applied.

            3 - DIAMONDS  will be applied.

            4 - CROSSES will be applied.

        incr
            Determines the curve marking frequency. (a whole number value
            between 1 and 255). If INCR = 1, markers are displayed at every
            data point on the curve. If INCR = 2 then markers are displayed at
            every second data point. If INCR = 3 then they are displayed at
            every third data point.

        Notes
        -----
        The user-specified markers will not be drawn when the area under the
        curve is color-filled (/GROPT, FILL).
        """
        command = "/GMARKER,%s,%s,%s" % (str(curve), str(key), str(incr))
        return self.run(command, **kwargs)

    def erase(self, **kwargs):
        """APDL Command: ERASE

        Explicitly erases the current display.

        Notes
        -----
        Similar to a hardware screen erase key. Useful during an "immediate"
        display to erase the screen without a replot so that the display
        continues on a clean screen. This action is automatically included in
        commands such as NPLOT and EPLOT.

        If the /NOERASE command is active, issuing the erase command will
        simply clear the display area. Subsequent replots will provide the
        display previously generated by the /NOERASE command.

        This command is valid in any processor.
        """
        command = "ERASE," % ()
        return self.run(command, **kwargs)

    def alist(self, na1="", na2="", ninc="", lab="", **kwargs):
        """APDL Command: ALIST

        Lists the defined areas.

        Parameters
        ----------
        na1, na2, ninc
            List areas from NA1 to NA2 (defaults to NA1) in steps of NINC
            (defaults to 1).  If NA1 = ALL (default), NA2 and NINC are ignored
            and all selected areas [ASEL] are listed.  If NA1 = P, graphical
            picking is enabled and all remaining arguments are ignored (valid
            only in the GUI).  A component name may also be substituted for NA1
            (NA2 and NINC are ignored).

        lab
            Determines what type of listing is used (one of the following):

            (blank) - Prints information about all areas in the specified range.

            HPT - Prints information about only those areas that contain hard points.

        Notes
        -----
        An attribute (TYPE, MAT, REAL, or ESYS) listed as a zero is unassigned;
        one listed as a positive value indicates that the attribute was
        assigned with the AATT command (and will not be reset to zero if the
        mesh is cleared); one listed as a negative value indicates that the
        attribute was assigned using the attribute pointer [TYPE, MAT, REAL, or
        ESYS] that was active during meshing (and will be reset to zero if the
        mesh is cleared).  A "-1" in the "nodes" column indicates that the area
        has been meshed but there are no interior nodes.  The area size is
        listed only if an ASUM command has been performed on the area.
        """
        command = "ALIST,%s,%s,%s,%s" % (str(na1), str(na2), str(ninc), str(lab))
        return self.run(command, **kwargs)

    def fctyp(self, oper="", lab="", **kwargs):
        """APDL Command: FCTYP

        Activates or removes failure-criteria types for postprocessing.

        Parameters
        ----------
        oper
            Operation key:

            ADD - Activate failure-criteria types. This option is the default behavior.

            DELE - Remove failure-criteria types.

        lab
            Valid failure-criteria labels. If ALL, select all available
            (including user-defined) failure criteria.

            EMAX - Maximum strain criterion (default)

            SMAX - Maximum stress criterion (default)

            TWSI  - Tsai-Wu strength index (default)

            TWSR  - Inverse of Tsai-Wu strength ratio index (default)

            HFIB  - Hashin fiber failure criterion

            HMAT  - Hashin matrix failure criterion

            PFIB  - Puck fiber failure criterion

            PMAT  - Puck inter-fiber (matrix) failure criterion

            L3FB - LaRc03 fiber failure criterion

            L3MT - LaRc03 matrix failure criterion

            L4FB - LaRc04 fiber failure criterion

            L4MT - LaRc04 matrix failure criterion

            USR1 through USR9  - User-defined failure criteria

        Notes
        -----
        The FCTYP command modifies the list of active failure criteria.

        By default, active failure criteria include EMAX, SMAX, TWSI, and TWSR.

        The command affects any subsequent postprocessing listing and plotting
        commands (such as PRESOL, PRNSOL, PLESOL, PLNSOL, and ETABLE).

        A single FCTYP command allows up to six failure-criteria labels. If
        needed, reissue the command to activate or remove additional failure-
        criteria types.
        """
        command = "FCTYP,%s,%s" % (str(oper), str(lab))
        return self.run(command, **kwargs)

    def vinv(self, nv1="", nv2="", nv3="", nv4="", nv5="", nv6="", nv7="",
             nv8="", nv9="", **kwargs):
        """APDL Command: VINV

        Finds the intersection of volumes.

        Parameters
        ----------
        nv1, nv2, nv3, . . . , nv9
            Numbers of volumes to be intersected.  If NV1 = ALL, NV2 to NV9 are
            ignored, and the intersection of all selected volumes is found.  If
            NV1 = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI).  A component name may
            also be substituted for NV1.

        Notes
        -----
        Finds the common (not pairwise) intersection of volumes.  The common
        intersection is defined as the regions shared (in common) by all
        volumes listed on this command.  New volumes will be generated where
        the original volumes intersect.  If the regions of intersection are
        only areas, new areas will be generated instead.  See the Modeling and
        Meshing Guide for an illustration.  See the BOPTN command for an
        explanation of the options available to Boolean operations.  Element
        attributes and solid model boundary conditions assigned to the original
        entities will not be transferred to the new entities generated.
        """
        command = "VINV,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nv1), str(nv2), str(nv3), str(nv4), str(nv5), str(nv6), str(nv7), str(nv8), str(nv9))
        return self.run(command, **kwargs)

    def expass(self, key="", **kwargs):
        """APDL Command: EXPASS

        Specifies an expansion pass of an analysis.

        Parameters
        ----------
        key
            Expansion pass key:

            OFF - No expansion pass will be performed (default).

            ON - An expansion pass will be performed.

        Notes
        -----
        Specifies that an expansion pass of a modal, substructure, buckling,
        transient, or harmonic analysis is to be performed.

        Note:: : This separate solution pass requires an explicit FINISH to
        preceding analysis and reentry into SOLUTION.

        This command is also valid in PREP7.
        """
        command = "EXPASS,%s" % (str(key))
        return self.run(command, **kwargs)

    def etlist(self, ityp1="", ityp2="", inc="", **kwargs):
        """APDL Command: ETLIST

        Lists currently defined element types.

        Parameters
        ----------
        ityp1, ityp2, inc
            Lists element types from ITYP1 to ITYP2 (defaults to ITYP1) in
            steps of INC (defaults to 1). If ITYP1 = ALL (default), ITYP2 and
            INC are ignored and all element types are listed.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "ETLIST,%s,%s,%s" % (str(ityp1), str(ityp2), str(inc))
        return self.run(command, **kwargs)

    def real(self, nset="", **kwargs):
        """APDL Command: REAL

        Sets the element real constant set attribute pointer.

        Parameters
        ----------
        nset
            Assign this real constant set number to subsequently defined
            elements (defaults to 1).

        Notes
        -----
        Identifies the real constant set number to be assigned to subsequently
        defined elements.  This number refers to the real constant set number
        (NSET) defined with the real constant sets [R].  Real constant set
        numbers may be displayed [/PNUM].  If the element type requires no real
        constants, this entry is ignored.  Elements of different type should
        not refer to the same real constant set.
        """
        command = "REAL,%s" % (str(nset))
        return self.run(command, **kwargs)

    def cbmd(self, row="", c_r__r_="", c_r__r_plus_1_="", c_r__r_plus_2_="",
             c_r__r_plus_3_="", c_r__r_plus_4_="", c_r__r_plus_5_="",
             **kwargs):
        """APDL Command: CBMD

        Specifies preintegrated section mass matrix for composite-beam
        sections.

        Parameters
        ----------
        row
            Row number of the matrix.

        c(r)(r), . . . , c(r)(r+5)
            Upper triangle of the cross-section mass matrix [C].

        Notes
        -----
        With a unit beam length, the section mass matrix relates the resultant
        forces and torques to accelerations and angular accelerations as
        follows (applicable to the local element coordinate system):

        The CBMD command, one of several composite beam section commands,
        specifies the section mass matrix (submatrix [C] data) for a composite
        beam section. The section data defined is associated with the section
        most recently defined (SECTYPE) at the specified temperature (CBTMP).

        Unspecified values default to zero.

        Related commands are CBTMP, CBTE, and CBMX.

        For complete information, see Using Preintegrated Composite Beam
        Sections.
        """
        command = "CBMD,%s,%s,%s,%s,%s,%s,%s" % (str(row), str(c_r__r_), str(c_r__r_plus_1_), str(c_r__r_plus_2_), str(c_r__r_plus_3_), str(c_r__r_plus_4_), str(c_r__r_plus_5_))
        return self.run(command, **kwargs)

    def imesh(self, laky="", nsla="", ntla="", kcn="", dx="", dy="", dz="",
              tol="", **kwargs):
        """APDL Command: IMESH

        Generates nodes and interface elements along lines or areas.

        Parameters
        ----------
        laky
            Copies mesh according to the following:

            LINE or 1 - Copies line mesh (default).

            AREA or 2 - Copies area mesh.

        nsla
            Number that identifies the source line or area. This is the line or
            area whose mesh will provide the pattern for the interface
            elements. ANSYS copies the pattern of the line or area elements
            through the area or volume to create the mesh of area or volume
            interface elements.

        ntla
            Number that identifies the target line or area. This is the line or
            area that is opposite the source line or area specified by NSLA.
            Add NTLA to obtain the copied mesh from the source line or area.

        kcn
            Number that identifies the particular ANSYS coordinate system.

        dx, dy, dz
            Incremental translation of node coordinates in the active
            coordinate system (DR, Dθ, DZ for cylindrical, and DR, Dθ, DΦ for
            spherical or toroidal). The source line or area coordinates + DX,
            DY, DZ = the target line or area coordinates. If left blank, ANSYS
            automatically estimates the incremental translation.

        tol
            Tolerance for verifying topology and geometry. By default, ANSYS
            automatically calculates the tolerance based on associated
            geometries.

        Notes
        -----
        Generates nodes and interface elements along lines or areas. The IMESH
        command requires that the target line or area exactly match the source
        line or area. Also, both target and source lines or areas must be in
        the same area or volume. The area or volume containing the source line
        or area must be meshed before executing IMESH, while the area or volume
        containing the target line or area must be meshed after executing
        IMESH.

        For three dimensional problems where LAKY = AREA, ANSYS fills the
        interface layer according to the following table:
        """
        command = "IMESH,%s,%s,%s,%s,%s,%s,%s,%s" % (str(laky), str(nsla), str(ntla), str(kcn), str(dx), str(dy), str(dz), str(tol))
        return self.run(command, **kwargs)

    def afillt(self, na1="", na2="", rad="", **kwargs):
        """APDL Command: AFILLT

        Generates a fillet at the intersection of two areas.

        Parameters
        ----------
        na1
            Number of the first intersecting area.  If NA1 = P, graphical
            picking is enabled and all remaining arguments are ignored (valid
            only in the GUI).

        na2
            Number of the second intersecting area.

        rad
            Radius of fillet to be generated.

        Notes
        -----
        Generates an area of constant fillet radius at the intersection of two
        areas using a series of Boolean operations.  Corresponding lines and
        keypoints are also generated.  See BOPTN command for an explanation of
        the options available to Boolean operations.  If areas do not initially
        intersect at a common line, use the AINA command.
        """
        command = "AFILLT,%s,%s,%s" % (str(na1), str(na2), str(rad))
        return self.run(command, **kwargs)

    def torus(self, rad1="", rad2="", rad3="", theta1="", theta2="", **kwargs):
        """APDL Command: TORUS

        Creates a toroidal volume.

        Parameters
        ----------
        rad1, rad2, rad3
            Three values that define the radii of the torus.  You can specify
            the radii in any order.  The smallest of the values is the inner
            minor radius, the intermediate value is the outer minor radius, and
            the largest value is the major radius.  (There is one exception
            regarding the order of the radii values--if you want to create a
            solid torus, specify zero or blank for the inner minor radius, in
            which case the zero or blank must occupy either the RAD1 or RAD2
            position.)  At least two of the values that you specify must be
            positive values; they will be used to define the outer minor radius
            and the major radius.  See the diagram in the Notes section for a
            view of a toroidal sector showing all radii.

        theta1, theta2
            Starting and ending angles (either order) of the torus.  Used for
            creating a toroidal sector.  The sector begins at the algebraically
            smaller angle, extends in a positive angular direction, and ends at
            the larger angle.  The starting angle defaults to 0° and the ending
            angle defaults to 360°.

        Notes
        -----
        Defines a toroidal volume centered about the working plane origin.  A
        solid torus of 360° will be defined with four areas, each area spanning
        180° around the major and minor circumference.

        To create the toroidal sector shown below, the command
        TORUS,5,1,2,0,180 was issued.  Since "1" was the smallest radii value
        specified, it defined the inner minor radius; since "2" was the
        intermediate radii value specified, it defined the outer minor radius;
        and since "5" was the largest radii value specified, it defined the
        major radius.  The values "0" and "180" defined the starting and ending
        angles of the torus.
        """
        command = "TORUS,%s,%s,%s,%s,%s" % (str(rad1), str(rad2), str(rad3), str(theta1), str(theta2))
        return self.run(command, **kwargs)

    def vabs(self, kabsr="", kabs1="", kabs2="", kabs3="", **kwargs):
        """APDL Command: *VABS

        Applies the absolute value function to array parameters.

        Parameters
        ----------
        kabsr
            Absolute value of results parameter:

            Do not take absolute value of results parameter (ParR). - Take absolute value.

        kabs1
            Absolute value of first parameter:

            Do not take absolute value of first parameter (Par1 or ParI). - Take absolute value.

        kabs2
            Absolute value of second parameter:

            Do not take absolute value of second parameter (Par2 or ParJ). - Take absolute value.

        kabs3
            Absolute value of third parameter:

            Do not take absolute value of third parameter (Par3 or ParK). - Take absolute value.

        Notes
        -----
        Applies an absolute value to parameters used in certain  *VXX and  *MXX
        operations.  Typical absolute value applications are of the form:

        ParR = |f(|Par1|)|

        or

        ParR = |(|Par1| o |Par2|)|

        The absolute values are applied to each input parameter value before
        the operation and to the result value after the operation.  Absolute
        values are applied before the scale factors so that negative scale
        factors may be used.  The absolute value settings are reset to the
        default (no absolute value) after each *VXX or *MXX operation.  Use
        *VSTAT to list settings.

        This command is valid in any processor.
        """
        command = "*VABS,%s,%s,%s,%s" % (str(kabsr), str(kabs1), str(kabs2), str(kabs3))
        return self.run(command, **kwargs)

    def lfillt(self, nl1="", nl2="", rad="", pcent="", **kwargs):
        """APDL Command: LFILLT

        Generates a fillet line between two intersecting lines.

        Parameters
        ----------
        nl1
            Number of the first intersecting line.  If NL1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).

        nl2
            Number of the second intersecting line.

        rad
            Radius of fillet to be generated.  Radius should be less than the
            lengths of the two lines specified with NL1 and NL2.

        pcent
            Number to be assigned to generated keypoint at fillet arc center.
            If zero (or blank), no keypoint is generated.

        Notes
        -----
        Generates a fillet line between two intersecting lines NL1 (P1-PINT)
        and NL2 (P2-PINT).  Three keypoints may be generated, two at the fillet
        tangent points (PTAN1 and PTAN2) and one (optional) at the fillet arc
        center (PCENT).  Line P1-PINT becomes P1-PTAN1, P2-PINT becomes
        P2-PTAN2, and new arc line PTAN1-PTAN2 is generated.  Generated
        keypoint and line numbers are automatically assigned (beginning with
        the lowest available values [NUMSTR]).  Line divisions are set to zero
        (use LESIZE, etc. to modify).
        """
        command = "LFILLT,%s,%s,%s,%s" % (str(nl1), str(nl2), str(rad), str(pcent))
        return self.run(command, **kwargs)

    def compress(self, **kwargs):
        """APDL Command: COMPRESS

        Deletes all specified sets.

        Notes
        -----
        Issue this command to delete all sets specified with the DELETE
        command.
        """
        command = "COMPRESS," % ()
        return self.run(command, **kwargs)

    def rmanl(self, fname="", ext="", dimn="", oper="", **kwargs):
        """APDL Command: RMANL

        Assigns model database, dimensionality, and operating direction for the
        ROM method.

        Parameters
        ----------
        fname
            Database file name and directory path  (248 characters maximum,
            including directory). The file name defaults to Jobname.

        ext
            File extension (8 character maximum). The extension defaults to db.

        --
            Unused field.

        dimn
            Model dimensionality:

            2 - 2-D models

            3 - 3-D Models

        oper
            Primary operating direction:

            X - direction

            Y - direction

            Z - direction

        Notes
        -----
        Required Inputs:

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMANL,%s,%s,%s,%s" % (str(fname), str(ext), str(dimn), str(oper))
        return self.run(command, **kwargs)

    def vfill(self, parr="", func="", con1="", con2="", con3="", con4="",
              con5="", con6="", con7="", con8="", con9="", con10="", **kwargs):
        """APDL Command: *VFILL

        Fills an array parameter.

        Parameters
        ----------
        parr
            The name of the resulting numeric array parameter vector.  See *SET
            for name restrictions.

        func
            Fill function:

            Assign specified values CON1, CON2, etc. to successive array elements.  Up to 10 assignments may be made at a time.  Any CON values after a blank CON value are ignored. - Assign ramp function values: CON1+((n-1)*CON2) , where n is the loop number
                              [*VLEN].  To specify a constant function (no
                              ramp), set CON2 to zero.

            Assign random number values based on a uniform distribution RAND(CON1,CON2), where: - Assign random sample of Gaussian distributions GDIS(CON1,CON2) where:

            Assigns random number values based on a triangular distribution TRIA(CON1,CON2,CON3) where: - Assigns random number values based on a beta distribution
                              BETA(CON1,CON2,CON3,CON4) where:

            Assigns random number values based on a gamma distribution: GAMM(CON1,CON2,CON3) where: - Generates the rigid body modes with respect to the reference point coordinates
                              (CON1, CON2, CON3). The dimensions of the array
                              parameter ParR are (dim1,dim2) where dim1 is the
                              maximum node number (including internal nodes)
                              multiplied by the number of degrees of freedom,
                              and dim2 is the number of rigid body modes (which
                              corresponds to the number of structural degrees
                              of freedom).

            Generates excitation frequencies with clustering option CLUSTER(CON1,CON2,CON3,CON4,%CON5%) where: - The dimension of the resulting array parameter ParR is less than
                              2+NFR*(2*CON3+1) where NFR is the number of
                              natural frequencies defined in CON5.

        con1, con2, con3, . . . , con10
            Constants used with above functions.

        Notes
        -----
        Operates on input data and produces one output array parameter vector
        according to:

        ParR = f(CON1, CON2, : ...)

        where the functions (f) are described above. Operations use successive
        array elements [*VLEN, *VMASK] with the default being all successive
        elements.  For example, *VFILL,A,RAMP,1,10 assigns A(1) = 1.0, A(2) =
        11.0, A(3) = 21.0, etc.  *VFILL,B(5,1),DATA,1.5,3.0 assigns B(5,1) =
        1.5 and B(6,1) = 3.0.  Absolute values and scale factors may be applied
        to the result parameter [*VABS, *VFACT].  Results may be cumulative
        [*VCUM].  See the *VOPER command for details.

        This command is valid in any processor.
        """
        command = "*VFILL,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(parr), str(func), str(con1), str(con2), str(con3), str(con4), str(con5), str(con6), str(con7), str(con8), str(con9), str(con10))
        return self.run(command, **kwargs)

    def djdele(self, elem="", lab="", **kwargs):
        """APDL Command: DJDELE

        Deletes boundary conditions on the components of relative motion of a
        joint element.

        Parameters
        ----------
        elem
            Element number or ALL. ALL (or leaving this field blank) will
            delete all joint element boundary conditions specified by LAB.

        lab
            Valid labels are:

            UX - Displacement in local x direction.

            UY - Displacement in local y direction.

            UZ - Displacement in local z direction.

            ROTX - Rotation about local x axis.

            ROTY - Rotation about local y axis.

            ROTZ - Rotation about local z axis.

            VELX - Linear velocity in local x direction.

            VELY - Linear velocity in local y direction.

            VELZ - Linear velocity in local z direction.

            OMGX - Angular velocity in local x direction.

            OMGY - Angular velocity in local y direction.

            OMGZ - Angular velocity in local z direction.

            ACCX - Linear acceleration in local x direction.

            ACCY - Linear acceleration in local y direction.

            ACCZ - Linear acceleration in local z direction.

            DMGX - Angular acceleration in local x direction.

            DMGY - Angular acceleration in local y direction.

            DMGZ - Angular acceleration in local z direction.

            ALL, or (blank) - Delete all applied boundary conditions.

        Notes
        -----
        This command is valid for MPC184 joint elements. See DJ for information
        on specifying boundary conditions on the components of relative motion
        of a joint element.
        """
        command = "DJDELE,%s,%s" % (str(elem), str(lab))
        return self.run(command, **kwargs)

    def tbcopy(self, lab="", matf="", matt="", **kwargs):
        """APDL Command: TBCOPY

        Copies a data table from one material to another.

        Parameters
        ----------
        lab
            Data table label. See the TB command for valid labels, and see
            "Notes" for Lab = ALL.

        matf
            Material reference number where data table is to be copied from.

        matt
            Material reference number where data table is to be copied to.

        Notes
        -----
        The TBCOPY command, with Lab = ALL, copies all of the nonlinear data
        defined by the TB command. If you copy a model that includes both yield
        behavior constants and linear constants (for example, a BKIN model),
        TBCOPY,ALL and MPCOPY are used together to copy the entire model. All
        input data associated with the model is copied, that is, all data
        defined through the TB and MP commands.

        Also, if you copy a material model using the Material Model Interface
        (Edit> Copy), both the commands TBCOPY,ALL and MPCOPY are issued,
        regardless of whether the model includes linear constants only, or if
        it includes a combination of linear and yield behavior constants.

        This command is also valid in SOLUTION.
        """
        command = "TBCOPY,%s,%s,%s" % (str(lab), str(matf), str(matt))
        return self.run(command, **kwargs)

    def hrcplx(self, loadstep="", substep="", omegat="", firstlc_ase="",
               secondlc_ase="", **kwargs):
        """APDL Command: HRCPLX

        Computes and stores in the database the time-harmonic solution at a
        prescribed phase angle.

        Parameters
        ----------
        loadstep
            Load step number of the data set to be read (defaults to 1).

        substep
            Substep number within LOADSTEP.

        omegat
            Angle in degrees (Ω (angle) times T (time)).

        1stlcase
            First load case number (defaults to 1).

        2ndlcase
            Second load case number (defaults to 2).

        Notes
        -----
        HRCPLX invokes a macro that combines the real and imaginary parts of
        the solution. If the angle is specified, it produces the following:

        Where:

        RR and RI are, respectively, the real and imaginary parts of the
        results quantity (e.g. the nodal displacements, the reaction forces,
        ...).

        α is the angle (OMEGAT).

        1STLCASE and 2NDLCASE are internally generated load cases. You may want
        to specify these to avoid overwriting an existing load case number 1 or
        2.

        Not all results computed by this command are valid. See Summable, Non-
        Summable and Constant Data in the Basic Analysis Guide for more
        information. When the amplitude of the solution is requested (OMEGAT >=
        360°), averaged values (such as the nodal component stresses, which are
        an average of element nodal component stresses) are calculated by
        averaging the amplitudes. Because the degrees of freedom results have
        different phases, derived results (such as the equivalent stress SEQV)
        are not valid. See POST1 and POST26 – Complex Results Postprocessing
        for more details about post-processing complex results.

        For postprocessing amplitudes, the only appropriate coordinate system
        is the solution coordinate system (RSYS ,SOLU).  When displaying the
        displacement amplitudes, use a contour display (PLNSOL command).
        Because a deformed shape display (PLDISP command) could lead to a non-
        physical shape, the displacement scaling is off by default
        (/DSCALE,,OFF).

        For postprocessing cylindrical geometry, it is suggested that you
        rotate the element coordinate systems into the appropriate cylindrical
        system (EMODIF,,ESYS) before running the solution and then view the
        results in this system (RSYS,SOLU) in POST1.

        Since HRCPLX performs load case combinations, it alters most of the
        data in the database. In particular, it alters applied loads such as
        forces and imposed displacements. To restore the original loads in the
        database for a subsequent analysis, reissue the SET command in POST1 to
        retrieve the real and imaginary set data.

        To animate the solution over one period, use the ANHARM command.

        OMEGAT is not equal to the phase shift.

        This command is not supported after a cyclic symmetry analysis; use
        /CYCEXPAND,,PHASEANG instead.
        """
        command = "HRCPLX,%s,%s,%s,%s,%s" % (str(loadstep), str(substep), str(omegat), str(firstlc_ase), str(secondlc_ase))
        return self.run(command, **kwargs)

    def vclear(self, nv1="", nv2="", ninc="", **kwargs):
        """APDL Command: VCLEAR

        Deletes nodes and volume elements associated with selected volumes.

        Parameters
        ----------
        nv1, nv2, ninc
            Delete mesh for volumes NV1 to NV2 (defaults to NV1) in steps of
            NINC (defaults to 1).  If NV1 = ALL, NV2 and NINC are ignored and
            mesh for all selected volumes [VSEL] is deleted.  If NV1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NV1 (NV2 and NINC are ignored).

        Notes
        -----
        Deletes all nodes and volume elements associated with selected volumes
        (regardless of whether the nodes or elements are selected).  Nodes
        shared by adjacent meshed volumes and nodes associated with non-volume
        elements will not be deleted.  Attributes assigned as a result of VATT
        are maintained.  In the program's response to the command, if a volume,
        area, line, or keypoint is tallied as "cleared," it means either its
        node or element reference was deleted.
        """
        command = "VCLEAR,%s,%s,%s" % (str(nv1), str(nv2), str(ninc))
        return self.run(command, **kwargs)

    def asifile(self, opt="", fname="", ext="", oper="", kdim="", kout="",
                limit="", **kwargs):
        """APDL Command: ASIFILE

        Writes or reads one-way acoustic-structural coupling data.

        Parameters
        ----------
        opt
            Command behavior option:

            WRITE  - Write the structural results to the specified file.

            READ  - Read the structural results from the specified file.

        fname
            File name and directory path of a one-way acoustic-structural
            coupling data file (248 characters maximum, including the
            characters needed for the directory path). An unspecified directory
            path defaults to the working directory; in this case, you can use
            all 248 characters for the file name (defaults to jobname).

        ext
            File name extension of the one-way acoustic-structural coupling
            data file (defaults to .asi).

        oper
            Command operation:

            NOMAP  - No mapping occurs between the structural and acoustic models when reading the
                     structural results from the specified file (default).

            MAP  - Maps the results from the structural to the acoustic model. (See "Notes".)

        kdim
            Interpolation criteria. Valid only when Oper = MAP.

        kout
            Outside region results. Valid only when Oper = MAP.

        limit
            Number of nearby nodes considered for interpolation. Valid only
            when Oper = MAP.

        Notes
        -----
        The ASIFILE command writes to, or reads from, a file containing one-way
        acoustic-structural coupling data.

        Results data on the one-way coupling interface (defined by the
        SF,,FSIN) in the structural model are written to the one-way coupling
        result data file during the structural solution.

        One-way coupling results data are read into the acoustic model as the
        velocity (harmonic) or acceleration (transient) excitation during the
        sequential acoustic solution.

        If Oper = NOMAP, both structural and acoustic models must share the
        same node number on the one-way coupling interface.

        If Oper = MAP:

        The one-way coupling interface must be defined in the acoustic model
        (SF,,FSIN) such that it corresponds to the field-surface interface
        number (FSIN) in the structural model.

        The output points are correct only if they are within the boundaries
        set via the specified input points.

        Calculations for out-of-bound points require much more processing time
        than do points that are within bounds.

        For each point in the acoustic destination mesh, the command searches
        all possible triangles in the structural source mesh to find the best
        triangle containing each point, then performs a linear interpolation
        inside this triangle. For faster and more accurate results, consider
        your interpolation method and search criteria carefully (see LIMIT).

        One-way coupling excitation can be applied to multiple frequencies or
        time steps.
        """
        command = "ASIFILE,%s,%s,%s,%s,%s,%s,%s" % (str(opt), str(fname), str(ext), str(oper), str(kdim), str(kout), str(limit))
        return self.run(command, **kwargs)

    def prim(self, **kwargs):
        """APDL Command: PRIM

        Specifies "Solid model primitives" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "PRIM," % ()
        return self.run(command, **kwargs)

    def gropt(self, lab="", key="", **kwargs):
        """APDL Command: /GROPT

        Sets various line graph display options.

        Parameters
        ----------
        lab
            Apply display style as selected from the following labels:

            AXDV - Axis division (tick) marks (defaults to KEY = ON).

            AXNM - Axis scale numbers (defaults to KEY = ON, which puts numbers at the back plane
                   of the graph).  If KEY = FRONT, numbers are on the front
                   plane of the graph.

            AXNSC - Axis number size scale factor.  Input the scale value for KEY (defaults to
                    1.0).

            ASCAL - Automatic scaling of additional Y-axes for multi-curve [/GRTYP, 2 or 3] graphs
                    (defaults to KEY = ON).  If KEY = OFF, use base Y-axis
                    scaling (see the /YRANGE command).

            LOGX - Log X scale (defaults to KEY = OFF (linear)).

            LOGY - Log Y scale (applies only to the base Y axis) (defaults to KEY = OFF (linear)).

            FILL - Color fill areas under curves (defaults to KEY = OFF).

            CGRID - Superimpose background grid [/GRID] over areas under filled curves (defaults to
                    KEY = OFF).

            DIG1 - Number of significant digits before decimal point for axis values.  Input the
                   value for KEY (defaults to 4).

            DIG2 - Number of significant digits after decimal point for axis values.  Input the
                   value for KEY (defaults to 3).

            VIEW - View key for graph displays (defaults to KEY = OFF, in which case the view is
                   (0,0,1) for 2-D graph displays or (1,2,3) for 3-D graph
                   displays).  If KEY = ON, the view settings for graph
                   displays are the same as the view settings for the model.

            REVX - Plots the values on the X-axis in reverse order.

            REVY - Plots the values on the Y-axis in reverse order.

            DIVX - Determines the number of divisions (grid markers) that will be plotted on the X
                   axis.

            DIVY - Determines the number of divisions (grid markers) that will be plotted on the Y
                   axis.

            LTYP - Determines whether ANSYS generated (KEY = 1) or system derived (KEY = 0) fonts
                   will be used for the axis labels.

            CURL - Determines the position of the curve labels. If (KEY = 1), the curve label will
                   be plotted in the legend column, and the label will be
                   displayed in the same color as the curve. If (KEY = 0) the
                   curve labels will be plotted near the curve. (default).

            XAXO - When you use this label, the subsequent KEY value will determine an offset
                   amount from the default (along the bottom) location for the
                   X axis. If KEY = 1.0, a full offset occurs (the X axis is
                   moved to the top of the graph). If KEY = 0.5, the axis is
                   offset to the midpoint of the graph, and if KEY = 0 the axis
                   remains in the original position, along the bottom of the
                   graph. For any offset, a grey copy of the original axis
                   (containing the axis numbering) remains at the original
                   location.

            YAXO - When you use this label, the subsequent KEY value will determine an offset
                   amount from the default (along the left side of the graph)
                   location for the Y axis. If KEY = 1.0, a full offset occurs
                   (the Y axis is moved to the right side of the graph). If KEY
                   = 0.5, the axis is offset to the midpoint of the graph, and
                   if KEY = 0 the axis remains in the original position, along
                   the left side of the graph. For any offset, a gray copy of
                   the original axis (containing the axis numbering) remains at
                   the original location.

        key
            Option values:

            OFF (0) - Do not apply selected style.

            ON (1) - Apply selected style.

            nnnn - If Lab is DIG1 or DIG2, input the number of digits.

            nn - If Lab is AXNSC, input the scale factor.

            FRONT - If Lab is AXNM, FRONT may also be input.

            Ndiv - If Lab is DIVX or DIVY, determines the number of divisions (1-99) that will be
                   applied to the axis.

            Kfont - If Lab is LTYP, Kfont is ON (1) or OFF(0).  ON will use ANSYS generated fonts
                    for the axis labels, while OFF will use SYSTEM (Windows,
                    X-system, etc.) fonts. The default value is ON (ANSYS
                    fonts).

        Notes
        -----
        Sets various line graph display options.  Issue /GROPT,STAT to display
        the current settings.  Issue /GROPT,DEFA to reset the default
        specifications.  ANSYS informs you that graph view manipulation is
        inactive unless you have issued the /GROPT,VIEW,ON command.  See the
        /AXLAB, /GRTYP, /GRID, and /GTHK commands for other graph control
        options.

        Automatic scaling using the /XRANGE and /YRANGE commands will often
        yield inappropriate range values for logarithmic scales (/GROPT, LOGX
        or /GROPT, LOGY).

        This command is valid in any processor.
        """
        command = "/GROPT,%s,%s" % (str(lab), str(key))
        return self.run(command, **kwargs)

    def vadd(self, nv1="", nv2="", nv3="", nv4="", nv5="", nv6="", nv7="",
             nv8="", nv9="", **kwargs):
        """APDL Command: VADD

        Adds separate volumes to create a single volume.

        Parameters
        ----------
        nv1, nv2, nv3, . . . , nv9
            Numbers of volumes to be added.  If NV1 = ALL, add all selected
            volumes and ignore NV2 to NV9.  If NV1 = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for NV1.

        Notes
        -----
        Adds separate volumes to create a single volume.  The original volumes
        (and their corresponding areas, lines and keypoints) will be deleted by
        default [BOPTN].  See the BOPTN command for the options available to
        Boolean operations.  Element attributes and solid model boundary
        conditions assigned to the original entities will not be transferred to
        the new entities generated.  Concatenated entities are not valid with
        this command.
        """
        command = "VADD,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nv1), str(nv2), str(nv3), str(nv4), str(nv5), str(nv6), str(nv7), str(nv8), str(nv9))
        return self.run(command, **kwargs)

    def tvar(self, key="", **kwargs):
        """APDL Command: TVAR

        Changes time to the cumulative iteration number.

        Parameters
        ----------
        key
            Time key:

            0 - Time is used for the variable TIME.

            1 - NCUMIT is used for the variable TIME.

        Notes
        -----
        Changes the meaning of the time variable to the cumulative iteration
        number (NCUMIT) variable.  Data can be read from the file, printed, and
        displayed as a function of NCUMIT rather than time.  All POST26
        descriptions applying to TIME then apply to NCUMIT.
        """
        command = "TVAR,%s" % (str(key))
        return self.run(command, **kwargs)

    def rmmrange(self, mode="", key="", min="", max="", nstep="", damp="",
                 scale="", **kwargs):
        """APDL Command: RMMRANGE

        Defines and edits various modal parameters for the ROM method.

        Parameters
        ----------
        mode
            Mode number. Must be lower or equal to the number of modes
            extracted via the RMNEVEC command.

        key
            Mode classification key. Valid keys are:

            DOMINANT - Dominant mode

        min
            Lower bound for fit range of mode.

        max
            Upper bound for fit range of mode.

        nstep
            Number of equidistant steps in fit range of mode.

        damp
            Modal damping factor. Defaults to 0.0.

        scale
            Modal scaling factor.

        Notes
        -----
        When selected manually (RMMSELECT), modes must be classified as
        dominant, relevant, or unused. Dominant modes (Key = DOMINANT) are
        basis functions with large amplitudes. Relevant modes (Key = RELEVANT)
        are influenced by the dominant modes but do not cause interactions
        among themselves due to the small amplitude. This assumption leads to
        essential speed up of the sample point generator (see RMSMPLE).

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMMRANGE,%s,%s,%s,%s,%s,%s,%s" % (str(mode), str(key), str(min), str(max), str(nstep), str(damp), str(scale))
        return self.run(command, **kwargs)

    def hbmat(self, fname="", ext="", form="", matrx="", rhs="", mapping="",
              **kwargs):
        """APDL Command: HBMAT

        Writes an assembled global matrix in Harwell-Boeing format.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        form
            Specifies format of output matrix file:

            ASCII - Write output matrix file in ASCII form.

            BIN - Write output matrix file in binary form.

        matrx
            Specify which matrix to write to the output matrix file:

            STIFF - Write stiffness matrix to output matrix file.  Valid for all types of analyses
                    that write a .FULL file.

            MASS - Write mass matrix to output matrix file.  Valid for buckling, substructure, and
                   modal analyses.  If .FULL file was generated in a buckling
                   analysis, then this label will write stress stiffening
                   matrix to output matrix file.

            DAMP - Write damping matrix to output matrix file.  Only valid for damped modal
                   analyses.

        rhs
            Specifies whether to write the right-hand side vector to output
            matrix file:

            YES - Write right-hand side vector to output matrix file.

            NO - Do not write right-hand side vector to output matrix file.

        mapping
            Specifies whether to write the mapping file. This file is always
            named Fname.MAPPING.

            YES - Write the mapping file.

            NO - Do not write the mapping file (default).

        Notes
        -----
        This command is used to copy a matrix from the assembled global matrix
        file (.FULL file) or from the superelement matrix file (.SUB file) as
        specified on the FILEAUX2 command and write it in Harwell-Boeing format
        to a new file, named jobname.MATRIX.  The Harwell-Boeing format is
        widely used by other applications that deal with matrices.

        The assembled global matrix file is created during solution depending
        on the analysis type, equation solver, and other solution options.  By
        default, the assembled global matrix file is never deleted at the end
        of solution. For most analysis types, the Sparse direct solver and the
        ICCG solver will write a .FULL file. All mode extraction methods used
        for buckling and modal analyses will write a properly formatted .FULL
        file to be used with the HBMAT command. However, when using Distributed
        ANSYS, a majority of analyses will write a distributed (or local) form
        of the .FULL file which is not currently supported by the HBMAT
        command.

        When dumping the stiffness matrix for transient and harmonic analyses,
        be aware that the element mass matrix values (and possibly element
        damping matrix values) are incorporated into the globally assembled
        stiffness matrix.  Thus, the globally assembled stiffness matrix
        represents more than the stiffness of the model for these analysis
        types.  Please refer to the Mechanical APDL Theory Reference for more
        details.

        When dumping a .FULL file, the rows and columns corresponding to
        specified constraints (e.g., D commands) are eliminated from the system
        of equations and therefore are not written to the .MATRIX file. Also,
        rows and columns corresponding to eliminated (slave) degrees of freedom
        from coupling and/or constraint equations (e.g., CE, CP commands) are
        also eliminated from the system of equations and are not written to the
        .MATRIX file. The DOFs that are eliminated from any coupling and/or
        constraint equations are determined internally by the solution code and
        may not match what you specified via the CE/CP (or similar) commands.

        When dumping a .SUB file, the full nxn matrix will be written to the
        .MATRIX file for either symmetric or unsymmetric matrices, regardless
        of whether any of the matrix coefficients are zero-valued. When dumping
        a .FULL file, only the lower triangular part of the matrix will be
        written to the .MATRIX file if the matrix is symmetric; the full matrix
        is written if the matrix is unsymmetric. Only matrix coefficients that
        are greater than zero will be written.

        The Harwell-Boeing format is column-oriented.  That is, non-zero matrix
        values are stored with their corresponding row indices in a sequence of
        columns.  However, since the ANSYS matrix files are stored by row and
        not column, when the HBMAT command is used with a non-symmetric matrix,
        the transpose of the matrix is, in fact, written.

        The WRFULL command, in conjunction with the SOLVE command, can be used
        to generate the assembled global matrix file and eliminate the equation
        solution process and results output process.

        The mapping file can be used to map the matrix equation numbers found
        in the .MATRIX file directly to the corresponding node numbers and
        degrees of freedom.

        When dumping a CMS .SUB file, the last rows/columns of the matrix are
        non-physical degrees of freedom added internally by the CMS process and
        cannot be mapped directly to a node number or particular degree of
        freedom.
        """
        command = "HBMAT,%s,%s,%s,%s,%s,%s" % (str(fname), str(ext), str(form), str(matrx), str(rhs), str(mapping))
        return self.run(command, **kwargs)

    def sfdele(self, nlist="", lab="", **kwargs):
        """APDL Command: SFDELE

        Deletes surface loads.

        Parameters
        ----------
        nlist
            Label defining where to find the list of nodes:

            ALL - Use all selected nodes [NSEL].  If P, use graphical picking in GUI.  A
                  component label may be substituted for Nlist.

        lab
            Valid surface load label.  If ALL, use all appropriate labels.  See
            the SF command for labels.

        Notes
        -----
        Deletes surface loads as applied with the SF command.  Loads are
        deleted only for the specified nodes on external faces of selected area
        and volume elements.  For shell elements, if the specified nodes
        include face one (which is usually the bottom face) along with other
        faces (such as edges), only the loads on face one will be deleted.  The
        element faces are determined from the list of selected nodes as
        described for the SF command.  See the SFEDELE command for deleting
        loads explicitly by element faces.

        This command is also valid in PREP7.
        """
        command = "SFDELE,%s,%s" % (str(nlist), str(lab))
        return self.run(command, **kwargs)

    def pdscat(self, rlab="", name1="", name2="", type="", order="", nmax="",
               **kwargs):
        """APDL Command: PDSCAT

        Plots a scatter graph.

        Parameters
        ----------
        rlab
            Result set label. Identifies the result set to be used for
            postprocessing. A result set label can be the solution set label
            you defined in a PDEXE command, or the response surface set label
            defined in an RSFIT command.

        name1, name2
            Parameter names. The parameters must have been previously defined
            as a random input variable or a random output parameter using the
            PDVAR command. The parameter data for Name1 is shown on the X-axis
            and the parameter data for Name2 is shown on the Y-axis in the
            plot.

        type
            Keyword for the type of trendline curve.

            POLY - Polynomial trendline (default).

            NONE - A trendline is not plotted.

        order
            Order of the polynomial trendline. This parameter is used only for
            Type = POLY. ORDER must be a positive number. There is no maximum
            for ORDER provided there are enough data points to evaluate a
            polynomial of the requested order. Default is 1.

        nmax
            Maximum number of points plotted in the scatter plot.  If there are
            more sample data, then only the first NMAX points are plotted. The
            default value is 10,000.

        Notes
        -----
        Plots a scatter graph with or without a trendline. The scatter plot
        shows the simulated points for two random parameters. Random input
        variables and random output parameters are valid for both X- and
        Y-axis. The mean value of both parameters are marked with separate
        green lines. The point where the green lines cross marks the
        statistical center of gravity of the cloud of all simulated data points
        of the two parameters.

        If Rlab is left blank, then the result set label is inherited from the
        last PDEXE command (Slab), RSFIT command (RSlab), or the most recently
        used PDS postprocessing command where a result set label was explicitly
        specified.

        If the parameter data for Name1 includes negative values, fitting a
        logarithmic trendline is not possible and the logarithmic trendline
        plot is suppressed if requested. The same applies for an exponential
        trendline if the data for the Name2 includes negative values.

        Because of the amount of data involved, the scatter plot is limited to
        NMAX points. If shown, the trendline is evaluated only on the NMAX
        points shown. However, the statistical information shown in the plot,
        such as the mean value lines for both parameters and the correlation
        coefficients listed in the legend are based on the full set of samples.
        If required, you can increase NMAX to plot more points, but this will
        affect the time needed to process the PDSCAT command. If NMAX is less
        than the total amount of simulated points, which is typically possible
        for Response Surface Methods, you will see an appropriate warning in
        the plot legend.
        """
        command = "PDSCAT,%s,%s,%s,%s,%s,%s" % (str(rlab), str(name1), str(name2), str(type), str(order), str(nmax))
        return self.run(command, **kwargs)

    def filedisp(self, fname="", ext="", **kwargs):
        """APDL Command: FILEDISP

        Specifies the file containing the graphics data.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        Notes
        -----
        Specifies the input file containing the graphics data (defaults to
        File.GRPH).
        """
        command = "FILEDISP,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def cfwrite(self, command="", **kwargs):
        """APDL Command: *CFWRITE

        Writes an ANSYS command (or similar string) to a "command" file.

        Parameters
        ----------
        command
            Command or string to be written.  The standard command form of a
            label followed by arguments separated by commas is assumed.
            Command may be a parameter assignment (e.g.,  *CFWRITE, A = 5).

        Notes
        -----
        Writes an ANSYS command (or similar string) to the file opened with
        *CFOPEN.  The Command string is not executed (except that numeric and
        character parameter substitution and operations (with imbedded *, /, >,
        etc. characters) are performed before writing).  When used with *GET
        results and parameter substitution, an ANSYS command can be created
        from results and then read back into the ANSYS program (or used
        elsewhere).  For example, if the command *CFWRITE,BF,NNUM,TEMP,TVAL is
        used in a do-loop, where TVAL is a parameter value returned from the
        *GET operation and NNUM is a specified or returned parameter value, a
        series of BF  commands, with numerical values substituted for the two
        parameters, will be written.  To create a file without parameter
        substitution, use *CREATE.

        This command is valid in any processor.
        """
        command = "*CFWRITE,%s" % (str(command))
        return self.run(command, **kwargs)

    def dklist(self, kpoi="", **kwargs):
        """APDL Command: DKLIST

        Lists the DOF constraints at keypoints.

        Parameters
        ----------
        kpoi
            List constraints for this keypoint.  If ALL (default), list for all
            selected keypoints [KSEL].  If KPOI = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for KPOI.

        Notes
        -----
        Listing applies to the selected keypoints [KSEL] and the selected
        degree of freedom labels [DOFSEL].

        This command is valid in any processor.
        """
        command = "DKLIST,%s" % (str(kpoi))
        return self.run(command, **kwargs)

    def lcdef(self, lcno="", lstep="", sbstep="", kimg="", **kwargs):
        """APDL Command: LCDEF

        Creates a load case from a set of results on a results file.

        Parameters
        ----------
        lcno
            Arbitrary pointer number (1-99) to be assigned to the load case
            specified by LSTEP, SBSTEP and by the FILE command.  Defaults to 1
            + previous value.

        lstep
            Load step number to be defined as the load case.  Defaults to one.

        sbstep
            Substep number.  Defaults to the last substep of the load step.

        kimg
            Used only with results from complex analyses:

            0 - Use real part of complex solution

            1 - Use imaginary part.

        Notes
        -----
        Creates a load case by establishing a pointer to a set of results on a
        results file (written during the ANSYS solution phase).  This pointer
        (LCNO) can then be used on the LCASE or LCOPER commands to read the
        load case data into the database.

        Issue LCDEF,ERASE to delete all load case pointers (and all load case
        files, if any).  Issue LCDEF,LCNO,ERASE to delete only the specific
        load case pointer LCNO (and its file, if any).  With the ERASE options,
        all pointers are deleted; however only files with the default extension
        [LCWRITE] are deleted.  Issue LCDEF,STAT for status of all selected
        load cases [LCSEL], or LCDEF,STAT,ALL for status of all load cases.
        The STAT command may be used to list all load cases.  See also LCFILE
        to establish a pointer to a set of results on a load case file (written
        by LCWRITE). Harmonic element data read from a result file load case is
        stored at the zero-degree position.
        """
        command = "LCDEF,%s,%s,%s,%s" % (str(lcno), str(lstep), str(sbstep), str(kimg))
        return self.run(command, **kwargs)

    def crplim(self, crcr="", option="", **kwargs):
        """APDL Command: CRPLIM

        Specifies the creep criterion for automatic time stepping.

        Parameters
        ----------
        crcr
            Value of creep criteria for the creep limit ratio control.

        option
            Type of creep analysis for which the creep limit ratio is
            specified:

            1 (or ON) - Implicit creep analysis.

            0 (or OFF) - Explicit creep analysis.

        Notes
        -----
        The CUTCONTROL command can also be used to set the creep criterion and
        is preferred over this command for setting automatic time step
        controls.

        The creep ratio control can be used at the same time for implicit creep
        and explicit creep analyses. For implicit creep (Option = 1), the
        default value of CRCR is zero (i.e., no creep limit control), and you
        can specify any value. For explicit creep (Option = 0), the default
        value of CRCR is 0.1, and the maximum value allowed is 0.25.

        This command is also valid in PREP7.
        """
        command = "CRPLIM,%s,%s" % (str(crcr), str(option))
        return self.run(command, **kwargs)

    def pdef(self, lab="", item="", comp="", avglab="", **kwargs):
        """APDL Command: PDEF

        Interpolates an item onto a path.

        Parameters
        ----------
        lab
            Label assigned to the resulting path item (8 characters maximum).
            This item may be used as input for other path operations.

        item
            Label identifying the item for interpolation.  Valid item labels
            are shown in Table 216: PDEF - valid Item and Component Labels
            below.  Some items also require a component label.

        comp
            Component of the item (if required).  Valid component labels are
            shown in Table 216: PDEF - valid Item and Component Labels below.

        avglab
            Option to average across element boundaries:

            AVG - Average element results across elements (default).

            NOAV - Do not average element results across elements.  If the parameter DISCON = MAT
                   on the PMAP command, this option is automatically invoked.

        Notes
        -----
        Defines and interpolates a labeled path item along a predefined path
        (PATH).  Path item results are in the global Cartesian coordinate
        directions unless transformed (RSYS).  A path item must be defined
        before it can be used with other path operations.  Additional path
        items may be defined from the PVECT, PCALC, PDOT, and PCROSS commands.
        Path items may be listed (PRPATH) or displayed (PLPATH, PLPAGM).  A
        maximum number of path items permitted is established by the nSets
        argument specified with the PATH command.

        When you create the first path item (PDEF or PVECT), the program
        automatically interpolates four path items which are used to describe
        the geometry of the path.  These predefined items are the position of
        the interpolated path points (labels XG, YG, and ZG) in global
        Cartesian coordinates, and the path length (label S).  For alternate
        methods of mapping the path geometry (to include, for example, material
        discontinuity) see the PMAP command.  These items may also be listed or
        displayed with the PRPATH, PLPATH, and PLPAGM commands.

        If specifying that load case operations act on principal/equivalent
        stresses (SUMTYPE,PRIN), derived quantities (principal and equivalent
        stresses/strains) will be zero for path plots. A typical use for such a
        case involves mode combinations in a response spectrum analysis.

        The number of interpolation points on the path is defined by the nDiv
        argument on the PATH command.  See Mapping Nodal and Element Data onto
        the Path in the Mechanical APDL Theory Reference for details.  Use
        PDEF,STAT to list the path item labels.  Use PDEF,CLEAR to erase all
        labeled path items, except the path geometry items (XG, YG, ZG, S).

        Table: 216:: : PDEF - valid Item and Component Labels

         For SHELL131 and SHELL132 elements with KEYOPT(3) = 0 or 1, use the
        labels TBOT, TE2, TE3, ..., TTOP instead of TEMP.

        For more information on the meaning of contact status and its possible
        values, see Reviewing Results in POST1 in the Contact Technology Guide.
        """
        command = "PDEF,%s,%s,%s,%s" % (str(lab), str(item), str(comp), str(avglab))
        return self.run(command, **kwargs)

    def vcol(self, ncol1="", ncol2="", **kwargs):
        """APDL Command: *VCOL

        Specifies the number of columns in matrix operations.

        Parameters
        ----------
        ncol1
            Number of columns to be used for Par1 with *MXX operations.
            Defaults to whatever is needed to fill the result array.

        ncol2
            Number of columns to be used for Par2 with *MXX operations.
            Defaults to whatever is needed to fill the result array.

        Notes
        -----
        Specifies the number of columns to be used in array parameter matrix
        operations.  The size of the submatrix used is determined from the
        upper left starting array element (defined on the operation command) to
        the lower right array element (defined by the number of columns on this
        command and the number of rows on the *VLEN command).

        The default NCOL is calculated from the maximum number of columns of
        the result array (the *DIM column dimension) minus the starting
        location + 1.  For example, *DIM,R,,1,10 and a starting location of
        R(1,7) gives a default of 4 columns ( starting with R(1,7), R(1,8),
        R(1,9), and R(1,10)).  Repeat operations automatically terminate at the
        last column of the result array.  Existing values in the rows and
        columns of the results matrix remain unchanged where not overwritten by
        the requested input or operation values.

        The column control settings are reset to the defaults after each *MXX
        operation.  Use *VSTAT to list settings.

        This command is valid in any processor.
        """
        command = "*VCOL,%s,%s" % (str(ncol1), str(ncol2))
        return self.run(command, **kwargs)

    def lang(self, nl1="", p3="", ang="", phit="", locat="", **kwargs):
        """APDL Command: LANG

        Generates a straight line at an angle with a line.

        Parameters
        ----------
        nl1
            Number of the line to be hit (touched by the end of the new line).
            If negative, assume P1 (see below) is the second keypoint of the
            line instead of the first.  If NL1 = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).

        p3
            Keypoint at which generated line must end.

        ang
            Angle of intersection of generated line PHIT-P3 with tangent to
            line P1-P2 at PHIT.  If 0 (default), the generated line is tangent
            to NL1 toward end P1; if 90, the generated line is perpendicular to
            NL1.  If 180, the generated line is tangent to NL1 toward end P2.
            ANG can be any value, but is adjusted to the corresponding acute
            angle with respect to LOCAT. See "Notes" for a discussion of
            accuracy.

        phit
            Number to be assigned to keypoint generated at hit location
            (defaults to lowest available keypoint number [NUMSTR]).

        locat
            Approximate location of PHIT in terms of the ratio of the distance
            along the line (NL1) to the length of the line.  LOCAT can range
            from 0 to 1.  If LOCAT is blank, the point will be located with
            less speed and accuracy, and an arbitrary location may result.

        Notes
        -----
        Generates a straight line (PHIT-P3) at an angle (ANG) with a line NL1
        (P1-P2).  The location of PHIT on the line is automatically calculated.
        Line P1-P2 becomes P1-PHIT and new lines PHIT-P2 and PHIT-P3 are
        generated.  Line divisions are set to zero (use LESIZE, etc. to
        modify).

        PHIT is positioned closest to LOCAT for the given angle, ANG.  To
        ensure better performance, it is recommended that LOCAT be input, even
        if it is 0.

        The program uses an iterative procedure to position PHIT.  The
        procedure is not exact, with the result that the actual value of ANG
        will sometimes differ slightly from the specified value.
        """
        command = "LANG,%s,%s,%s,%s,%s" % (str(nl1), str(p3), str(ang), str(phit), str(locat))
        return self.run(command, **kwargs)

    def xfrm(self, lab="", x1="", y1="", z1="", x2="", y2="", z2="", **kwargs):
        """APDL Command: /XFRM

        Controls the centroid or the axis of dynamic rotation.

        Parameters
        ----------
        lab
            The location or entity (centroid) used to define the center or axis
            of rotation.

            NODE - If NODE is chosen for the center of rotation, the node number will be X1. If
                   the rotation is to be about an axis, then X1 and Y1 define
                   the two nodes between which a line is drawn to determine the
                   axis. The remaining arguments are ignored.

            ELEMENT - If ELEMENT is chosen for the center of rotation, the element number will be X1.
                      If the rotation is to be about an axis, then X1 and Y1
                      define the two elements between which a line is drawn to
                      determine the axis. The remaining arguments are ignored.

            KP - If KP is chosen for the center of rotation, the keypoint number will be X1. If
                 the rotation is to be about an axis, then X1 and Y1 define the
                 two keypoints between which a line is drawn to determine the
                 axis.  The remaining arguments are ignored.

            LINE - If LINE is chosen for the center of rotation, the line number will be X1. If
                   the rotation is to be about an axis, then X1 and Y1 define
                   the two lines between which a line is drawn to determine the
                   axis. The remaining arguments are ignored.

            AREA - If AREA is chosen for the center of rotation, the area number will be X1. If
                   the rotation is to be about an axis, then X1 and Y1 define
                   the two areas between which a line is drawn to determine the
                   axis. The remaining arguments are ignored.

            VOLUME - If VOLUME is chosen for the center of rotation, the volume number will be X1.
                     If the rotation is to be about an axis, then X1 and Y1
                     define the two volumes between which a line is drawn to
                     determine the axis. The remaining arguments are ignored.

            XYZ - If XYZ is chosen for the center of rotation, the location of that center is
                  determined by the coordinates X1, Y1, Z1. If values are
                  specified for X2, Y2, Z2, then the axis of rotation will be
                  about the line between those two points.

            OFF - If LAB = OFF, DEFAULT, FOCUS or if no value is specified, then the center of
                  rotation is set at the FOCUS point, as defined by the /FOCUS
                  command.

        x1
            The entity number or X coordinate for the center of rotation.

        y1
            The entity number or Y coordinate for the center of rotation.

        z1
            The Z coordinate for the center of rotation.

        x2
            The X coordinate for the axis of rotation.

        y2
            The Y coordinate for the axis of rotation.

        z2
            The Z coordinate for the axis of rotation.

        Notes
        -----
        The /XFRM command is active only when the cumulative rotation key is
        specified ON for the /ANGLE command (KINCR = 1). This command affects
        dynamic manipulations only.

        For center rotation, the middle mouse button will rotate the model
        about the screen Z axis and the right mouse button will rotate the
        model about the screen X and Y axis.

        For rotation about an axis, the middle mouse button will rotate the
        model about the defined axis of rotation and the right mouse button
        will be deactivated.

        This command is valid in any processor.
        """
        command = "/XFRM,%s,%s,%s,%s,%s,%s,%s" % (str(lab), str(x1), str(y1), str(z1), str(x2), str(y2), str(z2))
        return self.run(command, **kwargs)

    def dllist(self, line="", **kwargs):
        """APDL Command: DLLIST

        Lists DOF constraints on a line.

        Parameters
        ----------
        line
            List constraints for this line.  If ALL (default), list for all
            selected lines [LSEL].  If LINE = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).  A component name may also be substituted for LINE.

        Notes
        -----
        Lists the degree of freedom constraints on a line previously specified
        with the DL command.

        This command is valid in any processor.
        """
        command = "DLLIST,%s" % (str(line))
        return self.run(command, **kwargs)

    def edbvis(self, qvco="", lvco="", **kwargs):
        """APDL Command: EDBVIS

        Specifies global bulk viscosity coefficients for an explicit dynamics
        analysis.

        Parameters
        ----------
        qvco
            Quadratic viscosity coefficient (defaults to 1.5).

        lvco
            Linear viscosity coefficient (defaults to 0.06).

        Notes
        -----
        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDBVIS,%s,%s" % (str(qvco), str(lvco))
        return self.run(command, **kwargs)

    def psmesh(self, secid="", name="", p0="", egroup="", num="", kcn="",
               kdir="", value="", ndplane="", pstol="", pstype="", ecomp="",
               ncomp="", **kwargs):
        """APDL Command: PSMESH

        Create and mesh a pretension section

        Parameters
        ----------
        secid
            Unique section number. This number must not already be assigned to
            a section.

        name
            Unique eight character descriptive name, if desired.

        p0
            Pretension node number. The node will be defined if it doesn't
            exist and the number defaults to the highest node number plus one.

        egroup, num
            Element group on which PSMESH will operate. If Egroup = P,
            graphical picking is enabled and NUM is ignored (valid only in the
            GUI).

            L (or LINE) - PSMESH operates on all elements in the line specified by NUM. New pretension
                          nodes are associated with NUM or entities below it.
                          Any subsequent LCLEAR operation of NUM deletes the
                          pretension elements and nodes created by PSMESH.

            A (or AREA) - PSMESH operates on all elements in the area specified by NUM. New pretension
                          nodes are associated with NUM or entities below it.
                          Any subsequent ACLEAR of NUM deletes the pretension
                          elements and nodes created by PSMESH.

            V (or VOLU) - PSMESH operates on all elements in the volume specified by NUM. New pretension
                          nodes are associated with NUM or entities below it.
                          Any subsequent VCLEAR of NUM deletes the pretension
                          elements and nodes created by PSMESH.

            P - PSMESH operates on elements selected through the subsequent picking operations,
                and NUM is ignored

            ALL - The command operates on all selected elements, and NUM is ignored.

        kcn
            Coordinate system number for the separation surface and normal
            direction.

        kdir
            Direction (x, y, or z) normal to separation surface in the KCN
            coordinate system.

        value
            Point along the KDIR axis at which to locate the separation
            surface. Ignored if NDPLANE is supplied.

        ndplane
            Existing node that PSMESH will use to locate the separation
            surface. If NDPLANE is supplied, the location of the separation
            surface is defined by the KDIR coordinate of NDPLANE.

        pstol
            Optional tolerance below VALUE. Allows nodes occurring precisely at
            or slightly below the separation  to be identified properly as
            above the plane. Has the effect of shifting the plane down by
            PSTOL.  The following expression represents the default value:

        pstype
            If specified, this value is the type number for pretension
            elements. (If not specified, ANSYS defines this value.) If already
            defined, it must be of type PRETS179.

        ecomp
            If specified, the name of a component to be composed of new
            pretension elements and existing elements modified by the PSMESH
            command.

        ncomp
            Name of a component to be composed of nodes on new pretension
            elements.

        Notes
        -----
        The PSMESH command creates a pretension section normal to the
        pretension load direction by cutting the mesh along existing element
        boundaries at the point defined by VALUE or NDPLANE and inserting
        PRETS179 elements. The PSMESH command verifies that PSTYPE is PRETS179;
        if it is not, the command finds the lowest available ITYPE that is
        PRETS179, or if necessary will create a new one.

        When it is necessary to define the pretension node, ANSYS uses node
        NDPLANE. If the NDPLANE value is not specified, ANSYS defines the
        pretension node at:

        The centroid of geometric entity NUM, if Egroup = LINE, AREA or VOLU

        The centroid location of all selected elements, if Egroup = ALL or if
        graphical picking is used.

        If the elements to which the pretension load is to be applied have
        already been meshed in two groups, PSMESH cannot be used to insert the
        pretension elements. The EINTF command must be used to insert the
        PRETS179 elements between the two meshed groups.

        The PSMESH operation copies any nodal temperatures you have defined on
        the split surface of the original mesh from the original nodes to the
        newly created coincident duplicate nodes. However, displacements,
        forces, and other boundary conditions are not copied.

        By mathematical definition, the pretension surface must always be a
        flat plane. In a non-Cartesian coordinate system, the PSMESH command
        creates that plane at the indicated position, oriented with respect to
        the specified direction of the active system (in the same manner that
        the NROTAT command orients a nodal system with respect to a curved
        system). For example, assuming a X = 1 and Y = 45 in a cylindrical
        coordinate system with Z as the axis of rotation (KCN = 1), a
        pretension surface normal to X tilts 45 degrees away from the global X
        axis.

        The PSMESH command is valid for structural analyses only.
        """
        command = "PSMESH,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(secid), str(name), str(p0), str(egroup), str(num), str(kcn), str(kdir), str(value), str(ndplane), str(pstol), str(pstype), str(ecomp), str(ncomp))
        return self.run(command, **kwargs)

    def layplot(self, iel="", layr1="", layr2="", **kwargs):
        """APDL Command: LAYPLOT

        Displays the layer stacking sequence for layered elements.

        Parameters
        ----------
        iel
            Element number for the display.  If blank and the current element
            type is a layered element type, display data from the current real
            constant table.

        layr1, layr2
            Range of layer numbers to be displayed.  If LAYR1 is greater than
            LAYR2, a reversed order display is produced.  Up to 20 layers may
            be displayed at a time.  LAYR1 defaults to 1. LAYR2 defaults to
            LAYR1 if LAYR1 is input or to the number of layers (or to 19+LAYR1,
            if smaller) if LAYR1 is not input.

        Notes
        -----
        Displays the layer-stacking sequence as defined in the real constant
        table for layered shell and solid elements in a form where the layers
        are visible (like a sheared deck of cards).

        The element x-axis is shown as 0.0 degrees.

        Layers are cross-hatched and color-coded for clarity. The hatch lines
        indicate the layer angle (real constant THETA) and the color coding is
        for material identification (real constant MAT).

        The actual orientation of a specific layer in three-dimensional space
        can be seen using /PSYMB,LAYR. To use /PSYMB,LAYR with smeared
        reinforcing elements (REINF265), first set the vector-mode graphics
        option (/DEVICE,VECTOR,1).

        Layer thickness can be displayed using the /ESHAPE and EPLOT commands.

        This command is valid in any processor.
        """
        command = "LAYPLOT,%s,%s,%s" % (str(iel), str(layr1), str(layr2))
        return self.run(command, **kwargs)

    def c(self, comment="", **kwargs):
        """APDL Command: C***

        Places a comment in the output.

        Parameters
        ----------
        comment
            Comment string, up to 75 characters.

        Notes
        -----
        The output from this command consists of two lines -- a blank line
        followed by a line containing C*** and the comment.  This command is
        similar to /COM except that the comment produced by C*** is more easily
        identified in the output.

        Another way to include a comment is to precede it with a ! character
        (on the same line).  The ! may be placed anywhere on the line, and any
        input following it is ignored as a comment.  No output is produced by
        such a comment, but the comment line is included on the log file.  This
        is a convenient way to annotate the log file.

        This command is valid anywhere.
        """
        command = "C***,%s" % (str(comment))
        return self.run(command, **kwargs)

    def fe(self, nev="", cycle="", fact="", title="", **kwargs):
        """APDL Command: FE

        Defines a set of fatigue event parameters.

        Parameters
        ----------
        nev
            Reference number for this event (within MXEV).

        cycle
            Number of required cycles (defaults to 1).  If -1, erase all
            parameters and fatigue stresses for this event.

        fact
            Scale factor to be applied to all loadings in this event (defaults
            to 1.0).

        title
            User defined identification title for this event (up to 20
            characters).

        Notes
        -----
        Repeat FE command to define additional sets of event parameters (MXEV
        limit), to redefine event parameters, or to delete event stress
        conditions.

        The set of fatigue event parameters is associated with all loadings and
        all locations.  See the FTSIZE command for the maximum set of events
        (MXEV) allowed.
        """
        command = "FE,%s,%s,%s,%s" % (str(nev), str(cycle), str(fact), str(title))
        return self.run(command, **kwargs)

    def monitor(self, var="", node="", lab="", **kwargs):
        """APDL Command: MONITOR

        Controls contents of three variable fields in nonlinear solution
        monitor file.

        Parameters
        ----------
        var
            One of three variable field numbers in the monitor file whose
            contents can be specified by the Lab field.  Valid arguments are
            integers 1, 2, or 3. See Notes section for default values.

        node
            The node number for which information is monitored in the specified
            VAR field.  In the GUI, if Node = P, graphical picking is enabled.
            If blank, the monitor file lists the maximum value of the specified
            quantity (Lab field) for the entire structure.

        lab
            The solution quantity to be monitored in the specified VAR field.
            Valid labels for solution quantities are UX, UY, and UZ
            (displacements); ROTX, ROTY, and ROTZ (rotations); and TEMP
            (temperature).  Valid labels for reaction force are FX, FY, and FZ
            (structural force) and MX, MY, and MZ (structural moment).  Valid
            label for heat flow rate is HEAT. For defaults see the Notes
            section.

        Notes
        -----
        The monitor file always has an extension of .mntr, and takes its file
        name from the specified Jobname.  If no Jobname is specified, the file
        name defaults to file.

        You must issue this command once for each solution quantity you want to
        monitor at a specified node at each load step. You cannot monitor a
        reaction force during a linear analysis. The variable field contents
        can be redefined at each load step by reissuing the command. The
        monitored quantities are appended to the file for each load step.

        Reaction forces reported in the monitor file may be incorrect if the
        degree of freedom of the specified node is involved in externally
        defined coupling (CP command) or constraint equations (CE command), or
        if the program has applied constraint equations internally to the node.

        The following example shows the format of a monitor file.  Note that
        the file only records the solution substep history when a substep is
        convergent.

        The following details the contents of the various fields in the monitor
        file:

        The current load step number.

        The current substep (time step) number.

        The number of attempts made in solving the current substep.  This
        number is equal to the number of failed attempts (bisections) plus one
        (the successful attempt).

        The number of iterations used by the last successful attempt.

        Total cumulative number of iterations (including each iteration used by
        a bisection).

        :

        Time or load factor increments for the current substep.

        Total time (or load factor) for the last successful attempt in the
        current substep.

        Variable field 1.  In this example, the field is reporting the UZ
        value.  By default, this field lists the CPU time used up to (but not
        including) the current substep.

        Variable field 2.  In this example, the field is reporting the MZ
        value.  By default, this field lists the maximum displacement in the
        entire structure.

        Variable field 3.  By default (and in the example), this field reports
        the maximum equivalent plastic strain increment in the entire
        structure.
        """
        command = "MONITOR,%s,%s,%s" % (str(var), str(node), str(lab))
        return self.run(command, **kwargs)

    def contour(self, wn="", ncont="", vmin="", vinc="", vmax="", **kwargs):
        """APDL Command: /CONTOUR

        Specifies the uniform contour values on stress displays.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        ncont
            Number of contour values. NCONT defaults to 9 for X11 or WIN32 and
            to 128 for X11c or WIN32C.  The default graphics window display for
            3-D devices is a smooth continuous shading effect that spans the
            maximum of 128 contours available. Use the /DV3D command to create
            defined banding for your contour values (values of 9 and 128 are
            displayed in smooth shading only). The legend, however, will
            display only nine color boxes, which span the full range of colors
            displayed in the graphics window.

        vmin
            Minimum contour value.  If VMIN = AUTO, automatically calculate
            contour values based upon NCONT uniformly spaced values over the
            min-max extreme range.  Or, if VMIN = USER, set contour values to
            those of the last display (useful when last display automatically
            calculated contours).

        vinc
            Value increment (positive) between contour values.  Defaults to
            (VMAX-VMIN)/NCONT.

        vmax
            Maximum contour value.  Ignored if both VMIN and VINC are
            specified.

        Notes
        -----
        See the /CVAL command for alternate specifications.  Values represent
        contour lines in vector mode, and the algebraic maximum of contour
        bands in raster mode.

        Note:: : No matter how many contours (NCONT) are specified by /CONTOUR,
        the actual number of contours that appear on your display depends also
        on the device name, whether the display is directed to the screen or to
        a file, the display mode (vector or raster), and the number of color
        planes.  (All these items are controlled by /SHOW settings.) In any
        case, regardless of whether they are smoothed or banded, only 128
        contours can be displayed. See Creating Geometric Results Displays in
        the Basic Analysis Guide for more information on changing the number of
        contours.

        If the current ANSYS graphics are not displayed as Multi-Plots, then
        the following is true:  If the current device is a 3-D device
        [/SHOW,3D], the model contours in all active windows will be the same,
        even if separate /CONTOUR commands are issued for each active window.
        For efficiency, ANSYS 3-D graphics logic maintains a single data
        structure (segment), which contains precisely one set of contours.  The
        program displays the same segment in all windows.  The view settings of
        each window constitute the only differences in the contour plots in the
        active windows.

        This command is valid in any processor.
        """
        command = "/CONTOUR,%s,%s,%s,%s,%s" % (str(wn), str(ncont), str(vmin), str(vinc), str(vmax))
        return self.run(command, **kwargs)

    def gsave(self, fname="", ext="", **kwargs):
        """APDL Command: /GSAVE

        Saves graphics settings to a file for later use.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        This command does not save all graphics settings, but only those that
        may be reset by the /RESET command.  The database remains untouched.
        Use the /GRESUME command to read the file.  Repeated use of the /GSAVE
        command overwrites the previous data on the file.  The following
        commands are saved by /GSAVE:

        This command is valid in any processor.
        """
        command = "/GSAVE,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def rssims(self, rslab="", nsim="", seed="", **kwargs):
        """APDL Command: RSSIMS

        Performs Monte Carlo simulations on response surface(s).

        Parameters
        ----------
        rslab
            Response Surface set label. Identifies the response surfaces
            generated by the RSFIT command.

        nsim
            Number of simulation loops on the response surfaces that will be
            generated for all random output parameters. If the RSSIMS command
            is issued multiple times using the same response surface set label
            the NSIM Monte Carlo simulations is appended to previous ones. The
            default value for NSIM is 10,000.

        seed
            Seed value label. Random number generators require a seed value
            that is used to calculate the next random number. After each random
            number generation finishes, the seed value is updated and is used
            again to calculate the next random number. By default ANSYS
            initializes the seed value with the system time (one time only)
            when the ANSYS session started.

            CONT - Continues updating using the derived seed value (default).

            TIME - Initializes the seed value with the system time. You can use this if you want
                   the seed value set to a specific value for one analysis and
                   then you want to continue with a "random" seed in the next
                   analysis. It is not recommended to "randomize" the seed
                   value with the Seed = TIME option for multiple analyses. If
                   the Monte Carlo simulations requested with this command will
                   be appended to previously existing simulations, then the
                   Seed option is ignored and Seed = CONT is used.

            INIT - Initializes the seed value using 123457. This value is a typical recommendation
                   used very often in literature. This option leads to
                   identical random numbers for all random input variables when
                   the exact analysis will be repeated, making it useful for
                   benchmarking and validation purposes (where identical random
                   numbers are desired). If the Monte Carlo simulations
                   requested with this command will be appended to previously
                   existing simulations, then the Seed option is ignored and
                   Seed = CONT is used.

            Value - Uses the specified (positive) value for the initialization of the seed value.
                    This option has the same effect as Seed = INIT, except you
                    can chose an arbitrary (positive) number for the
                    initialization. If the Monte Carlo simulations requested
                    with this command will be appended to previously existing
                    simulations, then the Seed option is ignored and Seed =
                    CONT is used.

        Notes
        -----
        Generate the Monte Carlo simulations on the response surfaces that are
        included in a response surface set. Simulations are evaluated only for
        the output parameters that have been fitted in a response surface set
        using the RSFIT command.

        If the RSSIMS command is issued multiple times using the same response
        surface label the probabilistic design system appends the samples
        generated here to the previous ones. This way you can start with a
        moderate NSIM number and add more samples if the probabilistic results
        are not accurate enough.
        """
        command = "RSSIMS,%s,%s,%s" % (str(rslab), str(nsim), str(seed))
        return self.run(command, **kwargs)

    def aclear(self, na1="", na2="", ninc="", **kwargs):
        """APDL Command: ACLEAR

        Deletes nodes and area elements associated with selected areas.

        Parameters
        ----------
        na1, na2, ninc
            Delete mesh for areas NA1 to NA2 (defaults to NA1) in steps of NINC
            (defaults to 1).  If NA1 = ALL, NA2 and NINC are ignored and the
            mesh for all selected areas [ASEL] is deleted.  If NA1 = P,
            graphical picking is enabled and all remaining arguments are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NA1 (NA2 and NINC are ignored).

        Notes
        -----
        Deletes all nodes and area elements associated with selected areas
        (regardless of whether the nodes or elements are selected).  Nodes
        shared by adjacent meshed areas and nodes associated with non-area
        elements will not be deleted.  Attributes assigned as a result of AATT
        are maintained.  In the program's response to the command, if an area,
        line, or keypoint is tallied as "cleared," it means either its node or
        element reference was deleted.

        This command is also valid for rezoning. When issued during rezoning
        (after the REMESH,START command and before the REMESH,FINISH command),
        ACLEAR clears only the area generated by the AREMESH command.
        """
        command = "ACLEAR,%s,%s,%s" % (str(na1), str(na2), str(ninc))
        return self.run(command, **kwargs)

    def local(self, kcn="", kcs="", xc="", yc="", zc="", thxy="", thyz="",
              thzx="", par1="", par2="", **kwargs):
        """APDL Command: LOCAL

        Defines a local coordinate system by a location and orientation.

        Parameters
        ----------
        kcn
            Arbitrary reference number assigned to this coordinate system.
            Must be greater than 10.  A coordinate system previously defined
            with this number will be redefined.

        kcs
            Coordinate system type:

            0 or CART - Cartesian

            1 or CYLIN - Cylindrical (circular or elliptical)

            2 or SPHE - Spherical (or spheroidal)

            3 or TORO - Toroidal

        xc, yc, zc
            Location (in the global Cartesian coordinate system) of the origin
            of the new coordinate system.

        thxy
            First rotation about local Z (positive X toward Y).

        thyz
            Second rotation about local X (positive Y toward Z).

        thzx
            Third rotation about local Y (positive Z toward X).

        par1
            Used for elliptical, spheroidal, or toroidal systems.  If KCS = 1
            or 2, PAR1 is the ratio of the ellipse Y-axis radius to X-axis
            radius (defaults to 1.0 (circle)).  If KCS = 3, PAR1 is the major
            radius of the torus.

        par2
            Used for spheroidal systems.  If KCS = 2, PAR2 = ratio of ellipse
            Z-axis radius to X-axis radius (defaults to 1.0 (circle)).

        Notes
        -----
        Defines a local coordinate system by origin location and orientation
        angles.  The local coordinate system is parallel to the global
        Cartesian system unless rotated.  Rotation angles are in degrees and
        redefine any previous rotation angles.  See the CLOCAL, CS, CSWPLA, and
        CSKP commands for alternate definitions.  This local system becomes the
        active coordinate system [CSYS].  Local coordinate systems may be
        displayed with the /PSYMB command.

        This command is valid in any processor.
        """
        command = "LOCAL,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(kcn), str(kcs), str(xc), str(yc), str(zc), str(thxy), str(thyz), str(thzx), str(par1), str(par2))
        return self.run(command, **kwargs)

    def mpamod(self, mat="", deftemp="", **kwargs):
        """APDL Command: MPAMOD

        Modifies temperature-dependent secant coefficients of thermal
        expansion.

        Parameters
        ----------
        mat
            Material number for which the secant coefficients of thermal
            expansion (SCTE's) are to be modified.  Defaults to 1.

        deftemp
            Definition temperature at which the existing SCTE-versus-
            temperature tables were defined.  Defaults to zero.

        Notes
        -----
        This command converts temperature-dependent SCTE data (properties ALPX,
        ALPY, ALPZ)  from the definition temperature (DEFTEMP) to the reference
        temperature defined by MP,REFT or TREF.  If both the MP,REFT and TREF
        commands have been issued, the reference temperature defined by the
        MP,REFT command will be used.

        This command does not apply to the instantaneous coefficients of
        thermal expansion (properties CTEX, CTEY, CTEZ) or to the thermal
        strains (properties THSX, THSY, THSZ).

        See Linear Material Properties in the Mechanical APDL Material
        Reference and the Mechanical APDL Theory Reference for more details.

        This command is also valid in SOLUTION.
        """
        command = "MPAMOD,%s,%s" % (str(mat), str(deftemp))
        return self.run(command, **kwargs)

    def lwplan(self, wn="", nl1="", ratio="", **kwargs):
        """APDL Command: LWPLAN

        Defines the working plane normal to a location on a line.

        Parameters
        ----------
        wn
            Window number whose viewing direction will be modified to be normal
            to the working plane (defaults to 1).  If WN is a negative value,
            the viewing direction will not be modified.

        nl1
            Number of line to be used.  If NL1 = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).

        ratio
            Location on NL1, specified as a ratio of the line length.  Must be
            between 0.0 and 1.0.  If RATIO = P, use graphical picking to
            specify location on the line.

        Notes
        -----
        Defines a working plane (to assist in picking operations) normal to a
        location on a line.  See WPSTYL command to set the style of working
        plane display.

        This command is valid in any processor.
        """
        command = "LWPLAN,%s,%s,%s" % (str(wn), str(nl1), str(ratio))
        return self.run(command, **kwargs)

    def free(self, name="", **kwargs):
        """APDL Command: *FREE

        Deletes a matrix or a solver object and frees its memory allocation.

        Parameters
        ----------
        name
            Name of the matrix or solver object to delete. Use Name = ALL to
            delete all APDL Math matrices and solver objects.  Use Name = WRK
            to delete all APDL Math matrices and solver objects that belong to
            a given workspace.

        val1
            If Name = WRK, Val1 is to set the memory workspace number.

        Notes
        -----
        A /CLEAR command will automatically delete all the current APDL Math
        objects.
        """
        command = "*FREE,%s" % (str(name))
        return self.run(command, **kwargs)

    def irlf(self, key="", **kwargs):
        """APDL Command: IRLF

        Specifies that inertia relief calculations are to be performed.

        Parameters
        ----------
        key
            Calculation key:

             0  - No inertia relief calculations.

             1  - Counterbalance loads with inertia relief forces.

            -1  - Precalculate masses for summary printout only (no inertia relief).

        Notes
        -----
        The IRLF command specifies that the program is to calculate
        accelerations to counterbalance the applied loads (inertia relief).
        Displacement constraints on the structure should be only those
        necessary to prevent rigid-body motions (3 are needed for a 2-D
        structure and 6 for a 3-D structure).  The sum of the reaction forces
        at the constraint points will be zero.  Accelerations are calculated
        from the element mass matrices and the applied forces.  Data needed to
        calculate the mass (such as density) must be input.  Both translational
        and rotational accelerations may be calculated.

        This option applies only to the static (ANTYPE,STATIC) analysis.
        Nonlinearities, elements that operate in the nodal coordinate system,
        and axisymmetric or generalized plane strain elements are not allowed.
        Symmetry models are not valid for inertia relief analysis. Models with
        both 2-D and 3-D element types are not recommended.

        Loads may be input as usual.  Displacements and stresses are calculated
        as usual.

        Use IRLIST to print inertia relief calculation results.  The mass and
        moment of inertia summary printed before the solution is accurate
        (because of the additional pre-calculations required for inertia
        relief).  See Inertia Relief in the Mechanical APDL Theory Reference
        for calculation details.  See also the Structural Analysis Guide for
        procedural details.

        If the inertia relief calculation is to be performed in the second or
        later load step, you must specify EMATWRITE,YES in the initial load
        step for the element matrices needed to perform the calculations to be
        available.

        When a superelement (MATRIX50) is present in the model, any DOF
        constraints that you need to apply (D) on a degree of freedom (DOF)
        belonging to the superelement must be applied in the use pass of the
        MATRIX50 element (not in the generation pass). The command has no
        effect in the generation pass of a substructure. In the expansion pass,
        precalculation of masses for summary printout (IRLF,-1) occurs only on
        elements that are part of the substructure.

        This command is also valid in PREP7.
        """
        command = "IRLF,%s" % (str(key))
        return self.run(command, **kwargs)

    def cpcyc(self, lab="", toler="", kcn="", dx="", dy="", dz="", knonrot="",
              **kwargs):
        """APDL Command: CPCYC

        Couples the two side faces of a cyclically symmetric model for loadings
        that are the same on every segment.

        Parameters
        ----------
        lab
            Degree of freedom label for coupled nodes (in the nodal coordinate
            system). If ALL, use all appropriate labels.  Valid labels are:
            Structural labels:  UX, UY, or UZ (displacements); ROTX, ROTY, or
            ROTZ (rotations, in radians).

        toler
            Tolerance for coincidence (based on maximum coordinate difference
            in each global Cartesian direction for node locations and on angle
            differences for node orientations).  Defaults to 0.0001. Only nodes
            within the tolerance are considered to be coincident for coupling.

        kcn
             In coordinate system KCN, node 1 of CP + dx dy dz = node 2 of CP.

        dx, dy, dz
            Node location increments in the active coordinate system (DR, Dθ,
            DZ for cylindrical, DR, D θ, DΦ for spherical or toroidal).

        knonrot
            When KNONROT = 0, the nodes on coupled sets are rotated into
            coordinate system KCN (see NROTAT command description). When
            KNONROT = 1, the nodes are not rotated, and you should make sure
            that coupled nodal DOF directions are correct.

        Notes
        -----
         Cyclic coupling requires identical node and element patterns on the
        low and high sector boundaries. The MSHCOPY operation allows convenient
        generation of identical node and element patterns. See Using CPCYC and
        MSHCOPY Commands in the Modeling and Meshing Guide for more
        information.

        Although developed primarily for use with cyclically symmetric models,
        your use of the CPCYC command is not limited to cyclic symmetry
        analyses.
        """
        command = "CPCYC,%s,%s,%s,%s,%s,%s,%s" % (str(lab), str(toler), str(kcn), str(dx), str(dy), str(dz), str(knonrot))
        return self.run(command, **kwargs)

    def elist(self, iel1="", iel2="", inc="", nnkey="", rkey="", ptkey="",
              **kwargs):
        """APDL Command: ELIST

        Lists the elements and their attributes.

        Parameters
        ----------
        iel1, iel2, inc
            Lists elements from IEL1 to IEL2 (defaults to IEL1) in steps of INC
            (defaults to 1). If IEL1 = ALL (default), IEL2 and INC are ignored
            and all selected elements [ESEL] are listed. If IEL1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI). A component name may also be substituted
            for IEL1 (IEL2 and INC are ignored).

        nnkey
            Node listing key:

            0 - List attribute references and nodes.

            1 - List attribute references but not nodes.

        rkey
            Real constant listing key:

            0 - Do not show real constants for each element.

            1 - Show real constants for each element. This includes default values chosen for
                the element.

        ptkey
            LS-DYNA part number listing key (applicable to ANSYS LS-DYNA only):

            0 - Do not show part ID number for each element.

            1 - Show part ID number for each element.

        Notes
        -----
        Lists the elements with their nodes and attributes (MAT, TYPE, REAL,
        ESYS, SECNUM, PART). See also the LAYLIST command for listing layered
        elements.

        This command is valid in any processor.
        """
        command = "ELIST,%s,%s,%s,%s,%s,%s" % (str(iel1), str(iel2), str(inc), str(nnkey), str(rkey), str(ptkey))
        return self.run(command, **kwargs)

    def set(self, lstep="", sbstep="", fact="", kimg="", time="", angle="",
            nset="", order="", **kwargs):
        """APDL Command: SET

        Defines the data set to be read from the results file.

        Parameters
        ----------
        lstep
            Load step number of the data set to be read (defaults to 1):

            N - Read load step N.

            FIRST - Read the first data set (Sbstep and TIME are ignored).

            LAST - Read the last data set (Sbstep and TIME are ignored).

            NEXT - Read the next data set (Sbstep and TIME are ignored).  If at the last data set,
                   the first data set will be read as the next.

            PREVIOUS - Read the previous data set (Sbstep and TIME are ignored).  If at the first data
                       set, the last data set will be read as the previous.

            NEAR - Read the data set nearest to TIME (Sbstep is ignored).  If TIME is blank, read
                   the first data set.

            LIST - Scan the results file and list a summary of each load step.  (KIMG, TIME,
                   ANGLE, and NSET are ignored.)

        sbstep
            Substep number (within Lstep). Defaults to the last substep of the
            load step (except in a buckling or modal analysis). For a buckling
            (ANTYPE,BUCKLE) or modal (ANTYPE,MODAL) analysis, Sbstep
            corresponds to the mode number. Specify Sbstep = LAST to store the
            last substep for the specified load step (that is, issue a
            SET,Lstep,LAST command).

        fact
            Scale factor applied to data read from the file. If zero (or
            blank), a value of 1.0 is used. This scale factor is only applied
            to displacement and stress results. A nonzero factor excludes non-
            summable items.

        kimg
            Used only with complex results (harmonic and complex modal
            analyses).

            0 or REAL - Store the real part of complex solution (default).

            1, 2 or IMAG - Store the imaginary part of a complex solution.

            3 or AMPL - Store the amplitude

            4 or PHAS - Store the phase angle. The angle value, expressed in degrees, will be between
                        -180°  and +180°.

        time
            Time-point identifying the data set to be read.  For a harmonic
            analyses, time corresponds to the frequency.

        angle
            Circumferential location (0.0 to 360°).  Defines the
            circumferential location for the harmonic calculations used when
            reading from the results file.

        nset
            Data set number of the data set to be read.  If a positive value
            for NSET is entered, Lstep, Sbstep, KIMG, and TIME are ignored.
            Available set numbers can be determined by SET,LIST.

        order
            Key to sort the harmonic index results. This option applies to
            cyclic symmetry buckling and modal analyses only, and is valid only
            when Lstep = FIRST, LAST, NEXT, PREVIOUS, NEAR or LIST.

            ORDER  - Sort the harmonic index results in ascending order of eigenfrequencies or
                     buckling load multipliers.

            (blank)  - No sorting takes place.

        Notes
        -----
        Defines the data set to be read from the results file into the
        database.  Various operations may also be performed during the read
        operation.  The database must have the model geometry available (or use
        the RESUME command before the SET command to restore the geometry from
        Jobname.DB).  Values for applied constraints [D] and loads [F] in the
        database will be replaced by their corresponding values on the results
        file, if available. (See the description of the OUTRES command.)  In a
        single load step analysis, these values are usually the same, except
        for results from harmonic elements. (See the description of the ANGLE
        value above.)

        In an interactive run, the sorted list (ORDER option) is also available
        for results-set reading via a GUI pick option.

        You can postprocess results without issuing a SET command if the
        solution results were saved to the database file (Jobname.DB).
        Distributed ANSYS, however, can only postprocess using the results file
        (for example, Jobname.RST) and cannot use the Jobname.DB file since no
        solution results are written to the database. Therefore, you must issue
        a SET command or a RESCOMBINE command before postprocessing in
        Distributed ANSYS.
        """
        command = "SET,%s,%s,%s,%s,%s,%s,%s,%s" % (str(lstep), str(sbstep), str(fact), str(kimg), str(time), str(angle), str(nset), str(order))
        return self.run(command, **kwargs)

    def pdhist(self, rlab="", name="", ncl="", type="", **kwargs):
        """APDL Command: PDHIST

        Plots the frequency histogram.

        Parameters
        ----------
        rlab
            Result set label. Identifies the result set to be used for
            postprocessing. A result set label can be the solution set label
            you defined in a PDEXE command (if you are directly postprocessing
            Monte Carlo Simulation results), or the response surface set label
            defined in an RSFIT command (for Response Surface Analyses).

        name
            Parameter name. The parameter must have been previously defined as
            a random input variable or a random output parameter with the PDVAR
            command.

        ncl
            Number of classes for the histogram plot. This is the number of
            bars shown in the histogram. NCL must be a positive number. If this
            field is left blank, Mechanical APDL calculates an appropriate
            number of classes based on the sample size. ANSYS divides the range
            between the smallest and largest sample value into NCL classes of
            equal width and determines the histogram frequencies by counting
            the number of hits that fall in the classes.

        type
            Type of histogram.

            ABS - Absolute frequency histogram. This is the actual number of hits in each class.

            REL - Relative frequency histogram (default). This is the number of hits in the
                  individual classes divided by the total number of samples.

            NORM - Normalized frequency histogram. This is the number of hits in the individual
                   classes divided by the total number of samples and divided
                   by the width of the class. This normalization makes the
                   histogram comparable to the probability density function.

        Notes
        -----
        Plots the frequency histogram.

        If Rlab is left blank, then the result set label is inherited from the
        last PDEXE command (Slab), RSFIT command (RSlab), or the most recently
        used PDS postprocessing command where a result set label was explicitly
        specified.

        The PDHIST command cannot be used to postprocess the results in a
        solution set that is based on Response Surface Methods, only Monte
        Carlo Simulations.
        """
        command = "PDHIST,%s,%s,%s,%s" % (str(rlab), str(name), str(ncl), str(type))
        return self.run(command, **kwargs)

    def mffname(self, fnumb="", fname="", **kwargs):
        """APDL Command: MFFNAME

        Specifies a file name for a field in an ANSYS Multi-field solver
        analysis.

        Parameters
        ----------
        fnumb
            Field number specified by the MFELEM command.

        fname
            File name. Defaults to field "FNUMB".

        Notes
        -----
        All files created for the field will have this file name with the
        appropriate extensions.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFFNAME,%s,%s" % (str(fnumb), str(fname))
        return self.run(command, **kwargs)

    def vinp(self, nv1="", nv2="", nv3="", nv4="", nv5="", nv6="", nv7="",
             nv8="", nv9="", **kwargs):
        """APDL Command: VINP

        Finds the pairwise intersection of volumes.

        Parameters
        ----------
        nv1, nv2, nv3, . . . , nv9
            Numbers of volumes to be intersected pairwise.  If NV1 = ALL, NV2
            to NV9 are ignored and the pairwise intersection of all selected
            volumes is found.  If NV1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  A
            component name may also be substituted for NV1.

        Notes
        -----
        Finds the pairwise intersection of volumes.  The pairwise intersection
        is defined as all regions shared by any two or more volumes listed on
        this command.  New volumes will be generated where the original volumes
        intersect pairwise.  If the regions of pairwise intersection are only
        areas, new areas will be generated.  See the Modeling and Meshing Guide
        for an illustration.  See the BOPTN command for an explanation of the
        options available to Boolean operations.  Element attributes and solid
        model boundary conditions assigned to the original entities will not be
        transferred to the new entities generated.
        """
        command = "VINP,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nv1), str(nv2), str(nv3), str(nv4), str(nv5), str(nv6), str(nv7), str(nv8), str(nv9))
        return self.run(command, **kwargs)

    def subopt(self, option="", value1="", **kwargs):
        """APDL Command: SUBOPT

        Specifies Subspace (SUBSP) eigensolver options.

        Parameters
        ----------
        option
            One of the following options:

            STRMCK - Controls whether a Sturm sequence check is performed.

            Value1: - OFF

            Do not perform Sturm sequence check (default). - ON

            Perform Sturm sequence check. - MEMORY

            Controls the memory allocation strategy for the Subspace eigensolver. - Value1:

            AUTO - Use the default memory allocation strategy (default).

            INCORE - Force the Subspace eigensolver to allocate in-core memory.

            OUTOFCORE - Force the Subspace eigensolver to use scratch files.

        Notes
        -----
        SUBOPT specifies options to be used with the Subspace eigensolver
        (MODOPT,SUBSP) during a modal analysis.
        """
        command = "SUBOPT,%s,%s" % (str(option), str(value1))
        return self.run(command, **kwargs)

    def bfunif(self, lab="", value="", **kwargs):
        """APDL Command: BFUNIF

        Assigns a uniform body force load to all nodes.

        Parameters
        ----------
        lab
            Valid body load label.  If ALL, use all appropriate labels.

        value
            Uniform value associated with Lab item, or table name when
            specifying tabular boundary conditions.  To specify a table,
            enclose the table name in percent signs (%), e.g.,
            BFUNIF,Lab,%tabname%.

        Notes
        -----
        In a transient or nonlinear thermal analysis, the uniform temperature
        is used during the first iteration of a solution as follows:  (a) as
        the starting nodal temperature (except where temperatures are
        explicitly specified [D, DK]), and (b) to evaluate temperature-
        dependent material properties.  In a structural analysis or explicit
        dynamic analysis, the uniform temperature is used as the default
        temperature for thermal strain calculations and material property
        evaluation (except where body load temperatures are specified [BF, BFE,
        BFK, LDREAD]).  In other scalar field analyses, the uniform temperature
        is used for material property evaluation.

        When the command BFUNIF,TEMP is used in an explicit dynamic analysis,
        you cannot use the EDLOAD,TEMP command to apply temperature loading.
        Furthermore, any temperature loading defined by BFUNIF cannot be listed
        or deleted by the EDLOAD command.

        An alternate command, TUNIF, may be used to set the uniform temperature
        instead of BFUNIF,TEMP. Since TUNIF (or BFUNIF,TEMP) is step-applied in
        the first iteration, you should use BF, ALL, TEMP, Value to ramp on a
        uniform temperature load.

        You can specify a table name only when using temperature (TEMP), heat
        generation rate (HGEN), and diffusing substance generation rate (DGEN)
        body load labels. When using TEMP, you can define a one-dimensional
        table that varies with respect to time (TIME) only. When defining this
        table, enter TIME as the primary variable. No other primary variables
        are valid. Tabular boundary conditions cannot be used in an explicit
        dynamic analysis.

        This command is also valid in PREP7.
        """
        command = "BFUNIF,%s,%s" % (str(lab), str(value))
        return self.run(command, **kwargs)

    def sread(self, strarray="", fname="", ext="", nchar="", nskip="",
              nread="", **kwargs):
        """APDL Command: *SREAD

        Reads a file into a string array parameter.

        Parameters
        ----------
        strarray
            Name of the "string array" parameter which will hold the read file.
            String array parameters are similar to character arrays, but each
            array element can be as long as 128 characters. If the string
            parameter does not exist, it will be created. The array will be
            created as: *DIM,StrArray,STRING,nChar,nRead

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        nchar
            Number of characters per line to read (default is length of the
            longest line in the file).

        nskip
            Number of lines to skip at the start of the file (default is 0).

        nread
            Number of lines to read from the file (default is the entire file).

        Notes
        -----
        The *SREAD command reads from a file into a string array parameter. The
        file must be an ASCII text file.
        """
        command = "*SREAD,%s,%s,%s,%s,%s,%s" % (str(strarray), str(fname), str(ext), str(nchar), str(nskip), str(nread))
        return self.run(command, **kwargs)

    def flst(self, nfield="", narg="", type="", otype="", leng="", **kwargs):
        """APDL Command: FLST

        Specifies data required for a picking operation (GUI).

        Parameters
        ----------
        nfield
            Field number on the command which uses the picking data.  (Count
            the command name as a field, so that a 2 indicates the first
            command argument, 3 for the second command argument, etc.)  The
            corresponding field on the command will have a P51X label.

        narg
            Number of items in the picked list.

        type
            Type of items picked:

            1 - Node numbers

            2 - Element numbers

            3 - Keypoint numbers

            4 - Line numbers

            5 - Area numbers

            6 - Volume numbers

            7 - Trace points

            8 - Coordinate locations (in Global Cartesian coordinates)

            9 - Screen picks (in X, Y screen coordinates (-1 to 1))

        otype
            Data order:

            NOOR - Data is not ordered (default).

            ORDER - Data is in an ordered list (such as for the E,P51X and A,P51X commands, in
                    which the order of the data items is significant for the
                    picking operation).

        leng
            Length of number of items describing the list (should equal NARG if
            Otype = NOOR; default).

        Notes
        -----
        Specifies data required for the FITEM command during a picking
        operation.  This is a command generated by the GUI and will appear in
        the log file (Jobname.LOG) if graphical picking is used.  This command
        is not intended to be typed in directly in an ANSYS session (although
        it can be included in an input file for batch input or for use with the
        /INPUT command).

        On the log file, FLST will always be followed by one or more FITEM
        commands which in turn are followed by the ANSYS command that contains
        a P51X label in one of its fields. This set of commands should not be
        edited.

        This command is valid in any processor.
        """
        command = "FLST,%s,%s,%s,%s,%s" % (str(nfield), str(narg), str(type), str(otype), str(leng))
        return self.run(command, **kwargs)

    def nang(self, node="", x1="", x2="", x3="", y1="", y2="", y3="", z1="",
             z2="", z3="", **kwargs):
        """APDL Command: NANG

        Rotates a nodal coordinate system by direction cosines.

        Parameters
        ----------
        node
            Rotate coordinate system of this node.

        x1, x2, x3
            Global X, Y, Z components of a unit vector in new nodal X
            direction.

        y1, y2, y3
            Global X, Y, Z components of a unit vector in new nodal Y
            direction.

        z1, z2, z3
            Global X, Y, Z components of a unit vector in new nodal Z
            direction.

        Notes
        -----
        Rotates a nodal coordinate system to the orientation specified by the
        X, Y and Z direction cosines.  Existing rotation specifications on the
        node are redefined.  If only two of the three unit vectors are
        specified, the third is defined according to the right hand rule.  It
        is the responsibility of the user to ensure that input direction
        cosines are orthogonal in a right-handed system.

        See the NMODIF, NROTAT, and NORA commands for other rotation options.
        """
        command = "NANG,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(node), str(x1), str(x2), str(x3), str(y1), str(y2), str(y3), str(z1), str(z2), str(z3))
        return self.run(command, **kwargs)

    def bfkdele(self, kpoi="", lab="", **kwargs):
        """APDL Command: BFKDELE

        Deletes body force loads at a keypoint.

        Parameters
        ----------
        kpoi
            Keypoint at which body load is to be deleted.  If ALL, delete for
            all selected keypoints [KSEL]. A component name may also be
            substituted for KPOI.

        lab
            Valid body load label. If ALL, use all appropriate labels. Load
            labels are listed under "Body Loads" in the input table for each
            element type in the Element Reference. See the BFK command for
            labels.

        Notes
        -----
        Deletes body force loads (and all corresponding finite element loads)
        for a specified keypoint and label.  Body loads may be defined at a
        keypoint with the BFK command.

        Graphical picking is available only via the listed menu paths.

        This command is also valid in PREP7.
        """
        command = "BFKDELE,%s,%s" % (str(kpoi), str(lab))
        return self.run(command, **kwargs)

    def rectng(self, x1="", x2="", y1="", y2="", **kwargs):
        """APDL Command: RECTNG

        Creates a rectangular area anywhere on the working plane.

        Parameters
        ----------
        x1, x2
            Working plane X coordinates of the rectangle.

        y1, y2
            Working plane Y coordinates of the rectangle.

        Notes
        -----
        The area will be defined with four keypoints and four lines.  See the
        BLC4 and BLC5 commands for alternate ways to create rectangles.
        """
        command = "RECTNG,%s,%s,%s,%s" % (str(x1), str(x2), str(y1), str(y2))
        return self.run(command, **kwargs)

    def lsread(self, lsnum="", **kwargs):
        """APDL Command: LSREAD

        Reads load and load step option data into the database.

        Parameters
        ----------
        lsnum
            Identification number of the load step file to be read.  Defaults
            to 1 + highest number read in the current session.  Issue
            LSREAD,STAT to list the current value of LSNUM.  Issue LSREAD,INIT
            to reset LSNUM to 1.  The load step files are assumed to be named
            Jobname.Sn, where n is a number assigned by the LSWRITE command (01
            --09,10,11, etc.).  On systems with a 3-character limit on the
            extension, the "S" is dropped for LSNUM > 99.

        Notes
        -----
        Reads load and load step option data from the load step file into the
        database.  LSREAD will not clear the database of all current loads.
        However, if a load is respecified with LSREAD, then it will overwrite
        the existing load. See the LSWRITE command to write load step files,
        and the LSDELE command to delete load step files.  LSREAD removes any
        existing SFGRAD specification.

        This command is also valid in PREP7.
        """
        command = "LSREAD,%s" % (str(lsnum))
        return self.run(command, **kwargs)

    def nread(self, fname="", ext="", **kwargs):
        """APDL Command: NREAD

        Reads nodes from a file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        The read operation is not necessary in a standard ANSYS run but is
        provided as a convenience to users wanting to read a coded node file,
        such as from another mesh generator or from a CAD/CAM program.  Data
        should be formatted as produced with the NWRITE command. Only nodes
        that are within the node range specified with the NRRANG command are
        read from the file.  Duplicate nodes already in the database will be
        overwritten.  The file is rewound before and after reading.  Reading
        continues until the end of the file.
        """
        command = "NREAD,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def lsbl(self, nl1="", nl2="", sepo="", keep1="", keep2="", **kwargs):
        """APDL Command: LSBL

        Subtracts lines from lines.

        Parameters
        ----------
        nl1
            Line (or lines, if picking is used) to be subtracted from.  If ALL,
            use all selected lines.  Lines specified in this argument are not
            available for use in the NL2 argument.  If P, graphical picking is
            enabled (valid only in the GUI) and all remaining fields are
            ignored.  A component name may also be substituted for NL1.

        nl2
            Line (or lines, if picking is used) to subtract.  If ALL, use all
            selected lines (except those included in the NL1 argument).  A
            component name may also be substituted for NL2.

        sepo
            Behavior if the intersection of the NL1 lines and the NL2 lines is
            a keypoint or keypoints:

            (blank) - The resulting lines will share keypoint(s) where they touch.

            SEPO - The resulting lines will have separate, but coincident keypoint(s) where they
                   touch.

        keep1
            Specifies whether NL1 lines are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NL1 lines after LSBL operation (override BOPTN command settings).

            KEEP - Keep NL1 lines after LSBL operation (override BOPTN command settings).

        keep2
            Specifies whether NL2 lines are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NL2 lines after LSBL operation (override BOPTN command settings).

            KEEP - Keep NL2 lines after LSBL operation (override BOPTN command settings).

        Notes
        -----
        Generates new lines by subtracting the regions common to both NL1 and
        NL2 lines (the intersection) from the NL1 lines.  The intersection can
        be a line(s) or point(s).  If the intersection is a point and SEPO is
        blank, the NL1 line is divided at the point and the resulting lines
        will be connected, sharing a common keypoint where they touch.  If SEPO
        is set to SEPO, NL1 is divided into two unconnected lines with separate
        keypoints where they touch.  See the Modeling and Meshing Guide for an
        illustration.  See the BOPTN command for an explanation of the options
        available to Boolean operations.  Element attributes and solid model
        boundary conditions assigned to the original entities will not be
        transferred to the new entities generated.  LSBL,ALL,ALL will have no
        effect since all the lines (in NL1) will be unavailable as NL2 lines.
        """
        command = "LSBL,%s,%s,%s,%s,%s" % (str(nl1), str(nl2), str(sepo), str(keep1), str(keep2))
        return self.run(command, **kwargs)

    def lrotat(self, nk1="", nk2="", nk3="", nk4="", nk5="", nk6="", pax1="",
               pax2="", arc="", nseg="", **kwargs):
        """APDL Command: LROTAT

        Generates circular lines by rotating a keypoint pattern about an axis.

        Parameters
        ----------
        nk1, nk2, nk3, . . . , nk6
            List of keypoints in the pattern to be rotated (6 maximum if using
            keyboard entry).  If NK1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  If
            NK1 = ALL, all selected keypoints (except PAX1 and PAX2) will
            define the pattern to be rotated.  A component name may also be
            substituted for NK1.

        pax1, pax2
            Keypoints defining the axis about which the keypoint pattern is to
            be rotated.

        arc
            Arc length (in degrees).  Positive follows right-hand rule about
            PAX1-PAX2 vector.  Defaults to 360.

        nseg
            Number of lines (8 maximum) around circumference.  Defaults to
            minimum required for 90° (maximum) arcs, i.e., 4 for 360°, 3 for
            270°, etc.

        Notes
        -----
        Generates circular lines (and their corresponding keypoints) by
        rotating a keypoint pattern about an axis.  Keypoint patterns are
        generated at regular angular locations (based on a maximum spacing of
        90°).  Line patterns are generated at the keypoint patterns.  Keypoint
        and line numbers are automatically assigned (beginning with the lowest
        available values [NUMSTR]).
        """
        command = "LROTAT,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nk1), str(nk2), str(nk3), str(nk4), str(nk5), str(nk6), str(pax1), str(pax2), str(arc), str(nseg))
        return self.run(command, **kwargs)

    def gplist(self, gap1="", gap2="", ginc="", **kwargs):
        """APDL Command: GPLIST

        Lists the gap conditions.

        Parameters
        ----------
        gap1, gap2, ginc
            List gap conditions from GAP1 to GAP2 (GAP2 defaults to GAP1) in
            steps of GINC  (defaults to 1).  If GAP1 = ALL (default), GAP2 and
            GINC  are ignored and all gap conditions are listed.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "GPLIST,%s,%s,%s" % (str(gap1), str(gap2), str(ginc))
        return self.run(command, **kwargs)

    def nrrang(self, nmin="", nmax="", ninc="", **kwargs):
        """APDL Command: NRRANG

        Specifies the range of nodes to be read from the node file.

        Parameters
        ----------
        nmin, nmax, ninc
            Node range is defined from NMIN (defaults to 1) to NMAX (defaults
            to 99999999) in steps of NINC (defaults to 1).

        Notes
        -----
        Defines the range of nodes to be read [NREAD] from the node file.  Also
        implies an element range since only elements fully attached to these
        nodes will be read from the element file.
        """
        command = "NRRANG,%s,%s,%s" % (str(nmin), str(nmax), str(ninc))
        return self.run(command, **kwargs)

    def keypts(self, **kwargs):
        """APDL Command: KEYPTS

        Specifies "Keypoints" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "KEYPTS," % ()
        return self.run(command, **kwargs)

    def domega(self, domgx="", domgy="", domgz="", **kwargs):
        """APDL Command: DOMEGA

        Specifies the rotational acceleration of the structure.

        Parameters
        ----------
        domgx, domgy, domgz
            Rotational acceleration of the structure about the global Cartesian
            X , Y, and Z axes.

        Notes
        -----
        Specifies the rotational acceleration of the structure about each of
        the global Cartesian axes.  Rotational accelerations may be defined in
        analysis types ANTYPE,STATIC, HARMIC (full or mode-superposition),
        TRANS (full or mode-superposition), and SUBSTR.  See Acceleration
        Effect in the Mechanical APDL Theory Reference for details.  Units are
        radians/time2.

        The DOMEGA command supports tabular boundary conditions (%TABNAME_X%,
        %TABNAME_Y%, and %TABNAME_Z%) for DOMEGA_X, DOMEGA_Y, and DOMEGA_Z
        input values (*DIM) for full transient and harmonic analyses.

        Related commands are ACEL, CGLOC, CGOMGA, DCGOMG, and OMEGA.

        See Analysis Tools in the Mechanical APDL Theory Reference for more
        information.

        In a modal harmonic or transient analysis, you must apply the load in
        the modal portion of the analysis. Mechanical APDL calculates a load
        vector and writes it to the mode shape file, which you can apply via
        the LVSCALE command.

        This command is also valid in PREP7.
        """
        command = "DOMEGA,%s,%s,%s" % (str(domgx), str(domgy), str(domgz))
        return self.run(command, **kwargs)

    def elbow(self, transkey="", tol="", dof="", cons1="", cons2="", cons3="",
              cons4="", **kwargs):
        """APDL Command: ELBOW

        Specifies degrees of freedom to be coupled for end release and applies
        section constraints to elbow elements.

        Parameters
        ----------
        transkey
            Pipe-to-elbow transition flag:

            OFF - Do not automatically transition pipes to elbows. (This behavior is the
                  default.)

            ON - Automatically convert straight PIPE289 elements to ELBOW290 elements where it
                 is beneficial. The program converts elements in transition
                 regions where curved ELBOW290 elements are connected to
                 straight PIPE289 elements.

        tol
            Angle tolerance (in degrees) between adjacent ELBOW290 elements.
            The default value is 20. A value of -1 specifies all selected
            ELBOW290 elements.

        dof
            Degrees of freedom to couple:

            ALL - Couple all nodal degrees of freedom (UX, UY, UZ, ROTX, ROTY, and ROTZ). This
                  behavior is the default.

            BALL - Create ball joints (equivalent to releasing ROTX, ROTY, and ROTZ).

        cons1, cons2, cons3, cons4
            Section degrees of freedoms to constrain. If Cons1 through Cons4
            are unspecified, no section constraints are applied:

            SECT  - All section deformation

            SE - Section radial expansion

            SO - Section ovalization

            SW - Section warping

            SRA - Local shell normal rotation about cylindrical axis t2

            SRT - Local shell normal rotation about cylindrical axis t1

        Notes
        -----
        The ELBOW command specifies end releases and section constraints for
        ELBOW290 elements and converts straight PIPE289 elements to ELBOW290
        elements.

        Curved PIPE289 elements are not converted to ELBOW290 elements.

        ELBOW290 elements are generated only if there are existing ELBOW290
        elements in the curved areas.

        The command works on currently selected nodes and elements. It creates
        end releases on any two connected elbow elements whose angle at
        connection exceeds the specified tolerance. From within the GUI, the
        Picked node option generates an end release and section constraints at
        the selected node regardless of the angle of connection (that is, the
        angle tolerance [TOL ] is set to -1).

        Elbow and pipe elements must share the same section ID in order for the
        pipe-to-elbow transition to occur.

        To list the elements altered by the ELBOW command, issue an ELIST
        command.

        To list the coupled sets generated by the ELBOW command, issue a CPLIST
        command.

        To list the section constraints generated by the ELBOW command, issue a
        DLIST command.
        """
        command = "ELBOW,%s,%s,%s,%s,%s,%s,%s" % (str(transkey), str(tol), str(dof), str(cons1), str(cons2), str(cons3), str(cons4))
        return self.run(command, **kwargs)

    def ddoption(self, decomp="", **kwargs):
        """APDL Command: DDOPTION

         Sets domain decomposer option for Distributed ANSYS.

        Parameters
        ----------
        decomp
            Controls which domain decomposition algorithm to use.

            AUTO - Use the default domain decomposition algorithm when splitting the model into
                   domains for Distributed ANSYS (default).

            GREEDY - Use the “greedy” domain decomposition algorithm.

            METIS - Use the METIS graph partitioning domain decomposition algorithm.

        Notes
        -----
        This command controls options relating to the domain decomposition
        algorithm used by Distributed ANSYS to split the model into pieces (or
        domains), with each piece being solved on a different processor.

        The greedy domain decomposition algorithm starts from a single element
        at a corner of the model. The domain grows by taking the properly
        connected neighboring elements and stops after reaching the optimal
        size.

        The METIS domain decomposition algorithm starts by creating a graph
        from the finite element mesh. It then uses a multilevel graph
        partitioning scheme which reduces the size of the original graph,
        creates domains using the reduced graph, and then creates the final CPU
        domains by expanding the smaller domains from the reduced graph back to
        the original mesh.
        """
        command = "DDOPTION,%s" % (str(decomp))
        return self.run(command, **kwargs)

    def header(self, header="", stitle="", idstmp="", notes="", colhed="",
               minmax="", **kwargs):
        """APDL Command: /HEADER

        Sets page and table heading print controls.

        Parameters
        ----------
        header
            ANSYS page header (system, date, time, version, copyright, title,
            etc.):

            ON - Turns this item on (default for batch mode; not available for interactive
                 mode).

            OFF - Turns this item off.

            (blank) - Retains the previous setting.

        stitle
            Subtitles (see /STITLE command):   ON, OFF, or (blank) (see above).

        idstmp
            Load step information (step number, substep number, time value):
            ON, OFF, or (blank) (see above).

        notes
            Information relative to particular table listings:   ON, OFF, or
            (blank) (see above).

        colhed
            Column header labels of table listings (currently only for single
            column tables):   ON, OFF, or (blank) (see above).

        minmax
            Minimum/maximum information or totals after table listings:   ON,
            OFF, or (blank) (see above).

        Notes
        -----
        Sets specifications on or off for page and table heading print controls
        associated with the POST1 PRNSOL, PRESOL, PRETAB, PRRSOL, and PRPATH
        commands.

        Note:: : If the printout caused a  top-of-form (page eject to top of
        next page), the top-of-form is also suppressed with the printout.
        Issue /HEADER,STAT to display the current settings.  Issue /HEADER,DEFA
        to reset the default specifications.

        This command is valid in any processor.
        """
        command = "/HEADER,%s,%s,%s,%s,%s,%s" % (str(header), str(stitle), str(idstmp), str(notes), str(colhed), str(minmax))
        return self.run(command, **kwargs)

    def vovlap(self, nv1="", nv2="", nv3="", nv4="", nv5="", nv6="", nv7="",
               nv8="", nv9="", **kwargs):
        """APDL Command: VOVLAP

        Overlaps volumes.

        Parameters
        ----------
        nv1, nv2, nv3, . . . , nv9
            Numbers of volumes to be operated on.  If NV1 = ALL, NV2 to NV9 are
            ignored and all selected volumes are used.  If NV1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).  A component name may also be substituted
            for NV1.

        Notes
        -----
        Overlaps volumes. Generates new volumes which encompass the geometry of
        all  the input volumes.  The new volumes are defined by the regions of
        intersection  of the input volumes, and by the complementary (non-
        intersecting) regions.   See the Modeling and Meshing Guide for an
        illustration.  This operation is only valid  when the region of
        intersection is a volume.  See the BOPTN command for an explanation of
        the options available to Boolean operations.  Element attributes and
        solid model boundary conditions assigned to the original entities will
        not be transferred to the new entities generated.
        """
        command = "VOVLAP,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nv1), str(nv2), str(nv3), str(nv4), str(nv5), str(nv6), str(nv7), str(nv8), str(nv9))
        return self.run(command, **kwargs)

    def fecons(self, **kwargs):
        """APDL Command: FECONS

        Specifies "Constraints on nodes" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "FECONS," % ()
        return self.run(command, **kwargs)

    def dmat(self, matrix="", type="", method="", val1="", val2="", val3="",
             val4="", val5="", **kwargs):
        """APDL Command: *DMAT

        Creates a dense matrix.

        Parameters
        ----------
        matrix
            Name used to identify the matrix. Must be specified.

        type
            Matrix type:

            Double precision real values (default). - Complex double precision values.

        method
            Method used to create the matrix:

            Allocate space for a matrix (default). - Resize an existing matrix to new row and column dimensions. Values are kept
                              from the original matrix. If the dimensions
                              specified by Val1 (rows) and Val2 (columns) are
                              greater than the original matrix size, the
                              additional entries are assigned a value of zero.

            Copy an existing matrix. - Link to an existing matrix. The memory will be shared between the original
                              matrix and the new matrix. This is useful for
                              manipulating a submatrix of a larger matrix. The
                              Val1 through Val5 arguments will be used to
                              specify the lower and upper bounds of row and
                              column numbers from the original matrix.

        val1, val2, val3, val4, val5
            Additional input. The meaning of Val1 through Val5 will vary
            depending on the specified Method. See details below.

        Notes
        -----
        This command allows you to create a dense matrix. To create a sparse
        matrix, use the *SMAT command. *SMAT is recommended for large matrices
        obtained from the .FULL or .HBMAT file. Refer to the HBMAT command
        documentation for more information about .FULL file contents.

        Use the *VEC command to create a vector.

        For very large matrices, use the OUTOFCORE option (Method = ALLOC or
        COPY) to keep some of the matrix on disk if there is insufficient
        memory.

        When importing a dense matrix from a DMIG file, you can define the
        formatting of the file using the Val3 and Val4 fields. Here are a few
        different example of formats:

        A formatted file (using Val3=’F’, and Val4=8):
        """
        command = "*DMAT,%s,%s,%s,%s,%s,%s,%s,%s" % (str(matrix), str(type), str(method), str(val1), str(val2), str(val3), str(val4), str(val5))
        return self.run(command, **kwargs)

    # def return(self, level="", **kwargs):
    #     """APDL Command: *RETURN

    #     Returns input stream to a higher level.

    #     Parameters
    #     ----------
    #     level
    #         Number of levels to move up from the current level.

    #         Move relative to current level. For example: *Return,-2 will go up two levels from the current level. - Move to absolute level. For example: *Return,2 will go to level 2.

    #     Notes
    #     -----
    #     This command is used to jump to the macro call sequence, ending the
    #     current macro file, and returning to the line after the calling line in
    #     the previous file. Unlike the *GO command, this command may be used
    #     inside *IF or *DO constructs.
    #     """
    #     command = "*RETURN,%s" % (str(level))
    #     return self.run(command, **kwargs)

    def slashgo(self, **kwargs):
        """APDL Command: /GO

        Reactivates suppressed printout.

        Notes
        -----
        Reactivates printout suppressed with the /NOPR command without
        producing any output.  The /GOPR command has the same function except
        that it also produces a command response from the program.

        This command is valid in any processor.
        """
        command = "/GO," % ()
        return self.run(command, **kwargs)

    def kclear(self, np1="", np2="", ninc="", **kwargs):
        """APDL Command: KCLEAR

        Deletes nodes and point elements associated with selected keypoints.

        Parameters
        ----------
        np1, np2, ninc
            Delete mesh for keypoints NP1 to NP2 (defaults to NP1) in steps of
            NINC (defaults to 1).  If NP1 = ALL, NP2 and NINC are ignored and
            the mesh for all selected keypoints [KSEL] is deleted.  If NP1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NP1.

        Notes
        -----
        Deletes all nodes and point elements associated with selected keypoints
        (regardless of whether the nodes or elements are selected).  Nodes
        associated with non-point elements will not be deleted.  Attributes
        assigned as a result of KATT are maintained.  In the program's response
        to the command, if a keypoint is tallied as "cleared," it means either
        its node or element reference was deleted.
        """
        command = "KCLEAR,%s,%s,%s" % (str(np1), str(np2), str(ninc))
        return self.run(command, **kwargs)

    def nsubst(self, nsbstp="", nsbmx="", nsbmn="", carry="", **kwargs):
        """APDL Command: NSUBST

        Specifies the number of substeps to be taken this load step.

        Parameters
        ----------
        nsbstp
            Number of substeps to be used for this load step (i.e., the time
            step size or frequency increment). If automatic time stepping is
            used (AUTOTS), NSBSTP defines the size of the first substep.

        nsbmx
            Maximum number of substeps to be taken (i.e., the minimum time step
            size) if automatic time stepping is used. The program automatically
            determines the default based on the physics of the model.

        nsbmn
            Minimum number of substeps to be taken (i.e., the maximum time step
            size) if automatic time stepping is used. The program automatically
            determines the default based on the physics of the model.

        carry
            Time step carryover key (program-determined default depending on
            the problem physics):

            OFF - Use NSBSTP to define time step at start of each load step.

            ON - Use final time step from previous load step as the starting time step (if
                 automatic time stepping is used).

        Notes
        -----
        See DELTIM for an alternative input.  It is recommended that all fields
        of this command be specified for solution efficiency and robustness.

        When the arc-length method is active (ARCLEN command), the NSBMX and
        NSBMN arguments are ignored.

        This command is also valid in PREP7.
        """
        command = "NSUBST,%s,%s,%s,%s" % (str(nsbstp), str(nsbmx), str(nsbmn), str(carry))
        return self.run(command, **kwargs)

    def cmplot(self, label="", entity="", keyword="", **kwargs):
        """APDL Command: CMPLOT

        Plots the entities contained in a component or assembly.

        Parameters
        ----------
        label
            Name of the component or assembly to be plotted.

            (blank) - All selected components and assemblies are plotted (default).  If fewer than 11
                      components are selected, then all  are plotted.  If more
                      than 11 components are selected, then only the first 11
                      are plotted.

            ALL - All selected components are plotted. If number of selected components is
                  greater than 11, then the legend showing component names will
                  not be shown.

            N - Next set of defined components and assemblies is plotted.

            P - Previous set of defined components and assemblies is plotted.

            Cname - The specified component or assembly is plotted.

            SetNo. - The specified set number is plotted.

        entity
            If Label is BLANK or ALL, then the following entity types can be
            specified:

            VOLU - Plot the volume components only.

            AREA - Plot the area components only.

            LINE - Plot the line components only.

            KP - Plot the keypoint components only.

            ELEM - Plot the element components only.

            NODE - Plot the node components only.

        keyword
            For Keyword = ALL, plot the specified component name in the Label
            field in the context of all entities of the same type. Not valid if
            Label field is BLANK or ALL.

        Notes
        -----
        Components are plotted with their native entities.  For assemblies, all
        native entities for the underlying component types are plotted
        simultaneously.  Although more components can be plotted, the legend
        displays only 11 at a time. When more than eleven are plotted, the
        legend is not displayed.

        Possible usage:

        This command is valid in any processor.
        """
        command = "CMPLOT,%s,%s,%s" % (str(label), str(entity), str(keyword))
        return self.run(command, **kwargs)

    def txtre(self, lab="", num="", n1="", n2="", ninc="", **kwargs):
        """APDL Command: /TXTRE

        Controls application of texture to selected items.

        Parameters
        ----------
        lab
            You can apply texture according to the following labels:

            ELEM - Apply texture to elements N1 through N2 in steps of NINC.

            AREA - Apply texture to areas N1 through N2 in steps of NINC.

            VOLU - Apply texture to volumes N1 through N2 in steps of NINC.

            CM - Apply texture to the component named in N1. N2 and NINC are ignored.

            ON, OFF - Sets the specified texture display on or off. All other fields are ignored.

            File - If Lab = File, the command format is /TXTRE, File, Key_Index, Fname, Fext, --,
                   Format (This variant of the command is applicable to 2-D
                   drivers).

            Key_Index - The texture index associated with the file. If the number fifty-one (51) is
                        used, the imported bitmap will be used as the window's
                        logo.

            Fname - File name and directory path (248 characters maximum, including the characters
                    needed for the directory path).  An unspecified directory
                    path defaults to the working directory; in this case, you
                    can use all 248 characters for the file name.

            Fext - Filename extension (eight-character maximum).

            -- - Unused field.

            Format - The file format. If Format = 0, the file is a pixmap (Linux) or Bitmap (PC).
                     The file cannot contain a compressed image, and the PC
                     file must be 8 or 24 bit BI_RGB format. If Format = 1 or
                     JPEG, then the file is in JPEG (Joint Photographic Experts
                     Group) format. If Format = 2 or PNG, then the file is in
                     PNG (Portable Network Graphics) format.

        num
            Select the texture index number from the following list:

            0 - No Texturing

            1 - Aluminum

            2 -  Aluminum, Brushed

            3 - Steel With Bumps

            4 - Steel, Embossed

            5 - Iron

            6 - Steel, Pattern

            7 - Steel, Riveted

            8 - Steel, Scratched

            9 - Tin

            10 - Metal

            11 - Steel, Etched

            12 - Metal, Hot

            13 - Iron, Grainy

            14 - Metal, Rusty

            15 - Brick

            16 - Block

            17 - Wood

            18 - Wood, Light

            19 - Wood, Walnut

            20 - Plastic, Hard Blue

            21 - Plastic, Light Blue

            22 - Plastic, Hard Red

            31 - Gold

            32 - Brass

            33 - Silver

            34 -  Plastic, Black

            35 - Plastic, Ivory

            36 - Plastic, Blue

            37 - Plastic, Red

            38 - Plastic, Yellow

            39 - Plastic, Green

            40 - Plastic, Brown

        n1, n2, ninc
            Apply texture to Lab items numbered N1 through N2 in steps of NINC
            (defaults to 1). If Lab = CM, then N1 is used to for the component
            name and N2 and NINC are ignored. If Lab = ELEM, AREA, or VOLU and
            N1 = blank or ALL, then the specified texture will be applied to
            all entities of type Lab. If N1 = P, then graphical picking is
            enabled.

        Notes
        -----
         This command is available for 3-D Open GL devices. 2-D devices are
        supported only for the Lab = File variation of the command, allowing
        imported bitmaps to be used for texturing and annotation. Textures can
        affect the speed of many of your display operations. You can increase
        the speed by temporarily turning the textures off (Utility Menu>
        PlotCtrls> Style> Texturing(3D)> Display Texturing). This menu
        selection toggles your textures on and off. When textures are toggled
        off, all of the texture information is retained and reapplied when
        texturing is toggled back on.

        For some displays, the texture will appear distorted because of a
        technique used to enhance 3-D displays (/DV3D,TRIS,1). Disabling this
        function (/DV3D,TRIS,0) will improve the quality of some texture
        displays. Disabling the TRIS option of the /DV3D command will slow down
        3-D displays significantly. Be sure to reapply the TRIS option after
        you obtain a satisfactory output.

        Specifying /TXTRE,DEFA removes all texturing.
        """
        command = "/TXTRE,%s,%s,%s,%s,%s" % (str(lab), str(num), str(n1), str(n2), str(ninc))
        return self.run(command, **kwargs)

    def vgen(self, itime="", nv1="", nv2="", ninc="", dx="", dy="", dz="",
             kinc="", noelem="", imove="", **kwargs):
        """APDL Command: VGEN

        Generates additional volumes from a pattern of volumes.

        Parameters
        ----------
        itime
            Do this generation operation a total of ITIMEs, incrementing all
            keypoints in the given pattern automatically (or by KINC) each time
            after the first.  ITIME must be > 1 for generation to occur.

        nv1, nv2, ninc
            Generate volumes from pattern beginning with NV1 to NV2 (defaults
            to NV1) in steps of NINC (defaults to 1).  If NV1 = ALL, NV2 and
            NINC are ignored and the pattern is all selected volumes [VSEL].
            If NV1 = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI).  A component name may
            also be substituted for NV1 (NV2 and NINC are ignored).

        dx, dy, dz
            Keypoint location increments in the active coordinate system (--,
            Dθ, DZ for cylindrical, --, Dθ, -- for spherical).

        kinc
            Keypoint increment between generated sets.  If zero, the lowest
            available keypoint numbers are assigned [NUMSTR].

        noelem
            Specifies if elements and nodes are also to be generated:

            0 - Generate nodes and elements associated with the original volumes, if they
                exist.

            1 - Do not generate nodes and elements.

        imove
            Specifies whether to redefine the existing volumes:

            0 - Generate additional volumes as requested with the ITIME argument.

            1 - Move original volumes to new position retaining the same keypoint line, and
                area numbers (ITIME, KINC, and NOELEM are ignored).
                Corresponding meshed items are also moved if not needed at
                their original position.

        Notes
        -----
        Generates additional volumes (and their corresponding keypoints, lines,
        areas and mesh) from a given volume pattern.  The MAT, TYPE, REAL, and
        ESYS attributes are based upon the volumes in the pattern and not upon
        the current settings of the pointers.  End slopes of the generated
        lines remain the same (in the active coordinate system) as those of the
        given pattern.  For example, radial slopes remain radial, etc.
        Generations which produce volumes of a size or shape different from the
        pattern (i.e., radial generations in cylindrical systems, radial and
        phi generations in spherical systems, and theta generations in
        elliptical systems) are not allowed.  Note that solid modeling in a
        toroidal coordinate system is not recommended.  Volume, area, and line
        numbers are automatically assigned (beginning with the lowest available
        values [NUMSTR]).
        """
        command = "VGEN,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(itime), str(nv1), str(nv2), str(ninc), str(dx), str(dy), str(dz), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def paget(self, parray="", popt="", **kwargs):
        """APDL Command: PAGET

        Writes current path information into an array variable.

        Parameters
        ----------
        parray
            The name of the array parameter that the ANSYS program creates to
            store the path information.  If the array parameter already exists,
            it will be replaced with the current path information.

        popt
            Determines how data will be stored in the parameter specified with
            PARRAY:

            POINTS - Store the path points, the nodes (if any), and coordinate system.  (For
                     information on defining paths and path points, see the
                     descriptions of the PATH and PPATH commands.)

            TABLE - Store the path data items.  (See the PDEF command description for path data
                    items.)

            LABEL - Stores path data labels.

        Notes
        -----
        Use the PAGET command together with the PAPUT command to store and
        retrieve path data in array variables for archiving purposes.  When
        retrieving path information, restore the path points (POINTS option)
        first, then the path data (TABLE option), and then the path labels
        (LABEL option).
        """
        command = "PAGET,%s,%s" % (str(parray), str(popt))
        return self.run(command, **kwargs)

    def mfclear(self, option="", value="", **kwargs):
        """APDL Command: MFCLEAR

        Deletes ANSYS Multi-field solver analysis settings.

        Parameters
        ----------
        option
            SOLU

            SOLU - Resets all ANSYS solution commands except KBC to their default states. This
                   option clears analysis options when setting up different
                   fields for an ANSYS Multi-field solver analysis.

            FIELD - Deletes all ANSYS Multi-field solver specifications for the specified field
                    number.

            SINT - Deletes all ANSYS Multi-field solver specifications for the specified surface
                   interface number.

            VINT - Deletes all ANSYS Multi-field solver specifications for the volumetric
                   interface number.

            ORD - Deletes the analysis order specified by the MFORDER command.

            EXT - Deletes external fields specified by the MFEXTER command

            MFLC - Deletes load transfers specified by the MFLCOMM command

        value
            Use only for Option = FIELD, SINT, or VINT.

        Notes
        -----
        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFCLEAR,%s,%s" % (str(option), str(value))
        return self.run(command, **kwargs)

    def eorient(self, etype="", dir="", toler="", **kwargs):
        """APDL Command: EORIENT

        Reorients solid element normals.

        Parameters
        ----------
        etype
            Specifies which elements to orient.

            LYSL - Specifies that certain solid elements (such as SOLID185 with KEYOPT(3) = 1,
                   SOLID186 with KEYOPT(3) = 1, and SOLSH190) will be oriented.
                   This value is the default.

        Notes
        -----
        EORIENT renumbers the element faces, designating the face  most
        parallel to the XY plane of the element coordinate system (set with
        ESYS) as face 1 (nodes I-J-K-L, parallel to the layers in layered
        elements). It calculates the outward normal of each face and changes
        the node designation  of the elements so the face with a normal most
        nearly parallel with and in the same general direction as the target
        axis becomes face 1.

        The target axis, defined by Dir, is either the negative or positive
        indicated axis or the outward normal of face 1 of that element.

        All SOLID185 Layered Structural Solid, SOLID186 Layered Structural
        Solid, and SOLSH190 solid shell elements in the selected set are
        considered for reorientation.

        After reorienting elements, you should always display and graphically
        review results using the /ESHAPE command. When plotting models with
        many or symmetric layers, it may be useful to temporarily reduce the
        number of layers to two, with one layer being much thicker than the
        other.

        You cannot use EORIENT to change the normal direction of any element
        that has a body or surface load.  We recommend that you apply all of
        your loads only after ensuring that the element normal directions are
        acceptable.

        Prisms and tetrahedrals are also supported, within the current
        limitations of the SOLID185, SOLID186, and SOLSH190 elements. (Layers
        parallel to the four-node face of the prism are not supported.)
        """
        command = "EORIENT,%s,%s,%s" % (str(etype), str(dir), str(toler))
        return self.run(command, **kwargs)

    def secjoint(self, kywrd="", val1="", val2="", val3="", val4="", val5="",
                 val6="", **kwargs):
        """APDL Command: SECJOINT

        Defines local coordinate systems at joint element nodes and other data
        for joint elements.

        Parameters
        ----------
        kywrd
            Keyword that indicates the type of joint element data being
            defined.

            LSYS or blank - Define local coordinate systems at the nodes that form the MPC184 joint
                            element.

            RDOF - Define the relative degrees of freedom to be fixed for an MPC184-General joint
                   element.

            PITC - Define the pitch of an MPC184-Screw joint element.

            FRIC - Define the geometric quantities required for Coulomb frictional behavior in the
                   MPC184-Revolute or MPC184-Translational joint element.

        val1, val2, val3, val4, val5, val6
            The meaning of Val1 through Val6 changes, depending on the value of
            Kywrd.

        Notes
        -----
        Use this command to define additional section data for MPC184 joint
        elements. To overwrite the current values, issue another SECJOINT
        command with the same Kywrd value. The data input on this command is
        interpreted based on the most recently issued SECTYPE command.
        """
        command = "SECJOINT,%s,%s,%s,%s,%s,%s,%s" % (str(kywrd), str(val1), str(val2), str(val3), str(val4), str(val5), str(val6))
        return self.run(command, **kwargs)

    def sort(self, **kwargs):
        """APDL Command: SORT

        Specifies "Sort settings" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "SORT," % ()
        return self.run(command, **kwargs)

    def asub(self, na1="", p1="", p2="", p3="", p4="", **kwargs):
        """APDL Command: ASUB

        Generates an area using the shape of an existing area.

        Parameters
        ----------
        na1
            Existing area number whose shape is to be used.  If P1 = P,
            graphical picking is enabled and all remaining arguments are
            ignored (valid only in the GUI).

        p1
            Keypoint defining starting corner of area.

        p2
            Keypoint defining second corner of area.

        p3
            Keypoint defining third corner of area.

        p4
            Keypoint defining fourth corner of area (defaults to P3).

        Notes
        -----
        The new area will overlay the old area.  Often used when the area to be
        subdivided consists of a complex shape that was not generated in a
        single coordinate system.  Keypoints and any corresponding lines must
        lie on the existing area.  Missing lines are generated to lie on the
        given area.  The active coordinate system is ignored.
        """
        command = "ASUB,%s,%s,%s,%s,%s" % (str(na1), str(p1), str(p2), str(p3), str(p4))
        return self.run(command, **kwargs)

    def suresu(self, fname="", fext="", fdir="", **kwargs):
        """APDL Command: SURESU

        Read a set of surface definitions and result items from a file and make
        them the current set.

        Parameters
        ----------
        --
            Unused field.

        fname
            Eight character name.

        fext
            Extension name.

        fdir
            Optional path specification.

        Notes
        -----
        Reading (and therefore resuming) surface and result definitions from a
        file overwritea any existing surface definitions.

        Reading surfaces back into the postprocessor (/POST1) does not insure
        that the surfaces (and their results) are appropriate for the model
        currently residing in /POST1.
        """
        command = "SURESU,%s,%s,%s" % (str(fname), str(fext), str(fdir))
        return self.run(command, **kwargs)

    def grid(self, key="", **kwargs):
        """APDL Command: /GRID

        Selects the type of grid on graph displays.

        Parameters
        ----------
        key
            Grid key:

            0 (OFF) - No grid.

            1 (ON) - Full grid (X and Y grid lines).

            2 (X) - Partial grid (X grid lines only).

            3 (Y) - Partial grid (Y grid lines only)

        Notes
        -----
        Selects the type of grid on graph displays.  Graphs with multiple
        Y-axes can have multiple grids [/GRTYP].  The grid of the first curve
        is also used as the background grid (above and behind the curve).
        Grids for other curves are limited to be under the curves.  See also
        /GTHK and /GROPT for other grid options.

        This command is valid in any processor.
        """
        command = "/GRID,%s" % (str(key))
        return self.run(command, **kwargs)

    def lsel(self, type="", item="", comp="", vmin="", vmax="", vinc="",
             kswp="", **kwargs):
        """APDL Command: LSEL

        Selects a subset of lines.

        Parameters
        ----------
        type
            Label identifying the type of select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

            ALL - Restore the full set.

            NONE - Unselect the full set.

            INVE - Invert the current set (selected becomes unselected and vice versa).

            STAT - Display the current select status.

        Notes
        -----
        Selects lines based on values of a labeled item and component.  For
        example, to select a new set of lines based on line numbers 1 through
        7, use LSEL,S,LINE,,1,7.  The subset is used when the ALL label is
        entered (or implied) on other commands, such as LLIST,ALL.  Only data
        identified by line number are selected.  Data are flagged as selected
        and unselected; no data are actually deleted from the database.

        If Item = LCCA, the command selects only those lines that were created
        by concatenation.  The KSWP field is processed, but the Comp, VMIN,
        VMAX, and VINC fields are ignored.

        If Item = HPT, the command selects only those lines that contain hard
        points.

        Item = RADIUS is only valid for lines that are circular arcs.

        LSEL is valid in any processor.

        For selections based on non-integer numbers (coordinates, results,
        etc.), items that are within the range VMIN -Toler and VMAX +Toler are
        selected. The default tolerance Toler is based on the relative values
        of VMIN and VMAX as follows:

        If VMIN = VMAX, Toler = 0.005 x VMIN.

        If VMIN = VMAX = 0.0, Toler = 1.0E-6.

        If VMAX ≠ VMIN, Toler = 1.0E-8 x (VMAX - VMIN).

        Use the SELTOL command to override this default and specify Toler
        explicitly.

        Table: 204:: : LSEL - Valid Item and Component Labels
        """
        command = "LSEL,%s,%s,%s,%s,%s,%s,%s" % (str(type), str(item), str(comp), str(vmin), str(vmax), str(vinc), str(kswp))
        return self.run(command, **kwargs)

    def timerange(self, tmin="", tmax="", **kwargs):
        """APDL Command: TIMERANGE

        Specifies the time range for which data are to be stored.

        Parameters
        ----------
        tmin
            Minimum time (defaults to first time (or frequency) point on the
            file).

        tmax
            Maximum time (defaults to last time (or frequency) point on the
            file).

        Notes
        -----
        Defines the time (or frequency) range for which data are to be read
        from the file and stored in memory.  Use the NSTORE command to define
        the time increment.

        Use PRTIME or PLTIME to specify the time (frequency) range for cyclic
        mode-superposition harmonic analyses.
        """
        command = "TIMERANGE,%s,%s" % (str(tmin), str(tmax))
        return self.run(command, **kwargs)

    def seltol(self, toler="", **kwargs):
        """APDL Command: SELTOL

        Sets the tolerance for subsequent select operations.

        Parameters
        ----------
        toler
            Tolerance value. If blank, restores the default tolerance logic.

        Notes
        -----
        For selects based on non-integer numbers (e.g. coordinates, results,
        etc.), items within the range VMIN - Toler and VMAX + Toler are
        selected, where VMIN and VMAX are the range values input on the xSEL
        commands (ASEL, ESEL, KSEL, LSEL, NSEL, and VSEL).

        The default tolerance logic is based on the relative values of VMIN and
        VMAX as follows:

        If VMIN = VMAX, Toler = 0.005 x VMIN.

        If VMIN = VMAX = 0.0, Toler = 1.0E-6.

        If VMAX ≠ VMIN, Toler = 1.0E-8 x (VMAX-VMIN).

        This command is typically used when VMAX-VMIN is very large so that the
        computed default tolerance is therefore large and the xSEL commands
        selects more than what is desired.

        Toler remains active until respecified by a subsequent SELTOL command.
        A SELTOL < blank > resets back to the default Toler logic.
        """
        command = "SELTOL,%s" % (str(toler))
        return self.run(command, **kwargs)

    def shade(self, wn="", type="", **kwargs):
        """APDL Command: /SHADE

        Defines the type of surface shading used with Z-buffering.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        type
            Shading type:

            FACET or 0 - Facet shading (one color per area face) (default).

            GOURAUD or 1 - Gouraud smooth shading (smooth variation of color based on interpolated vertex
                           colors).

            PHONG or 2 - Phong smooth shading (smooth variation of color based on interpolated vertex
                         normals).

        Notes
        -----
        Defines the type of surface shading used on area, volume, and
        PowerGraphics [/GRAPHICS,POWER] displays when software Z-buffering is
        enabled [/TYPE].  This command is only functional for 2-D display
        devices.

        This command is valid in any processor.
        """
        command = "/SHADE,%s,%s" % (str(wn), str(type))
        return self.run(command, **kwargs)

    def anum(self, num="", type="", xhot="", yhot="", **kwargs):
        """APDL Command: /ANUM

        Specifies the annotation number, type, and hot spot (GUI).

        Parameters
        ----------
        num
            Annotation number.  ANSYS automatically assigns the lowest
            available number.  You cannot assign a higher number if a lower
            number is available; ANSYS will substitute the lowest available
            number in place of any user-specified higher number.

        type
            Annotation internal type number.  If TYPE = DELE, delete annotation
            NUM.

            1 - Text

            2 - Block text (not available in GUI)

            3 - Dimensions

            4 - Lines

            5 - Rectangles

            6 - Circles

            7 - Polygons

            8 - Arcs

            9 - Wedges, pies

            11 - Symbols

            12 - Arrows

            13 - Bitmap

        xhot
            X hot spot (-1.0 < X < 2.0).  Used for menu button item delete.

        yhot
            Y hot spot (-1.0 < Y < 1.0).  Used for menu button item delete.

        Notes
        -----
        This is a command generated by the GUI and will appear in the log file
        (Jobname.LOG) if annotation is used.  This command is not intended to
        be typed in directly in an ANSYS session (although it can be included
        in an input file for batch input or for use with the /INPUT command).

        Type 13 (bitmap) annotation applies user defined bitmaps defined using
        the FILE option of the /TXTRE command.

        This command is valid in any processor.
        """
        command = "/ANUM,%s,%s,%s,%s" % (str(num), str(type), str(xhot), str(yhot))
        return self.run(command, **kwargs)

    def starlist(self, fname="", ext="", **kwargs):
        """APDL Command: *LIST

        Displays the contents of an external, coded file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Displays the contents of an external, coded file.  The file to be
        listed cannot be in use (open) at the time (except for the error file,
        File.ERR, which may be displayed with *LIST,ERR).

        Use caution when you are listing active ANSYS files via the List>
        Files> Other and File> List> Other menu paths.  File I/O buffer and
        system configurations can result in incomplete listings unless the
        files are closed.

        This command is valid in any processor.
        """
        command = "*LIST,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def hropt(self, method="", maxmode="", minmode="", mcout="", damp="",
              **kwargs):
        """APDL Command: HROPT

        Specifies harmonic analysis options.

        Parameters
        ----------
        method
            Solution method for the harmonic analysis:

            AUTO - Automatically select the most efficient method. Either the FULL method or the
                   Variational Technology method is selected depending on the
                   model. (default method).

            FULL - Full method.

            MSUP - Mode-superposition method.

            VT - Variational Technology method (based on FULL harmonic algorithm).

            VTPA - Variational Technology perfect absorber method (based on FULL harmonic
                   algorithm).

            VTRU - Variational Technology reuse method (based on FULL harmonic algorithm).

        maxmode
            Largest mode number to be used to calculate the response (for
            Method = MSUP only).  Defaults to the highest mode calculated in
            the preceding modal analysis.

        minmode
            Smallest mode number to be used (for Method = MSUP only).  Defaults
            to 1.

        mcout
            Modal coordinates output key (valid only for the mode superposition
            method MSUP):

            NO - No output of modal coordinates (default).

            YES - Output modal coordinates to the text file jobname.MCF.

        damp
            Damping mode for frequency-dependent material properties (valid
            only for the Variational Technology Method VT).

            Hysteretic - Not proportional to the frequency.

            Viscous - Proportional to the frequency (default).

        Notes
        -----
        Specifies the method of solution for a harmonic analysis
        (ANTYPE,HARMIC).  If used in SOLUTION, this command is valid only
        within the first load step. See the product restrictions indicated
        below.

        For cyclic symmetry mode-superposition harmonic solutions, MAXMODE and
        MINMODE are ignored.

        To include residual vectors in your mode-superposition harmonic
        analysis, specify RESVEC,ON.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: The VTRU method is not supported.
        """
        command = "HROPT,%s,%s,%s,%s,%s" % (str(method), str(maxmode), str(minmode), str(mcout), str(damp))
        return self.run(command, **kwargs)

    def mfvolume(self, inumb="", fnumb1="", label="", fnumb2="", **kwargs):
        """APDL Command: MFVOLUME

        Defines a volume load transfer for an ANSYS Multi-field solver
        analysis.

        Parameters
        ----------
        inumb
            Interface number for load transfer. The interface number
            corresponds to the interface number specified by the volume flag
            FVIN (BFE command).

        fnumb1
            Field number of sending field.

        label
            Valid volume load labels:

        fnumb2
            Field number for receiving field.

        Notes
        -----
        This command is also valid in PREP7.

        The ANSYS Multi-field solver solver does not allow you to switch the
        load transfer direction for the same load quantity across the same
        interfaces for a restart run. For example, if Field1 sends temperature
        to and receives heat flow from Field2 across Interface 1 in a previous
        solution, then you cannot make Field1 send heat flow to and receive
        temperatures from Field2 across the same interface in a restart run,
        even if you cleared the corresponding load transfer command.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFVOLUME,%s,%s,%s,%s" % (str(inumb), str(fnumb1), str(label), str(fnumb2))
        return self.run(command, **kwargs)

    def rmore(self, r7="", r8="", r9="", r10="", r11="", r12="", **kwargs):
        """APDL Command: RMORE

        Adds real constants to a set.

        Parameters
        ----------
        r7, r8, r9, . . . , r12
            Add real constants 7 to 12 (numerical values or table names) to the
            most recently defined set.

        Notes
        -----
        Adds six more real constants to the most recently defined set.  Repeat
        the RMORE command for constants 13 to 18, again for 19-24, etc.

        If using table inputs (SURF151, SURF152, FLUID116, CONTA171, CONTA172,
        CONTA173, CONTA174, and CONTA175 only), enclose the table name in %
        signs (e.g., %tabname%).

        When copying real constants to new sets, ANSYS, Inc. recommends that
        you use the command input. If you do use the GUI, restrict the real
        constant copy to only the first six real constants (real constants
        seven and greater will be incorrect for both the master and copy set).

        This command is also valid in SOLUTION.
        """
        command = "RMORE,%s,%s,%s,%s,%s,%s" % (str(r7), str(r8), str(r9), str(r10), str(r11), str(r12))
        return self.run(command, **kwargs)

    def check(self, sele="", levl="", **kwargs):
        """APDL Command: CHECK

        Checks current database items for completeness.

        Parameters
        ----------
        sele
            Specifies which elements are to be checked:

            (blank) - Check all data.

            ESEL - Check only elements in the selected set and unselect any elements not producing
                   geometry check messages.  The remaining elements (those
                   producing check messages) can then be displayed and
                   corrected.  A null set results if no elements produce a
                   message.  Issue ESEL,ALL to select all elements before
                   proceeding.

        levl
            Used only with Sele = ESEL:

            WARN - Select elements producing warning and error messages.

            ERR - Select only elements producing error messages (default).

        Notes
        -----
        This command will not work if SHPP,OFF has been set. A similar,
        automatic check of all data is done before the solution begins.

        If the "Check Elements" option is invoked through the GUI (menu path
        Main Menu> Preprocessor> Meshing> Check Elems), the CHECK,ESEL logic is
        used to highlight elements in the following way:  good elements are
        blue, elements having warnings are yellow, and bad (error) elements are
        red.

        Note:: : The currently selected set of elements is not changed by this
        GUI function.

        This command is also valid in PREP7.
        """
        command = "CHECK,%s,%s" % (str(sele), str(levl))
        return self.run(command, **kwargs)

    def bfvdele(self, volu="", lab="", **kwargs):
        """APDL Command: BFVDELE

        Deletes body force loads on a volume.

        Parameters
        ----------
        volu
            Volume at which body load is to be deleted.  If ALL, delete for all
            selected volumes [VSEL]. A component name may also be substituted
            for VOLU.

        lab
            Valid body load label. If ALL, use all appropriate labels. Load
            labels are listed under "Body Loads" in the input table for each
            element type in the Element Reference. See the BFV command for
            labels.

        Notes
        -----
        Deletes body force loads (and all corresponding finite element loads)
        for a specified volume and label.  Body loads may be defined on a
        volume with the BFV command.

        Graphical picking is available only via the listed menu paths.

        This command is also valid in PREP7.
        """
        command = "BFVDELE,%s,%s" % (str(volu), str(lab))
        return self.run(command, **kwargs)

    def lfsurf(self, sline="", tline="", **kwargs):
        """APDL Command: LFSURF

        Generates surface elements overlaid on the edge of existing solid
        elements and assigns the extra node as the closest fluid element node.

        Parameters
        ----------
        sline
            Component name for the surface lines of the meshed solid areas.

        tline
            Component name for the target lines meshed with fluid elements.

        Notes
        -----
        This command macro is used to generate surface effect elements overlaid
        on the surface of existing plane elements and, based on proximity, to
        determine and assign the extra node for each surface element.  The
        underlying areas of the solid region and the fluid lines must be meshed
        prior to calling this command macro. The active element type must be
        SURF151 with appropriate settings for KEYOPT(4), KEYOPT(5), KEYOPT(6),
        and KEYOPT(8).

        The surface lines of the solid and the target lines of the fluid are
        grouped into components and named using the CM command.  The names must
        be enclosed in single quotes (e.g., 'SLINE') when the LFSURF command is
        manually typed in.

        When using the GUI method, node and element components are created
        through the picking dialog boxes associated with this command.

        The macro is applicable for the SURF151 and FLUID116 element types.
        """
        command = "LFSURF,%s,%s" % (str(sline), str(tline))
        return self.run(command, **kwargs)

    def coval(self, tblno1="", tblno2="", sv1="", sv2="", sv3="", sv4="",
              sv5="", sv6="", sv7="", **kwargs):
        """APDL Command: COVAL

        Defines PSD cospectral values.

        Parameters
        ----------
        tblno1
            First input PSD table number associated with this spectrum.

        tblno2
            Second input PSD table number associated with this spectrum.

        sv1, sv2, sv3, . . . , sv7
            PSD cospectral values corresponding to the frequency points
            [PSDFRQ].

        Notes
        -----
        Defines PSD cospectral values to be associated with the previously
        defined frequency points.  Two table references are required since
        values are off-diagonal terms.  Unlike autospectra [PSDVAL], the
        cospectra can be positive or negative.  The cospectral curve segment
        where there is a sign change is interpolated linearly (the rest of the
        curve segments use log-log interpolation).  For better accuracy, choose
        as small a curve segment as possible wherever a sign change occurs.

        Repeat COVAL command using the same table numbers for additional
        points.  This command is valid for SPOPT,PSD only.

        This command is also valid in PREP7.
        """
        command = "COVAL,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(tblno1), str(tblno2), str(sv1), str(sv2), str(sv3), str(sv4), str(sv5), str(sv6), str(sv7))
        return self.run(command, **kwargs)

    def lsba(self, nl="", na="", sepo="", keepl="", keepa="", **kwargs):
        """APDL Command: LSBA

        Subtracts areas from lines.

        Parameters
        ----------
        nl
            Line (or lines, if picking is used) to be subtracted from.  If ALL,
            use all selected lines.  If NL = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).  A component name may also be substituted for NL.

        na
            Area (or areas, if picking is used) to be subtracted.  If ALL, use
            all selected areas.  A component name may also be substituted for
            NA.

        sepo
            Behavior if the intersection of the lines and the areas is a
            keypoint or keypoints:

            (blank) - The resulting lines will share keypoint(s) where they touch.

            SEPO - The resulting lines will have separate, but coincident keypoint(s) where they
                   touch.

        keepl
            Specifies whether NL lines are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NL lines after LSBA operation (override BOPTN command settings).

            KEEP - Keep NL lines after LSBA operation (override BOPTN command settings).

        keepa
            Specifies whether NA areas are to be deleted:

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete areas after LSBA operation (override BOPTN command settings).

            KEEP - Keep areas after LSBA operation (override BOPTN command settings).

        Notes
        -----
        Generates new lines by subtracting the regions common to both NL lines
        and NA areas (the intersection) from the NL lines.  The intersection
        can be a line(s) or keypoint(s).  If the intersection is a keypoint and
        SEPO is blank, the NL line is divided at the keypoint and the resulting
        lines will be connected, sharing a common keypoint where they touch.
        If SEPO is set to SEPO, NL is divided into two unconnected lines with
        separate keypoints where they touch.  See the Modeling and Meshing
        Guide for an illustration.  See the BOPTN command for an explanation of
        the options available to Boolean operations.  Element attributes and
        solid model boundary conditions assigned to the original entities will
        not be transferred to the new entities generated.
        """
        command = "LSBA,%s,%s,%s,%s,%s" % (str(nl), str(na), str(sepo), str(keepl), str(keepa))
        return self.run(command, **kwargs)

    def vfun(self, parr="", func="", par1="", con1="", con2="", con3="",
             **kwargs):
        """APDL Command: *VFUN

        Performs a function on a single array parameter.

        Parameters
        ----------
        parr
            The name of the resulting numeric array parameter vector.  See *SET
            for name restrictions.

        func
            Function to be performed:

            Arccosine: ACOS(Par1). - Arcsine: ASIN(Par1).

            Par1 is sorted in ascending order.  *VCOL, *VMASK, *VCUM, and *VLEN,,NINC do not apply.  *VLEN,NROW does apply. - Arctangent: ATAN(Par1).

            Compress:  Selectively compresses data set.  "True" (*VMASK) values of Par1 (or row positions to be considered according to the NINC value on the *VLEN command) are written in  compressed form to ParR, starting at the specified position. - Copy: Par1 copied to ParR.

            Cosine: COS(Par1). - Hyperbolic cosine: COSH(Par1).

            Direction cosines of the principal stresses (nX9).  Par1 contains the nX6 component stresses for the n locations of the calculations. - Par1 is sorted in descending order.  *VCOL, *VMASK, *VCUM, and *VLEN,,NINC do
                              not apply.  *VLEN,NROW does apply.

            Euler angles of the principal stresses (nX3).  Par1 contains the nX6 component stresses for the n locations of the calculations. - Exponential: EXP(Par1).

            Expand:  Reverse of the COMP function.  All elements of Par1 (starting at the position specified) are written in expanded form to corresponding "true" (*VMASK) positions (or row positions to be considered according to the NINC value on the *VLEN command) of ParR. - Natural logarithm: LOG(Par1).

            Common logarithm: LOG10(Par1). - Nearest integer: 2.783 becomes 3.0, -1.75 becomes -2.0.

            Logical complement: values   0.0 (false) become 1.0 (true).  Values > 0.0 (true) become 0.0 (false). - Principal stresses (nX5). Par1 contains the nX6 component stresses for the n
                              locations of the calculations.

            Power function: Par1**CON1. Exponentiation of any negative number in the vector Par1 to a non-integer power is performed by exponentiating the positive number and prepending the minus sign. For example, -4**2.3 is -(4**2.3). - Sine: SIN(Par1).

            Hyperbolic sine: SINH(Par1). - Square root: SQRT(Par1).

            Tangent: TAN(Par1). - Hyperbolic tangent: TANH(Par1).

            Tangent to a path at a point:  the slope at a point is determined by linear interpolation half way between the previous and next points.  Points are assumed to be in the global Cartesian coordinate system.  Path points are specified in array Par1 (having 3 consecutive columns of data, with the columns containing the x, y, and z coordinate locations, respectively, of the points).  Only the starting row index and the column index for the x coordinates are specified, such as A(1,1).  The y and z coordinates of the vector are assumed to begin in the corresponding next columns, such as A(1,2) and A(1,3).  The tangent result, ParR, must also have 3 consecutive columns of data and will contain the tangent direction vector (normalized to 1.0); such as 1,0,0 for an x-direction vector. - Normal to a path and an input vector at a point: determined from the cross-
                              product of the calculated tangent vector (see
                              TANG) and the input direction vector (with the i,
                              j, and k components input as CON1, CON2, and
                              CON3).  Points are assumed to be in the global
                              Cartesian coordinate system.  Path points are
                              specified in array Par1 (having 3 consecutive
                              columns of data, with the columns containing the
                              x, y, and z coordinate locations, respectively,
                              of the points).  Only the starting row index and
                              the column index for the x coordinates are
                              specified, such as A(1,1).  The y and z
                              coordinates of the vector are assumed to begin in
                              the corresponding next columns, such as A(1,2)
                              and A(1,3).  The normal result, ParR, must also
                              have 3 consecutive columns of data and will
                              contain the normal direction vector (normalized
                              to 1.0); such as 1,0,0 for an x-direction vector.

            Transforms global Cartesian coordinates of a point to the coordinates of a specified system: points to be transformed are specified in array Par1 (having 3 consecutive columns of data, with the columns containing the x, y, and z global Cartesian coordinate locations, respectively, of the points).  Only the starting row index and the column index for the x coordinates are specified, such as A(1,1).  The y and z coordinates of the vector are assumed to begin in the corresponding next columns, such as A(1,2) and A(1,3).  Results are transformed to coordinate system CON1 (which may be any valid coordinate system number, such as 1,2,11,12, etc.).  The transformed result, ParR, must also have 3 consecutive columns of data and will contain the corresponding transformed coordinate locations. - Transforms specified coordinates of a point to global Cartesian coordinates:
                              points to be transformed are specified in array
                              Par1 (having 3 consecutive columns of data, with
                              the columns containing the local coordinate
                              locations (x, y, z or r, θ, z or etc.) of the
                              points).  Only the starting row index and the
                              column index for the x coordinates are specified,
                              such as A(1,1).  The y and z coordinates (or θ
                              and z, or etc.) of the vector are assumed to
                              begin in the corresponding next columns, such as
                              A(1,2) and A(1,3).  Local coordinate locations
                              are assumed to be in coordinate system CON1
                              (which may be any valid coordinate system number,
                              such as 1,2,11,12, etc.).  The transformed
                              result, ParR, must also have 3 consecutive
                              columns of data, with the columns containing the
                              global Cartesian x, y, and z coordinate
                              locations, respectively.

        par1
            Array parameter vector in the operation.

        con1, con2, con3
            Constants (used only with the PWR, NORM, LOCAL, and GLOBAL
            functions).

        Notes
        -----
        Operates on one input array parameter vector and produces one output
        array parameter vector according to:

        ParR = f(Par1)

        where the functions (f) are described below.  Functions are based on
        the standard FORTRAN definitions where possible.  Out-of-range function
        results (or results with exponents whose magnitudes are approximately
        greater than 32 or less than -32) produce a zero value.  Input and
        output for angular functions may be radians (default) or degrees
        [*AFUN].  ParR may be the same as Par1.  Starting array element numbers
        must be defined for each array parameter vector if it does not start at
        the first location. For example, *VFUN,A,SQRT,B(5) takes the square
        root of the fifth element of B and stores the result in the first
        element of A.  Operations continue on successive array elements [*VLEN,
        *VMASK] with the default being all successive elements.  Absolute
        values and scale factors may be applied to all parameters [*VABS,
        *VFACT].  Results may be cumulative [*VCUM].  Skipping array elements
        via *VMASK or *VLEN for the TANG and NORM functions skips only the
        writing of the results (skipped array element data are used in all
        calculations).  See the *VOPER command for detail   s   .   /   p   >
        p   >   T   h   i   s       c   o   m   m   a   n   d       i   s
        v   a   l   i   d       i   n       a   n   y       p   r   o   c   e
        s   s   o   r   .   /   p   >   /   d   i   v   >   d   i   v       c
        l   a   s   s   =   "   r   e   f   s   e   c   t   1   "       t   i
        t   l   e   =   "   M   e   n   u       P   a   t   h   s   "   >   a
        n   a   m   e   =   "   d   0   e   2   9   2   8   5   8   "   >   /
        a   >   h   2   >   M   e   n   u       P   a   t   h   s   /   h   2
        >   t   a   b   l   e       b   o   r   d   e   r   =   "   0   "
        s   u   m   m   a   r   y   =   "   S   i   m   p   l   e       l   i
        s   t   "       c   l   a   s   s   =   "   s   i   m   p   l   e   l
        i   s   t   "   >   t   r   >   t   d   >   s   p   a   n       c   l
        a   s   s   =   "   g   u   i   m   e   n   u   "   >   s   t   r   o
        n   g   >   U   t   i   l   i   t   y       M   e   n   u   &g   t   ;
        P   a   r   a   m   e   t   e   r   s   &g   t   ;   A   r   r   a   y
        O   p   e   r   a   t   i   o   n   s   &g   t   ;   V   e   c   t   o
        r       F   u   n   c   t   i   o   n   s   /   s   t   r   o   n   g
        >   /   s   p   a   n   >   /   t   d   >   /   t   r   >   /   t   a
        b   l   e   >   /   d   i   v   >   /   d   i   v   >   h   r   >   p
        c   l   a   s   s   =   "   l   e   g   a   l   f   o   o   t   e   r
        "   >   s   m   a   l   l   >   i   >   R   e   l   e   a   s   e
        1   6   .   2       -       &c   o   p   y   ;       S   A   S       I
        P   ,       I   n   c   .       A   l   l       r   i   g   h   t   s
        r   e   s   e   r   v   e   d   .   /   i   >   /   s   m   a   l   l
        >   /   p   >   /   b   o   d   y   >   /   h   t   m   l   >
        """
        command = "*VFUN,%s,%s,%s,%s,%s,%s" % (str(parr), str(func), str(par1), str(con1), str(con2), str(con3))
        return self.run(command, **kwargs)

    def rmndisp(self, loadt="", loc="", **kwargs):
        """APDL Command: RMNDISP

        Extracts neutral plane displacements from a test load or element load
        solution for the ROM method.

        Parameters
        ----------
        loadt
            Load type. Load type must be an alphanumeric string enclosed in
            single quotes. Valid load types are 'TLOAD' for the test load and
            'ELOAD' for the element load.

        loc
            Determines whether file will be overwritten or appended. Valid
            labels are 'WRITE' or 'APPEND'. Defaults to 'WRITE' for test load.

        Notes
        -----
        This command extracts the displacements at a neutral plane of a model.
        If  LoadT = 'TLOAD', extract displacements for a test load on a
        structure that represents the expected deflection state.  A test load
        is used to assist in the automatic mode selection for the ROM mode
        characterization. If LoadT = 'ELOAD', extract the neutral plane
        displacements for an element load that will be used in the use pass of
        a ROM analysis.  Typical element loads are gravity, and pressure
        loading. The element loads may be scaled [RMLVSCALE] during the use
        pass.

        The command requires a node component named "NEUN" to be defined. These
        nodes represent the nodes at the neutral plane of a structure (in the
        case of a stress-stiffened structure), or at any plane in the structure
        (non stress-stiffened case).

        For LoadT = 'TLOAD', node displacements are written to the file
        jobname.tld.  For LoadT = 'ELOAD', node displacements are written to
        the file jobname.eld. Up to 5 element load cases may be written to the
        file jobname.eld.

        This command is only valid in POST1.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMNDISP,%s,%s" % (str(loadt), str(loc))
        return self.run(command, **kwargs)

    def lstr(self, p1="", p2="", **kwargs):
        """APDL Command: LSTR

        Defines a straight line irrespective of the active coordinate system.

        Parameters
        ----------
        p1
            Keypoint at the beginning of line.  If P1 = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI)

        p2
            Keypoint at the end of line.

        Notes
        -----
        Defines a straight line from P1 to P2 using the global Cartesian
        coordinate system.  The active coordinate system will be ignored.  The
        line shape is invariant with the coordinate system after it is
        generated.  Lines may be redefined only if not yet attached to an area.
        """
        command = "LSTR,%s,%s" % (str(p1), str(p2))
        return self.run(command, **kwargs)

    def lmatrix(self, symfac="", coilname="", curname="", indname="",
                **kwargs):
        """APDL Command: LMATRIX

        Calculates an inductance matrix and the total flux linkage for an
        N-winding coil system.

        Parameters
        ----------
        symfac
            Geometric symmetry factor.  Inductance terms are scaled by this
            factor which represents the fraction of the total device modeled.
            Default is 1.

        coilname
            Alphanumeric prefix identifier for coil label used in defining
            named element coil components. Default is 'coil.'

        curname
            Name of a predefined parameter array containing the nominal coil
            currents of the system.  The array must be defined (see *DIM
            command) prior to calling the LMATRIX macro. Default is 'cur.'

        indname
            Name of the array parameter to be created by LMATRIX containing the
            calculated inductance matrix and the flux linkage in each coil.  A
            text file of the same name with an extension .TXT is created
            containing the matrix data. Default is 'lmatrix.'

        Notes
        -----
        LMATRIX calculates the differential inductance matrix for an N-winding
        system where N is the number of coils in the system, and calculates the
        total flux linkage in each coil. LMATRIX may only be executed after the
        solution of a problem with nominal currents applied to the coils at a
        desired “operating point.” The array Indname has N rows and N+1
        columns. The N x N block is the differential inductance matrix; the
        N+1th column contains the total flux linkage, with the ith row
        corresponding to the ith coil. See the Mechanical APDL Theory Reference
        for more details.

        To invoke the LMATRIX macro, for the classical formulations, the
        elements for each coil must be grouped into a component using the CM
        command.  Each set of independent coil elements is assigned a component
        name with the prefix Coilname followed by the coil number. For the
        solenoidal formulations, you must make the exciting node with a F,AMPS
        load a node component using the CM command.  The classical and
        solenoidal formulations cannot be mixed.

        To invoke the LMATRIX macro, the vector array parameter Curname with
        dimension N must be defined and named using the *DIM command.  You must
        set each vector array entry equal to the nominal current per turn in
        the corresponding coil at the operating point.  Zero current values
        must be approximated by a negligibly small applied current.

        Do not apply (or remove) inhomogeneous loads before using the LMATRIX
        command. Inhomogeneous loads are those created by:

        Degree of freedom commands (D, DA, etc.) specifying nonzero degrees of
        freedom values on nodes or solid model entities

        Any CE command with a nonzero constant term

        Do not put any loads (for example, current) on elements not contained
        in the element component.

        Operating solutions must be obtained through static analysis before
        calling LMATRIX. All name-strings must be enclosed in single quotes in
        the LMATRIX command line. The geometric symmetry factor, Symfac,
        represents the fraction of the device modeled, disregarding any current
        source primitives.

        LMATRIX works only with magnetic field elements: PLANE53, SOLID96, and
        SOLID97, and with SOURC36 solenoidal formulations. For electromagnetic
        elements PLANE233, SOLID236 and SOLID237, static linear perturbation
        analysis can be used to calculate the differential inductance using the
        element incremental energy record (IENE).

        For more information, see LMATRIX in the Low-Frequency Electromagnetic
        Analysis Guide.

        See the Mechanical APDL Theory Reference and Electric and Magnetic
        Macros in the Low-Frequency Electromagnetic Analysis Guide for details.

        This command does not support multiframe restarts.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "LMATRIX,%s,%s,%s,%s" % (str(symfac), str(coilname), str(curname), str(indname))
        return self.run(command, **kwargs)

    def tspec(self, tcolor="", tsize="", txthic="", pangle="", iangle="",
              **kwargs):
        """APDL Command: /TSPEC

        Creates annotation text attributes (GUI).

        Parameters
        ----------
        tcolor
            Text color (0  TCOLOR   15):

            0 - Black.

            1 - Red-Magenta.

            2 - Magenta.

            3 - Blue-Magenta.

            4 - Blue.

            5 - Cyan-Blue.

            6 - Cyan.

            7 - Green-Cyan.

            8 - Green.

            9 - Yellow-Green.

            10 - Yellow.

            11 - Orange.

            12 - Red.

            13 - Dark Gray.

            14 - Light Gray.

            15 - White.

        tsize
            Text size factor.

        txthic
            Text thickness key:

            1 - normal.

            2 - twice as thick.

            3 - three times as thick.

            4 - four times as thick.

        pangle
            Text path angle (0.0 < angle < 360.0).

        iangle
            Text italic angle (0.0 < angle < 45.0).

        Notes
        -----
        Defines annotation text attributes to control certain characteristics
        of the text created via the /TLABEL command.  This is a command
        generated by the Graphical User Interface (GUI) and will appear in the
        log file (Jobname.LOG) if annotation is used.  This command is not
        intended to be typed in directly in an ANSYS session (although it can
        be included in an input file for batch input or for use with the /INPUT
        command).

        This command is valid in any processor.
        """
        command = "/TSPEC,%s,%s,%s,%s,%s" % (str(tcolor), str(tsize), str(txthic), str(pangle), str(iangle))
        return self.run(command, **kwargs)

    def for2d(self, **kwargs):
        """APDL Command: FOR2D

        Calculates magnetic forces on a body.

        Notes
        -----
        FOR2D invokes an ANSYS macro which calculates magnetic forces on a body
        that is completely surrounded by air (symmetry permitted).  The
        calculated forces are stored in the parameters FX and FY.  In
        interactive mode, a node plot is produced with the integration path
        highlighted.  A predefined closed path [PATH], passing through the air
        elements surrounding the body, must be available for this calculation.
        A counterclockwise ordering of nodes on the PPATH command will give the
        correct sign on the forces.  Forces are calculated using a Maxwell
        stress tensor approach.  The macro is valid for 2-D planar or
        axisymmetric analysis.  Path operations are used for the calculations,
        and all path items are cleared upon completion.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "FOR2D," % ()
        return self.run(command, **kwargs)

    def rsplot(self, rslab="", yname="", x1name="", x2name="", type="",
               npts="", plow="", pup="", **kwargs):
        """APDL Command: RSPLOT

        Plot a response surface.

        Parameters
        ----------
        rslab
            Response Surface set label. Identifies the response surfaces
            generated by the RSFIT command.

        yname
            Parameter name. The parameter must have been previously defined as
            a random output parameter with the PDVAR command.

        x1name
            Parameter name. The parameter must have been previously defined as
            a random input variable with the PDVAR command.

        x2name
            Parameter name. The parameter must have been previously defined as
            a random input variable with the PDVAR command. X2Name must be
            different than X1Name.

        type
            Type of the response surface visualization.

            2D - 2-D contour plot.

            3D - 3-D surface plot.

        npts
            Number of grid points for both the X1-axis and the X2-axis. The
            grid points are used for the evaluation of the response surface.
            The number must be between 1 and 500. Defaults to 20. If NPTS = 0
            or greater than 500, then a value of 20 is used.

        plow
            Lower probability level used to determine the lower boundary
            (plotting range) of the curve in case the random input variable
            does not have a minimum value (such as Gauss). This probability
            must be between 0.0 and 1.0. Defaults to 0.0025.

        pup
            Upper probability level used to determine the upper boundary of the
            curve. This probability must be between 0.0 and 1.0. Defaults to
            0.9975.

        Notes
        -----
         Plots the response surface of an output parameter YName as a function
        of two input parameters X1Name and X2Name.

        If PLOW is left blank, then a minimum value of the distribution is used
        for plotting, provided it exists (for example, uniform distribution).
        If the distribution type has no minimum value (for example, Gaussian
        distribution), then the default value is used to determine the lower
        plotting range value. The same is true for the maximum value if PUP is
        left blank.

        In addition to the response surface, the sampling points that are
        fitted by the response surface are also plotted by this command.
        However, sampling points falling outside of the plotting range defined
        by the PLOW and PUP fields will not be shown in the plot.
        """
        command = "RSPLOT,%s,%s,%s,%s,%s,%s,%s,%s" % (str(rslab), str(yname), str(x1name), str(x2name), str(type), str(npts), str(plow), str(pup))
        return self.run(command, **kwargs)

    def dot(self, vector1="", vector2="", par_real="", par_imag="", **kwargs):
        """APDL Command: *DOT

        Computes the dot (or inner) product of two vectors.

        Parameters
        ----------
        vector1
            Name of first vector; must have been previously specified by a *VEC
            command.

        vector2
            Name of second vector; must have been previously specified by a
            *VEC command.

        par_real
            Parameter name that contains the result.

        par_imag
            Parameter name that contains the imaginary part of the result (used
            only for complex vectors).

        Notes
        -----
        If Vector1 and Vector2 are complex, the complex conjugate of Vector1 is
        used to compute the result (Par_Real, Par_Imag).
        """
        command = "*DOT,%s,%s,%s,%s" % (str(vector1), str(vector2), str(par_real), str(par_imag))
        return self.run(command, **kwargs)

    def cone(self, rbot="", rtop="", z1="", z2="", theta1="", theta2="",
             **kwargs):
        """APDL Command: CONE

        Creates a conical volume centered about the working plane origin.

        Parameters
        ----------
        rbot, rtop
            Radii of the bottom and top faces of the cone.  A value of zero or
            blank for either RBOT or RTOP defines a degenerate face at the
            center axis (i.e., the vertex of the cone).  The same value for
            both RBOT and RTOP defines a cylinder instead of a cone.

        z1, z2
            Working plane Z coordinates of the cone.  The smaller value is
            always associated with the bottom face.

        theta1, theta2
            Starting and ending angles (either order) of the cone.  Used for
            creating a conical sector.  The sector begins at the algebraically
            smaller angle, extends in a positive angular direction, and ends at
            the larger angle.  The  starting angle defaults to 0° and the
            ending angle defaults to 360°.  See the Modeling and Meshing Guide
            for an illustration.

        Notes
        -----
        Defines a solid conical volume centered about the working plane origin.
        The non-degenerate face (top or bottom) is parallel to the working
        plane but not necessarily coplanar with (i.e., "on") the working plane.
        The cone must have a spatial volume greater than zero. (i.e., this
        volume primitive command cannot be used to create a degenerate volume
        as a means of creating an area.)  For a cone of 360°, top and bottom
        faces will be circular (each area defined with four lines), and they
        will be connected with two areas (each spanning 180°).  See the CON4
        command for an alternate way to create cones.
        """
        command = "CONE,%s,%s,%s,%s,%s,%s" % (str(rbot), str(rtop), str(z1), str(z2), str(theta1), str(theta2))
        return self.run(command, **kwargs)

    def engen(self, iinc="", itime="", ninc="", iel1="", iel2="", ieinc="",
              minc="", tinc="", rinc="", cinc="", sinc="", dx="", dy="", dz="",
              **kwargs):
        """APDL Command: ENGEN

        Generates elements from an existing pattern.

        Parameters
        ----------
        iinc
            Increment to be added to element numbers in pattern.

        itime, ninc
            Do this generation operation a total of ITIMEs, incrementing all
            nodes in the given pattern by NINC each time after the first. ITIME
            must be > 1 if generation is to occur. NINC may be positive, zero,
            or negative.

        iel1, iel2, ieinc
            Generate elements from the pattern that begins with IEL1 to IEL2
            (defaults to IEL1) in steps of IEINC (defaults to 1). If IEL1 is
            negative, IEL2 and IEINC are ignored and use the last |IEL1|
            elements (in sequence backward from the maximum element number) as
            the pattern to be repeated.  If IEL1 = ALL, IEL2 and IEINC are
            ignored and all selected elements [ESEL] are used as the pattern to
            be repeated. If IEL1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI). A
            component name may also be substituted for IEL1 (IEL2 and IEINC are
            ignored).

        minc
            Increment material number of all elements in the given pattern by
            MINC each time after the first.

        tinc
            Increment type number by TINC.

        rinc
            Increment real constant table number by RINC.

        cinc
            Increment element coordinate system number by CINC.

        sinc
            Increment section ID number by SINC.

        dx, dy, dz
            Define nodes that do not already exist but are needed by generated
            elements (NGEN,ITIME,INC,NODE1,,,DX,DY,DZ). Zero is a valid value.
            If blank, DX, DY, and DZ are ignored.

        Notes
        -----
        Same as the EGEN command except it allows element numbers to be
        explicitly incremented (IINC) from the generated set. Any existing
        elements already having these numbers will be redefined.
        """
        command = "ENGEN,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(iinc), str(itime), str(ninc), str(iel1), str(iel2), str(ieinc), str(minc), str(tinc), str(rinc), str(cinc), str(sinc), str(dx), str(dy), str(dz))
        return self.run(command, **kwargs)

    def setfgap(self, gap="", ropt="", pamb="", acf1="", acf2="", pref="",
                mfp="", **kwargs):
        """APDL Command: SETFGAP

        Updates or defines the real constant table for squeeze film elements.

        Parameters
        ----------
        gap
            Gap separation.

        ropt
            Real constant set option.

            0 - Creates separate real constant sets for each selected element with the
                specified real constant values (default).

            1 - Updates existing real constant sets. The gap separation is updated from
                displacement results in the database. Other real constants are
                updated as specified in the command input parameters.

        --
            Unused field

        pamb
            Ambient pressure.

        acf1, acf2
            Accommodation factor 1 and 2.

        pref
            Reference pressure for mean free path.

        mfp
            Mean free path.

        Notes
        -----
        This command is used for large signal cases to update the gap
        separation real constant on a per-element basis.  Issue this command
        prior to solution using the default ROPT value to initialize real
        constant sets for every fluid element.  After a solution, you can re-
        issue the command to update the real constant set for a subsequent
        analysis. See Introduction for more information on thin film analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "SETFGAP,%s,%s,%s,%s,%s,%s,%s" % (str(gap), str(ropt), str(pamb), str(acf1), str(acf2), str(pref), str(mfp))
        return self.run(command, **kwargs)

    def bstq(self, val1="", val2="", t="", **kwargs):
        """APDL Command: BSTQ

        Specifies the cross section twist and torque relationship for beam
        sections.

        Parameters
        ----------
        val1
            Twist component (χ).

        val2
            Torque component (τ).

        t
            Temperature.

        Notes
        -----
        The behavior of beam elements is governed by the generalized-
        stress/generalized-strain relationship of the form:

        The BSTQ command, one of several nonlinear general beam section
        commands, specifies the cross section twist and torque relationship for
        a beam section. The section data defined is associated with the section
        most recently defined (via the SECTYPE command).

        Unspecified values default to zero.

        Related commands are BSAX, BSM1, BSM2, BSS1, BSS2, BSMD, and BSTE.

        For complete information, see Using Nonlinear General Beam Sections.
        """
        command = "BSTQ,%s,%s,%s" % (str(val1), str(val2), str(t))
        return self.run(command, **kwargs)

    def tintp(self, gamma="", alpha="", delta="", theta="", oslm="", tol="",
              avsmooth="", alphaf="", alpham="", **kwargs):
        """APDL Command: TINTP

        Defines transient integration parameters.

        Parameters
        ----------
        gamma
            Amplitude decay factor for 2nd order transient integration, e.g.,
            structural dynamics (used only if ALPHA, DELTA, ALPHAF, and ALPHAM
            are blank).  Defaults to 0.005.

        alpha
            2nd order transient integration parameter (used only if GAMMA is
            blank).  Defaults to 0.2525.

        delta
            2nd order transient integration parameter (used only if GAMMA is
            blank).  Defaults to 0.5050.

        theta
            1st order transient (e.g., thermal transient) integration
            parameter.  Defaults to 1.0.

        oslm
            Specifies the oscillation limit criterion for automatic time
            stepping of 1st order transients (e.g., thermal transients).
            Defaults to 0.5 with a tolerance of TOL.

        tol
            Tolerance applied to OSLM.  Defaults to 0.0.

        --, --
            Unused fields.

        avsmooth
            Smoothing flag option:

            0 - Include smoothing of the velocity (1st order system) or the acceleration (2nd
                order system) (default).

            1 - Do not include smoothing.

        alphaf
            Interpolation factor in HHT algorithm for force and damping terms
            (used only if GAMMA is blank). Defaults to 0.005.

        alpham
            Interpolation factor in HHT algorithm for inertial term (used only
            if GAMMA is blank). Defaults to 0.0.

        Notes
        -----
        Used to define the transient integration parameters.  For more
        information on transient integration parameters, refer to the
        Mechanical APDL Theory Reference.

        For structural transient analyses, you may choose between the Newmark
        and HHT time integration methods (see the TRNOPT command). In this
        case, if GAMMA is input and the integration parameters ALPHA, DELTA,
        ALPHAF, and ALPHAM are left blank, the program will calculate the
        integration parameters. Alternatively, you can input these integration
        parameters directly on this command. However, for the unconditional
        stability and second order accuracy of the time integration, these
        parameters should satisfy a specific relationship, as described in
        Description of Structural and Other Second Order Systems of the
        Mechanical APDL Theory Reference.

         In a transient piezoelectric analysis, required input for this command
        is ALPHA = 0.25, DELTA = 0.5, and THETA = 0.5.  For a coupled
        electromagnetic-circuit transient analysis, use THETA = 1.0, the
        default value, to specify the backward Euler method.

        This command is also valid in PREP7.
        """
        command = "TINTP,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(gamma), str(alpha), str(delta), str(theta), str(oslm), str(tol), str(avsmooth), str(alphaf), str(alpham))
        return self.run(command, **kwargs)

    def lrefine(self, nl1="", nl2="", ninc="", level="", depth="", post="",
                retain="", **kwargs):
        """APDL Command: LREFINE

        Refines the mesh around specified lines.

        Parameters
        ----------
        nl1, nl2, ninc
            Lines (NL1 to NL2 in increments of NINC) around which the mesh is
            to be refined.  NL2 defaults to NL1, and NINC defaults to 1.  If
            NL1 = ALL, NL2 and NINC are ignored and all selected lines are used
            for refinement.  If NL1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  A
            component name may also be substituted for NL1 (NL2 and NINC are
            ignored).

        level
            Amount of refinement to be done.  Specify the value of LEVEL as an
            integer from 1 to 5, where a value of 1 provides minimal
            refinement, and a value of 5 provides maximum refinement (defaults
            to 1).

        depth
            Depth of mesh refinement in terms of the number of elements outward
            from the indicated lines (defaults to 1).

        post
            Type of postprocessing to be done after element splitting, in order
            to improve element quality:

            OFF - No postprocessing will be done.

            SMOOTH - Smoothing will be done.  Node locations may change.

            CLEAN - Smoothing and cleanup will be done.  Existing elements may be deleted, and node
                    locations may change (default).

        retain
            Flag indicating whether quadrilateral elements must be retained in
            the refinement of an all-quadrilateral mesh.  (The ANSYS program
            ignores the RETAIN argument when you are refining anything other
            than a quadrilateral mesh.)

            ON - The final mesh will be composed entirely of quadrilateral elements, regardless
                 of the element quality (default).

            OFF - The final mesh may include some triangular elements in order to maintain
                  element quality and provide transitioning.

        Notes
        -----
        LREFINE performs local mesh refinement around the specified lines. By
        default, the indicated elements are split to create new elements with
        1/2 the edge length of the original elements (LEVEL = 1).

        LREFINE refines all area elements and tetrahedral volume elements that
        are adjacent to the specified lines. Any volume elements that are
        adjacent to the specified lines, but are not tetrahedra (for example,
        hexahedra, wedges, and pyramids), are not refined.

        You cannot use mesh refinement on a solid model that contains initial
        conditions at nodes [IC], coupled nodes [CP family of commands],
        constraint equations [CE family of commands], or boundary conditions or
        loads applied directly to any of its nodes or elements. This applies to
        nodes and elements anywhere in the model, not just in the region where
        you want to request mesh refinement. For additional restrictions on
        mesh refinement, see Revising Your Model in the Modeling and Meshing
        Guide.

        This command is also valid for rezoning.
        """
        command = "LREFINE,%s,%s,%s,%s,%s,%s,%s" % (str(nl1), str(nl2), str(ninc), str(level), str(depth), str(post), str(retain))
        return self.run(command, **kwargs)

    def wplane(self, wn="", xorig="", yorig="", zorig="", xxax="", yxax="",
               zxax="", xplan="", yplan="", zplan="", **kwargs):
        """APDL Command: WPLANE

        Defines a working plane to assist in picking operations.

        Parameters
        ----------
        wn
            Window number whose viewing direction will be modified to be normal
            to the working plane (defaults to 1).  If WN is a negative value,
            the viewing direction will not be modified.  If fewer than three
            points are used, the viewing direction of window WN will be used
            instead to define the normal to the working plane.

        xorig, yorig, zorig
            Global Cartesian coordinates of the origin of the working plane
            coordinate system.

        xxax, yxax, zxax
            Global Cartesian coordinates of a point defining the x-axis
            orientation.  The x-axis aligns with the projection of the line
            from this orientation point to the origin.

        xplan, yplan, zplan
            Global Cartesian coordinates of the third point defining the
            working plane.  This point will also define the location of the
            positive XY-sector of the working plane coordinate system.

        Notes
        -----
        Defines a working plane to assist in picking operations using the
        coordinates of three noncolinear points.  The three points also define
        the working plane coordinate system.  A minimum of one point (the
        working plane origin) is required.  Immediate mode may also be active.
        See WPSTYL command to set the style of working plane display.

        This command is valid in any processor.
        """
        command = "WPLANE,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(wn), str(xorig), str(yorig), str(zorig), str(xxax), str(yxax), str(zxax), str(xplan), str(yplan), str(zplan))
        return self.run(command, **kwargs)

    def esln(self, type="", ekey="", nodetype="", **kwargs):
        """APDL Command: ESLN

        Selects those elements attached to the selected nodes.

        Parameters
        ----------
        type
            Label identifying the type of element selected:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        ekey
            Node set key:

            0 - Select element if any of its nodes are in the selected nodal set (default).

            1 - Select element only if all of its nodes are in the selected nodal set.

        nodetype
            Label identifying type of nodes to consider when selecting:

            ALL - Select elements considering all of their nodes (default).

            ACTIVE - Select elements considering only their active nodes. An active node is a node
                     that contributes DOFs to the model.

            INACTIVE - Select elements considering only their inactive nodes (such as orientation or
                       radiation nodes).

            CORNER - Select elements considering only their corner nodes.

            MID - Select elements considering only their midside nodes.

        Notes
        -----
        ESLN selects elements which have any (or all EKEY) NodeType nodes in
        the currently-selected set of nodes. Only elements having nodes in the
        currently-selected set can be selected.

        This command is valid in any processor.
        """
        command = "ESLN,%s,%s,%s" % (str(type), str(ekey), str(nodetype))
        return self.run(command, **kwargs)

    def dowhile(self, par="", **kwargs):
        """APDL Command: *DOWHILE

        Loops repeatedly through the next *ENDDO command.

        Parameters
        ----------
        par
            The name of the scalar parameter to be used as the loop index.
            There is no character parameter substitution for the Par field.

        Notes
        -----
        *DOWHILE loops repeatedly through the next *ENDDO command as long as
        Par is greater than zero. The block of commands following the *DOWHILE
        command (up to the *ENDDO command) is executed repeatedly until some
        loop control is satisfied.  Printout is automatically suppressed on all
        loops after the first (include a /GOPR command to restore the
        printout).  The command line loop control (Par) must be input; however,
        *IF within the block can also be used to control looping [*EXIT,
        *CYCLE].  One level of internal file switching is used for each nested
        *DOWHILE.  Twenty levels of nested do-loops are allowed.

        This command is valid in any processor.
        """
        command = "*DOWHILE,%s" % (str(par))
        return self.run(command, **kwargs)

    def tbeo(self, par="", value="", **kwargs):
        """APDL Command: TBEO

        Sets special options or parameters for material data tables.

        Parameters
        ----------
        par
            Parameter name:

            CAPCREEPREG - Available for the viscoplasticity/creep model (TB,CREEP), allows two creep
                          models to be specified via the same material ID when
                          used with the Extended Drucker-Prager model (TB,EDP).

        value
            Parameter value:

            SHEA -  Use the shear stress-state creep model with the Extended Drucker-Prager model.
                   Valid only when Par = CAPCREEPREG.

            COMP - Use the compaction stress-state creep model with the Extended Drucker-Prager
                   model. Valid only when Par = CAPCREEPREG.

        Notes
        -----
        Issue the TBEO command after activating the data table (TB) but before
        defining data for the table (TBDATA) or a point on a nonlinear data
        curve (TBPT).
        """
        command = "TBEO,%s,%s" % (str(par), str(value))
        return self.run(command, **kwargs)

    def prrsol(self, lab="", **kwargs):
        """APDL Command: PRRSOL

        Prints the constrained node reaction solution.

        Parameters
        ----------
        lab
            Nodal reaction load type.  If blank, use the first ten of all
            available labels. Valid labels are:

        Notes
        -----
        Prints the constrained node reaction solution for the selected nodes in
        the sorted sequence.  For coupled nodes and nodes in constraint
        equations, the sum of all reactions in the coupled or constraint
        equation set  appears at the primary node of the set.  Results are in
        the global Cartesian coordinate directions unless transformed (RSYS).

        PRRSOL is not valid if any load is applied to a constrained node in the
        direction of the constraint and any of the following is true:

        LCOPER has been used.

        LCASE has been used to read from a load case file.

        The applied loads and constraints in the database are not the ones used
        to create the results data being processed.

        PRRSOL provides the total reaction solution (static, plus damping, plus
        inertial, as appropriate based on the analysis type); however, modal
        reactions include only the static contribution.

        Use PRRFOR instead of PRRSOL with the FORCE command to obtain only the
        static, damping, or inertial components.
        """
        command = "PRRSOL,%s" % (str(lab))
        return self.run(command, **kwargs)

    def edvel(self, option="", cname="", vx="", vy="", vz="", omegax="",
              omegay="", omegaz="", xc="", yc="", zc="", angx="", angy="",
              angz="", **kwargs):
        """APDL Command: EDVEL

        Applies initial velocities to nodes or node components in an explicit
        dynamic analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed.

            VGEN - Define initial velocities based on translational velocities (relative to global
                   Cartesian) and the rotational velocity about an arbitrary
                   axis. For this option, use the fields VX, VY, VZ to specify
                   the translational velocities, and use OMEGAX, XC, YC, ZC,
                   ANGX, ANGY, ANGZ to specify the rotational velocity and the
                   axis of rotation.

            VELO - Define initial velocity based on translational velocities and nodal rotational
                   velocities input relative to the global Cartesian axes. For
                   this option, use the following fields to define the initial
                   velocity: VX, VY, VZ, OMEGAX, OMEGAY, OMEGAZ.

            LIST - List initial velocity for the component or node specified by Cname. If Cname is
                   blank, all initial velocities defined on nodes and node
                   components are listed. Remaining fields are ignored for this
                   option.

            DELE - Delete initial velocity defined for the component or node specified by Cname.
                   If Cname is blank, all initial velocities defined on nodes
                   and node components are deleted. Remaining fields are
                   ignored for this option.

        cname
            Name of existing component [CM] or node number to which the initial
            velocity is to be applied. If a component is used, it must consist
            of nodes.

        vx
            Initial velocity in X direction. Defaults to 0.

        vy
            Initial velocity in Y direction. Defaults to 0.

        vz
            Initial velocity in Z direction. Defaults to 0.

        omegax
            For Option = VGEN, OMEGAX is the initial rotational velocity of the
            component (or node) about the specified rotational axis. For Option
            = VELO, OMEGAX is the initial nodal rotational velocity about the
            X-axis. OMEGAX defaults to 0.

        omegay
            Initial nodal rotational velocity about the Y-axis (used only if
            Option = VELO). Defaults to 0.

        omegaz
            Initial nodal rotational velocity about the Z-axis (used only if
            Option = VELO). Defaults to 0.

        Notes
        -----
        You cannot mix the two methods of initial velocity input (Option = VELO
        and Option = VGEN) in the same analysis. You must use only one method
        for all initial velocity definitions.

        The VGEN and VELO methods differ in how the rotational velocity is
        defined. Use Option = VGEN to input the initial velocities of a
        rotating component. Use Option = VELO to apply the rotations directly
        to the nodes' rotation degrees of freedom. Since only shell and beam
        elements have rotation degrees of freedom, the rotations input with
        Option = VELO are only applicable to SHELL163 and BEAM161 elements. The
        rotational velocities input with Option = VELO are ignored for nodes
        not having rotational degrees of freedom (such as nodes attached to a
        SOLID164 or SOLID168 element).

        It is normally acceptable to mix nodes belonging to deformable bodies
        and rigid bodies in the nodal component used in an initial velocity
        definition. However, when defining initial velocities in an implicit-
        to-explicit sequential solution, this is not an acceptable practice. In
        order for the initial velocities to be defined correctly in this type
        of analysis, you must define the initial velocities on the deformable
        body nodes separately from the initial velocities on the rigid body
        nodes.

        Issuing the EDVEL command again for the same component or node (Cname)
        will overwrite previous initial velocities defined for that component
        or node.

        To set the initial velocities to zero, issue the EDVEL command with
        only the Option (use VELO or VGEN) and Cname fields specified.

        In a small restart analysis (EDSTART,2), you can only use the Option =
        VELO method to change initial velocities. When used in a small restart,
        the command EDVEL,VELO changes the velocity of the specified nodes. If
        you don't change the velocity of the nodes, their velocity at the
        beginning of the restart will be the same as the velocity at the end of
        the previous analysis.

        Except for the LIST option, the EDVEL command is not supported in a
        full restart analysis (EDSTART,3). You can list initial velocities
        defined in the previous analysis with the command EDVEL,LIST. However,
        you cannot change initial velocities for nodes or node components that
        existed in the previous analysis; their velocity at the beginning of
        the analysis will be the same as the velocity at the end of the
        previous analysis. In addition, you cannot define initial velocities
        for any nodes that are added in the full restart; the velocity of new
        nodes will be zero.

        To apply initial velocities to parts or part assemblies, use the EDPVEL
        command.

        You can use EDPVEL and EDVEL in the same analysis. If a node or node
        component input on the EDVEL command shares common nodes with a part or
        part assembly input on the EDPVEL command, the initial velocities
        defined on the common nodes will be determined by the last command
        input.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDVEL,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(cname), str(vx), str(vy), str(vz), str(omegax), str(omegay), str(omegaz), str(xc), str(yc), str(zc), str(angx), str(angy), str(angz))
        return self.run(command, **kwargs)

    def lsymm(self, ncomp="", nl1="", nl2="", ninc="", kinc="", noelem="",
              imove="", **kwargs):
        """APDL Command: LSYMM

        Generates lines from a line pattern by symmetry reflection.

        Parameters
        ----------
        ncomp
            Symmetry key:

            X - X symmetry (default).

            Y - Y symmetry.

            Z - Z symmetry.

        nl1, nl2, ninc
            Reflect lines from pattern beginning with NL1 to NL2 (defaults to
            NL1) in steps of NINC (defaults to 1).  If NL1 = ALL, NL2 and NINC
            are ignored and pattern is all selected lines [LSEL].  If NL1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NL1 (NL2 and NINC are ignored).

        kinc
            Keypoint increment between sets.  If zero, the lowest available
            keypoint  numbers are assigned [NUMSTR].

        noelem
            Specifies whether nodes and elements are also to be generated:

            0 - Generate nodes and elements associated with the original lines, if they exist.

            1 - Do not generate nodes and elements.

        imove
            Specifies whether areas will be moved or newly defined:

            0 - Generate additional lines.

            1 - Move original lines to new position retaining the same keypoint numbers (KINC
                and NOELEM are ignored).  Valid only if the old lines are no
                longer needed at their original positions.  Corresponding
                meshed items are also moved if not needed at their original
                position.

        Notes
        -----
        Generates a reflected set of lines (and their corresponding keypoints
        and mesh) from a given line pattern by a symmetry reflection (see
        analogous node symmetry command, NSYM).  The MAT, TYPE, REAL, and ESYS
        attributes are based upon the lines in the pattern and not upon the
        current settings.  Reflection is done in the active coordinate system
        by changing a particular coordinate sign.  The active coordinate system
        must be Cartesian.  Lines in the pattern may have been generated in any
        coordinate system.  However, solid modeling in a toroidal coordinate
        system is not recommended.  Lines are generated as described in the
        LGEN command.

        See the ESYM command for additional information about symmetry
        elements.
        """
        command = "LSYMM,%s,%s,%s,%s,%s,%s,%s" % (str(ncomp), str(nl1), str(nl2), str(ninc), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def wsort(self, lab="", kord="", wopt="", oldmax="", oldrms="", **kwargs):
        """APDL Command: WSORT

        Initiates element reordering based upon a geometric sort.

        Parameters
        ----------
        lab
            Coordinate (in the active system) along which element centroid
            locations are sorted.  Valid labels are:  X, Y, Z, ALL.  If ALL
            (default), all three directions will be used, and the order
            corresponding to the lowest MAX or RMS wavefront value will be
            retained.

        kord
            Sort order:

            0 - Sort according to ascending coordinate values.

            1 - Sort according to descending coordinate values.

        --
            Unused field.

        wopt
            Option for comparison:

            MAX - Use maximum wavefront value for comparison (default).

            RMS - Use RMS wavefront value.

        oldmax, oldrms
            MAX and RMS wavefront values of model to be used in place of the
            old values.  OLDRMS defaults to OLDMAX (and vice versa).  If
            neither is  specified, each defaults to its calculated old value.

        Notes
        -----
        Initiates element reordering based upon a geometric sort of the element
        centroid locations.  Wave lists, if any [WSTART], are ignored.
        Reordering affects only the element order for the solution phase and
        not the element numbers (input referring to element numbers, such as
        element pressures, is unaffected by reordering).

        Note:: : The new order is retained only if new the new maximum or RMS
        wavefront values are lower than the old values, as described below.
        See the WAVES command for another reordering procedure and for more
        details on reordering.  The resulting element ordering can be shown by
        listing the wavefront history [WFRONT,1] or by displaying elements with
        their element location numbers [/PNUM].

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "WSORT,%s,%s,%s,%s,%s" % (str(lab), str(kord), str(wopt), str(oldmax), str(oldrms))
        return self.run(command, **kwargs)

    def pdcfld(self, parr="", entity="", ctype="", clength="", **kwargs):
        """APDL Command: PDCFLD

        Calculates a correlation field and stores it into an ANSYS array.

        Parameters
        ----------
        parr
            Parameter name. ParR is a one-dimensional array with the dimension
            N * (N - 1)/2, where N is either the number of the selected nodes
            or the number of the selected elements (depending on the Entity
            field). The PDCFLD command automatically sets ParR as a one-
            dimensional array, (so you do not have to use the *DIM command). If
            you use the PDCFLD command twice with the ANSYS parameter ParR,
            then the values stored in the array are automatically overwritten.
            If the number of selected FE entities is different from the
            previous PDCFLD command, then the array ParR is re-dimensioned
            automatically.

        entity
            Specifies which FE entity the calculation of the correlation field
            is based on. This field must not be blank.

            NODE - Calculate the correlation coefficients based on the distance between the
                   selected nodes.

            ELEM - Calculate the correlation coefficients based on the distance between the
                   centroids of the selected elements.

        ctype
            Specifies the equation used to calculate the correlation
            coefficients as a function of the nodal or element centroid
            distances. This field must not be blank.

            NONE - The random field is not correlated. This means the correlation coefficients are
                   determined according to

            ρij = 1 for i = j - ρij = 0 for i ≠ j

            Here, ρij is the correlation coefficient between the i-th and j-th selected FE entity (node or element centroid). - LEXP

            Calculate the correlation coefficient according to a linear-exponential decay function. - Here, D({xi} , {xj}) is the “domain distance” between {xi}, {xj}, and {xi} and
                              {xj} are the coordinate vectors of the i-th and
                              j-th selected FE entity (node or element
                              centroid), and CL is the correlation length of
                              the random field as specified in the CLENGTH
                              field.

        clength
            Correlation length of the correlation field. The correlation length
            is a characteristic length that influences how strongly two
            elements of a random field are correlated with each other. The
            larger the value of CLENGTH, the stronger the correlation between
            the random field elements. CLENGTH is required for Ctype = LEXP and
            Ctype = QEXP; it must be a nonzero, positive number.

        Notes
        -----
        Calculates a correlation field for a probabilistic analysis involving a
        random field. Random fields are random effects with a spatial
        distribution; the value of a random field not only varies from
        simulation to simulation at any given location, but also from location
        to location. The correlation field describes the correlation
        coefficient between two different spatial locations. Random fields can
        be either based on element properties (typically material) or nodal
        properties (typically surface shape defined by nodal coordinates).
        Hence, random fields are either associated with the selected nodes or
        the selected elements. If a random field is associated with elements,
        then the correlation coefficients of the random field are calculated
        based on the distance of the element centroids.

        For more information, see Probabilistic Design in the Advanced Analysis
        Guide.

        Note that for correlation fields, the “domain distance” D({xi} , {xj})
        is not the spatial distance |{xi} - {xj}|, but the length of a path
        between {xi} and {xj} that always remains inside the finite element
        domain. However, exceptions are possible in extreme meshing cases. For
        elements that share at least one node, the PDCFLD evaluates the
        distance by directly connecting the element centroids with a straight
        line. If these neighboring elements form a sharp inward corner then it
        is possible that the “domain distance” path lies partly outside the
        finite element domain, as illustrated below.

        After the correlation coefficients have been calculated and stored in
        the ANSYS parameter ParR, then use the PDCORR command to define the
        correlations between the elements of the random field.
        """
        command = "PDCFLD,%s,%s,%s,%s" % (str(parr), str(entity), str(ctype), str(clength))
        return self.run(command, **kwargs)

    def prscontrol(self, key="", **kwargs):
        """APDL Command: PRSCONTROL

        Specifies whether to include pressure load stiffness in the element
        stiffness formation.

        Parameters
        ----------
        key
            Pressure load stiffness key. In general, use the default setting.
            Use a non-default setting only if you encounter convergence
            difficulties. Pressure load stiffness is automatically included
            when using eigenvalue buckling analyses (ANTYPE,BUCKLE), equivalent
            to Key = INCP. For all other types of analyses, valid arguments for
            Key are:

            NOPL - Pressure load stiffness not included for any elements.

            (blank) (default) - Include pressure load stiffness for elements SURF153, SURF154, SURF156,
                              SURF159, SHELL181, PLANE182, PLANE183, SOLID185,
                              SOLID186, SOLID187, SOLSH190, BEAM188, BEAM189,
                              FOLLW201, SHELL208, SHELL209, SOLID272, SOLID273,
                              SHELL281, SOLID285, PIPE288, PIPE289, and
                              ELBOW290. Do not include pressure load stiffness
                              for elements SOLID65.

            INCP - Pressure load stiffness included for all of the default elements listed above
                   and SOLID65.

        Notes
        -----
        This command is rarely needed. The default settings are recommended for
        most analyses.
        """
        command = "PRSCONTROL,%s" % (str(key))
        return self.run(command, **kwargs)

    def spgraph(self, tblno="", curvno="", curvnobeg ="", **kwargs):
        """APDL Command: SPGRAPH

        Displays input spectrum curves for MPRS analysis.

        Parameters
        ----------
        tblno
            Table number to display.  Defaults to 1.

        curvno
            Curve number to display. Defaults to none.

        curvnobeg
            Beginning of the curve number range to display. Defaults to 1.

        Notes
        -----
        You can display up to 10 input spectrum curves (SPVAL and SPFREQ
        commands) with log X scale.

        If the input spectrum curves are not associated with a damping value
        (SPDAMP command), CURVNO and CURVNOBeg are not applicable and table
        TBLNO is displayed. Otherwise, specify CURVNO or CURVNOBeg:

        if CURVNO is used, one curve is displayed.

        if CURVNOBeg is used, up to 10 curves are displayed. CURVNOBeg is the
        beginning of the curve number range of interest.
        """
        command = "SPGRAPH,%s,%s,%s" % (str(tblno), str(curvno), str(curvnobeg ))
        return self.run(command, **kwargs)

    def ftype(self, filetype="", prestype="", **kwargs):
        """APDL Command: FTYPE

        Specifies the file type and pressure type for the subsequent import of
        source points and pressures.

        Parameters
        ----------
        filetype
            Type of file from which the pressure data will be retrieved (no
            default):

            CFXTBR - File from a CFX Transient Blade Row (TBR) analysis export.

            CFDPOST - File from a CFD-Post BC Profile export.

            FORMATTED - Formatted file.

            CSV - Comma-Separated Values file.

        prestype
            Type of pressure data contained in the file:

            0 - Only real-valued pressures are on the file.

            1 - Real-valued and imaginary-valued pressures are on the file (default).

        Notes
        -----
        CFX Transient Blade Row files (FileType = CFXTBR) are obtained from the
        Export Results Tab in CFX-Pre, with [Export Surface Name]: Option set
        to Harmonic Forced Response.

        CFD-Post files (FileType = CFDPOST) are obtained from the Export action
        in CFD-Post with Type set to BC Profile.

        Formatted files (FileType = FORMATTED) contain the coordinates and
        pressure data in fixed-format columns in the order  x, y, z, pressure.
        You may have other columns of data in the file which can be skipped
        over in the Format specifier on the READ command, but the data must be
        in that order.

        Comma-separated values files (FileType = CSV) contain the coordinates
        and pressure data in comma-separated fields. The data can be in any
        order, and other fields of data may also be present.
        """
        command = "FTYPE,%s,%s" % (str(filetype), str(prestype))
        return self.run(command, **kwargs)

    def lssolve(self, lsmin="", lsmax="", lsinc="", **kwargs):
        """APDL Command: LSSOLVE

        Reads and solves multiple load steps.

        Parameters
        ----------
        lsmin, lsmax, lsinc
            Range of load step files to be read and solved, from LSMIN to LSMAX
            in steps of LSINC.  LSMAX defaults to LSMIN, and LSINC defaults to
            1. If LSMIN is blank, a brief command description is displayed.
            The load step files are assumed to be named Jobname.Sn, where n is
            a number assigned by the LSWRITE command (01--09,10,11, etc.).  On
            systems with a 3-character limit on the extension, the "S" is
            dropped for numbers > 99.

        Notes
        -----
        LSSOLVE invokes an ANSYS macro to read and solve multiple load steps.
        The macro loops through a series of load step files written by the
        LSWRITE command.  The macro file called by LSSOLVE is called
        LSSOLVE.MAC.

        LSSOLVE cannot be used with the birth-death option.

        LSSOLVE is not supported for cyclic symmetry analyses.

        LSSOLVE does not support restarts.
        """
        command = "LSSOLVE,%s,%s,%s" % (str(lsmin), str(lsmax), str(lsinc))
        return self.run(command, **kwargs)

    def ioptn(self, lab="", val1="", **kwargs):
        """APDL Command: IOPTN

        Controls options relating to importing a model.

        Parameters
        ----------
        lab
            Label identifying the import option.  The meaning of VAL1 varies
            depending on Lab.

            STAT - List overall status of import facilities, including current option values.
                   VAL1 is ignored.

            DEFA - Set default values for all import options.  VAL1is ignored.

            MERG - Entity merge option.  VAL1 can be:

            YES - Automatic merging is performed (default).

            NO - No merging of entities.

            SOLID - Solid option.  VAL1 can be:

            YES - Solid is created automatically (default).

            NO - No solid created.

            GTOLER - Entity merging tolerance. If IGES = SMOOTH, the GTOLER,VAL1 can be:

            DEFA - Use system defaults (default).

            FILE - Use tolerance from the imported file.

            n - A user-specified tolerance value.

            IGES - IGES import option.  VAL1 can be:

            STAT - List status of IGES related options in the output window.

            SMOOTH (or RV52) - Use more robust IGES revision 5.2 import function (default).

            SMALL - Small areas option.   VAL1 can be:

            YES - Small areas are deleted (default).

            NO - Small areas are retained.

        val1
            Additional input value as described under each Lab option.

        Notes
        -----
        Controls various options during a model file transfer.  A global solid
        model tolerance (GTOLER) can be specified.

        The SMALL,YES option (default) delete small areas  and can cause
        geometrical inconsistencies that could cause the import process to
        abort.  Retaining the small areas increases processor time and memory
        usage.

        The data is stored in the standard ANSYS graphics database.

        The IGES,SMOOTH (default) option is capable of reading in any rational
        B-spline curve entity (type 126), or rational B-spline surface entity
        (type 128) with a degree less than or equal to 20.  Attempts to read in
        B-spline curve or surface entities of degree higher than 20 may result
        in error messages.

        If you issue the /CLEAR command, the IOPTN settings return to their
        defaults.

        For MERG,YES, merging of coincident geometry items is performed
        automatically when the IGESIN command is issued (that is, an internal
        NUMMRG,KP command is issued).  The model is merged with the
        consideration tolerance (TOLER on NUMMRG) set equal to 0.75 * the
        shortest distance between the endpoints of any active line. See the
        NUMMRG command for more information about the tolerances. In most
        cases, the default merging is appropriate.  Use the IOPTN command when
        you want to:

        Disable merging operations.

        Override the default merging and specify a global solid model tolerance
        value (GTOLER).

        Disable the automatic creation of solids (SOLID).

        The IOPTN command should be issued before the IGESIN command. You
        cannot change these options after your model has been imported or
        created. If you must change the options:

        Clear the database (/CLEAR) or exit and restart the program.

        Set the correct options.

        Reimport or recreate the model.

        This command is valid in any processor.
        """
        command = "IOPTN,%s,%s" % (str(lab), str(val1))
        return self.run(command, **kwargs)

    def ncnv(self, kstop="", dlim="", itlim="", etlim="", cplim="", **kwargs):
        """APDL Command: NCNV

        Sets the key to terminate an analysis.

        Parameters
        ----------
        kstop
            Program behavior upon nonconvergence:

            0 - Do not terminate the analysis if the solution fails to converge.

            1 - Terminate the analysis and the program execution if the solution fails to
                converge (default).

            2 - Terminate the analysis, but not the program execution, if the solution fails to
                converge.

        dlim
            Terminates program execution if the largest nodal DOF solution
            value (displacement, temperature, etc.) exceeds this limit.
            Defaults to 1.0E6 for all DOF except MAG and A. Defaults to 1.0E10
            for MAG and A.

        itlim
            Terminates program execution if the cumulative iteration number
            exceeds this limit (defaults to infinity).

        etlim
            Terminates program execution if the elapsed time (seconds) exceeds
            this limit (defaults to infinity).

        cplim
            Terminates program execution if the CPU time (seconds) exceeds this
            limit (defaults to infinity).

        Notes
        -----
        Sets the key to terminate an analysis if not converged, or if any of
        the following limits are exceeded for nonlinear and full transient
        analyses: DOF (displacement), cumulative iteration, elapsed time, or
        CPU time limit.  Applies only to static and transient analyses
        (ANTYPE,STATIC and ANTYPE,TRANS). Time limit checks are made at the end
        of each equilibrium iteration.

        This command is also valid in PREP7.
        """
        command = "NCNV,%s,%s,%s,%s,%s" % (str(kstop), str(dlim), str(itlim), str(etlim), str(cplim))
        return self.run(command, **kwargs)

    def larea(self, p1="", p2="", narea="", **kwargs):
        """APDL Command: LAREA

        Generates the shortest line between two keypoints on an area.

        Parameters
        ----------
        p1
            First keypoint of line to be generated.  If P1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).

        p2
            Second keypoint of line to be generated.

        narea
            Area containing P1 and P2, or area to which generated line is to be
            parallel.

        Notes
        -----
        Generates the shortest line between two keypoints, P1 and P2, both of
        which lie on an area.  The generated line will also lie on the area.
        P1 and P2 may also be equidistant (in global Cartesian space) from the
        area (and on the same side of the area), in which case a line parallel
        to the area is generated.
        """
        command = "LAREA,%s,%s,%s" % (str(p1), str(p2), str(narea))
        return self.run(command, **kwargs)

    def mdamp(self, stloc="", v1="", v2="", v3="", v4="", v5="", v6="",
              **kwargs):
        """APDL Command: MDAMP

        Defines the damping ratios as a function of mode.

        Parameters
        ----------
        stloc
            Starting location in table for entering data.  For example, if
            STLOC = 1, data input in the V1 field applies to the first constant
            in the table.  If STLOC = 7, data input in the V1 field applies to
            the seventh constant in the table, etc.  Defaults to the last
            location filled + 1.

        v1, v2, v3, . . . , v6
            Data assigned to six locations starting with STLOC.  If a value is
            already in this location, it will be redefined.  Blank values for
            V2 to V6 leave the corresponding previous value unchanged.

        Notes
        -----
        Defines the damping ratios as a function of mode.  Table position
        corresponds to mode number.  These ratios are added to the DMPRAT
        value, if defined.  Use STAT command to list current values.  Applies
        to the mode-superposition harmonic (ANTYPE,HARMIC), the mode-
        superposition linear transient dynamic (ANTYPE,TRANS), and the spectrum
        (ANTYPE,SPECTR) analyses.  Repeat MDAMP command for additional
        constants (10000 maximum).

        MDAMP can also be defined in a substructure analysis using component
        mode synthesis with fixed-interface method (ANTYPE,SUBSTR with
        CMSOPT,FIX and SEOPT,,,3). The damping ratios are added to the diagonal
        of the reduced damping matrix as explained in Component Mode Synthesis
        (CMS).

        This command is also valid in PREP7.
        """
        command = "MDAMP,%s,%s,%s,%s,%s,%s,%s" % (str(stloc), str(v1), str(v2), str(v3), str(v4), str(v5), str(v6))
        return self.run(command, **kwargs)

    def qdval(self, tblno1="", tblno2="", sv1="", sv2="", sv3="", sv4="",
              sv5="", sv6="", sv7="", **kwargs):
        """APDL Command: QDVAL

        Defines PSD quadspectral values.

        Parameters
        ----------
        tblno1
            First input PSD table number associated with this spectrum.

        tblno2
            Second input PSD table number associated with this spectrum.

        sv1, sv2, sv3, . . . , sv7
            PSD quadspectral values corresponding to the frequency points
            [PSDFRQ].

        Notes
        -----
        Defines PSD quadspectral values to be associated with the previously
        defined frequency points.  Repeat QDVAL command with the same table
        number for additional points.  Unlike autospectra [PSDVAL], the
        quadspectra can be positive or negative.  The quadspectral curve
        segment where there is a sign change is interpolated linearly (the rest
        of the curve segments use log-log interpolation).  For better accuracy,
        choose as small a curve segment as possible wherever a sign change
        occurs.

        Two table numbers are required since values are off-diagonal terms.
        This command is valid for SPOPT,PSD only.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "QDVAL,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(tblno1), str(tblno2), str(sv1), str(sv2), str(sv3), str(sv4), str(sv5), str(sv6), str(sv7))
        return self.run(command, **kwargs)

    def append(self, lstep="", sbstep="", fact="", kimg="", time="", angle="",
               nset="", **kwargs):
        """APDL Command: APPEND

        Reads data from the results file and appends it to the database.

        Parameters
        ----------
        lstep
            Load step number of the data set to be read.  Defaults to 1.  If
            FIRST, ignore SBSTEP and TIME and read the first data set.  If
            LAST, ignore SBSTEP and TIME and read the last data set.  If NEXT,
            ignore SBSTEP and TIME and read the next data set.  If already at
            the last data set, the next set is the first data set.  If NEAR,
            ignore SBSTEP and read the data set nearest to TIME.  If TIME is
            blank, read the first data set.  If LIST, scan the results file to
            produce a summary of each load step (FACT, KIMG, TIME  and ANGLE
            are ignored).

        sbstep
            Substep number (within LSTEP) (defaults to last substep of load
            step).   For the Buckling (ANTYPE,BUCKLE) or Modal (ANTYPE,MODAL)
            analysis, the substep corresponds to the mode number (defaults to
            first mode).  If LSTEP = LIST, SBSTEP = 0 or 1 will list the basic
            load step information;  SBSTEP = 2 will also list the load step
            title, and label the imaginary data sets if they exist.

        fact
            Scale factor applied to data read from the file.  If zero (or
            blank), a value of 1.0 is used.  Harmonic velocities or
            accelerations may be calculated from the displacement results from
            a modal or harmonic (ANTYPE,HARMIC) analyses.  If FACT = VELO, the
            harmonic velocities (v) are calculated from the displacements (d)
            at a particular frequency (f) according to the relationship v =
            2 πfd.  Similarly, if FACT = ACEL, the harmonic accelerations (a)
            are calculated as a = (2 πf)2d.

        kimg
            Used only with results from complex analyses:

            0 - Store real part of complex solution.

            1 - Store imaginary part.

        time
            Time-point identifying the data set to be read.  For harmonic
            analyses, time corresponds to the frequency.  For the buckling
            analysis, time corresponds to the load factor.  Used only in the
            following cases:  If LSTEP is NEAR, read the data set nearest to
            TIME.   If both LSTEP and SBSTEP are zero (or blank), read data set
            at time = TIME.  If TIME is between two solution time points on the
            results file, a linear interpolation is done between the two data
            sets.  Solution items not written to the results file [OUTRES] for
            either data set will result in a null item after data set
            interpolation.  If TIME is beyond the last time point on the file,
            the last time point is used.

        angle
            Circumferential location (0° to 360°).  Defines the circumferential
            location for the harmonic calculations used when reading from the
            results file.  The harmonic factor (based on the circumferential
            angle) is applied to the harmonic elements (PLANE25, PLANE75,
            PLANE78, PLANE83, and SHELL61) of the load case.  See the
            Mechanical APDL Theory Reference for details.  Note that factored
            values of applied constraints and loads will overwrite any values
            existing in the database.

        nset
            Data set number of the data set to be read.  If a positive value
            for NSET is entered, LSTEP, SBSTEP, KIMG, and TIME are ignored.
            Available set numbers can be determined by APPEND,LIST.  To
            determine if data sets are real or imaginary, issue APPEND,LIST,2
            which labels imaginary data sets.

        Notes
        -----
        Reads a data set from the results file and appends it to the existing
        data in the database for the selected model only.  The existing
        database is not cleared (or overwritten in total), allowing the
        requested results data to be merged into the database.  Various
        operations may also be performed during the read operation.  The
        database must have the model geometry available (or used the RESUME
        command before the APPEND command to restore the geometry from
        File.DB).
        """
        command = "APPEND,%s,%s,%s,%s,%s,%s,%s" % (str(lstep), str(sbstep), str(fact), str(kimg), str(time), str(angle), str(nset))
        return self.run(command, **kwargs)

    def anflow(self, nfram="", delay="", ncycl="", time="", spacing="",
               size="", length="", **kwargs):
        """APDL Command: ANFLOW

        Produces an animated sequence of particle flow in a flowing fluid or a
        charged particle traveling in an electric or magnetic field.

        Parameters
        ----------
        nfram
            Number of frames captured (defaults to 5).

        delay
            Time delay during animation (defaults to 0.1 seconds).

        ncycl
            Number of animation cycles (defaults to 5).  Non-UI mode only.

        time
            Total Trace Time (seconds) (defaults to 0, which is the full flow
            trace).

        spacing
            Particle spacing in seconds (defaults to 0).

        size
            Particle size (defaults to 0, which is a line).

        length
            Particle length fraction (defaults to .1).

        Notes
        -----
        ANFLOW invokes an ANSYS macro which produces an animation of particle
        flow in a flowing fluid or charged particle motion in an electric or
        magnetic field by the last plot action command (i.e., PLTRAC).  This
        command is only operational on graphic display platforms supporting the
        /SEG command.  After executing ANFLOW, you can replay the animated
        sequence by issuing the ANIM command.  This command is functional only
        in the Postprocessor.

        The TIME option lets you set the time interval of forward travel for
        the trace.  The SPACING option is used to define the particle spacing
        in seconds from adjacent particles in the stream line.  The SIZE
        variable sets the radius of the particle.  The LENGTH variable is used
        to define the particle length fraction.  By default, the LENGTH is set
        to .1, which means the particle occupies 10% of the flow region and the
        other 90% is a color-code line.  The SPACING and LENGTH variables only
        make sense when the SIZE variable is nonzero (i.e., the particle is
        bigger than the line).
        """
        command = "ANFLOW,%s,%s,%s,%s,%s,%s,%s" % (str(nfram), str(delay), str(ncycl), str(time), str(spacing), str(size), str(length))
        return self.run(command, **kwargs)

    def pause(self, **kwargs):
        """APDL Command: PAUSE

        Temporarily releases the current product license.

        Notes
        -----
        The PAUSE command temporarily releases (or pauses) the current product
        license so that another application can use it.

        This application consumes a license as soon as you launch it, and
        retains that license until it is finished. If you launch the product
        interactively, the license is retained until you either close the
        application or issue a PAUSE command via the command line.

        No other operation (other than SAVE or /EXIT) is possible in the
        current application while use of the product license is paused.

        When the second application has finished and releases the license,
        issue an UNPAUSE command via the command line to restore use of the
        license to the current application.

        For more information, see the ANSYS, Inc. Licensing Guide.
        """
        command = "PAUSE," % ()
        return self.run(command, **kwargs)

    def psdres(self, lab="", relkey="", **kwargs):
        """APDL Command: PSDRES

        Controls solution output written to the results file from a PSD
        analysis.

        Parameters
        ----------
        lab
            Label identifying the solution output:

            DISP - Displacement solution (default).  One-sigma displacements, stresses, forces,
                   etc.  Written as load step 3 on File.RST.

            VELO - Velocity solution.  One-sigma velocities, "stress velocities," "force
                   velocities," etc.  Written as load step 4 of File.RST.

            ACEL - Acceleration solution.  One-sigma accelerations, "stress accelerations," "force
                   accelerations,” etc.  Written as load step 5 on File.RST.

        relkey
            Key defining relative or absolute calculations:

            REL - Calculations are relative to the base excitation (default).

            ABS - Calculations are absolute.

            OFF - No calculation of solution output identified by Lab.

        Notes
        -----
        Controls the amount and form of solution output written to the results
        file from a PSD analysis.  One-sigma values of the relative or absolute
        displacement solution, relative or absolute velocity solution, relative
        or absolute acceleration solution, or any combination may be included
        on the results file.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "PSDRES,%s,%s" % (str(lab), str(relkey))
        return self.run(command, **kwargs)

    def tchg(self, ename1="", ename2="", etype2="", **kwargs):
        """APDL Command: TCHG

        Converts 20-node degenerate tetrahedral elements to their 10-node non-
        degenerate counterparts.

        Parameters
        ----------
        ename1
            Name (or the number) of the 20-node tetrahedron element that you
            want to convert.  This argument is required.

        ename2
            Name (or the number) of the 10-node tetrahedron element to which
            you want to convert the ENAME  elements.  This argument is
            required.

        etype2
            Element TYPE reference number for ENAME2.  If ETYPE2 is 0 or is not
            specified, the program selects the element TYPE reference number
            for ENAME2.  See the "Notes" section for details.  This argument is
            optional.

        Notes
        -----
        The TCHG command allows you to specify conversion of any selected
        20-node brick that is degenerated into a tetrahedron to a 10-node
        tetrahedron.

        The TCHG command is useful when used in with the MOPT,PYRA command.
        Twenty-node pyramid shaped elements may be used in the same volume with
        10-node tetrahedra.

        Performing a conversion is likely to create circumstances in which more
        than one element type is defined for a single volume.

        If specified, ETYPE2 will usually be the same as the local element TYPE
        number (ET,ITYPE) that was assigned to ENAME2 with the ET command.  You
        can specify a unique number for ETYPE2 if you prefer.  Although ETYPE2
        is optional, it may be useful when two or more ITYPEs have been
        assigned to the same element (for example, if two SOLID187 elements
        have been established in the element attribute tables for the current
        model, use the ETYPE2 argument to distinguish between them).  If ETYPE2
        is nonzero and it has not already been assigned to an element via ET,
        the program assigns the ETYPE2 value to ENAME2 as its element TYPE
        reference number.

        If ETYPE2 is 0 or is not specified, the program determines the element
        TYPE reference number for ENAME2 in one of these ways:

        If ETYPE2 is 0 or is not specified, and ENAME2 does not appear in the
        element attribute tables, the program uses the next available (unused)
        location in the element attribute tables to determine the element TYPE
        reference number for ENAME2.

        If ETYPE2 is 0 or is not specified, and ENAME2 appears in the element
        attribute tables, the program uses ENAME2 's existing element TYPE
        reference number for ETYPE2 .  (If there is more than one occurrence of
        ENAME2 in the element attribute tables (each with its own TYPE
        reference number), the program uses the first ENAME2 reference number
        for ETYPE2 .)

        You cannot use element conversion if boundary conditions or loads are
        applied directly to any selected elements.

        For more information about converting degenerate tetrahedral elements,
        see Meshing Your Solid Model in the Modeling and Meshing Guide
        """
        command = "TCHG,%s,%s,%s" % (str(ename1), str(ename2), str(etype2))
        return self.run(command, **kwargs)

    def com(self, comment="", **kwargs):
        """APDL Command: /COM

        Places a comment in the output.

        Parameters
        ----------
        comment
            Comment string, up to 75 characters.

        Notes
        -----
        The output from this command consists of the comment string.  This
        command is similar to C*** except that the comment produced by C*** is
        more easily identified in the output. Parameter substitution within the
        comment occurs for every valid expression delimited by percent (%)
        signs. Enclosing such an expression in single quotes prevents parameter
        substitution.

        Another way to include a comment is to precede it with a ! character
        (on the same line).  The ! may be placed anywhere on the line, and any
        input following it is ignored as a comment.  No output is produced by
        such a comment, but the comment line is included on the log file.  This
        is a convenient way to annotate the log file.

        This command is valid anywhere.
        """
        command = "/COM,%s" % (str(comment))
        return self.run(command, **kwargs)

    def vcross(self, labxr="", labyr="", labzr="", labx1="", laby1="",
               labz1="", labx2="", laby2="", labz2="", **kwargs):
        """APDL Command: VCROSS

        Forms element table items from the cross product of two vectors.

        Parameters
        ----------
        labxr, labyr, labzr
            Label assigned to X, Y, and Z-component of resultant vector.

        labx1, laby1, labz1
            X, Y, and Z-component of first vector label.

        labx2, laby2, labz2
            X, Y, and Z-component of second vector label.

        Notes
        -----
        Forms labeled result items for the selected element from the cross
        product of two vectors:

        {LabXR, LabYR, LabZR} = {LabX1, LabY1, LabZ1} X {LabX2, LabY2, LabZ2}

        Data must be in a consistent coordinate system.  Labels are those
        associated with the ETABLE command.
        """
        command = "VCROSS,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(labxr), str(labyr), str(labzr), str(labx1), str(laby1), str(labz1), str(labx2), str(laby2), str(labz2))
        return self.run(command, **kwargs)

    def pngr(self, kywrd="", opt="", val="", **kwargs):
        """APDL Command: PNGR

        Provides PNG file export for ANSYS displays.

        Parameters
        ----------
        kywrd
            Specifies various PNG file export options.

            COMP - If Kywrd = COMP, then OPT is either ON or OFF (blank is interpreted as OFF).
                   This option allows you to turn PNG file compression ON or
                   OFF. If OPT = ON, then The VAL field is read to determine
                   the degree of compression. See the VALUE argument for
                   acceptable compression values.

            ORIENT - If Kywrd = ORIENT, then OPT will determine the orientation of the entire plot.
                     OPT can be either Horizontal (default) or Vertical.

            COLOR - If Kywrd = COLOR, then OPT will determine the color depth of the saved file.
                    OPT can be 0, 1, or 2, corresponding to Black and White,
                    Grayscale, and Color (default), respectively.

            TMOD - If Kywrd = TMOD, then OPT will determine the text method. OPT can be either 1
                   or 0, corresponding to bitmap text (default) or line stroke
                   text, respectively.

            DEFAULT - If Kywrd = DEFAULT, then all of the default values, for all of the Kywrd
                      parameters listed above, are active.

            STAT - Shows the current status of PNG file export.

        opt
            OPT can have the following names or values, depending on the value
            for Kywrd (see above).

            ON, OFF - If Kywrd = COMP, the values On and Off control the use of compression. The
                      degree of compression is determined by VAL

            Horizontal, Vertical - If Kywrd = ORIENT, the terms Horizontal or Vertical determine the orientation
                              of the plot.

            0, 1, 2 - If Kywrd = COLOR, the numbers 0, 1, and 2 correspond to Black and White,
                      Grayscale and Color, respectively.

            1, 0 - If Kywrd = TMOD, the values 1 and 0 determine whether bitmap (1) or stroke text
                   (0) fonts will be used

        val
            VAL is active only when Kywrd = COMP, and determines the degree of
            compression applied to the exported file (see above).

            1  - Apply the default, optimum value for compression. This value represents the
                 best combination of speed and compression. It varies according
                 to the release level of the ZLIB compression package.

            1-9  - Use this value to specify a specific compression level. 1 is the lowest
                   compression level (fastest) and 9 is the highest compression
                   level (slowest).
        """
        command = "PNGR,%s,%s,%s" % (str(kywrd), str(opt), str(val))
        return self.run(command, **kwargs)

    def lcwrite(self, lcno="", fname="", ext="", **kwargs):
        """APDL Command: LCWRITE

        Creates a load case by writing results to a load case file.

        Parameters
        ----------
        lcno
            Arbitrary pointer number (1-99) to be assigned to this load case.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Creates a load case by writing the results data in the database to a
        load case file.  The database remains unchanged by this operation.  A
        pointer is also established to the written set of results on the load
        case file.  This pointer (LCNO) can then be used on the LCASE or LCOPER
        commands to read the load case data into the database.  By default,
        only summable results data (such as displacements, stresses, elastic
        strains) and constant results data (such as volume) are written to the
        load case file unless requested (LCSUM command).  Non-summable results
        data (such as plastic strains, strain energy), boundary conditions, and
        nodal loads are not written to the load case file.  The load case file
        may be named by default or by a user name.  Rewriting to the same file
        overwrites the previous data.  See the LCDEF command for status and
        erase operations.
        """
        command = "LCWRITE,%s,%s,%s" % (str(lcno), str(fname), str(ext))
        return self.run(command, **kwargs)

    def vtran(self, kcnto="", nv1="", nv2="", ninc="", kinc="", noelem="",
              imove="", **kwargs):
        """APDL Command: VTRAN

        Transfers a pattern of volumes to another coordinate system.

        Parameters
        ----------
        kcnto
            Reference number of coordinate system where the pattern is to be
            transferred.  Transfer occurs from the active coordinate system.
            The coordinate system type and parameters of KCNTO must be the same
            as the active system.

        nv1, nv2, ninc
            Transfer volumes from pattern beginning with NV1 to NV2 (defaults
            to NV1) in steps of NINC (defaults to 1).  If NV1 = ALL, NV2 and
            NINC are ignored and the pattern is all selected volumes [VSEL].
            If NV1 = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI).  A component name may
            also be substituted for NV1 (NV2 and NINC are ignored).

        kinc
            Keypoint increment between sets.  If zero, the lowest available
            keypoint numbers are assigned [NUMSTR].

        noelem
            Specifies whether elements and nodes are also to be generated:

            0 - Generate nodes and elements associated with the original volumes, if they
                exist.

            1 - Do not generate nodes and elements.

        imove
            Specifies whether to redefine the existing volumes:

            0 - Generate additional volumes.

            1 - Move original volumes to new position retaining the same keypoint numbers (KINC
                and NOELEM are ignored).  Corresponding meshed items are also
                moved if not needed at their original position.

        Notes
        -----
        Transfers a pattern of volumes (and their corresponding keypoints,
        lines, areas and mesh) from one coordinate system to another (see
        analogous node transfer command, TRANSFER).  The MAT, TYPE, REAL, and
        ESYS attributes are based upon the volumes in the pattern and not upon
        the current settings.  Coordinate systems may be translated and rotated
        relative to each other.  Initial pattern may be generated in any
        coordinate system.  However, solid modeling in a toroidal coordinate
        system is not recommended.  Coordinate and slope values are interpreted
        in the active coordinate system and are transferred directly.  Volumes
        are generated as described in the VGEN command.
        """
        command = "VTRAN,%s,%s,%s,%s,%s,%s,%s" % (str(kcnto), str(nv1), str(nv2), str(ninc), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def pdcdf(self, rlab="", name="", type="", conf="", nmax="", **kwargs):
        """APDL Command: PDCDF

        Plots the cumulative distribution function.

        Parameters
        ----------
        rlab
            Result set label. Identifies the result set to be used for
            postprocessing. A result set label can be the solution set label
            you defined in a PDEXE command (if you are directly postprocessing
            Monte Carlo Simulation results), or the response surface set label
            defined in an RSFIT command (for Response Surface Analyses).

        name
            Parameter name. The parameter must have been previously defined as
            a random input variable or a random output parameter with the PDVAR
            command.

        type
            Type of cumulative distribution curve to be displayed.

            EMP - Show an empirical cumulative distribution curve.

            GAUS - Show a cumulative distribution curve in a normal distribution plot. A random
                   variable based on a normal or Gaussian distribution appears
                   as a straight line in this type of plot.

            LOGN - Show a cumulative distribution curve in a log-normal plot. A random variable
                   based on a log-normal distribution appears as a straight
                   line in this type of plot.

            WEIB - Show a cumulative distribution curve in a Weibull distribution plot. A random
                   variable based on a Weibull distribution appears as a
                   straight line in this type of plot.

        conf
            Confidence level. The confidence level is used to plot confidence
            bounds around the cumulative distribution function. The value for
            the confidence level must be between 0.0 and 1.0 and it defaults to
            0.95 (95%). Plotting of the confidence bound is suppressed for CONF
            0.5. This parameter is ignored for the postprocessing of response
            surface methods results.

        nmax
            Maximum number of points to be plotted for the distribution curve.
            This must be a positive number and it defaults to 100. If the
            sample size is less than NMAX, all sample data is represented in
            the plot. If the sample size is larger than NMAX, the probabilistic
            design system classifies the sample into NMAX classes of
            appropriate size.

        Notes
        -----
        Plots the cumulative distribution function.

        The PDCDF command cannot be used to postprocess the results in a
        solution set that is based on Response Surface Methods, only Monte
        Carlo Simulations.

        If Rlab is left blank, then the result set label is inherited from the
        last PDEXE command (Slab), RSFIT command (RSlab), or the most recently
        used PDS postprocessing command where a result set label was explicitly
        specified.
        """
        command = "PDCDF,%s,%s,%s,%s,%s" % (str(rlab), str(name), str(type), str(conf), str(nmax))
        return self.run(command, **kwargs)

    def help(self, name="", **kwargs):
        """APDL Command: HELP

        Displays help information on ANSYS commands and element types.

        Parameters
        ----------
        name
            Command name or element type. Examples are: HELP,MP or
            HELP,SOLID185 (or HELP,185).  For a list of elements of a
            particular type, enter HELP,BEAM, HELP,SOLID, HELP,HYPER, etc.

        Notes
        -----
        If Name uniquely matches a command or element name, the description for
        that command or element will be displayed in the Help Window.  For
        command help, you must type the complete command name (including the *
        or /). The help system cannot find partial matches.  If * is used at
        the beginning of the string, it will be interpreted as an ANSYS *
        command.

        For help on topics that are not ANSYS commands or element types (for
        example, help for the word "material"), use the index or full text
        search features of the ANSYS online help system.

        The HELP command is valid only in GUI mode.  To obtain help when not in
        GUI mode, you can either activate the GUI by typing /MENU,ON, or you
        can activate the help system directly by issuing /UI,HELP.

        This command is valid in any processor.
        """
        command = "HELP,%s" % (str(name))
        return self.run(command, **kwargs)

    def sys(self, string="", **kwargs):
        """APDL Command: /SYS

        Passes a command string to the operating system.

        Parameters
        ----------
        string
            Command string, up to 639 characters (including blanks, commas,
            etc.). The specified string is passed verbatim to the operating
            system, i.e., no parameter substitution is performed.

        Notes
        -----
        Passes a command string to the operating system for execution (see the
        Operations Guide).  Typical strings are system commands such as list,
        copy, rename, etc.  Control returns to the ANSYS program after the
        system procedure is completed.   ANSYS may not be aware of your
        specific user environment. For example, on Linux this command may not
        recognize aliases, depending on the hardware platform and user
        environment.

        This command is valid in any processor.
        """
        command = "/SYS,%s" % (str(string))
        return self.run(command, **kwargs)

    def slashlarc(self, xcentr="", ycentr="", xlrad="", angle1="", angle2="",
                  **kwargs):
        """APDL Command: /LARC

        Creates annotation arcs (GUI).

        Parameters
        ----------
        xcentr
            Arc X center location (-1.0 < X < 1.0).

        ycentr
            Arc Y center location (-1.0 < Y < 1.0).

        xlrad
            Arc radius length.

        angle1
            Starting angle of arc.

        angle2
            Ending angle of arc.  The arc is drawn counterclockwise from the
            starting angle, ANGLE1, to the ending angle, ANGLE2.

        Notes
        -----
        Defines annotation arcs to be written directly onto the display at a
        specified location.  This is a command generated by the Graphical User
        Interface (GUI) and will appear in the log file (Jobname.LOG) if
        annotation is used.  This command is not intended to be typed in
        directly in an ANSYS session (although it can be included in an input
        file for batch input or for use with the /INPUT command).

        All arcs are shown on subsequent displays unless the annotation is
        turned off or deleted.  Use the /LSPEC command to set the attributes of
        the arc.

        This command is valid in any processor.
        """
        command = "/LARC,%s,%s,%s,%s,%s" % (str(xcentr), str(ycentr), str(xlrad), str(angle1), str(angle2))
        return self.run(command, **kwargs)

    def directory(self, strarray="", filename="", ext="", dir="", **kwargs):
        """APDL Command: /DIRECTORY

        Put the file names in the current directory into a string parameter
        array.

        Parameters
        ----------
        strarray
            Name of the "string array" parameter which will hold the returned
            values. String array parameters are similar to character arrays,
            but each array element can be as long as 128 characters. If the
            string parameter does not exist, it will be created. The array will
            be created as: *DIM,StrArray,STRING,64,2,numFileName

        filename
            File name (64 characters maximum). Only files matching this name
            will be returned. The FileName ALL may match any file name.

        ext
            File name extension (8 characters maximum). Only files with an
            extension matching this name will be returned. A blank or ALL will
            match any extension.

        directory
            The directory in which the files reside. The default is the current
            working directory.

        Notes
        -----
        The /DIRECTORY command gets the file names in the current directory and
        puts them into a string parameter array. Each file will be included in
        the array as a name-extension pair.
        """
        command = "/DIRECTORY,%s,%s,%s,%s" % (str(strarray), str(filename), str(ext), str(dir))
        return self.run(command, **kwargs)

    def prtime(self, tmin="", tmax="", **kwargs):
        """APDL Command: PRTIME

        Defines the time range for which data are to be listed.

        Parameters
        ----------
        tmin
            Minimum time (defaults to the first point stored).

        tmax
            Maximum time (defaults to the last point stored).

        Notes
        -----
        Defines the time (or frequency) range (within the range stored) for
        which data are to be listed.
        """
        command = "PRTIME,%s,%s" % (str(tmin), str(tmax))
        return self.run(command, **kwargs)

    def frqscl(self, scaling ="", **kwargs):
        """APDL Command: FRQSCL

        Turns on automatic scaling of the entire mass matrix and frequency
        range for modal analyses using the Block Lanczos, PCG Lanczos, or
        Supernode mode extraction method.

        Parameters
        ----------
        scaling


            Off  - Do not use automatic scaling of the mass matrix and frequency range.

            On  - Use automatic scaling of the mass matrix and frequency range.

        Notes
        -----
        Use this command to deactivate or force activation of automatic scaling
        of the entire mass matrix and frequency range for modal analyses where
        the entire mass matrix is significantly different (i.e., orders of
        magnitude difference) than the entire stiffness matrix (for example,
        due to the particular unit system being used).  Where the mass matrix
        is significantly smaller compared to the stiffness matrix, the
        eigenvalues will tend to approach very large numbers (>10e12), making
        the Block Lanczos, PCG Lanczos, or Supernode mode extraction method
        less efficient and more likely to miss modes.

        ANSYS uses scaling (if appropriate) by default. However, you can issue
        FRQSCL,ON to force the entire mass matrix and frequency range to be
        scaled to bring the stiffness and mass matrices closer together in
        terms of orders of magnitude, improving efficiency and reducing the
        likelihood of missed modes.  The resulting eigenvalues are then
        automatically scaled back to the original system. If you are using
        micro MKS units, where the density is typically very small compared to
        the stiffness, you may want to issue FRQSCL,ON to force scaling on.

        If the stiffness and mass are on the same scale, FRQSCL,ON has no
        effect.

        This command is available only for modal analyses using the Block
        Lanczos, PCG Lanczos, or Supernode mode extraction method (MODOPT,LANB,
        LANPCG, or SNODE).

        This command is not valid and has no effect when used in conjunction
        with the MSAVE,ON command in a modal analysis with the PCG Lanczos mode
        extraction method.
        """
        command = "FRQSCL,%s" % (str(scaling ))
        return self.run(command, **kwargs)

    def fj(self, elem="", label="", value="", **kwargs):
        """APDL Command: FJ

        Specify forces or moments on the components of the relative motion of a
        joint element.

        Parameters
        ----------
        elem
            Element number or ALL to specify all joint elements.

        label
            Valid labels:

            FX - Force in local x direction.

            FY - Force in local y direction.

            FZ - Force in local z direction.

            MX - Moment about local x axis.

            MY - Moment about local y axis.

            MZ - Moment about local z axis.

        value
            Value of the label.

        Notes
        -----
        Valid for MPC184 (joint options in KEYOPT(1)).

        See FJDELE for information on deleting forces and moments.
        """
        command = "FJ,%s,%s,%s" % (str(elem), str(label), str(value))
        return self.run(command, **kwargs)

    def suvect(self, rsetname="", lab1="", oper="", lab2="", offset="",
               **kwargs):
        """APDL Command: SUVECT

        Create new result data by operating on two existing result vectors on a
        given surface.

        Parameters
        ----------
        rsetname
            Eight character name of the result data output. There will be one
            or three RSetName values depending on the operation specified in
            Oper.

        lab1
            Eight character name of the mapped data that forms vector 1.
            Specified sets must exist on all selected surfaces for this
            operation to take place. The names NORM and GC will be reserved for
            normals and for global (x, y, z).

        oper
            DOT

            DOT - Computes dot product between lab1 and lab2 vectors. The result is a scalar
                  parameter (RSetName) and each value within the set can be
                  modified (incremented) via Offset.

            CROSS - Computes cross product between lab1 and lab2 vectors. Each X, Y, Z value in the
                    result can be modified (incremented) via Offset.

            SMULT - Scales (lab1x, lab1y, lab1z) vector by scalar lab2. Each X,Y,Z value in the
                    result can be modified (incremented) via Offset.

        lab2
            Eight character name of the mapped data that forms vector 2. Sets
            with names Lab2X, Lab2Y, and Lab2Z must exist on all selected
            surfaces for operation to take place.  For Oper = SMULT a scalar
            value or another predefined scalar item (e.g., DA) can be supplied.

        offset
            An offset value to be applied to the resultant RSetName. One value
            is specified for Oper = DOT, and three values are specified for
            Oper = SMULT.
        """
        command = "SUVECT,%s,%s,%s,%s,%s" % (str(rsetname), str(lab1), str(oper), str(lab2), str(offset))
        return self.run(command, **kwargs)

    def lglue(self, nl1="", nl2="", nl3="", nl4="", nl5="", nl6="", nl7="",
              nl8="", nl9="", **kwargs):
        """APDL Command: LGLUE

        Generates new lines by "gluing" lines.

        Parameters
        ----------
        nl1, nl2, nl3, . . . , nl9
            Numbers of the lines to be glued.  If NL1 = ALL, all selected lines
            will be glued (NL2 to NL9 will be ignored).  If NL1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).  A component name may also be substituted
            for NL1.

        Notes
        -----
        Use of the LGLUE command generates new lines by "gluing" input lines.
        The glue operation redefines the input lines so that they share
        keypoints at their common ends.  The new lines encompass the same
        geometry as the original lines.  This operation is only valid if the
        intersections of the input lines are keypoints at the ends of those
        lines.  See the Modeling and Meshing Guide for an illustration.  See
        the BOPTN command for an explanation of the options available to
        Boolean operations.  Element attributes and solid model boundary
        conditions assigned to the original entities will not be transferred to
        the new entities generated.

        The LGLUE command results in the merging of keypoints at the common end
        of the lines. The keypoints of the lower numbered line will be kept.
        This means one must be aware of line numbering when multiple LGLUE
        commands are applied to avoid any “ungluing” of geometry.
        """
        command = "LGLUE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nl1), str(nl2), str(nl3), str(nl4), str(nl5), str(nl6), str(nl7), str(nl8), str(nl9))
        return self.run(command, **kwargs)

    def syp(self, string="", arg1="", arg2="", arg3="", arg4="", arg5="",
            arg6="", arg7="", arg8="", **kwargs):
        """APDL Command: /SYP

        Passes a command string and arguments to the operating system.

        Parameters
        ----------
        string
            Command string (cannot include commas).  See also the /SYS command.

        arg1, arg2, arg3, . . . , arg8
            Arguments to be appended to the command string, separated by
            blanks, commas, or other delimiter characters (see the Operations
            Guide).  The arguments may be numbers, parameters, or parametric
            expressions.

        Notes
        -----
        Passes a command string to the operating system for execution, along
        with arguments to be appended to the command string.  See the
        Operations Guide for details.  ANSYS may not be aware of your specific
        user environment. For example, on Linux this command may not recognize
        aliases, depending on the hardware platform and user environment.

        This command is valid in any processor.
        """
        command = "/SYP,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(string), str(arg1), str(arg2), str(arg3), str(arg4), str(arg5), str(arg6), str(arg7), str(arg8))
        return self.run(command, **kwargs)

    def prvar(self, nvar1="", nvar2="", nvar3="", nvar4="", nvar5="", nvar6="",
              **kwargs):
        """APDL Command: PRVAR

        Lists variables vs. time (or frequency).

        Parameters
        ----------
        nvar1, nvar2, nvar3, . . . , nvar6
            Variables to be displayed, defined either by the reference number
            or a unique thirty-two character name. If duplicate names are used
            the command will print the data for the lowest-numbered variable
            with that name.

        Notes
        -----
        Lists variables vs. time (or frequency).  Up to six variables may be
        listed across the line. Time column output format can be changed using
        the /FORMAT command arguments Ftype, NWIDTH, and DSIGNF.
        """
        command = "PRVAR,%s,%s,%s,%s,%s,%s" % (str(nvar1), str(nvar2), str(nvar3), str(nvar4), str(nvar5), str(nvar6))
        return self.run(command, **kwargs)

    def mfun(self, parr="", func="", par1="", **kwargs):
        """APDL Command: *MFUN

        Copies or transposes an array parameter matrix.

        Parameters
        ----------
        parr
            The name of the resulting array parameter matrix.  See *SET for
            name restrictions.

        func
            Copy or transpose function:

            Par1 is copied to ParR - Par1 is transposed to ParR.  Rows (m) and columns (n) of Par1 matrix are
                              transposed to resulting ParR matrix of shape
                              (n,m).

        par1
            Array parameter matrix input to the operation.

        Notes
        -----
        Operates on one input array parameter matrix and produces one output
        array parameter matrix according to:

        ParR = f(Par1)

        where the function (f) is either a copy or transpose, as described
        above.

        Functions are based on the standard FORTRAN definitions where possible.
        ParR may be the same as Par1.  Starting array element numbers must be
        defined for each array parameter matrix if it does not start at the
        first location. For example, *MFUN,A(1,5),COPY,B(2,3) copies matrix B
        (starting at element (2,3)) to matrix A (starting at element (1,5)).
        The diagonal corner elements for each submatrix must be defined: the
        upper left corner by the array starting element (on this command), the
        lower right corner by the current values from the *VCOL and *VLEN
        commands.  The default values are the (1,1) element and the last
        element in the matrix.  No operations progress across matrix planes (in
        the 3rd dimension).  Absolute values and scale factors may be applied
        to all parameters [*VABS, *VFACT].  Results may be cumulative [*VCUM].
        Array elements should not be skipped with the *VMASK and the NINC value
        of the *VLEN specifications.  The number of rows [*VLEN] applies to the
        Par1 array.  See the *VOPER command for details.

        This command is valid in any processor.
        """
        command = "*MFUN,%s,%s,%s" % (str(parr), str(func), str(par1))
        return self.run(command, **kwargs)

    def stat(self, **kwargs):
        """APDL Command: STAT

        Displays the status of database settings.

        Notes
        -----
        In the DISPLAY program, STAT will show the current status of the
        program settings.

        In the ANSYS program, STAT is a command generated by the GUI and will
        appear in the log file (Jobname.LOG) if status is requested for some
        items under Utility Menu> List> Status.  Generally, STAT will be
        preceded by one of the commands listed below, which specifies the
        particular topic that status was requested for.

        If entered directly into the program, the STAT command should be
        immediately preceded by the desired topic command listed below.  In
        processors other than those listed below (e.g., AUX12), no topic
        command should proceed STAT.

        This command is valid in any processor.

        PREP7 topic commands (and their corresponding topics) are:

        SOLUTION topic commands (and their corresponding topics) are:

        POST1 topic commands (and their corresponding topics) are:

        POST26 topic commands (and their corresponding topics) are:
        """
        command = "STAT," % ()
        return self.run(command, **kwargs)

    def copy(self, fname1="", ext1="", fname2="", ext2="", distkey="",
             **kwargs):
        """APDL Command: /COPY

        Copies a file.

        Parameters
        ----------
        fname1
            File name to be copied and its directory path (248 characters
            maximum for both file name and directory). If you do not specify a
            directory path, it will default to your working directory and you
            can use all 248 characters for the file name.

        ext1
            Filename extension (eight-character maximum).

        --
            Unused field.

        fname2
            File name to be created and its directory path (248 characters
            maximum for both file name and directory). If you do not specify a
            directory path, it will default to your working directory and you
            can use all 248 characters for the file name.

        ext2
            Filename extension (eight-character maximum).

        --
            Unused field.

        distkey
            Key that specifies whether the copy operation is performed on all
            processes in distributed parallel mode (Distributed ANSYS):

            1 (ON or YES) - The program performs the copy operation locally on each process.

            0 (OFF or NO) - The program performs the copy operation only on the master process (default).

        Notes
        -----
        The original file is untouched.  Ex:  /COPY,A,,,B copies file A to B in
        the same directory.  /COPY,A,DAT,,,INP copies the file A.DAT to A.INP.
        See the Operations Guide for details.  ANSYS binary and ASCII files can
        be copied.

        In distributed parallel mode (Distributed ANSYS), only the master
        process will copy Fname1.Ext1 to Fname2.Ext2 by default. However, when
        DistKey is set to 1 (or ON or YES), the command is executed by all
        processes. In this case, Fname1 and Fname2 will automatically have the
        process rank appended to them. This means Fname1N.Ext1 will be copied
        to Fname2N.Ext2 by all processes, where N is the Distributed ANSYS
        process rank.  For more information see Differences in General Behavior
        in the Parallel Processing Guide.
        """
        command = "/COPY,%s,%s,%s,%s,%s" % (str(fname1), str(ext1), str(fname2), str(ext2), str(distkey))
        return self.run(command, **kwargs)

    def lsrestore(self, enginename="", filename="", **kwargs):
        """APDL Command: *LSRESTORE

        Restores a linear solver engine from a binary file.

        Parameters
        ----------
        enginename
            Name used to identify this engine.

        filename
            Name of the file to read from.

        Notes
        -----
        Restores a previously dumped Linear Solver (see the *LSDUMP command).
        This Linear Solver can be used to solve a linear system using the
        *LSBAC command.
        """
        command = "*LSRESTORE,%s,%s" % (str(enginename), str(filename))
        return self.run(command, **kwargs)

    def kmesh(self, np1="", np2="", ninc="", **kwargs):
        """APDL Command: KMESH

        Generates nodes and point elements at keypoints.

        Parameters
        ----------
        np1, np2, ninc
            Mesh keypoints from NP1 to NP2 (defaults to NP1) in steps of NINC
            (defaults to 1).  If NP1 = ALL, NP2 and NINC are ignored and all
            selected keypoints [KSEL] are meshed.  If NP1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).  A component name may also be substituted
            for NP1.

        Notes
        -----
        Missing nodes required for the generated elements are created and
        assigned the lowest available numbers.
        """
        command = "KMESH,%s,%s,%s" % (str(np1), str(np2), str(ninc))
        return self.run(command, **kwargs)

    def transfer(self, kcnto="", inc="", node1="", node2="", ninc="",
                 **kwargs):
        """APDL Command: TRANSFER

        Transfers a pattern of nodes to another coordinate system.

        Parameters
        ----------
        kcnto
            Reference number of coordinate system where the pattern is to be
            transferred.  Transfer occurs from the active coordinate system.

        inc
            Increment all nodes in the given pattern by INC to form the
            transferred node pattern.

        node1, node2, ninc
            Transfer nodes from pattern beginning with NODE1 to NODE2 (defaults
            to NODE1) in steps of NINC (defaults to 1).  If NODE1 = ALL, NODE2
            and NINC are ignored and the pattern is all selected nodes [NSEL].
            If NODE1 = P, graphical picking is enabled and all remaining
            command fields are ignored (valid only in the GUI).  A component
            may be substituted for NODE1 (NODE2 and NINC are ignored).

        Notes
        -----
        Transfers a pattern of nodes from one coordinate system to another.
        Coordinate systems may be translated and rotated relative to each
        other.  Initial pattern may be generated in any coordinate system.
        Coordinate values are interpreted in the active coordinate system and
        are transferred directly.

        A model generated in one coordinate system may be transferred to
        another coordinate system.  The user may define several coordinate
        systems (translated and rotated from each other), generate a model in
        one coordinate system, and then repeatedly transfer the model to other
        coordinate systems.  The model may be generated in any type of
        coordinate system (Cartesian, cylindrical, etc.) and transferred to any
        other type of coordinate system.  Coordinate values (X, Y, Z, or R,: θ,
        Z, or etc.) of the model being transferred are interpreted in the
        active coordinate system type, regardless of how they were generated.
        Values are transferred directly and are interpreted according to the
        type of coordinate system being transferred to.  For example,
        transferring from a Cartesian coordinate system to a cylindrical
        coordinate system (not recommended) would cause X = 2.0 and Y = 3.0
        values to be directly interpreted as R = 2.0 and θ = 3.0 values,
        respectively.

        This command is also valid in the /MAP processor.
        """
        command = "TRANSFER,%s,%s,%s,%s,%s" % (str(kcnto), str(inc), str(node1), str(node2), str(ninc))
        return self.run(command, **kwargs)

    def afsurf(self, sarea="", tline="", **kwargs):
        """APDL Command: AFSURF

        Generates surface elements overlaid on the surface of existing solid
        elements and assigns the extra node as the closest fluid element node.

        Parameters
        ----------
        sarea
            Component name for the surface areas of the meshed solid volumes.

        tline
            Component name for the target lines meshed with fluid elements.

        Notes
        -----
        This command macro is used to generate surface effect elements overlaid
        on the surface of existing  solid elements and, based on proximity, to
        determine and assign the extra node for each surface element.  The
        underlying volumes of the solid region and the fluid lines must be
        meshed prior to calling this command macro. The active element type
        must be SURF152 with appropriate settings for KEYOPT(4), KEYOPT(5),
        KEYOPT(6), and KEYOPT(8).

        The surface areas of the solid and the target lines of the fluid are
        grouped into components and named using the CM command.  The names must
        be enclosed in single quotes (e.g., 'SAREA') when the AFSURF command is
        manually typed in.

        When using the GUI method, node and element components are created
        through the picking dialog boxes associated with this command.

        The macro is applicable for the SURF152 and FLUID116 element types.
        """
        command = "AFSURF,%s,%s" % (str(sarea), str(tline))
        return self.run(command, **kwargs)

    def wstart(self, node1="", node2="", ninc="", itime="", inc="", **kwargs):
        """APDL Command: WSTART

        Defines a starting wave list.

        Parameters
        ----------
        node1, node2, ninc
            Define a set of nodes in the starting wave list from NODE1 to NODE2
            (defaults to NODE1) in steps of NINC (defaults to 1).  If NODE1 =
            ALL, ignore remaining fields and use all selected nodes [NSEL].

        itime, inc
            Add more node sets to the same starting wave list by repeating the
            previous node set with NODE1 and NODE2 incremented by INC (defaults
            to 1) each time after the first.  ITIME is the total number of sets
            (defaults to 1) defined with this command.

        Notes
        -----
        Defines a starting wave list (optional) for reordering with the WAVES
        command.  Repeat WSTART command to define other starting wave lists (20
        maximum).

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "WSTART,%s,%s,%s,%s,%s" % (str(node1), str(node2), str(ninc), str(itime), str(inc))
        return self.run(command, **kwargs)

    def bfdele(self, node="", lab="", **kwargs):
        """APDL Command: BFDELE

        Deletes nodal body force loads.

        Parameters
        ----------
        node
            Node at which body load is to be deleted.  If ALL, delete for all
            selected nodes [NSEL].  If NODE = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).  A component name may also be substituted for NODE.

        lab
            Valid body load label. If ALL, use all appropriate labels. See the
            BF command for labels. In an explicit dynamic analysis, the only
            valid body load label is TEMP.

        Notes
        -----
        Deletes nodal body force loads for a specified node and label.  Nodal
        body loads may be defined with the BF command (except in an explicit
        dynamic analysis).

        The command BFDELE,TEMP can be used in an explicit dynamic analysis to
        delete temperature loads that are read in by the LDREAD command. BFDELE
        cannot be used to delete temperature loads defined by the EDLOAD
        command (use EDLOAD,DELE to delete this type of load).

        This command is also valid in PREP7.
        """
        command = "BFDELE,%s,%s" % (str(node), str(lab))
        return self.run(command, **kwargs)

    def input(self, fname="", ext="", dir="", line="", log="", **kwargs):
        """APDL Command: /INPUT

        Switches the input file for the commands that follow.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        dir
            Directory path (64 characters maximum). Defaults to current
            directory.

        line
            A value indicating either a line number in the file or a user-
            defined label in the file from which to begin reading the input
            file.

            (blank), 0, or 1 - Begins reading from the top of the file (default).

            LINE_NUMBER - Begins reading from the specified line number in the file.

            :label - Begins reading from the first line beginning with the matching user-defined
                     label :label (beginning with a colon (:), 8 characters
                     maximum).

        log
            Indicates whether secondary input from this command should be
            recorded in the command log (File.LOG) and the database log:

            0 - Record only the /INPUT command on the log (default).

            1 - Record commands in the specified secondary file as they are executed.

        Notes
        -----
        Switches the input file for the next commands.  Commands are read from
        this file until an end-of-file or another file switching directive is
        read.  An end-of-file occurs after the last record of the file or when
        a /EOF command is read.  An automatic switch back one level (to the
        previous file) occurs when an end-of-file is encountered.  Twenty
        levels of nested file switching are allowed.  Note that files including
        *DO, *USE, *ULIB, and the "Unknown Command" Macro have less nesting
        available because each of these operations also uses a level of file
        switching.  For an interactive run, a /INPUT,TERM switches to the
        terminal for the next input.  A /EOF read from the terminal then
        switches back to the previous file.  A /INPUT (with a blank second
        field) switches back to the primary input file.

        Setting LOG = 1 on /INPUT causes all commands read from the specified
        file to be recorded in the command log (File.LOG) and the internal
        database command log [LGWRITE].  This option is recommended if the log
        file will be used later .  The LOG = 1 option is only valid when the
        /INPUT occurs in the primary input file.  Using LOG = 1 on a nested
        /INPUT or on a /INPUT within a do-loop will have no effect (i.e.,
        commands in the secondary input file are not written to the command
        log).

        The Dir option is optional as the directory path can be included
        directly in Fname.

        This command is valid in any processor.
        """
        command = "/INPUT,%s,%s,%s,%s,%s" % (str(fname), str(ext), str(dir), str(line), str(log))
        return self.run(command, **kwargs)

    def edge(self, wn="", key="", angle="", **kwargs):
        """APDL Command: /EDGE

        Displays only the common lines (“edges”) of an object.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies. The default window
            is 1.

        key
            Edge key:

            0 - Display common lines between all adjacent element faces.

            1 - Display only the common lines between non-coplanar faces (that is, show only
                the edges).

        angle
            Largest angle between two faces for which the faces are considered
            to be coplanar (0° to 180°). Defaults to 45°. A smaller angle
            produces more edges, a larger angle produces fewer edges.

        Notes
        -----
        The ANGLE field is used in PowerGraphics to determine geometric
        discontinuities. It is a tolerance measure for the differences between
        the normals of the surfaces being considered. Values within the
        tolerance are accepted as coplanar (geometrically continuous). In
        postprocessing displays, results are not averaged across discontinuous
        surfaces.

        A surface can be displayed as an edge outline without interior detail.
        This is useful for both geometry and postprocessing displays. Element
        outlines are normally shown as solid lines for geometry and
        displacement displays. Lines common to adjacent "coplanar" element
        faces are removed from the display.  Midside nodes of elements are
        ignored.

        The /SHRINK option is ignored with the edge option.

        /EDGE is not supported for PLESOL and /ESHAPE displays when in
        PowerGraphics mode (/GRAPHICS,POWER).

        The /EDGE command is valid in any processor.
        """
        command = "/EDGE,%s,%s,%s" % (str(wn), str(key), str(angle))
        return self.run(command, **kwargs)

    def spec(self, **kwargs):
        """APDL Command: SPEC

        Specifies "Miscellaneous specifications" as the subsequent status
        topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "SPEC," % ()
        return self.run(command, **kwargs)

    def ematwrite(self, key="", **kwargs):
        """APDL Command: EMATWRITE

        Forces the writing of all the element matrices to File.EMAT.

        Parameters
        ----------
        key
            Write key:

            YES - Forces the writing of the element matrices to File.EMAT even if not normally
                  done.

            NO - Element matrices are written only if required. This value is the default.

        Notes
        -----
        The EMATWRITE command forces ANSYS to write the File.EMAT file. The
        file is necessary if you intend to follow the initial load step with a
        subsequent inertia relief calculation (IRLF). If used in the solution
        processor (/SOLU), this command is only valid within the first load
        step.

        This command is also valid in PREP7.
        """
        command = "EMATWRITE,%s" % (str(key))
        return self.run(command, **kwargs)

    def mfexter(self, fnumb1="", fnumb2="", fnumb3="", fnumb4="", fnumb5="",
                fnumb6="", fnumb7="", fnumb8="", fnumb9="", fnumb10="",
                fnumb11="", fnumb12="", fnumb13="", fnumb14="", fnumb15="",
                fnumb16="", fnumb17="", fnumb18="", fnumb19="", fnumb20="",
                **kwargs):
        """APDL Command: MFEXTER

        Defines external fields for an ANSYS Multi-field solver analysis.

        Parameters
        ----------
        fnumb1, fnumb2, fnumb3, . . . , fnumb20
            External field numbers defined by the MFELEM command.

        Notes
        -----
        This command specifies external field numbers to be used for load
        transfer in an ANSYS Multi-field solver analysis. Use the MFIMPORT
        command to import the external fields.

        Use the MFELEM command to specify external field numbers. Use the
        MFORDER command to specify the solution order for the external fields.

        You can define a maximum of 20 fields.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFEXTER,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(fnumb1), str(fnumb2), str(fnumb3), str(fnumb4), str(fnumb5), str(fnumb6), str(fnumb7), str(fnumb8), str(fnumb9), str(fnumb10), str(fnumb11), str(fnumb12), str(fnumb13), str(fnumb14), str(fnumb15), str(fnumb16), str(fnumb17), str(fnumb18), str(fnumb19), str(fnumb20))
        return self.run(command, **kwargs)

    def enersol(self, nvar="", item="", name="", **kwargs):
        """APDL Command: ENERSOL

        Specifies the total energies to be stored.

        Parameters
        ----------
        nvar
            Arbitrary reference number assigned to this variable (2 to NV).
        """
        command = "ENERSOL,%s,%s,%s" % (str(nvar), str(item), str(name))
        return self.run(command, **kwargs)

    def dvmorph(self, volu="", xarea="", rmshky="", **kwargs):
        """APDL Command: DVMORPH

        Move nodes in selected volumes to conform to structural displacements.

        Parameters
        ----------
        volu
            Non-structural volume to which mesh movement (morph) applies.  If
            ALL, apply morphing to all selected volumes [VSEL]. If VOLU  = P,
            graphical picking is enabled. A component may be substituted for
            VOLU.

        xarea
            Areas to be excluded from morphing. If ALL, exclude all selected
            areas [ASEL].  If XAREA = P, graphical picking is enabled. A
            component may be substituted for XAREA. If XAREA is blank
            (default), allow morphing of nodes attached to areas of the
            selected volumes (VOLU) which are not shared by unselected volumes.
            (See Notes for clarification).

        rmshky
            Remesh flag option:

            0 - Remesh the selected non-structural volumes only if mesh morphing fails.

            1 - Remesh the selected non-structural volumes and bypass mesh morphing.

            2 - Perform mesh morphing only and do not remesh.

        Notes
        -----
        The selected volumes should include only non-structural regions
        adjacent to structural regions. DVMORPH will morph the non-structural
        volumes to coincide with the deflections of the structural regions.

        Nodes in the structural regions move in accordance with computed
        displacements. Displacements from a structural analysis must be in the
        database prior to issuing DVMORPH.

        By default, nodes attached to areas can move along the areas. You can
        use XAREA to restrain nodes on certain areas.

        By default (RMSHKY = 0), DVMORPH will remesh the selected non-
        structural volumes entirely if a satisfactory morphed mesh cannot be
        provided.

        If boundary conditions and loads are applied directly to nodes and
        elements, the DVMORPH command requires that these be removed before
        remeshing can take place.

        Exercise care with initial conditions defined by the IC command. Before
        a structural analysis is performed for a sequentially coupled analysis,
        the DVMORPH command requires that initial conditions be removed from
        all null element type nodes in the non-structural regions. Use ICDELE
        to delete the initial conditions.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "DVMORPH,%s,%s,%s" % (str(volu), str(xarea), str(rmshky))
        return self.run(command, **kwargs)

    def da(self, area="", lab="", value1="", value2="", **kwargs):
        """APDL Command: DA

        Defines degree-of-freedom constraints on areas.

        Parameters
        ----------
        area
            Area on which constraints are to be specified.  If ALL, apply to
            all selected areas [ASEL].  If AREA = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for AREA.

        lab
            Symmetry label (see 2 below):

            SYMM - Generate symmetry constraints. Requires no Value1 or Value2.

            ASYM - Generate antisymmetry constraints. Requires no Value1 or Value2.

        value1
            Value of DOF or table name reference on the area.  Valid for all
            DOF labels.  To specify a table, enclose the table name in % signs
            (e.g., DA,AREA,TEMP,%tabname%).  Use the *DIM command to define a
            table.

        value2
            For MAG and VOLT DOFs:

        Notes
        -----
        For elements SOLID236 and SOLID237, if Lab = AZ and Value1 = 0, this
        sets the flux-parallel condition for the edge formulation.  (A flux-
        normal condition is the natural boundary condition.)  Do not use the DA
        command to set the edge-flux DOF, AZ to a nonzero value.

        If Lab = MAG and Value1 = 0, this sets the flux-normal condition for
        the magnetic scalar potential formulations (MSP) (A flux-parallel
        condition is the natural boundary condition for MSP.)

        If Lab = VOLT and Value1 = 0, the J-normal condition is set (current
        density (J) flow normal to the area). (A J-parallel condition is the
        natural boundary condition.)

        You can transfer constraints from areas to nodes with the DTRAN or
        SBCTRAN commands.  See the DK command for information about generating
        other constraints on areas.

        Symmetry and antisymmetry constraints are generated as described for
        the DSYM command.

        Tabular boundary conditions (VALUE = %tabname%) are available only for
        the following degree of freedom labels: Electric (VOLT), Structural
        (UX, UY, UZ, ROTX, ROTY, ROTZ), Acoustic (PRES, UX, UY, UZ), and
        temperature (TEMP, TBOT, TE2, TE3, . . ., TTOP).

        Constraints specified by the DA command can conflict with other
        specified constraints.  See Resolution of Conflicting Constraint
        Specifications in the Basic Analysis Guide for details.

        The DA command is also valid in PREP7.
        """
        command = "DA,%s,%s,%s,%s" % (str(area), str(lab), str(value1), str(value2))
        return self.run(command, **kwargs)

    def rpsd(self, ir="", ia="", ib="", itype="", datum="", name="", signif="",
             **kwargs):
        """APDL Command: RPSD

        Calculates response power spectral density (PSD).

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previous
            variable, the previous variable will be overwritten with this
            result.

        ia, ib
            Reference numbers of the two variables to be operated on.  If only
            one, leave IB blank.

        itype
            Defines the type of response PSD to be calculated:

            0,1 - Displacement (default).

            2 - Velocity.

            3 - Acceleration.

        datum
            Defines the reference with respect to which response PSD is to be
            calculated:

            1 - Absolute value.

            2 - Relative to base (default).

        name
            Thirty-two character name identifying variable on listings and
            displays.  Embedded blanks are compressed for output.

        signif
            Combine only those modes whose significance level exceeds the
            SIGNIF threshold. The significance level is defined as the modal
            covariance matrix term divided by the maximum of all the modal
            covariance matrix terms. Any term whose significance level is less
            than SIGNIF is considered insignificant and does not contribute to
            the response. All modes are taken into account by default (SIGNIF =
            0.0).

        Notes
        -----
        This command calculates response power spectral density (PSD) for the
        variables referenced by the reference numbers IA and IB.  The variable
        referred by IR will contain the response PSD.  You must issue the
        STORE,PSD command first; File.PSD must be available for the
        calculations to occur.

        See POST26 - Response Power Spectral Density in the Mechanical APDL
        Theory Reference for more information on these equations.
        """
        command = "RPSD,%s,%s,%s,%s,%s,%s,%s" % (str(ir), str(ia), str(ib), str(itype), str(datum), str(name), str(signif))
        return self.run(command, **kwargs)

    def starvplot(self, parx="", pary="", y2="", y3="", y4="", y5="", y6="",
                  y7="", y8="", **kwargs):
        """APDL Command: *VPLOT

        Graphs columns (vectors) of array parameters.

        Parameters
        ----------
        parx
            Name of the array parameter whose column vector values will be the
            abscissa of the graph.  If blank, row subscript numbers are used
            instead.  ParX is not sorted by the program.

        pary
            Name of the array parameter whose column vector values will be
            graphed against the ParX values.

        y2, y3, y4, . . . , y8
            Additional column subscript of the ParY array parameter whose
            values are to be graphed against the ParX values.

        Notes
        -----
        The column to be graphed and the starting row for each array parameter
        must be specified as subscripts.  Additional columns of the ParY array
        parameter may be graphed by specifying column numbers for Y2,  Y3,
        ...,Y8.  For example, *VPLOT,TIME (4,6), DISP (8,1),2,3 specifies that
        the 1st, 2nd, and 3rd columns of array parameter DISP (all starting at
        row 8) are to be graphed against the 6th column of array parameter TIME
        (starting at row 4).  The columns are graphed from the starting row to
        their maximum extent.  See the *VLEN and  *VMASK commands to limit or
        skip data to be graphed.  The array parameters specified on the *VPLOT
        command must be of the same type (type ARRAY or TABLE; [*DIM].   Arrays
        of type TABLE are graphed as continuous curves.  Arrays of type ARRAY
        is displayed in bar chart fashion.

        The normal curve labeling scheme for *VPLOT is to label curve 1 “COL
        1”, curve 2 “COL 2” and so on. You can use the /GCOLUMN command to
        apply user-specified labels (8 characters maximum) to your curves. See
        Modifying Curve Labels in the ANSYS Parametric Design Language Guide
        for more information on using /GCOLUMN.

        When a graph plot reaches minimum or maximum y-axis limits, the program
        indicates the condition by clipping the graph. The clip appears as a
        horizontal magenta line. Mechanical APDL calculates y-axis limits
        automatically; however, you can modify the (YMIN and YMAX) limits via
        the /YRANGE command.

        This command is valid in any processor.
        """
        command = "*VPLOT,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(parx), str(pary), str(y2), str(y3), str(y4), str(y5), str(y6), str(y7), str(y8))
        return self.run(command, **kwargs)

    def edbound(self, option="", lab="", cname="", xc="", yc="", zc="",
                cname2="", copt="", **kwargs):
        """APDL Command: EDBOUND

        Defines a boundary plane for sliding or cyclic symmetry.

        Parameters
        ----------
        option
            Label identifying the symmetry plane option to be performed.

            ADD - Define a sliding or cyclic symmetry plane.

            DELE - Delete a specified sliding or cyclic symmetry plane.

            LIST - List defined sliding or cyclic symmetry planes.

        lab
            Valid boundary options for defining a symmetry plane. A valid label
            must always be specified for adding, deleting, or listing boundary
            planes.

            SLIDE - Sliding symmetry plane.

            CYCL - Cyclic symmetry plane.

        cname
            Name of existing component [CM] to which boundary symmetry is to be
            applied or deleted. Component must consist of nodes. For Option =
            LIST, a component is not required because all defined symmetry
            planes are listed for the specified Lab.  For Option = DELE, use
            Cname = ALL to delete all symmetry planes currently defined for the
            specified Lab.

        xc, yc, zc
            X, Y, and Z coordinates of the head of the vector defining normal
            (Lab = SLIDE) or axis of rotation (Lab = CYCL). The tail of the
            vector is at the global origin.

        cname2
            Name of existing nodal component [CM] for which second cyclic
            boundary plane is to be applied. Each node in Cname2 component is
            constrained to a corresponding node in the first component set.
            Therefore, component Cname2 must have the same number of nodes as
            the Cname component. Cname2 is valid only for Lab = CYCL.

        copt
            Specified constraint option for sliding plane symmetry. COPT is
            valid only for Lab = SLIDE. Valid COPT options are:

            0 - Nodes move on normal plane (default).

            1 - Nodes move only in vector direction.

        Notes
        -----
        For cyclic symmetry, the node numbers in component Cname2 must differ
        from the node numbers in Cname by a constant offset value. In addition,
        the nodes in Cname2 must have locations which, if given in cylindrical
        coordinates, all differ by the same angle from the nodes in Cname. The
        following figure shows how you would define components for a cyclic
        symmetry plane.

        This command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDBOUND,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(lab), str(cname), str(xc), str(yc), str(zc), str(cname2), str(copt))
        return self.run(command, **kwargs)

    def nooffset(self, label="", **kwargs):
        """APDL Command: NOOFFSET

        Prevents the CDREAD command from offsetting specified data items

        Parameters
        ----------
        label
            Specifies items not to be offset.

            NODE - Node numbers

            ELEM - Element numbers

            KP - Keypoint numbers

            LINE - Line numbers

            AREA - Area numbers

            VOLU - Volume numbers

            MAT - Material numbers

            TYPE - Element type numbers

            REAL - Real constant numbers

            CSYS - Coordinate system numbers

            SECN - Section numbers

            CP - Coupled set numbers

            CE - Constraint equation numbers

            CLEAR - All items will be offset

            STATUS - Shows which items are specified notto be offset.

        Notes
        -----
         The NOOFFSET command specifies data items not to be offset by a set of
        data read from a CDREAD command.
        """
        command = "NOOFFSET,%s" % (str(label))
        return self.run(command, **kwargs)

    def cplgen(self, nsetf="", lab1="", lab2="", lab3="", lab4="", lab5="",
               **kwargs):
        """APDL Command: CPLGEN

        Generates sets of coupled nodes from an existing set.

        Parameters
        ----------
        nsetf
            Generate sets from existing set NSETF.

        lab1, lab2, lab3, . . . , lab5
            Generate sets with these labels (see CP command for valid labels).
            Sets are numbered as the highest existing set number + 1.

        Notes
        -----
        Generates additional sets of coupled nodes (with different labels) from
        an existing set [CP, CPNGEN].  The same node numbers are included in
        the generated sets.  If all labels of nodes are to be coupled and the
        nodes are coincident, the NUMMRG command should be used to
        automatically redefine the node number (for efficiency).
        """
        command = "CPLGEN,%s,%s,%s,%s,%s,%s" % (str(nsetf), str(lab1), str(lab2), str(lab3), str(lab4), str(lab5))
        return self.run(command, **kwargs)

    def lccat(self, nl1="", nl2="", **kwargs):
        """APDL Command: LCCAT

        Concatenates multiple lines into one line for mapped meshing.

        Parameters
        ----------
        nl1, nl2
            Lines to be concatenated.  If NL1 = ALL, NL2 is ignored and all
            selected lines [LSEL] are concatenated.  If NL1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).  A component name may also be substituted
            for NL1 (NL2 is ignored).

        Notes
        -----
        Concatenates multiple, adjacent lines (the input lines) into one line
        (the output line) in preparation for mapped meshing.  An area that
        contains too many lines for mapped meshing can still be mapped meshed
        if some of the lines in that area are first concatenated (see Meshing
        Your Solid Model in the Modeling and Meshing Guide for details on
        mapped meshing restrictions).

        LCCAT is meant to be used solely for meshing and cannot be used for any
        other purposes.  Specifically, (a) the output line and any areas that
        have the output line on their line list [ALIST] cannot be used as input
        to any other solid modeling operation (not even another LCCAT command);
        and (b) the output line cannot accept solid model boundary conditions
        [DL, SFL].

        The output line will take on the element divisions of the input lines
        and will not accept element divisions that are directly assigned
        [LESIZE].  The output line from the LCCAT operation will be coincident
        with the input lines and the input lines will be retained.  Consider
        the LCOMB command instead of LCCAT if you wish to delete the input
        lines and if the lines to be combined have similar slopes at the common
        keypoint(s).  When an LCCAT command is issued, area line lists [ALIST]
        that contain all of the input lines will be updated so that the area
        line lists refer to the output line instead of the input lines.
        Deletion of the output line [LDELE] effectively reverses the LCCAT
        operation and restores area line lists to their original condition.

        You can use the LSEL command to select lines that were created by
        concatenation, and then follow it with an LDELE,ALL command to delete
        them.  Also see Meshing Your Solid Model in the Modeling and Meshing
        Guide for a discussion on how to easily select and delete concatenated
        lines in one step.
        """
        command = "LCCAT,%s,%s" % (str(nl1), str(nl2))
        return self.run(command, **kwargs)

    def en(self, iel="", i="", j="", k="", l="", m="", n="", o="", p="",
           **kwargs):
        """APDL Command: EN

        Defines an element by its number and node connectivity.

        Parameters
        ----------
        iel
            Number assigned to element being defined. If IEL = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).

        i
            Number of node assigned to first nodal position (node I).

        j, k, l, m, n, o, p
            Number assigned to second (node J) through eighth (node P) nodal
            position, if any.

        Notes
        -----
        Defines an element by its nodes and attribute values. Similar to the E
        command except it allows the element number (IEL) to be defined
        explicitly.  Element numbers need not be consecutive. Any existing
        element already having this number will be redefined.

        Up to 8 nodes may be specified with the EN command. If more nodes are
        needed for the element, use the EMORE command. The number of nodes
        required and the order in which they should be specified are described
        in the Element Reference for each element type.  The current (or
        default) MAT, TYPE, REAL, SECNUM, and ESYS attribute values are also
        assigned to the element.

        When creating elements with more than 8 nodes using this command and
        the EMORE command, it may be necessary to turn off shape checking using
        the SHPP command before issuing this command. If a valid element type
        can be created without using the additional nodes on the EMORE command,
        this command will create that element. The EMORE command will then
        modify the element to include the additional nodes. If shape checking
        is active, it will be performed before the EMORE command is issued.
        Therefore, if the shape checking limits are exceeded, element creation
        may fail before the EMORE command modifies the element into an
        acceptable shape.
        """
        command = "EN,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(iel), str(i), str(j), str(k), str(l), str(m), str(n), str(o), str(p))
        return self.run(command, **kwargs)

    def vcum(self, key="", **kwargs):
        """APDL Command: *VCUM

        Allows array parameter results to add to existing results.

        Parameters
        ----------
        key
            Accumulation key:

            Overwrite results. - Add results to the current value of the results parameter.

        Notes
        -----
        Allows results from certain *VXX and *MXX operations to overwrite or
        add to existing results.  The cumulative operation is of the form:

        ParR = ParR + ParR(Previous)

        The cumulative setting is reset to the default (overwrite) after each
        *VXX or *MXX operation.  Use *VSTAT to list settings.

        This command is valid in any processor.
        """
        command = "*VCUM,%s" % (str(key))
        return self.run(command, **kwargs)

    def vptn(self, nv1="", nv2="", nv3="", nv4="", nv5="", nv6="", nv7="",
             nv8="", nv9="", **kwargs):
        """APDL Command: VPTN

        Partitions volumes.

        Parameters
        ----------
        nv1, nv2, nv3, . . . , nv9
            Numbers of volumes to be operated on.  If NV1 = ALL, NV2 to NV9 are
            ignored and all selected volumes are used.  If NV1  = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).  A component name may also be substituted
            for NV1.

        Notes
        -----
        Partitions volumes.  Generates new volumes which encompass the geometry
        of all the input volumes.  The new volumes are defined by the regions
        of intersection of the input volumes, and by the complementary (non-
        intersecting) regions.  See the Modeling and Meshing Guide for an
        illustration. See the BOPTN command for an explanation of the options
        available to Boolean operations.  Element attributes and solid model
        boundary conditions assigned to the original entities will not be
        transferred to the new entities generated.
        """
        command = "VPTN,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nv1), str(nv2), str(nv3), str(nv4), str(nv5), str(nv6), str(nv7), str(nv8), str(nv9))
        return self.run(command, **kwargs)

    def expsol(self, lstep="", sbstep="", timfrq="", elcalc="", **kwargs):
        """APDL Command: EXPSOL

        Specifies the solution to be expanded for mode-superposition analyses
        or substructure analyses.

        Parameters
        ----------
        lstep, sbstep
            Expand the solution identified as load step LSTEP and substep
            SBSTEP.

        timfrq
            As an alternative to LSTEP and SBSTEP, expand the solution at, or
            nearest to, the time value TIMFRQ (for ANTYPE,TRANS or
            ANTYPE,SUBSTR) or frequency value TIMFRQ (for ANTYPE,HARMIC).
            LSTEP and SBSTEP should be blank.

        elcalc
            Element calculation key:

            YES - Calculate element results, nodal loads, and reaction loads.

            NO - Do not calculate these items.

        Notes
        -----
        Specifies the solution to be expanded from analyses that use the mode-
        superposition method (ANTYPE,HARMIC or TRANS) or substructuring
        (ANTYPE,SUBSTR). Use the NUMEXP command to expand a group of solutions.

        The resulting results file will maintain the same load step, substep,
        and time (or frequency) values as the requested solution to be
        expanded.

        This command is also valid in PREP7.
        """
        command = "EXPSOL,%s,%s,%s,%s" % (str(lstep), str(sbstep), str(timfrq), str(elcalc))
        return self.run(command, **kwargs)

    def rmrgenerate(self, **kwargs):
        """APDL Command: RMRGENERATE

        Performs fitting procedure for all ROM functions to generate response
        surfaces.

        Notes
        -----
        The fitting procedure uses modal analysis data and function data
        generated using the RMSMPLE command and specifications set forth in the
        RMROPTIONS command. The files jobname_ijk.pcs (modes i, j, k) will be
        generated containing the coefficients of the response surfaces. These
        files are needed for the ROM Use Pass along with a ROM data base file
        [RMSAVE].

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.

        Strain energy and capacitance data file jobname_ijk.dec

        Response surface coefficients jobname_ijk.pcs (modes i, j, k)
        """
        command = "RMRGENERATE," % ()
        return self.run(command, **kwargs)

    def campbell(self, action="", **kwargs):
        """APDL Command: CAMPBELL

        Prepares the result file for a subsequent Campbell diagram of a
        prestressed structure.

        Parameters
        ----------
        action
            Campbell action:

            NONE - Do not prepare the result file. This option is the default behavior.

            RSTP - Prepare the result file (Jobname.RSTP) for a subsequent Campbell diagram of a
                   prestressed structure.

        Notes
        -----
        For an analysis involving a prestressed structure, the CAMPBELL command
        specifies whether or not to prepare the result file to support  a
        Campbell diagram analysis (PRCAMP or PLCAMP).

        To prestress a structure, the program performs a static solution before
        the linear perturbation modal solution.

        The CAMPBELL command requires that modal and static analyses be
        performed alternately. It works only when the number of static analyses
        is the same as the number of modal analyses. Any number of analyses can
        be performed, but the same number of each (static and modal) is
        expected. The modal solutions are appended in the results file
        (Jobname.RSTP).

        For an example of PLCAMP command usage, see Example Campbell Diagram
        Analysis in the Advanced Analysis Guide.
        """
        command = "CAMPBELL,%s" % (str(action))
        return self.run(command, **kwargs)

    def partsel(self, type="", pmin="", pmax="", pinc="", **kwargs):
        """APDL Command: PARTSEL

        Selects a subset of parts in an explicit dynamic analysis.

        Parameters
        ----------
        type
            Label identifying type of select. Because PARTSEL is a command
            macro, the label must be enclosed in single quotes.

            'S' - Select a new set (default).

            'R' - Reselect a set from the current set.

            'A' - Additionally select a set and extend the current set.

            'U' - Unselect a set from the current set.

            'ALL' - Select all parts.

            'NONE' - Unselect all parts.

            'INVE' - Invert the current selected set.

        Notes
        -----
        PARTSEL invokes an ANSYS macro that selects parts in an explicit
        dynamic analysis. When PARTSEL is executed, an element component is
        automatically created for each existing part. For example, the elements
        that make up PART 1 are grouped into the element component _PART1. Each
        time the PARTSEL command is executed, components for unselected parts
        will be unselected. To plot selected parts, choose Utility Menu> Plot>
        Parts in the GUI or issue the command PARTSEL,'PLOT'.

        After selecting parts, if you change the selected set of nodes or
        elements and then plot parts, the nodes and elements associated with
        the previously selected parts (from the last PARTSEL command) will
        become the currently selected set.

        Note:: : A more efficient way to select and plot parts is to use the
        ESEL (with ITEM = PART) and EPLOT commands. We recommend using ESEL
        instead of PARTSEL since PARTSEL will be phased out in a future
        release. Note that the menu path mentioned above for plotting parts
        does not work with the ESEL command; use Utility Menu> Plot> Elements
        instead.

        In an explicit dynamic small restart analysis (EDSTART,2), PARTSEL can
        be used to unselect a part during the solution even if it is referenced
        in some way (such as in a contact definition). (Note that ESEL cannot
        be used for this purpose.) However, in a new analysis or a full restart
        analysis (EDSTART,3), all parts that are used in some type of
        definition must be selected at the time of solution.

        This command is valid in any processor.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "PARTSEL,%s,%s,%s,%s" % (str(type), str(pmin), str(pmax), str(pinc))
        return self.run(command, **kwargs)

    def pdplot(self, name="", plow="", pup="", **kwargs):
        """APDL Command: PDPLOT

        Plots the distribution curves of a defined random input variable.

        Parameters
        ----------
        name
            Parameter name. The parameter name must have been previously
            defined as a random input variable using the PDVAR command.

        plow
            Lower probability level used to determine the lower boundary of the
            curve. This probability must be between 0.0 and 1.0 and it defaults
            to 0.0025. This parameter is used to determine the lower plotting
            range (boundary) in case the random input variable does not have a
            minimum value (such as Gauss).

        pup
            Upper probability level used to determine the upper boundary of the
            curve. This probability must be between 0.0 and 1.0 and it defaults
            to 0.9975.

        Notes
        -----
        Plots the distribution of a defined random input variable. The PDPLOT
        command generates a probability density function plot as well as a
        cumulative distribution function plot of the random variable. The
        probabilities PLOW and PUP are used to determine the plot range of the
        random input variable values. To do this, the probabilities are
        converted into random input variable values using the inverse
        cumulative distribution function of the random input variable as shown
        in the following illustration.

        Using the probabilities ensures that the boundaries are always feasible
        and meaningful for the random input variable regardless of its
        distribution type.

         If PLOW is left blank, then a minimum value of the distribution is
        used for plotting, provided it exists (for example, uniform
        distribution). If the distribution type has no minimum value (for
        example, a Gaussian distribution) then the default value is used to
        determine the lower plotting range value. The same applies for the
        maximum value, if  PUP is left blank.
        """
        command = "PDPLOT,%s,%s,%s" % (str(name), str(plow), str(pup))
        return self.run(command, **kwargs)

    def nwrite(self, fname="", ext="", kappnd="", **kwargs):
        """APDL Command: NWRITE

        Writes nodes to a file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        kappnd
            Append key:

            0 - Rewind file before the write operation.

            1 - Append data to the end of the existing file.

        Notes
        -----
        Writes selected nodes [NSEL] to a file.  The write operation is not
        necessary in a standard ANSYS run but is provided as a convenience to
        users wanting a coded node file.  Data are written in a coded format.
        The format used is (I8, 6G20.13) to write out
        NODE,X,Y,Z,THXY,THYZ,THZX.  If the last number is zero (i.e., THZX =
        0), or the last set of numbers are zero, they are not written but are
        left blank. Therefore, you must use a formatted read to process this
        file.  Coordinate values are in the global Cartesian system.
        """
        command = "NWRITE,%s,%s,%s" % (str(fname), str(ext), str(kappnd))
        return self.run(command, **kwargs)

    def ltan(self, nl1="", p3="", xv3="", yv3="", zv3="", **kwargs):
        """APDL Command: LTAN

        Generates a line at the end of, and tangent to, an existing line.

        Parameters
        ----------
        nl1
            Number of the line the generated line is tangent to.  If negative,
            assume P1 (see below), instead of P2, is the second keypoint of
            line NL1.  If NL1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).

        p3
            Keypoint at which generated line must end.

        Notes
        -----
        Generates a line (P2-P3) tangent at end point (P2) of line NL1 (P1-P2).
        """
        command = "LTAN,%s,%s,%s,%s,%s" % (str(nl1), str(p3), str(xv3), str(yv3), str(zv3))
        return self.run(command, **kwargs)

    def showdisp(self, dname="", ncpl="", **kwargs):
        """APDL Command: /SHOWDISP

        Defines the display driver name.

        Parameters
        ----------
        dname
            Valid driver name (see Getting Started with Graphics in the Basic
            Analysis Guide for details):

            <device name> - Any linked terminal driver (such as X11, TEKTRONIX, etc.)

            HPGL - Hewlett-Packard Graphics Language

            HPGL2 - Hewlett-Packard Graphics Language with enhanced color.  (See the HPGL command
                    for options.)  Ignores the NCPL field.

            INTERLEAF - Interleaf ASCII Format, OPS Version 5.0

            POSTSCRIPT - PostScript, Version 1.0 Minimally Conforming

            DUMP - ASCII Text Dump

        --, --
            Unused fields.

        ncpl
            Number of color planes (4 to 8).  Default is device-dependent.
        """
        command = "/SHOWDISP,%s,%s" % (str(dname), str(ncpl))
        return self.run(command, **kwargs)

    def pstres(self, key="", **kwargs):
        """APDL Command: PSTRES

        Specifies whether prestress effects are calculated or included.

        Parameters
        ----------
        key
            Prestress key:

            OFF - Do not calculate (or include) prestress effects (default).

            ON - Calculate (or include) prestress effects.

        Notes
        -----
        The PSTRES command specifies whether or not prestress effects are to be
        calculated or included. The command should be issued after the ANTYPE
        command.

        Prestress effects are calculated in a static or transient analysis for
        inclusion in a buckling, modal, harmonic (Method = FULL), or
        substructure generation analysis. If used in the solution processor
        (/SOLU), this command is valid only within the first load step.

        If you apply thermal body forces during a static analysis to calculate
        prestress effects, do not delete the forces during any subsequent full
        harmonic analyses. If you delete the thermal body forces, the thermal
        prestress effects will not be included in the harmonic analysis.
        Temperature loads used to define the thermal prestress will also be
        used in the full harmonic analysis as sinusoidally time-varying
        temperature loads.

        A prestress effect applied with non-follower loads resists rigid body
        rotation of the model. For example, an unsupported beam with axial
        tensile forces applied to both ends will have two nonzero rotational
        rigid body modes.

        If tabular loading (*DIM,,TABLE) was used in the prestress static
        analysis step, the corresponding value of TIME will be used for tabular
        evaluations in the modal analysis.

        This command is also valid in PREP7.
        """
        command = "PSTRES,%s" % (str(key))
        return self.run(command, **kwargs)

    def abextract(self, mode1="", mode2="", **kwargs):
        """APDL Command: ABEXTRACT

        Extracts the alpha-beta damping multipliers for Rayleigh damping.

        Parameters
        ----------
        mode1
            First mode number.

        mode2
            Second mode number.

        Notes
        -----
        ABEXTRACT calls the command macro DMPEXT to extract the damping ratio
        of MODE1 and MODE2 and then computes the Alpha and Beta damping
        multipliers for use in a subsequent structural harmonic or transient
        analysis. See Damping in the Structural Analysis Guide for more
        information on the alpha and beta damping multipliers. The damping
        multipliers are stored in parameters ALPHADMP and BETADMP and can be
        applied using the ALPHAD and BETAD commands. Before calling ABEXTRACT,
        you must issue RMFLVEC to extract the modal displacements. In addition,
        a node component FLUN must exist from all FLUID136 nodes. See
        Introduction for more information on thin film analyses.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "ABEXTRACT,%s,%s" % (str(mode1), str(mode2))
        return self.run(command, **kwargs)

    def use(self, name="", arg1="", arg2="", arg3="", arg4="", arg5="",
            arg6="", arg7="", arg8="", arg9="", ar10="", ar11="", ar12="",
            ar13="", ar14="", ag15="", ar16="", ar17="", ar18="", **kwargs):
        """APDL Command: *USE

        Executes a macro file.

        Parameters
        ----------
        name
            Name (32 characters maximum, beginning with a letter) identifying
            the macro file or a macro block on a macro library file.

        arg1, arg2, arg3, . . . , ar18
            Values passed into the file or block where the parameters ARG1
            through ARG9 and AR10 through AR18 are referenced.  Values may be
            numbers, alphanumeric character strings (up to 32 characters
            enclosed in single quotes), parameters (numeric or character) or
            parametric expressions.  See below for additional details.

        Notes
        -----
        Causes execution of a macro file called Name, or, if not found, a macro
        block "Name" on the macro library file [*ULIB].  Argument values
        (numeric or character) are passed into the file or block and
        substituted for local parameters ARG1, ARG2, ..., AR18.  The file Name
        may also be executed as an "unknown command" (i.e., without the *USE
        command name) as described below.

        A macro is a sequence of ANSYS commands (as many as needed) recorded in
        a file or in a macro block in a library file (specified with the *ULIB
        command).  The file or block is typically executed with the *USE
        command.  In addition to command, numerical and alphanumeric data, the
        macro may include parameters which will be assigned numerical or
        alphanumerical character values when the macro is used.  Use of the
        macro may be repeated (within a do-loop, for example) with the
        parameters incremented.  A macro is defined within a run by "enclosing"
        a sequence of data input commands between a *CREATE and a *END
        command.  The data input commands are passive (not executed) while
        being written to the macro file.  The macro file (without *CREATE and
        *END ) can also be created external to ANSYS.

        Up to 99 specially named scalar parameters called ARG1 to AR99 are
        locally available to each macro.  Note that the prefix for the first 9
        parameters is "ARG," while the prefix for the last 90 is "AR."  A local
        parameter is one which is not affected by, nor does it affect, other
        parameters, even those of the same name, which are used outside of the
        macro.  The only way a local parameter can affect, or be affected by,
        parameters outside the macro is if values are passed out of, or into,
        the macro by an argument list.  Parameters ARG1 through AR18 can have
        their values (numeric or character) passed via the argument list on the
        *USE command (ARG1 through AR19 can be passed as arguments on the
        "unknown command" macro).  Parameters AR19 through AR99 (AR20 through
        AR99 in the "unknown command" macro) are available solely for use
        within the macro; they cannot be passed via an argument list.  Local
        parameters are available to do-loops and to /INPUT files processed
        within the macro.  In addition to an ARG1--AR99 set for each macro,
        another ARG1--AR99 set is available external to all macros, local to
        "non-macro" space.

        A macro is exited after its last line is executed.  Macros may be
        nested (such as a *USE or an "unknown command" within a macro).  Each
        nested macro has its own set of 99 local parameters.  Only one set of
        local parameters can be active at a time and that is the set
        corresponding to the macro currently being executed or to the set
        external to all macros (if any).  When a nested macro completes
        execution, the previous set of local parameters once again becomes
        available.  Use *STATUS,ARGX to view current macro parameter values.

        An alternate way of executing a macro file is via the "unknown command"
        route.  If a command unknown to the ANSYS program is entered, a search
        for a file of that name (plus a .MAC suffix) is made.  If the file
        exists, it is executed, if not, the "unknown command" message is
        output.  Thus, users can write their own commands in terms of other
        ANSYS commands.  The procedure is similar to issuing the *USE command
        with the unknown command in the Name field.  For example, the command
        CMD,10,20,30 is internally similar to *USE,CMD,10,20,30.  The macro
        file named CMD.MAC will be executed with the three parameters.  The
        *USE macro description also applies to the "unknown command" macro,
        except that various directories are searched and a suffix (.MAC) is
        assumed.  Also, a macro library file is not searched.

        A three-level directory search for the "unknown command" macro file may
        be available (see the Operations Guide).  The search order may be: 1) a
        high-level system directory, 2) the login directory, and 3) the local
        (working) directory.  Use the /PSEARCH command to change the directory
        search path.  For an "unknown command" CMD, the first file named
        CMD.MAC found to exist in the search order will be executed.  The
        command may be input as upper or lower case, however, it is converted
        to upper case before the file name search occurs.  On systems that
        uniquely support both upper and lower case file names, the file with
        the matching lower case name will be used if it exists, otherwise, the
        file with the matching upper case name will be used. All macro files
        placed in the apdl directory must be upper case.

         Note, since undocumented commands exist in the ANSYS program, the user
        should issue the command intended for the macro file name to be sure
        the "unknown command" message is output in the processor where it's to
        be used.  If the macro is to be used in other processors, the other
        processors must also be checked.

        This command is valid in any processor.
        """
        command = "*USE,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(name), str(arg1), str(arg2), str(arg3), str(arg4), str(arg5), str(arg6), str(arg7), str(arg8), str(arg9), str(ar10), str(ar11), str(ar12), str(ar13), str(ar14), str(ag15), str(ar16), str(ar17), str(ar18))
        return self.run(command, **kwargs)

    def xflist(self, enrichmentid="", **kwargs):
        """APDL Command: XFLIST

        Lists enrichment details and associated crack information

        Parameters
        ----------
        enrichmentid or (blank)
            Name of the enrichment specified via the associated XFENRICH
            command. Specifying EnrichmentID is optional.

        Notes
        -----
        This command is valid in PREP7 (/PREP7) and SOLUTION (/SOLU).
        """
        command = "XFLIST,%s" % (str(enrichmentid))
        return self.run(command, **kwargs)

    def cutcontrol(self, lab="", value="", option="", **kwargs):
        """APDL Command: CUTCONTROL

        Controls time-step cutback during a nonlinear solution.

        Parameters
        ----------
        lab
            Specifies the criteria for causing a cutback.  Valid labels are:

            PLSLIMIT  - Maximum equivalent plastic strain allowed within a time-step (substep).  If the
                        calculated value exceeds the VALUE, the program
                        performs a cutback (bisection).  VALUE defaults to 0.15
                        (15%).

            CRPLIMIT  - Set values for calculating the maximum equivalent creep ratio allowed within a
                        time step. If the calculated maximum creep ratio
                        exceeds the defined creep ratio limit, the program
                        performs a cutback.

            DSPLIMIT  - Maximum incremental displacement within the solution field in a time step
                        (substep).  If the maximum calculated value exceeds
                        VALUE, the program performs a cutback (bisection).
                        VALUE defaults to 1.0 x 107.

            NPOINT  - Number of points in a cycle for a second order dynamic equation, used to
                      control automatic time stepping.  If the number of
                      solution points per cycle is less than VALUE, the program
                      performs a cutback in time step size. VALUE defaults to
                      13 for linear analysis, 5 for nonlinear analysis. A
                      larger number of points yields a more accurate solution
                      but also increases the solution run time.

            This option works well for linear problems. For nonlinear analyses, other factors such as contact status changes and solution convergence rate can overwrite NPOINT. See Automatic Time Stepping in the Mechanical APDL Theory Reference for more information on automatic time stepping. - NOITERPREDICT 

            If VALUE is 0 (default), an internal auto time step scheme will predict the number of iterations for nonlinear convergence and perform a cutback earlier than the number of iterations specified by the NEQIT command. This is the recommended option. If VALUE is 1, the solution will iterate (if nonconvergent) to NEQIT number of iterations before a cutback is invoked. It is sometimes useful for poorly-convergent problems, but rarely needed in general. - Bisection is also controlled by contact status change, plasticity or creep
                              strain limit, and other factors. If any of these
                              factors occur, bisection will still take place,
                              regardless of the NOITERPREDICT setting.

            CUTBACKFACTOR  - Changes the cutback value for bisection. Default is 0.5. VALUE must be greater
                             than 0.0 and less than 1.0. This option is active
                             only if AUTOTS,ON is set.

        value
            Numeric value for the specified cutback criterion. For Lab =
            CRPLIMIT, VALUE is the creep criteria for the creep ratio limit.

        option
            Type of creep analysis. Valid for Lab = CRPLIMIT only.

            IMPRATIO  - Set the maximum creep ratio value for implicit creep. The default is 0.0 (i.e.,
                        no creep limit control) and any positive value is
                        valid. (See Implicit Creep Procedure in the Structural
                        Analysis Guide for information on how to define
                        implicit creep.)

            EXPRATIO   - Set the maximum creep ratio value for explicit creep. The default value is 0.1
                         and any positive value up to 0.25 is allowed. (See
                         Explicit Creep Procedure in the Structural Analysis
                         Guide for information on how to define explicit
                         creep.)

            STSLIMIT   - Stress threshold for calculating the creep ratio. For integration points with
                         effective stress below this threshold, the creep ratio
                         does not cause cutback. The default value is 0.0 and
                         any positive value is valid.

            STNLIMIT   - Elastic strain threshold for calculating the creep ratio. For integration
                         points with effective elastic strain below this
                         threshold, the creep ratio does not cause cutback. The
                         default value is 0.0 and any positive value is valid.

        Notes
        -----
        A cutback is a method for automatically reducing the step size when
        either the solution error is too large or the solution encounters
        convergence difficulties during a nonlinear analysis.

        Should a convergence failure occur, the program reduces the time step
        interval to a fraction of its previous size and automatically continues
        the solution from the last successfully converged time step. If the
        reduced time step again fails to converge, the program again reduces
        the time step size and proceeds with the solution. This process
        continues until convergence is achieved or the minimum specified time
        step value is reached.

        For creep analysis, the cutback procedure is similar; the process
        continues until the minimum specified time step size is reached.
        However, if the creep ratio limit is exceeded, the program issues a
        warning but continues the substep until the analysis is complete. In
        this case, convergence is achieved but the creep ratio criteria is not
        satisfied.

        The CRPLIM command is functionally equivalent to Lab = CRPLIMIT with
        options IMPRATIO and EXPRATIO
        """
        command = "CUTCONTROL,%s,%s,%s" % (str(lab), str(value), str(option))
        return self.run(command, **kwargs)

    def gmface(self, lab="", n="", **kwargs):
        """APDL Command: GMFACE

        Specifies the facet representation used to form solid models.

        Parameters
        ----------
        lab
            Valid Labels:

            FINE - Value that determines how coarse the facets will be.

        n
            An integer value between one (small) and ten (large) that
            determines the tolerances that will be applied to the creation of
            arcs and surfaces. Ten will create many facets, which may in turn
            cause ANSYS to run very slowly. One will create fewer facets, which
            may in turn cause larger tolerance errors.
        """
        command = "GMFACE,%s,%s" % (str(lab), str(n))
        return self.run(command, **kwargs)

    def geom(self, k2d="", ndiv="", **kwargs):
        """APDL Command: GEOM

        Defines the geometry specifications for the radiation matrix
        calculation.

        Parameters
        ----------
        k2d
            Dimensionality key:

            0 - 3-D geometry (default)

            1 - 2-D geometry (plane or axisymmetric)

        ndiv
            Number of divisions in an axisymmetric model.  Used only with K2D =
            1.  Defaults to 0 (2-D plane).  The 2-D model is internally
            expanded to a 3-D model based on the number of divisions specified
            (6   NDIV   90).  For example, NDIV of 6 is internally represented
            by six 60° sections.
        """
        command = "GEOM,%s,%s" % (str(k2d), str(ndiv))
        return self.run(command, **kwargs)

    def polygon(self, nvert="", x1="", y1="", x2="", y2="", x3="", y3="",
                x4="", y4="", **kwargs):
        """APDL Command: /POLYGON

        Creates annotation polygons (GUI).

        Parameters
        ----------
        nvert
            Number of vertices of polygon (3  NVERT   8).  Use /PMORE for
            polygons with more than 4 vertices.

        x1
            X location for vertex 1 of polygon (-1.0 < X < 2.0).

        y1
            Y location for vertex 1 of polygon (-1.0 < Y < 1.0).

        x2
            X location for vertex 2 of polygon (-1.0 < X < 2.0).

        y2
            Y location for vertex 2 of polygon (-1.0 < Y < 1.0).

        x3
            X location for vertex 3 of polygon (-1.0 < X < 2.0).

        y3
            Y location for vertex 3 of polygon (-1.0 < Y < 1.0).

        x4
            X location for vertex 4 of polygon (-1.0 < X < 2.0).

        y4
            Y location for vertex 4 of polygon (-1.0 < Y < 1.0).

        Notes
        -----
        Creates annotation polygons to be written directly onto the display at
        a specified location.  This is a command generated by the Graphical
        User Interface (GUI) and will appear in the log file (Jobname.LOG) if
        annotation is used.  This command is not intended to be typed in
        directly in an ANSYS session (although it can be included in an input
        file for batch input or for use with the /INPUT command).

        All polygons are shown on subsequent displays unless the annotation is
        turned off or deleted.  Use the /LSPEC and the /PSPEC command to set
        the attributes of the polygon.  Use the /PMORE command to define the
        5th through 8th vertices of the polygon.

        This command is valid in any processor.
        """
        command = "/POLYGON,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nvert), str(x1), str(y1), str(x2), str(y2), str(x3), str(y3), str(x4), str(y4))
        return self.run(command, **kwargs)

    def gsum(self, **kwargs):
        """APDL Command: GSUM

        Calculates and prints geometry items.

        Notes
        -----
        Calculates and prints geometry items (centroid location, moments of
        inertia, length, area, volume etc.) associated with the selected
        keypoints, lines, areas, and volumes. Geometry items are reported in
        the global Cartesian coordinate system.   For volumes, a unit density
        is assumed unless the volumes have a material association via the VATT
        command.  For areas, a unit density (and thickness) is assumed unless
        the areas have a material (and real constant) association via the AATT
        command.  For lines and keypoints, a unit density is assumed,
        irrespective of any material associations [LATT, KATT, MAT].  Items
        calculated by GSUM and later retrieved by a *GET or *VGET commands are
        valid only if the model is not modified after the GSUM command is
        issued.  This command combines the functions of the KSUM, LSUM, ASUM,
        and VSUM commands.
        """
        command = "GSUM," % ()
        return self.run(command, **kwargs)

    def ksll(self, type="", **kwargs):
        """APDL Command: KSLL

        Selects those keypoints contained in the selected lines.

        Parameters
        ----------
        type
            Label identifying the type of keypoint select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "KSLL,%s" % (str(type))
        return self.run(command, **kwargs)

    def etchg(self, cnv="", **kwargs):
        """APDL Command: ETCHG

        Changes element types to their corresponding types.

        Parameters
        ----------
        cnv
            Converts the element types to the corresponding type. Valid labels
            are:

            ETI - Explicit to Implicit

            ITE - Implicit to Explicit

            TTE - Thermal to Explicit

            TTS - Thermal to Structural

            STT - Structural to Thermal

            MTT - Magnetic to Thermal

            FTS - Fluid to Structural

            ETS - Electrostatic to Structural

            ETT - Electrical to Thermal

        Notes
        -----
        Changes the currently defined element types to their corresponding
        types.  Elements without a companion element (listed above) are not
        switched and should be switched with the ET command to an appropriate
        element type or to a null element. The KEYOPT values for the switched
        element types are reset to zero or to their default values. You must
        check these values to see if they are still meaningful. Additionally,
        if Cnv = ETI, ITE, or TTE, all real constants are set to zero.

        If Cnv = ITE, you will need to choose a material model that corresponds
        to your previously-defined material properties. If working
        interactively, you will be prompted to do so.
        """
        command = "ETCHG,%s" % (str(cnv))
        return self.run(command, **kwargs)

    def remesh(self, action="", filename="", ext="", opt1="", opt2="",
               **kwargs):
        """APDL Command: REMESH

        Specifies the starting and ending remeshing points, and other options,
        for rezoning.

        Parameters
        ----------
        action
            START

            START - Starts the remeshing operation.

            FINISH - Ends the remeshing operation.

            READ - Reads in a generic (.cdb format) new mesh file generated by a third-party
                   application. This remeshing option applies to both 2-D and
                   3-D rezoning.

            SPLIT - Splits selected elements of an existing 2-D or 3-D mesh such that a
                    quadrilateral element is split into four quadrilaterals, a
                    degenerate quadrilateral is split into three
                    quadrilaterals, and a quadratic triangular element is split
                    into four quadratic triangles.  A tetrahedral element is
                    split into eight tetrahedra.

        filename
            Name of a .cdb generic mesh file. The default value is jobname.
            Valid only when Action = READ.

        ext
            File name extension. The only valid (and the default) extension is
            CDB. Valid only when Action = READ.

        --
            Unused field.

        opt1
            Specifies options for the new mesh when using a generic imported
            mesh file or the mesh-splitting remeshing method. Valid only when
            Action = READ or Action = SPLIT.

            REGE  - Regenerates all node and element numbers on the new mesh using an offset of the
                    highest existing node and element numbers. This is the
                    default behavior when Action = READ; otherwise, this value
                    is ignored.

            KEEP  - Keeps the similarly numbered nodes and elements in the new and the old meshes
                    unchanged. Valid only when Action = READ.

            TRAN  - Generates transition elements to ensure nodal compatibility between split and
                    unsplit parts of the mesh. Valid only when Action = SPLIT
                    for 2-D analyses.

        opt2
            Specifies transition options for the mesh when elements are split.
            These options are valid only when Action = SPLIT for 2-D analyses.

            QUAD  - Minimizes the number of degenerate elements in the transition mesh and tries to
                    maximize the number of quadrilateral transition elements
                    across several layers of elements from the split regions.
                    This is the default behavior.

            DEGE  - Creates transition zones between the split and unsplit parts of the mesh using
                    mostly degenerate elements with a single element layer.

        Notes
        -----
        The REMESH command is valid only during the rezoning (REZONE) process.

        In rezoning, a REMESH,START command temporarily exits the /SOLU
        solution processor and enters a special mode of the /PREP7
        preprocessor, after which a limited number of preprocessing commands
        are available for mesh control, but no solution commands are valid.

        A REMESH,FINISH command exits the remeshing process and reenters the
        solution processor, at which point no preprocessing commands are
        available. If the new mesh exists, the command creates contact elements
        if needed, and transfers all boundary conditions (BCs) and loads from
        the original mesh to the new mesh. You can issue any list or plot
        command to verify the created contact elements, transferred BCs, and
        loads. A REMESH,FINISH command is valid only after a previously issued
        REMESH,START command, and is the only way to safely end the remeshing
        operation (and exit the special mode of the /PREP7 preprocessor).

        A REMESH,READ command is valid only when you want to perform a rezoning
        operation using a generic new mesh generated by a third-party
        application (rather than a new mesh generated internally by the ANSYS
        program). The command is valid between REMESH,START and REMESH,FINISH
        commands. In this case, the only valid file extension is .cdb (Ext =
        CDB). When Option = KEEP, ANSYS assumes that the common node and
        element numbers between the old and the new mesh are topologically
        similar (that is, these commonly numbered areas have the same element
        connectivity and nodal coordinates).

        A REMESH,SPLIT command is valid only when you wish to perform a
        rezoning operation by splitting the existing mesh. The command is valid
        between REMESH,START and REMESH,FINISH commands.

        You can use REMESH,READ and REMESH,SPLIT commands for horizontal
        multiple rezoning provided that the meshes used in REMESH,READ do not
        intersect. (ANSYS recommends against issuing an AREMESH command after
        issuing either of these commands.)

        For more detailed about the remeshing options available to you during a
        rezoning operation, see Rezoning in the Advanced Analysis Guide.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "REMESH,%s,%s,%s,%s,%s" % (str(action), str(filename), str(ext), str(opt1), str(opt2))
        return self.run(command, **kwargs)

    def gcmd(self, wn="", lab1="", lab2="", lab3="", lab4="", lab5="", lab6="",
             lab7="", lab8="", lab9="", lab10="", lab11="", lab12="",
             **kwargs):
        """APDL Command: /GCMD

        Controls the type of element or graph display used for the GPLOT
        command.

        Parameters
        ----------
        wn
            Window number (or ALL) to which this command applies (defaults to
            1)

        lab1, lab2, lab3, . . . , lab12
            Command labels (for example, PLNSOL,S,X)

        Notes
        -----
        This command controls the type of element or graph display that appears
        when you issue the GPLOT command when the /GTYPE,,(ELEM or GRPH) entity
        type is active.  If you have multiple plotting windows enabled, you can
        also use /GCMD to select one window when you wish to edit its contents.

        For related information, see the descriptions of the GPLOT and /GTYPE
        commands in this manual.

        This command is valid in any processor.
        """
        command = "/GCMD,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(wn), str(lab1), str(lab2), str(lab3), str(lab4), str(lab5), str(lab6), str(lab7), str(lab8), str(lab9), str(lab10), str(lab11), str(lab12))
        return self.run(command, **kwargs)

    def psdfrq(self, tblno1="", tblno2="", freq1="", freq2="", freq3="",
               freq4="", freq5="", freq6="", freq7="", **kwargs):
        """APDL Command: PSDFRQ

        Defines the frequency points for the input spectrum tables PSDVAL vs.
        PSDFRQ for PSD analysis.

        Parameters
        ----------
        tblno1
            Input table number.  When used with the COVAL or the QDVAL command,
            TBLNO1 represents the row number of this table. Up to 200 tables
            may be defined.

        tblno2
            Input table number.  TBLNO2 is used only for the COVAL or the QDVAL
            commands and represents the column number of this table.

        freq1, freq2, freq3, . . . , freq7
            Frequency points (cycles/time) for spectrum vs. frequency tables.
            FREQ1 should be greater than zero, and values must be in ascending
            order.  Log-log interpolation will be used between frequency
            points.

        Notes
        -----
        The spectrum values may be input with the PSDVAL, COVAL , or QDVAL
        commands.  A separate PSDFRQ command must be used for each table and
        cross table defined.  Frequencies must be in ascending order.

        Repeat PSDFRQ command for additional frequency points.  Values are
        added after the last nonzero frequency.  If all fields after PSDFRQ are
        blank, all input vs. frequency tables are erased.  If TBLNO1 is
        nonblank, all corresponding PSDVAL tables are erased.  If both TBLNO1
        and TBLNO2 are nonblank,  all corresponding COVAL and QDVAL tables are
        erased.

        This command is also valid in PREP7.
        """
        command = "PSDFRQ,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(tblno1), str(tblno2), str(freq1), str(freq2), str(freq3), str(freq4), str(freq5), str(freq6), str(freq7))
        return self.run(command, **kwargs)

    def gauge(self, opt="", freq="", **kwargs):
        """APDL Command: GAUGE

        Gauges the problem domain for a magnetic edge-element formulation.

        Parameters
        ----------
        opt
            Type of gauging to be performed:

            ON - Perform tree gauging of the edge values (default).

            OFF - Gauging is off. (You must specify custom gauging via APDL specifications.)

            STAT - Gauging status (returns the current Opt and FREQ values)

        freq
            The following options are valid when Opt = ON:

            0 - Generate tree-gauging information once, at the first load step. Gauging data is
                retained for subsequent load steps. (This behavior is the
                default.)

            1 - Repeat gauging for each load step. Rewrites the gauging information at each
                load step to accommodate changing boundary conditions on the AZ
                degree of freedom (for example, adding or deleting AZ
                constraints via the D or CE commands).

        Notes
        -----
        The GAUGE command controls the tree-gauging procedure required for
        electromagnetic analyses using an edge-based magnetic formulation
        (elements SOLID236 and SOLID237).

        Gauging occurs at the solver level for each solution (SOLVE). It sets
        additional zero constraints on the edge-flux degrees of freedom AZ to
        produce a unique solution; the additional constraints are removed after
        solution.

        Use the FREQ option to specify how the command generates gauging
        information for multiple load steps.

        Access the gauging information via the _TGAUGE component of gauged
        nodes. The program creates and uses this component internally to remove
        and reapply the AZ constraints required by gauging. If FREQ = 0, the
        _TGAUGE component is created at the first load step and is used to
        reapply the tree gauge constraints at subsequent load steps. If FREQ =
        1, the tree-gauging information and the _TGAUGE component are generated
        at every load step

        If gauging is turned off (GAUGE,OFF), you must specify your own gauging
        at the APDL level.

        This command is also valid in PREP7.
        """
        command = "GAUGE,%s,%s" % (str(opt), str(freq))
        return self.run(command, **kwargs)

    def eddump(self, num="", dt="", **kwargs):
        """APDL Command: EDDUMP

        Specifies output frequency for the explicit dynamic restart file
        (d3dump).

        Parameters
        ----------
        num
            Number of d3dump (restart) files written during the analysis
            (defaults to 1). When you specify NUM, the time interval between
            restart files is TIME / NUM, where TIME is the analysis end-time
            specified on the TIME command.

        dt
            Time interval at which the d3dump (restart) files are written. If
            NUM is input, DT is ignored.

        Notes
        -----
        You can use NUM or DT to specify the time interval at which d3dump
        restart files will be written. You should not specify both quantities;
        if both are input, NUM will be used. The restart files are written
        sequentially as d3dump01, d3dump02, etc.

        In LS-DYNA, the restart file output is specified in terms of number of
        time steps. Because the total number of time steps is not known until
        the LS-DYNA solution finishes, Mechanical APDL calculates an
        approximate number of time steps for the solution, and then uses NUM or
        DT to calculate the required LS-DYNA input. This approximated number of
        time steps may be different from the total number reached in LS-DYNA
        after the solution finishes. Therefore, the number of restart dump
        files or the output interval may differ slightly from what you
        requested using NUM or DT.

        In an explicit dynamic small restart (EDSTART,2) or full restart
        analysis (EDSTART,3), the EDDUMP setting will default to the NUM or DT
        value used in the original analysis. You can issue EDDUMP in the
        restart to change this setting.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDDUMP,%s,%s" % (str(num), str(dt))
        return self.run(command, **kwargs)

    def toffst(self, value="", **kwargs):
        """APDL Command: TOFFST

        Specifies the temperature offset from absolute zero to zero.

        Parameters
        ----------
        value
            Degrees between absolute zero and zero of temperature system used
            (should be positive).

        Notes
        -----
        Specifies the difference (in degrees) between absolute zero and the
        zero of the temperature system used.  Absolute temperature values are
        required in evaluating certain expressions, such as for creep,
        swelling, radiation heat transfer, MASS71, etc.  (The offset
        temperature is not used in evaluating emissivity.) Examples are 460°
        for the Fahrenheit system and 273° for the Celsius system.  The offset
        temperature is internally included in the element calculations and does
        not affect the temperature input or output.  If used in SOLUTION, this
        command is valid only within the first load step.

        This command is also valid in PREP7.
        """
        command = "TOFFST,%s" % (str(value))
        return self.run(command, **kwargs)

    def mfbucket(self, key="", value="", **kwargs):
        """APDL Command: MFBUCKET

        Turns a bucket search on or off.

        Parameters
        ----------
        key
            Bucket search key:

            ON - Activates a bucket search (default).

            OFF - Deactivates a bucket search. A global search is then activated.

        value
            Scaling factor (%) used to determine the number of buckets for a
            bucket search. Defaults to 50%.

        Notes
        -----
        A bucket search will more efficiently compute the mapping of surface
        and volumetric interpolation data across field interfaces (flagged by
        the FSIN label using SF, SFA, SFE, or SFL or the FVIN label using BFE).

        The number of buckets used to partition a flagged interface is equal to
        the scaling factor (%) times the total number of interface elements.
        For example, for the default scaling factor of 50% and a 10,000 element
        interface, 5,000 buckets are used.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFBUCKET,%s,%s" % (str(key), str(value))
        return self.run(command, **kwargs)

    def sucr(self, surfname="", surftype="", nrefine="", radius="", tolout="",
             **kwargs):
        """APDL Command: SUCR

        Create a surface.

        Parameters
        ----------
        surfname
            Eight character surface name.

        surftype
            Surface type.

            CPLANE - Surface is defined by the cutting plane in window one (controlled by the
                     working plane (/CPLANE,1), NOT the view settings
                     (/CPLANE,0)).

            SPHERE - Surface is defined by a spherical surface centered about the working plane
                     origin.

            INFC - Surface is defined by a cylindrical surface centered about the working plane
                   origin and extending indefinitely in the positive and
                   negative Z directions.

        nrefine
            Refinement level.

            For SurfType = CPLANE -  The refinement level of the surface "mesh". This will be an integer between 0
                              and 3 (default = 0). See Notes below.

            For SurfType = SPHERE - The number of divisions along a 90° arc (minimum = 9). The default is 9.

            For SurfType = INFC - The number of divisions along a 90° arc (minimum = 9). The default is 9.

        radius
            Appropriate radius value (for INFC or SPHERE).

        tolout
            Tolerance value for inclusion of element facets within a prescribed
            volume. (for INFC)

        Notes
        -----
        This command creates a new surface and stores the following data for
        that surface:

        For SurfType = CPLANE, nRefine refers to the number of points that
        define the surface. An nRefine value of zero is used for points where
        the element face intersects the cutting plane.

        If SurfType = CPLANE and nRefine = 0, the points reside at the section
        cuts where the element intersects the cutting plane. Increasing nRefine
        from 0 to 1 will subdivide each surface facet into 4 subfacets, and
        increase the number of points at which results can be interpolated.

        For SurfType = CPLANE , the setting from the /EFACET command will
        affect the creation of surface facets and the quality of the fit of the
        surface in the model.  SUCR employs geometry data from PowerGraphics to
        aid in determining where the surface intersects the model.  If
        /EFACET,1 is in effect when the SUCR command is issued, then the
        curvature of high order elements (that is, elements with midside nodes)
        will be ignored.  If your model contains high order elements, you can
        see a better fit for your surface if /EFACET,2 is in effect when the
        SUCR command is issued.  Currently, the SUCR command interprets
        /EFACET,4 to mean /EFACET,2.

        For SurfType = INFC, a default tolerance of 0.01 will be applied to
        include the vertices of any facets that fall out of the cylinder
        definition. This tolerance increases the facet size by one percent to
        check for inclusion. Excluding facets under such a small tolerance may
        yield unacceptable (aesthetically) results. Increasing the tolerance by
        a larger amount (0.1 or 10%) will sometimes yield smother edges along
        the surface you create.
        """
        command = "SUCR,%s,%s,%s,%s,%s" % (str(surfname), str(surftype), str(nrefine), str(radius), str(tolout))
        return self.run(command, **kwargs)

    def emid(self, key="", edges="", **kwargs):
        """APDL Command: EMID

        Adds or removes midside nodes.

        Parameters
        ----------
        key
            Add or remove key:

            ADD - Add midside node to elements (default).

            REMOVE - Remove midside nodes from elements.

        edges
            ALL

            ALL - Add (or remove) midside nodes to (from) all edges of all selected elements,
                  independent of which nodes are selected (default).

            EITHER - Add (or remove) midside nodes only to (from) element edges which have either
                     corner node selected.

            BOTH - Add (or remove) midside nodes only to (from) element edges which have both
                   corner nodes selected.

        Notes
        -----
        This command adds midside nodes to (or removes midside nodes from) the
        selected elements. For this to occur, the selected elements must be
        midside node capable, the active element type [TYPE] must allow midside
        node capability, and the relationship between the finite element model
        and the solid model (if any) must first be disassociated [MODMSH].

        By default, EMID generates a midside node wherever a zero (or missing)
        midside node occurs for that element. You can control this and add (or
        remove) midside nodes selectively by using the Edges argument. Nodes
        are located midway between the two appropriate corner nodes based on a
        linear Cartesian interpolation. Nodal coordinate system rotation angles
        are also linearly interpolated. Connected elements share the same
        midside node. Node numbers are generated sequentially from the maximum
        node number.

        The EMID command is useful for transforming linear element types to
        quadratic element types having the same corner node connectivity.

        EMID is also useful for transforming elements created outside of the
        program.
        """
        command = "EMID,%s,%s" % (str(key), str(edges))
        return self.run(command, **kwargs)

    def desol(self, elem="", node="", item="", comp="", v1="", v2="", v3="",
              v4="", v5="", v6="", **kwargs):
        """APDL Command: DESOL

        Defines or modifies solution results at a node of an element.

        Parameters
        ----------
        elem
            Element number for which results are defined or modified.  If ALL,
            apply to all selected elements [ESEL].

        node
            Node of element (actual node number, not the position) to which
            results are specified.  If ALL, specify results for all selected
            nodes [NSEL] of element.  If NODE = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).  A component name may also be substituted for NODE.

        item
            Label identifying results.  Valid item labels are shown in
            Table 129: DESOL - Valid Item and Component Labels below.  Some
            items also require a component label (Comp).

        comp
            Component of the item (if required); see Table 129: DESOL - Valid
            Item and Component Labels.

        v1
            Value (in the element coordinate system) assigned to the database
            item (and component, if any).  If zero, a zero value will be
            assigned.  If blank, value remains unchanged.

        v2, v3, v4, . . . , v6
            Additional values (if any) assigned to the remaining components (in
            the order corresponding to the Comp list shown below) for the
            specified Item (starting from the specified Comp label and
            proceeding to the right).

        Notes
        -----
        The DESOL command defines or modifies solution results in the database
        at a node of an area or volume element.  For example,
        DESOL,35,50,S,X,1000,2000,1000 assigns values 1000, 2000, and 1000 to
        SX, SY, and SZ (respectively) of node 50 of element 35.

        The settings of the POST1 FORCE, SHELL, and LAYER commands, if
        applicable, further specify which database items are affected.

        For layered composite shells, specify the current element layer (LAYER)
        before issuing the DESOL command.

        All data is stored in the solution coordinate system but is displayed
        in the results coordinate system (RSYS). To list the current results,
        use the PRESOL command.

        Modified solution results are not saved automatically. To save separate
        records of modified results, use either the RAPPND or LCWRITE command.

        Result items are available depending on element type; check the
        individual element for availability. Valid item and component labels
        for element results are:

        Table: 129:: : DESOL - Valid Item and Component Labels
        """
        command = "DESOL,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(elem), str(node), str(item), str(comp), str(v1), str(v2), str(v3), str(v4), str(v5), str(v6))
        return self.run(command, **kwargs)

    def data(self, ir="", lstrt="", lstop="", linc="", name="", kcplx="",
             **kwargs):
        """APDL Command: DATA

        Reads data records from a file into a variable.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        lstrt
            Start at location LSTRT (defaults to 1).

        lstop
            Stop at location LSTOP (defaults to LSTRT).  Maximum location
            available is determined from data previously stored.

        linc
            Fill every LINC location between LSTRT and LSTOP (defaults to 1).

        name
            Eight character name for identifying the variable on the printout
            and displays.  Embedded blanks are compressed upon output.

        kcplx
            Complex number key:

            0 - Data stored as the real part of the complex number.

            1 - Data stored as the imaginary part of the complex number.

        Notes
        -----
        This command must be followed by a format statement (on the next line)
        and the subsequent data records, and all must be on the same file (that
        may then be read with the /INPUT command).  The format specifies the
        number of fields to be read per record, the field width, and the
        placement of the decimal point (if one is not included in the data
        value).  The read operation follows the available FORTRAN FORMAT
        conventions of the system.  See the system FORTRAN manual for details.
        Any standard FORTRAN real format (such as (4F6.0), (F2.0,2X,F12.0),
        etc.) may be used.  Integer (I), character (A), and list-directed (*)
        descriptors may not be used.  The parentheses must be included in the
        format.  Up to 80 columns per record may be read.  Locations may be
        filled within a range.  Previous data in the range will be overwritten.
        """
        command = "DATA,%s,%s,%s,%s,%s,%s" % (str(ir), str(lstrt), str(lstop), str(linc), str(name), str(kcplx))
        return self.run(command, **kwargs)

    def finish(self, **kwargs):
        """APDL Command: FINISH

        Exits normally from a processor.

        Notes
        -----
        Exits any of the ANSYS processors or the DISPLAY program.  For the
        ANSYS processors, data will remain intact in the database but the
        database is not automatically written to a file (use the SAVE command
        to write the database to a file).  See also the /QUIT command for an
        alternate processor exit command.  If exiting POST1, POST26, or OPT,
        see additional notes below.

        POST1:  Data in the database will remain intact, including the POST1
        element table data, the path table data, the fatigue table data, and
        the load case pointers.

        POST26:  Data in the database will remain intact, except that POST26
        variables are erased and specification commands (such as FILE, PRTIME,
        NPRINT, etc.) are reset.  Use the /QUIT command to exit the processor
        and bypass these exceptions.

        This command is valid in any processor.  This command is not valid at
        the Begin level.
        """
        command = "FINISH," % ()
        return self.run(command, **kwargs)

    def rmroptions(self, refname="", type="", invert="", **kwargs):
        """APDL Command: RMROPTIONS

        Defines options for ROM response surface fitting.

        Parameters
        ----------
        refname
            Reference name of ROM function to be fitted. Valid reference names
            are "SENE" for the strain energy of the structural domain and any
            capacitance reference name previously defined by means of RMCAP
            command for the electrostatic domain.

        type
            Type of fitting function to be applied for regression analysis.
            Valid types are:

            LAGRANGE - Lagrange type (default)

        invert
            Flag to specify whether data should be inverted prior to fitting.

            0 - Do not invert data (default for SENE)

        Notes
        -----
        The objective of response surface fit is to compute an analytical
        expression for the strain energy and the capacitance as functions of
        modal amplitudes.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMROPTIONS,%s,%s,%s" % (str(refname), str(type), str(invert))
        return self.run(command, **kwargs)

    def presol(self, item="", comp="", **kwargs):
        """APDL Command: PRESOL

        Prints the solution results for elements.

        Parameters
        ----------
        item
            Label identifying the item.  Valid item labels are shown in
            Table 224: PRESOL - Valid Item and Component Labels for Element
            Results below.  Some items also require a component label.

        comp
            Component of the item (if required).  Valid component labels are
            shown in Table 224: PRESOL - Valid Item and Component Labels for
            Element Results below.

        Notes
        -----
        Prints the solution results for the selected elements in the sorted
        sequence.  For example, PRESOL,S prints the stress items SX, SY, SZ,
        SXY, SYZ, and SXZ for the node locations of the element.  Component
        results are in the global Cartesian coordinate directions unless
        transformed (RSYS).

        Shell elements print values at the top, then bottom of the element (or
        layer). If KEYOPT(8) = 2 (for SHELL181, SHELL208, SHELL209, SHELL281,
        or ELBOW290), the results are printed in the order TOP, BOT and then
        MID of each element, (or layer). The MID value will be the actual value
        as written to the results file.

        Items are listed as columns of a table versus element number.  An
        exception occurs for item ELEM which uses an element format (all
        applicable line element results are listed per element) instead of a
        tabular format.

        The FORCE command can be used to define which component of the nodal
        load is to be used (static, damping, inertia, or total).  See the
        ETABLE and PRETAB commands for printing items not available through
        this command (such as line element results).

        For PowerGraphics [/GRAPHICS,POWER], results are listed only for the
        element surface.  The items marked with [1] are not supported  by
        PowerGraphics.

        Table: 224:: : PRESOL - Valid Item and Component Labels for Element
        Results

        Failure criteria for virgin material [1][2].

        Default components: Maximum of all failure criteria defined at current
        location (MAX), maximum strain (EMAX), maximum stress (SMAX), Tsai-Wu
        Strength Index (TWSI), inverse of Tsai-Wu Strength Ratio Index (TWSR).

        Other available components: Hashin Fiber Failure (HFIB), Hashin Matrix
        Failure (HMAT), Puck Fiber Failure (PFIB), Puck Matrix Failure (PMAT),
        LaRc03 Fiber Failure (L3FB),  LaRc03 Matrix Failure (L3MT), LaRc04
        Fiber Failure (L4FB), LaRc04 Matrix Failure (L4MT), and any user-
        defined failure criteria (USR1 through USR9) [4].

        Issue the FCTYP command to activate or remove failure criteria.

        Failure criteria based on the effective stresses in the damaged
        material.

        Components: Maximum of all failure criteria defined at current location
        (MAX), fiber tensile failure (FT), fiber compressive failure (FC),
        matrix tensile failure (MT), and matrix compressive (MC).

        Progressive damage parameters.

        Components: Damage status (STAT, 0 - undamaged, 1 - damaged, 2 -
        complete damage), fiber tensile damage variable (FT), fiber compressive
        damage variable (FC), matrix tensile damage variable (MT), matrix
        compressive damage variable (MC), shear damage variable (S),  energy
        dissipated per unit volume (SED), energy per unit volume due to viscous
        damping (SEDV).
        """
        command = "PRESOL,%s,%s" % (str(item), str(comp))
        return self.run(command, **kwargs)

    def dl(self, line="", area="", lab="", value1="", value2="", **kwargs):
        """APDL Command: DL

        Defines DOF constraints on lines.

        Parameters
        ----------
        line
            Line at which constraints are to be specified. If ALL, apply to all
            selected lines [LSEL]. If LINE = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI). A component name may also be substituted for LINE.

        area
            Area containing line. The normal to the symmetry or antisymmetry
            surface is assumed to lie on this area. Defaults to the lowest
            numbered selected area containing the line number.

        lab
            Symmetry label (see 2):

            SYMM - Generate symmetry constraints.

            ASYM - Generate antisymmetry constraints.

        value1
            Value of DOF (real part) or table name reference on the line.
            Valid for all DOF labels.  To specify a table, enclose the table
            name in % signs (e.g., DL,LINE,AREA,TEMP,%tabname%).  Use the *DIM
            command to define a table.

        value2
            For VOLT DOFs:

        Notes
        -----
        You can transfer constraints from lines  to nodes with the  DTRAN or
        SBCTRAN commands.  See the DK command for information about generating
        other constraints at lines.

        Symmetry and antisymmetry constraints are generated as described on the
        DSYM command.

        Setting Lab = VOLT and Value1 = 0 applies the J-normal boundary
        condition (current density vector (J) flows normal to the line).  No
        input is required for the J-parallel condition because it is the
        natural boundary condition.

        Tabular boundary conditions (Value1 = %tabname%) are available only for
        the following degree of freedom labels: Electric (VOLT), Structural
        (UX, UY, UZ, ROTX, ROTY, ROTZ), Acoustic (PRES, UX, UY, UZ), and
        temperature (TEMP, TBOT, TE2, TE3, . . ., TTOP).

        Constraints specified by the DL command can conflict with other
        specified constraints.  See Resolution of Conflicting Constraint
        Specifications in the Basic Analysis Guide for details.

        This command is also valid in PREP7.
        """
        command = "DL,%s,%s,%s,%s,%s" % (str(line), str(area), str(lab), str(value1), str(value2))
        return self.run(command, **kwargs)

    def master(self, **kwargs):
        """APDL Command: MASTER

        Specifies "Master DOF" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "MASTER," % ()
        return self.run(command, **kwargs)

    def plvect(self, item="", lab2="", lab3="", labp="", mode="", loc="",
               edge="", kund="", **kwargs):
        """APDL Command: PLVECT

        Displays results as vectors.

        Parameters
        ----------
        item
            Predefined vector item (from Table 223: PLVECT - Valid Item Labels
            below) or a label identifying the i-component of a user-defined
            vector.

        lab2
            Label identifying the j-component of a user-defined vector. In most
            cases, this value must be blank if Item is selected from
            Table 223: PLVECT - Valid Item Labels. Individual principal
            stresses (Item = S) or principal strains (Item = EPxx) may be
            plotted by specifying the value as 1, 2, or 3.

        lab3
            Label identifying the k-component of a user-defined vector.  Must
            be blank if Item is selected from list below or for 2-D user
            defined vector.

        labp
            Label assigned to resultant vector for display labeling (defaults
            to Item).

        mode
            Vector or raster mode override key:

            (blank) - Use the setting of KEY on the /DEVICE command.

            RAST - Use raster mode for PLVECT displays.

            VECT - Use vector mode for PLVECT displays.

        loc
            Vector location for display of field element results:

            ELEM - Display at element centroid (default).

            NODE - Display at element nodes.

        edge
            Edge display override key:

            (blank) - Use the setting of Key on the /EDGE  command.

            OFF - Deactivate the edge display.

            ON - Activate the edge display.

        kund
            Undisplaced shape key:

            0 - Display vectors on undeformed mesh or geometry.

            1 - Display vectors on deformed mesh or geometry.

        Notes
        -----
        Displays various solution results as vectors (arrows) for the selected
        nodes and/or elements (elements must contain at least three nodes that
        are not colinear).  For example, PLVECT,U displays the displacement
        vector for all selected nodes.  For section displays [/TYPE], the
        vectors are shown only on the section face (i.e., cutting plane).  The
        PLVECT display of principal strains and stresses  (Item = S, EPTO,
        EPEL, EPPL, EPCR, or EPTH) on a "cut" of the model (/TYPE,,1 ,5,7,8, or
        9) is not supported.  The resulting plot displays the vectors on all
        selected elements, not on just the sliced surface.  See the /VSCALE
        command to scale vector lengths. Vector magnitudes may be shown as a
        contour display with the PLNSOL command.  Various results also depend
        upon the recalculation method and the selected results location [LAYER,
        SHELL, and NSEL].

        Items may be selected from a set of recognized vector labels (Item) or
        a vector may be defined from up to three scalar labels
        (Item,Lab2,Lab3).  Scalar labels may be user-defined with the ETABLE
        command.  The vectors appear on an element display as arrows showing
        the relative magnitude of the vector and its direction.  The predefined
        items will be shown either at the node or at the element centroid,
        depending on what item is being displayed and depending on the Loc
        setting.  User defined ETABLE items will be shown at the element
        centroid, regardless of the Loc setting. Stress vectors appear as
        arrows at the element centroid, with the arrowheads pointing away from
        each other for tension and toward each other for compression.

        For PowerGraphics, vector arrow displays are generated in Global
        Cartesian (RSYS = 0). All subsequent displays will revert to your
        original coordinate system.

        When vector mode is active (Mode = VECT), use the Z-buffered display
        type [/TYPE,,6] to maximize speed of PLVECT plots  (other hidden
        display types may make plotting slow). For PowerGraphics
        [/GRAPHICS,POWER], the items marked with [1] are not supported  by
        PowerGraphics.

        It is possible to plot principal stresses (Item = S) or principal
        strains (Item = EPxx) individually. To do so, specify a Lab2 value of
        1, 2, or 3. For example, the following are valid commands:

        Table: 223:: : PLVECT - Valid Item Labels

        Not supported by PowerGraphics
        """
        command = "PLVECT,%s,%s,%s,%s,%s,%s,%s,%s" % (str(item), str(lab2), str(lab3), str(labp), str(mode), str(loc), str(edge), str(kund))
        return self.run(command, **kwargs)

    def sptopt(self, **kwargs):
        """APDL Command: SPTOPT

        Specifies "Spectrum analysis options" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "SPTOPT," % ()
        return self.run(command, **kwargs)

    def nscale(self, inc="", node1="", node2="", ninc="", rx="", ry="", rz="",
               **kwargs):
        """APDL Command: NSCALE

        Generates a scaled set of nodes from a pattern of nodes.

        Parameters
        ----------
        inc
            Do this scaling operation one time, incrementing all nodes in the
            given pattern by INC.  If INC = 0, nodes will be redefined at the
            scaled locations.

        node1, node2, ninc
            Scale nodes from pattern of nodes beginning with NODE1 to NODE2
            (defaults to NODE1) in steps of NINC (defaults to 1).  If  NODE1 =
            ALL, NODE2 and NINC are ignored and pattern is all selected nodes
            [NSEL].  If NODE1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  A
            component name may also be substituted for NODE1 (NODE2 and NINC
            are ignored).

        rx, ry, rz
            Scale factor ratios.  Scaling is relative to the origin of the
            active coordinate system (RR, Rθ, RZ for cylindrical, RR, Rθ, RΦ
            for spherical or toroidal).  If absolute value of ratio > 1.0,
            pattern is enlarged.  If < 1.0, pattern is reduced.  Ratios default
            to 1.0 (each).

        Notes
        -----
        Generates a scaled pattern of nodes from a given node pattern.  Scaling
        is done in the active coordinate system.  Nodes in the pattern may have
        been generated in any coordinate system.

        This command is also valid in the /MAP processor.
        """
        command = "NSCALE,%s,%s,%s,%s,%s,%s,%s" % (str(inc), str(node1), str(node2), str(ninc), str(rx), str(ry), str(rz))
        return self.run(command, **kwargs)

    def vsymm(self, ncomp="", nv1="", nv2="", ninc="", kinc="", noelem="",
              imove="", **kwargs):
        """APDL Command: VSYMM

        Generates volumes from a volume pattern by symmetry reflection.

        Parameters
        ----------
        ncomp
            Symmetry key:

            X - X symmetry (default).

            Y - Y symmetry.

            Z - Z symmetry.

        nv1, nv2, ninc
            Reflect volumes from pattern beginning with NV1 to NV2 (defaults to
            NV1) in steps of NINC (defaults to 1).  If NV1 = ALL, NV2 and NINC
            are ignored and the pattern is all selected volumes [VSEL].  If NV1
            = P, graphical picking is enabled and all remaining command fields
            are ignored (valid only in the GUI).  A component name may also be
            substituted for NV1 (NV2 and NINC are ignored).

        kinc
            Keypoint increment between sets.  If zero, the lowest available
            keypoint numbers are assigned [NUMSTR].

        noelem
            Specifies whether nodes and elements are also to be generated:

            0 - Generate nodes and elements associated with the original volumes, if they
                exist.

            1 - Do not generate nodes and elements.

        imove
            Specifies whether volumes will be moved or newly defined:

            0 - Generate additional volumes.

            1 - Move original volumes to new position retaining the same keypoint numbers (KINC
                and NOELEM are ignored).  Corresponding meshed items are also
                moved if not needed at their original position.

        Notes
        -----
        Generates a reflected set of volumes (and their corresponding
        keypoints, lines, areas and mesh) from a given volume pattern by a
        symmetry reflection (see analogous node symmetry command, NSYM).  The
        MAT, TYPE, REAL, and ESYS attributes are based upon the volumes in the
        pattern and not upon the current settings.  Reflection is done in the
        active coordinate system by changing a particular coordinate sign.  The
        active coordinate system must be a Cartesian system.  Volumes in the
        pattern may have been generated in any coordinate system.   However,
        solid modeling in a toroidal coordinate system is not recommended.
        Volumes are generated as described in the VGEN command.

        See the ESYM command for additional information about symmetry
        elements.
        """
        command = "VSYMM,%s,%s,%s,%s,%s,%s,%s" % (str(ncomp), str(nv1), str(nv2), str(ninc), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def fill(self, node1="", node2="", nfill="", nstrt="", ninc="", itime="",
             inc="", space="", **kwargs):
        """APDL Command: FILL

        Generates a line of nodes between two existing nodes.

        Parameters
        ----------
        node1, node2
            Beginning and ending nodes for fill-in.  NODE1 defaults to next to
            last node specified, NODE2 defaults to last node specified.  If
            NODE1 = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI).

        nfill
            Fill NFILL nodes between NODE1 and NODE2 (defaults to
            |NODE2-NODE1|-1).  NFILL must be positive.

        nstrt
            Node number assigned to first filled-in node (defaults to NODE1 +
            NINC).

        ninc
            Add this increment to each of the remaining filled-in node numbers
            (may be positive or negative).  Defaults to the integer result of
            (NODE2-NODE1)/(NFILL + 1), i.e., linear interpolation.  If the
            default evaluates to zero, or if zero is input, NINC is set to 1.

        itime, inc
            Do fill-in operation a total of ITIMEs, incrementing NODE1, NODE2
            and NSTRT by INC each time after the first.  ITIME and INC both
            default to 1.

        space
            Spacing ratio.  Ratio of last division size to first division size.
            If > 1.0, divisions increase.  If < 1.0, divisions decrease.  Ratio
            defaults to 1.0 (uniform spacing).

        Notes
        -----
        Generates a line of nodes (in the active coordinate system) between two
        existing nodes.  The two nodes may have been defined in any coordinate
        system.  Nodal locations and rotation angles are determined by
        interpolation.  Any number of nodes may be filled-in and any node
        number sequence may be assigned.  See the CSCIR command when filling
        across the 180° singularity line in a non-Cartesian system.
        """
        command = "FILL,%s,%s,%s,%s,%s,%s,%s,%s" % (str(node1), str(node2), str(nfill), str(nstrt), str(ninc), str(itime), str(inc), str(space))
        return self.run(command, **kwargs)

    def wrk(self, num="", **kwargs):
        """APDL Command: *WRK

        Sets the active workspace number.

        Parameters
        ----------
        num
            Number of the active memory workspace for APDLMath vector and
            matrices. All the following APDLMath vectors and matrices will
            belong to this memory workspace, until the next call to the *WRK
            command. By default, all the APDLMath objects belong to workspace
            number 1.

        Notes
        -----
        This feature enables you to associate a set of vector and matrices in a
        given memory workspace, so that you can easily manage the free step:

        This feature can be useful to free all the temporary APDLMath variables
        inside a MACRO in one call.
        """
        command = "*WRK,%s" % (str(num))
        return self.run(command, **kwargs)

    def vfopt(self, opt="", filename="", ext="", dir="", filetype="",
              fileformat="", **kwargs):
        """APDL Command: VFOPT

        Specifies options for the view factor file and calculates view factors.

        Parameters
        ----------
        opt
            View factor option:

            NEW - Calculate view factors and write them to a file.

            OFF - Do not recalculate view factors it they already exist in the database,
                  otherwise calculate compute them. This option is the default
                  behavior.

            READ - Read view factors from a binary file. For subsequent SOLVE commands, switch to
                   the default option (OFF).

            NONE - Do not write view factors to a file.

        fname
            File name for view factor matrix. Default = Jobname.

        ext
            Filename extension for view factor matrix. Default = .vf.

        dir
            Directory path for view factor matrix. If you do not specify a
            directory path, it will default to your working directory.

        filetype
            View factor file type:

            BINA - Binary (default).

            ASCI - ASCII.

        fileformat
            Format for the specified Filetype:

            Binary files (Filetype = BINA): - 0

            No compression. (View factor file size may be very large.) - 1

        Notes
        -----
        The VFOPT command allows you to deactivate the view factor computation
        (Opt = OFF) if the view factors already exist in the database. The
        default behavior is OFF upon encountering the second and subsequent
        SOLVE commands in the solution processor.

        When Opt = READ, only a previously calculated view factor binary file
        is valid.

        For 3-D analyses, two options are available for calculating view
        factors when running Distributed ANSYS:

        Issue a SOLVE command -- View factors are calculated in parallel mode
        if no view factors were previously calculated.

        Issue a VFOPT,NEW command -- View factors are calculated in serial
        mode.

        For 2-D analyses, view factors are calculated in serial mode.
        """
        command = "VFOPT,%s,%s,%s,%s,%s,%s" % (str(opt), str(filename), str(ext), str(dir), str(filetype), str(fileformat))
        return self.run(command, **kwargs)

    def kpscale(self, np1="", np2="", ninc="", rx="", ry="", rz="", kinc="",
                noelem="", imove="", **kwargs):
        """APDL Command: KPSCALE

        Generates a scaled set of (meshed) keypoints from a pattern of
        keypoints.

        Parameters
        ----------
        np1, np2, ninc
            Set of keypoints (NP1 to NP2 in steps of NINC) that defines the
            pattern to be scaled.  NP2 defaults to NP1, NINC defaults to 1.  If
            NP1 = ALL, NP2 and NINC are ignored and the pattern is defined by
            all selected keypoints.  If NP1 = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).  A component name may also be substituted for NP1 (NP2 and
            NINC are ignored).

        rx, ry, rz
            Scale factors to be applied to the X, Y, Z keypoint coordinates in
            the active coordinate system (RR, Rθ, RZ for cylindrical; RR, Rθ,
            RΦ for spherical).  The Rθ and RΦ scale factors are interpreted as
            angular offsets.  For example, if CSYS = 1, an RX, RY, RZ input of
            (1.5,10,3) would scale the specified keypoints 1.5 times in the
            radial and 3 times in the Z direction, while adding an offset of 10
            degrees to the keypoints.)  Zero, blank, or negative scale factor
            values are assumed to be 1.0.  Zero or blank angular offsets have
            no effect.

        kinc
            Increment to be applied to the keypoint numbers for generated set.
            If zero, the lowest available keypoint numbers will be assigned
            [NUMSTR].

        noelem
            Specifies whether nodes and elements are also to be generated:

            0 - Nodes and point elements associated with the original keypoints will be
                generated (scaled) if they exist.

            1 - Nodes and point elements will not be generated.

        imove
            Specifies whether keypoints will be moved or newly defined:

            0 - Additional keypoints will be generated.

            1 - Original keypoints will be moved to new position (KINC and NOELEM are ignored).
                Use only if the old keypoints are no longer needed at their
                original positions.  Corresponding meshed items are also moved
                if not needed at their original position.

        Notes
        -----
        Generates a scaled set of keypoints (and corresponding mesh) from a
        pattern of keypoints.  The MAT, TYPE, REAL, and ESYS attributes are
        based on the keypoints in the pattern and not the current settings.
        Scaling is done in the active coordinate system.  Keypoints in the
        pattern could have been generated in any coordinate system.  However,
        solid modeling in a toroidal coordinate system is not recommended.
        """
        command = "KPSCALE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(np1), str(np2), str(ninc), str(rx), str(ry), str(rz), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def rcyc(self, ir="", ia="", sector="", name="", **kwargs):
        """APDL Command: RCYC

        Calculates cyclic results for a mode-superposition harmonic solution.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]). If this number is the same as for a previous
            variable, the previous variable will be overwritten with this
            result.

        ia
            Reference number of the variable to be operated on.

        sector
            Sector number to calculate the results for.

        name
            Thirty-two character name identifying the variable on listings and
            displays. Embedded blanks are compressed for output.

        Notes
        -----
        This command calculates the harmonic response in the sector specified
        by SECTOR for the variable referenced by the reference number IA. Only
        component values for IA are valid (no principles or sums). The variable
        specified by IR will contain the harmonic solution. Jobname.RFRQ from
        the cyclic mode-superposition harmonic solve and Jobname.RST or
        Jobname.RSTP from the cyclic modal solve must be available for the
        calculations to occur. The Jobname must be the same for the cyclic
        modal solve and the cyclic mode-superposition harmonic solve.

        For SECTOR > 1, the result is in the nodal coordinate system of the
        base sector, and it is rotated to the expanded sector’s location. Refer
        to Using the /CYCEXPAND Command in the Cyclic Symmetry Analysis Guide
        for more information.

        See also Mode-Superposition Harmonic Cyclic Symmetry Analysis in the
        Cyclic Symmetry Analysis Guide.
        """
        command = "RCYC,%s,%s,%s,%s" % (str(ir), str(ia), str(sector), str(name))
        return self.run(command, **kwargs)

    def pcalc(self, oper="", labr="", lab1="", lab2="", fact1="", fact2="",
              const="", **kwargs):
        """APDL Command: PCALC

        Forms additional labeled path items by operating on existing path
        items.

        Parameters
        ----------
        oper
            Type of operation to be performed.  See "Notes" below for specific
            descriptions of each operation:

            ADD - Adds two existing path items.

            MULT - Multiplies two existing path items.

            DIV - Divides two existing path items (a divide by zero results in a value of zero).

            EXP - Exponentiates and adds existing path items.

            DERI - Finds a derivative.

            INTG - Finds an integral.

            SIN - Sine.

            COS - Cosine.

            ASIN - Arcsine.

            ACOS - Arccosine.

            LOG - Natural log.

        labr
            Label assigned to the resulting path item.

        lab1
            First labeled path item in operation.

        lab2
            Second labeled path item in operation.  Lab2 must not be blank for
            the MULT, DIV, DERI, and INTG operations.

        fact1
            Factor applied to Lab1. A (blank) or '0' entry defaults to 1.0.

        fact2
            Factor applied to Lab2. A (blank) or '0' entry defaults to 1.0.

        const
            Constant value (defaults to 0.0).

        Notes
        -----
        If Oper = ADD, the command format is:

        PCALC,ADD,LabR,Lab1,Lab2,FACT1,FACT2,CONST

        This operation adds two existing path items according to the operation:

        LabR = (FACT1   x Lab1) + (FACT2 x Lab2) + CONST

        It may be used to scale the results for a single path item.

        If Oper = MULT, the command format is:

        PCALC,MULT,LabR,Lab1,Lab2,FACT1

        Lab2 must not be blank.  This operation multiplies two existing path
        items according to the operation:

        LabR = Lab1 x Lab2 x FACT1

        If Oper = DIV, the command format is:

        PCALC,DIV,LabR,Lab1,Lab2,FACT1

        Lab2 must not be blank.  This operation divides two existing path items
        according to the operation:

        LabR = (Lab1/Lab2) x FACT1

        If Oper = EXP, the command format is:

        PCALC,EXP,LabR,Lab1,Lab2,FACT1,FACT2

        This operation exponentiates and adds existing path items according to
        the operation:

        LabR = (|Lab1|FACT1) + (|Lab2|FACT2|)

        If Oper = DERI, the command format is:

        PCALC,DERI,LabR,Lab1,Lab2,FACT1

        Lab2 must not be blank.  This operation finds a derivative according to
        the operation:

        LabR = FACT1 x d(Lab1)/d(Lab2)

        If Oper = INTG, the command format is:

        PCALC,INTG,LabR,Lab1,Lab2,FACT1

        Lab2 must not be blank.  This operation finds an integral according to
        the operation:

        Use S for Lab2 to integrate Lab1 with respect to the path length.  S,
        the distance along the path, is automatically calculated by the program
        when a path item is created with the PDEF command.

        If Oper = SIN, COS, ASIN, ACOS, or LOG, the command format is:

        PCALC,Oper,LabR,Lab1,,FACT1,CONST

        where the function (SIN, COS, ASIN, ACOS or LOG) is substituted for
        Oper and Lab2 is blank.

        The operation finds the resulting path item according to one of the
        following formulas:

        LabR = FACT2 x sin(FACT1 x Lab1) + CONST

        LabR = FACT2 x cos(FACT1 x Lab1) + CONST

        LabR = FACT2 x sin-1(FACT1 x Lab1) + CONST

        LabR = FACT2 x cos-1(FACT1 x Lab1) + CONST

        LabR = FACT2 x log(FACT1 x Lab1) + CONST
        """
        command = "PCALC,%s,%s,%s,%s,%s,%s,%s" % (str(oper), str(labr), str(lab1), str(lab2), str(fact1), str(fact2), str(const))
        return self.run(command, **kwargs)

    def sph5(self, xedge1="", yedge1="", xedge2="", yedge2="", **kwargs):
        """APDL Command: SPH5

        Creates a spherical volume by diameter end points.

        Parameters
        ----------
        xedge1, yedge1
            Working plane X and Y coordinates of one edge of the sphere.

        xedge2, yedge2
            Working plane X and Y coordinates of the other edge of the sphere.

        Notes
        -----
        Defines a solid spherical volume anywhere on the working plane by
        specifying diameter end points.  The sphere must have a spatial volume
        greater than zero.  (i.e., this volume primitive command cannot be used
        to create a degenerate volume as a means of creating an area.)  A
        sphere of 360° will be defined with two areas, each consisting of a
        hemisphere.  See the SPHERE and SPH4 commands for other ways to create
        spheres.
        """
        command = "SPH5,%s,%s,%s,%s" % (str(xedge1), str(yedge1), str(xedge2), str(yedge2))
        return self.run(command, **kwargs)

    def rappnd(self, lstep="", time="", **kwargs):
        """APDL Command: RAPPND

        Appends results data from the database to the results file.

        Parameters
        ----------
        lstep
            Load step number to be assigned to the results data set.  If it is
            the same as an existing load step number on the results file, the
            appended load step will be inaccessible.  Defaults to 1.

        time
            Time value to be assigned to the results data set.  Defaults to
            0.0.  A time value greater than the last load step should be used.

        Notes
        -----
        This command is typically used to append the results from a load case
        combination to the results file.  See the LCWRITE command to create a
        separate load case file.  Only summable and constant data are written
        to the results file by default; non-summable data are not written
        unless requested (LCSUM command). RAPPND should not be used to append
        results from a harmonic analysis.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RAPPND,%s,%s" % (str(lstep), str(time))
        return self.run(command, **kwargs)

    def bioopt(self, **kwargs):
        """APDL Command: BIOOPT

        Specifies "Biot-Savart options" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "BIOOPT," % ()
        return self.run(command, **kwargs)

    def expand(self, nrepeat="", hindex="", icsys="", sctang="", ph_ase="",
               **kwargs):
        """APDL Command: EXPAND

        Displays the results of a modal cyclic symmetry analysis.

        Parameters
        ----------
        nrepeat
            Number of sector repetitions for expansion. The default is 0 (no
            expansion).

        modal
            Specifies that the expansion is for a modal cyclic symmetry
            analysis.

        hindex
            The harmonic index ID for the results to expand.

        icsys
            The coordinate system number used in the modal cyclic symmetry
            solution. The default is the global cylindrical coordinate system
            (specified via the CSYS command where KCN = 1).

        sctang
            The sector angle in degrees, equal to 360 divided by the number of
            cyclic sectors.

        --
            This field is reserved for future use.

        phase
            The phase angle in degrees to use for the expansion. The default is
            0. Typically, the value is the peak displacement (or stress/strain)
            phase angle obtained via the CYCPHASE command.

        Notes
        -----
        Issue this command to display the results of a modal cyclic symmetry
        analysis.

        When you issue the EXPAND,Nrepeat command, subsequent SET commands read
        data from the results file and expand them to Nrepeat sectors. As long
        as no entities have been modified, this expansion can be negated (that
        is, reverted to single sector) by issuing EXPAND with no arguments. If
        you modify entities and wish to return to the partial model, use the
        Session Editor (see Restoring Database Contents in the Operations
        Guide).

        EXPAND displays the results and allows you to print them, as if for a
        full model. The harmonic index (automatically retrieved from the
        results file) appears in the legend column.

        When plotting or printing element strain energy (SENE), the EXPAND
        command works with brick or tet models only. Element kinetic energy
        (KENE) plotting or printing is not supported.

        EXPAND is a specification command valid only in POST1.  It is
        significantly different from the /CYCEXPAND command in several
        respects, (although you can use either command to display the results
        of a modal cyclic symmetry analysis):

        EXPAND has none of the limitations of the /CYCEXPAND command.

        EXPAND changes the database by modifying the geometry, the nodal
        displacements, and element stresses as they are read from the results
        file, whereas the /CYCEXPAND command does not change the database.

        Caution:: : The EXPAND command creates new nodes and elements;
        therefore, saving (or issuing the /EXIT, ALL command) after issuing the
        EXPAND command can result in large databases.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EXPAND,%s,%s,%s,%s,%s" % (str(nrepeat), str(hindex), str(icsys), str(sctang), str(ph_ase))
        return self.run(command, **kwargs)

    def fitem(self, nfield="", item="", itemy="", itemz="", **kwargs):
        """APDL Command: FITEM

        Identifies items chosen by a picking operation (GUI).

        Parameters
        ----------
        nfield
            Field number on the command which uses the picking data.  (Count
            the command name as a field, so that a 2 indicates the first
            command argument, 3 the second command argument, etc.)  The
            corresponding field on the command will have a P51X label.

        item
            Entity number of the entity picked.  Negative entity numbers are
            used to indicate a range of entities.  If the item picked is a
            coordinate location, then this field represents the X-coordinate.
            See also the FLST command.

        itemy, itemz
            Y and Z coordinates of a picked coordinate location.  ITEM
            represents the X coordinate.  See also the FLST  command.

        Notes
        -----
        This is a command generated by the GUI and will appear in the log file
        (Jobname.LOG) if graphical picking is used.  This command is not
        intended to be typed in directly in an ANSYS session (although it can
        be included in an input file for batch input or for use with the /INPUT
        command).

        On the log file, a set of FITEM commands is preceded by one FLST
        command which defines the picking specifications for that pick
        operation.  The data listed in the FITEM commands are used by the first
        subsequent command containing a P51X label in one of its fields.

        Caution:: : For a given entity type, a list containing an ITEM that is
        larger than the maximum defined entity, could deplete the system memory
        and produce unpredictable results.

        This command is valid in any processor.
        """
        command = "FITEM,%s,%s,%s,%s" % (str(nfield), str(item), str(itemy), str(itemz))
        return self.run(command, **kwargs)

    def prod(self, ir="", ia="", ib="", ic="", name="", facta="", factb="",
             factc="", **kwargs):
        """APDL Command: PROD

        Multiplies variables.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        ia, ib, ic
            Reference numbers of the three variables to be operated on.  If
            only two leave IC blank.  If only one, leave IB blank also.

        name
            Thirty-two character name identifying the variable on printouts and
            displays.  Embedded blanks are compressed for output.

        --, --
            Unused fields

        facta, factb, factc
            Scaling factors (positive or negative) applied to the corresponding
            variables (default to 1.0).

        Notes
        -----
        Multiplies variables (up to three at once) according to the operation:

        IR = (FACTA x IA) x (FACTB x IB) x (FACTC x IC)
        """
        command = "PROD,%s,%s,%s,%s,%s,%s,%s,%s" % (str(ir), str(ia), str(ib), str(ic), str(name), str(facta), str(factb), str(factc))
        return self.run(command, **kwargs)

    def sectype(self, secid="", type="", subtype="", name="", refinekey="",
                **kwargs):
        """APDL Command: SECTYPE

        Associates section type information with a section ID number.

        Parameters
        ----------
        secid
            Section identification number.

        type
            BEAM

            BEAM - Defines a beam section.

            TAPER - Defines a tapered beam or pipe section. The sections at the end points must be
                    topologically identical.

            GENB - Defines a nonlinear general (temperature-dependent) beam section.

            COMB - Defines a composite (temperature-dependent) beam section.

            PIPE - Defines a pipe section.

            LINK - Defines a link section.

            AXIS - Define the axis for a general axisymmetric section.

            SHELL - Defines a shell section.

            GENS - Defines a preintegrated general (temperature-dependent) shell section.

            PRETENSION - Defines a pretension section.

            JOINT - Defines a joint section.

            REINF - Defines a reinforcing section.

            CONTACT - Defines a contact section.

        subtype
            When Type = BEAM, the possible beam sections that can be defined
            for Subtype are:

        name
            An eight-character name for the section. Name can be a string such
            as "W36X210" or "HP13X73" for beam sections. Section name can
            consist of letters and numbers, but cannot contain punctuation,
            special characters, or spaces.

        refinekey
            Sets mesh refinement level for thin-walled beam sections. Valid
            values are 0 (the default - no mesh refinement) through 5 (high
            level of mesh refinement). This value has meaning only when Type =
            BEAM.

        Notes
        -----
        SECTYPE sets the section ID number, section type, and subtype for a
        section. If the section ID number is not specified, ANSYS increments
        the highest section ID number currently defined in the database by one.
        A previously-defined section with the same identification number will
        be redefined. The geometry data describing this section type is defined
        by a subsequent SECDATA command. Define the offsets by a subsequent
        SECOFFSET command. The SLIST command lists the section properties, and
        the SECPLOT command displays the section to scale. The SECNUM command
        assigns the section ID number to a subsequently-defined beam element.

        For a beam section (Type = BEAM), a subsequent SECDATA command builds a
        numeric model using a nine-node cell for determining the properties
        (Ixx, Iyy, etc.) of the section and for the solution to the Poisson's
        equation for torsional behavior. See Beam Analysis and Cross Sections
        in the Structural Analysis Guide for examples using the section
        commands.

        For a nonlinear general beam section (Type = GENB), the Subtype and
        REFINEKEY options do not apply. Subsequent commands are necessary to
        define the section: BSAX, BSM1, BSM2, BSTQ, BSS1, BSS2, BSMD, and BSTE
        are available. All other section commands are ignored for this section
        type.

        For a preintegrated composite-beam section (Type = COMB), the REFINEKEY
        options do not apply. Subsequent commands are necessary to define the
        section: CBTMP, CBMX, CBMD, and CBTE are available. All other section
        commands are ignored for this section type.

        For a tapered beam or pipe section (Type = TAPER), two subsequent
        SECDATA commands are required (one for each end section). Section ends
        must be topologically identical (same Subtype, number of cells and
        material IDs). For a tapered pipe section, end sections must have the
        same number of cells around the circumference and along the pipe wall,
        and the same shell section ID for a composite pipe wall.

        """
        command = "SECTYPE,%s,%s,%s,%s,%s" % (str(secid), str(type), str(subtype), str(name), str(refinekey))
        return self.run(command, **kwargs)

    def elem(self, **kwargs):
        """APDL Command: ELEM

        Specifies "Elements" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command. Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu>: List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "ELEM," % ()
        return self.run(command, **kwargs)

    def mail(self, address="", fname="", ext="", **kwargs):
        """APDL Command: /MAIL

        Mails file to the specified address.

        Parameters
        ----------
        --
            Unused field.

        address
            Email address (up to 64 characters) of the intended recipient of
            the file.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        Notes
        -----
        Issue the /MAIL command to alert someone when a long-running job has
        completed, as shown in this example:

        If you are running ANSYS in a Microsoft Windows environment, you must
        cofigure BLAT
        """
        command = "/MAIL,%s,%s,%s" % (str(address), str(fname), str(ext))
        return self.run(command, **kwargs)

    def replot(self, label="", **kwargs):
        """APDL Command: /REPLOT

        Automatically reissues the last display command for convenience.

        Parameters
        ----------
        label
            Controls the type of replot.

            RESIZE - Issued internally when a graphics window resize occurs (Default).

            FAST - Only applicable for 3-D devices that allow a fast redisplay for changes in the
                   view characteristics only.

        Notes
        -----
        Reissues the last display command (NPLOT, EPLOT, KPLOT, PLNSOL, PLVAR,
        etc.), along with its parameters, for convenience.  The current display
        specifications are used.

        When the last display command is invalid in a particular processor, the
        use of the /REPLOT command is also invalid in that processor.  However,
        if you attempt a /REPLOT and the last display command is invalid in the
        current processor, ANSYS produces an element display [EPLOT] instead,
        as long as the last display command was PLNSOL, PLESOL, or PLDISP.
        ANSYS performs this substitution of /REPLOT with EPLOT for your
        convenience.

        For example, the PLNSOL command, which is used to display solution
        results as continuous contours, is a valid command in the general
        postprocessor [/POST1].  If you issue PLNSOL followed by /REPLOT while
        in the general postprocessor, the /REPLOT command effectively reissues
        your earlier PLNSOL command, along with its parameters.  But if you
        then exit the general postprocessor, enter the preprocessor [/PREP7],
        and issue the /REPLOT command again, ANSYS internally issues EPLOT
        instead.  This occurs because PLNSOL is not a valid command in the
        preprocessor.

        When you click on one of the buttons on the  Pan, Zoom, Rotate dialog
        box to manipulate the view of a model, the /REPLOT command is issued
        internally.  Thus, the substitution of /REPLOT with EPLOT as described
        above may occur not only for the PLNSOL, PLESOL, and PLDISP results
        display commands, but also for operations that you perform with the
        Pan, Zoom, Rotate dialog box.

        /REPLOT will not show boundary conditions if they are only applied to a
        solid model and the last display command (for example, EPLOT) displays
        the finite element model. To show boundary conditions, the following
        options are available:

        Issue /REPLOT after you issue the SBCTRAN command to transfer solid
        model boundary conditions to the finite element model.

        Issue /REPLOT after you issue a solid model display command (for
        example, VPLOT).

        This command is valid in any processor (except as noted above).
        """
        command = "/REPLOT,%s" % (str(label))
        return self.run(command, **kwargs)

    def taxis(self, parmloc="", naxis="", val1="", val2="", val3="", val4="",
              val5="", val6="", val7="", val8="", val9="", val10="", **kwargs):
        """APDL Command: *TAXIS

        Defines table index numbers.

        Parameters
        ----------
        parmloc
            Name and starting location in the table array parameter for
            indexing. Indexing occurs along the axis defined with nAxis.

        naxis
            Axis along which indexing occurs.  Valid labels are:

            Corresponds to Row. Default. - Corresponds to Column.

            Corresponds to Plane. - Corresponds to Book.

            Corresponds to Shelf. - Lists all index numbers. Valid only if Val1 = LIST.

        val1, val2, val3, . . . , val10
            Values of the index numbers for the axis nAxis, starting from the
            table array parameter location ParmLoc. You can define up to ten
            values.

        Notes
        -----
        *TAXIS is a convenient method to define table index values. These
        values reside in the zero column, row, etc. Instead of filling values
        in these zero location spots, use the *TAXIS command. For example,

         would fill index values 1.0, 2.2, 3.5, 4.7, and 5.9 in nAxis 2 (column
        location), starting at location 4.

        To list index numbers, issue *TAXIS,ParmLoc, nAxis, LIST, where nAxis =
        1 through 5 or ALL.
        """
        command = "*TAXIS,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(parmloc), str(naxis), str(val1), str(val2), str(val3), str(val4), str(val5), str(val6), str(val7), str(val8), str(val9), str(val10))
        return self.run(command, **kwargs)

    def coriolis(self, option="", refframe="", rotdamp="", **kwargs):
        """APDL Command: CORIOLIS

        Applies the Coriolis effect to a rotating structure.

        Parameters
        ----------
        option
            Flag to activate or deactivate the Coriolis effect:

            1 (ON or YES) - Activate. This value is the default.

            0 (OFF or NO) - Deactivate.

        --, --
            Unused fields.

        refframe
            Flag to activate or deactivate a stationary reference frame.

            1 (ON or YES) - Activate.

            0 (OFF or NO) - Deactivate. This value is the default.

        rotdamp
            Flag to activate or deactivate rotating damping effect.

            1 (ON or YES) - Activate.

            0 (OFF or NO) - Deactivate. This value is the default.

        Notes
        -----
        The CORIOLIS command is used for analyses in either a rotating or a
        stationary reference frame, and performs differently according to the
        designated RefFrame value. Specific restrictions and elements apply to
        each case, as follows:

        ROTATING REFERENCE FRAME (RefFrame = OFF):

        The command applies the Coriolis effect in the following structural
        element types: MASS21, SHELL181, PLANE182, PLANE183, SOLID185,
        SOLID186, SOLID187, BEAM188, BEAM189, SOLSH190, SHELL281, PIPE288 and
        PIPE289. It also applies this effect in the PLANE223, SOLID226, and
        SOLID227 analyses with structural degrees of freedom.

        In a rotating reference frame, both the Coriolis and spin-softening
        effects contribute to the gyroscopic moment. Therefore, ANSYS applies
        spin-softening by default for dynamic analyses. If a rotational
        velocity is specified (OMEGA or CMOMEGA), centrifugal forces will be
        included.

        To include Coriolis effects in a large deflection prestressed analysis,
        follow the procedure for linear perturbation detailed in Considerations
        for Rotating Structures. In a nonlinear transient analysis
        (ANTYPE,TRANS and NLGEOM, ON), any spinning motion applied through
        either the IC of the D commands will include the Coriolis effect
        without having to issue the CORIOLIS command. Refer to Rotating
        Structure Analysis in the Advanced Analysis Guide for more information.

        STATIONARY REFERENCE FRAME (RefFrame = ON):

        The command activates the gyroscopic damping matrix in the following
        structural elements: MASS21, BEAM188, SHELL181, BEAM189, SOLID185,
        SOLID186, SOLID187, SOLID272, SOLID273, SHELL281, PIPE288, PIPE289, and
        MATRIX50.

        The rotating structure must be axisymmetric about the axis of rotation.

        Static analysis (ANTYPE, STATIC) does not support Coriolis effects with
        a stationary reference frame. However, you can include the gyroscopic
        effects in a prestresses analysis follow the procedure detailed in
        Considerations for Rotating Structures.

        Rotating damping effect (RotDamp = ON) applies only for the stationary
        reference frame. Therefore, this effect is supported only by the
        elements listed above that generate a gyroscopic damping matrix.
        Proportional damping must be present in the element (MP,BETD or BETAD).
        It is also supported by element COMBI214 with non zero and axisymmetric
        damping characteristics (non zero real constants C11=C22 and
        C21=C12=0).

        For more information about using the CORIOLIS command, see Rotating
        Structure Analysis in the Advanced Analysis Guide and also in the
        Rotordynamic Analysis Guide. For details about the Coriolis and
        gyroscopic effect element formulations, see the Mechanical APDL Theory
        Reference.

        This command is also valid in PREP7.
        """
        command = "CORIOLIS,%s,%s,%s" % (str(option), str(refframe), str(rotdamp))
        return self.run(command, **kwargs)

    def mfanalysis(self, key="", **kwargs):
        """APDL Command: MFANALYSIS

        Activates or deactivates an ANSYS Multi-field solver analysis.

        Parameters
        ----------
        key
            Multifield analysis key:

            ON - Activates an ANSYS Multi-field solver analysis.

            OFF - Deactivates an ANSYS Multi-field solver analysis (default).

        Notes
        -----
        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFANALYSIS,%s" % (str(key))
        return self.run(command, **kwargs)

    def resume(self, fname="", ext="", nopar="", knoplot="", **kwargs):
        """APDL Command: RESUME

        Resumes the database from the database file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        nopar
            Parameter resume key:

            0 - All data in the database, including the scalar parameters, are replaced with
                the data saved on File.DB (default).

            1 - All data in the database, except the scalar parameters, are replaced with the
                data saved on File.DB.

        knoplot
            If equal to 1, will suppress automatic plot. Otherwise, if the GUI
            is on and this RESUME command was not read from a file, the
            selected elements from Fname are plotted. (If there are no selected
            elements, selected nodes are plotted. If no nodes, volumes; if no
            volumes, areas; if no areas, lines; if no lines, keypoints. If
            there are no selected keypoints, the screen is erased.)

        Notes
        -----
        The RESUME command resumes a database file into the ANSYS program. The
        command causes the database file (File.DB) to be read, thereby
        resetting the database (including any geometry settings) either a) as
        it was at the last SAVE command, or b) as it was saved with the last
        /EXIT command, whichever was last.

        For multiple load step analyses (because only the data for one load
        step at a time may reside in the database), the load step data restored
        to the database will correspond to the load step data written when the
        save occurred.

        If the database file was saved in another ANSYS, Inc. product, it may
        contain element type and KEYOPT specifications which are invalid in the
        resuming product. Immediately after the database resume is completed,
        you should redefine these invalid element types and KEYOPT settings to
        valid ones (ET, KEYOPT).

        The NOPAR = 1 option should not be used if array parameters are
        defined, as existing array parameters might be redefined with arbitrary
        values. For a more general method of preventing the replacement of both
        scalar and array parameters, see PARSAV and PARRES.)

        This command is valid in any processor.  If used in the solution
        processor, this command is valid only within the first load step.
        """
        command = "RESUME,%s,%s,%s,%s" % (str(fname), str(ext), str(nopar), str(knoplot))
        return self.run(command, **kwargs)

    def stargo(self, b_ase="", **kwargs):
        """APDL Command: *GO

        Causes a specified line on the input file to be read next.

        Parameters
        ----------
        base
            "Go to" action:

            A user-defined label (beginning with a colon (:), 8 characters maximum).  The command reader will skip (and wrap to the beginning of the file, if necessary) to the first line that begins with the matching :label.   - Caution:   This label option may not be mixed with do-loop or if-then-else
                              constructs.

        Notes
        -----
        Causes the next read to be from a specified line on the input file.
        Lines may be skipped or reread.  The *GO command will not be executed
        unless it is part of a macro, user file (processed by *USE),  an
        alternate input file (processed by /INPUT), or unless it is used in a
        batch-mode input stream.  Jumping into, out of, or within a do-loop or
        an if-then-else construct to a :label line is not allowed.

        This command is valid in any processor.
        """
        command = "*GO,%s" % (str(b_ase))
        return self.run(command, **kwargs)

    def pscr(self, kywrd="", key="", **kwargs):
        """APDL Command: PSCR

        Specifies various PostScript options.

        Parameters
        ----------
        index
            Color map index (0 to 15, 128 to 255).

        ired
            Red intensity (0 to 100).

        igrn
            Green intensity (0 to 100).

        iblu
            Blue intensity (0 to 100).

        Notes
        -----
        This command is available in both the ANSYS and DISPLAY programs.  It
        is valid for postscript format files chosen in ANSYS with the
        /SHOW,PSCR command, or in DISPLAY with /SHOWDISP,POSTSCRIPT.

        An output file is generated for each plot.  The ANSYS file is named
        JobnameNN.pscr.  In the DISPLAY program, this file is named PSCRnn.
        This file remains open for a subsequent /NOERASE plot, and will be
        incomplete until the program is closed (/EXIT), or until the next file
        is opened by the next /ERASE plot request.

        Issuing PSCR,STAT will list paper size, orientation and resolution
        modes.
        """
        command = "PSCR,%s,%s" % (str(kywrd), str(key))
        return self.run(command, **kwargs)

    def prnsol(self, item="", comp="", **kwargs):
        """APDL Command: PRNSOL

        Prints nodal solution results.

        Parameters
        ----------
        item
            Label identifying the item.  Valid item labels are shown in
            Table 225: PRNSOL - Valid Item and Component Labels below.  Some
            items also require a component label.

        comp
            Component of the item (if required).  Valid component labels are
            shown in Table 225: PRNSOL - Valid Item and Component Labels below.
            Defaults to COMP.

        Notes
        -----
        Prints the nodal solution results for the selected nodes in the sorted
        sequence. For example, PRNSOL,U,X prints the X component of
        displacement vector U (that is, the UX degree of freedom). Component
        results are in the global Cartesian coordinate directions unless
        transformed (RSYS). Various element results also depend upon the
        recalculation method and the selected results location (AVPRIN, RSYS,
        LAYER, SHELL, and NSEL). If the LAYER command is issued, then the
        resulting output is listed in full graphics mode (/GRAPHICS,FULL). You
        can use the FORCE command to define which component of the nodal load
        (static, damping, inertia, or total) should be used.

        PowerGraphics can affect your nodal solution listings. For
        PowerGraphics (/GRAPHICS,POWER), results are listed only for the model
        exterior surfaces.

        When shell element types are present, results are output on a surface-
        by-surface basis. For shell elements, such as SHELL181 or SHELL281, and
        for ELBOW290, printed output is for both the top and bottom surfaces.
        For solid elements such as SOLID185, the output is averaged for each
        surface and printed as follows:

        For a node at a vertex, three lines are output (one printed line for
        each surface).

        For a node on an edge, two lines are output (one printed line for each
        surface).

        For nodes on a face, one value is output.

        For nodes interior to the volume, no printed values are output.

        If a node is common to more than one element, or if a geometric
        discontinuity exists, several conflicting listings may result. For
        example, a corner node incorporating results from solid elements and
        shell elements could yield as many as nine different results; the
        printed output would be averages at the top and bottom for the three
        shell surfaces plus averages at the three surfaces for the solid, for a
        total of nine lines of output. ANSYS does not average result listings
        across geometric discontinuities when shell element types are present.
        It is important to analyze the listings at discontinuities to ascertain
        the significance of each set of data.

        The printed output for full graphics (/GRAPHICS,FULL) follows the
        standard ANSYS convention of averaging results at the node.  For shell
        elements, the default for display is TOP so that the results for the
        top of the shell are averaged with the other elements attached to that
        node.

        If an NSORT, ESORT or /ESHAPE command is issued with PowerGraphics
        activated, then the PRNSOL listings will be the same as in full
        graphics mode (/GRAPHICS,FULL). The items marked with [2] are not
        supported by PowerGraphics. To print midside nodes, you must first
        issue an /EFACET,2 command.

        Table: 225:: : PRNSOL - Valid Item and Component Labels

        Failure criteria  [2][4].

        Default components: Maximum of all failure criteria defined at current
        location (MAX), maximum strain (EMAX), maximum stress (SMAX), Tsai-Wu
        Strength Index (TWSI), inverse of Tsai-Wu Strength Ratio Index (TWSR).
        """
        command = "PRNSOL,%s,%s" % (str(item), str(comp))
        return self.run(command, **kwargs)

    def lsbac(self, enginename="", rhsvector="", solvector="", **kwargs):
        """APDL Command: *LSBAC

        Performs the solve (forward/backward substitution) of a factorized
        linear system.

        Parameters
        ----------
        enginename
            Name used to identify this engine. Must have been previously
            created using *LSENGINE and factorized using *LSFACTOR.

        rhsvector
            Name of vector containing the right-hand side (load) vectors as
            input. Must have been previously defined as a *VEC vector or a
            *DMAT matrix.

        solvector
            Name of vector that will contain the solution vectors upon
            completion. Must be predefined as a *VEC vector or *DMAT matrix.

        Notes
        -----
        This command performs forward and back substitution to obtain the
        solution to the linear matrix equation Ax = b. The matrix engine must
        have been previously defined using *LSENGINE, and the matrix factored
        using *LSFACTOR.

        You can use the *DMAT,,,COPY (or *VEC,,,COPY) command to copy the load
        vector to the solution vector in order to predefine it with the
        appropriate size.
        """
        command = "*LSBAC,%s,%s,%s" % (str(enginename), str(rhsvector), str(solvector))
        return self.run(command, **kwargs)

    def ednrot(self, option="", cid="", cname="", dof1="", dof2="", dof3="",
               dof4="", dof5="", dof6="", **kwargs):
        """APDL Command: EDNROT

        Applies a rotated coordinate nodal constraint in an explicit dynamics
        analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed:

            ADD - Add a rotated nodal coordinate constraint (default).

            DELE - Delete specified rotated nodal coordinate constraints.

            LIST - List all rotated nodal coordinate constraints.

        cid
            Coordinate system ID for which rotated nodal constraints will be
            added or deleted. The CID must have been previously defined with
            the EDLCS command. If Option = DELE, use CID = ALL to delete all
            previously specified nodal constraints.

        cname
            Nodal component set to which the rotated coordinate constraint will
            be applied. Cname must be previously specified using the CM
            command.

        dof1, dof2, dof3, . . . , dof6
            Degrees of freedom for which the rotated nodal constraint will be
            applied.  Valid degree of freedom labels include UX, UY, UZ, ROTX,
            ROTY, and ROTZ.  If DOF1 = ALL, rotated nodal constraints will be
            applied to all degrees of freedom.

        Notes
        -----
        Constraints applied with EDNROT are zero displacement constraints.

        This command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDNROT,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(cid), str(cname), str(dof1), str(dof2), str(dof3), str(dof4), str(dof5), str(dof6))
        return self.run(command, **kwargs)

    def mflcomm(self, type="", fname1="", intname1="", label1="", fname2="",
                intname2="", label2="", option="", **kwargs):
        """APDL Command: MFLCOMM

        Defines a load transfer for code coupling analyses.

        Parameters
        ----------
        type
             Set to SURF for a surface load transfer. Only surface load
            transfers are available for MFX.

        fname1
            Sets the field solver name for the server (sending) code with a
            case-sensitive character string of up to 80 characters.

        intname1
            Sets the interface name or number for the field solver of the
            server code. ANSYS interfaces are numbered and are defined by the
            SF family of commands (SF, SFA, or SFE) with the FSIN surface load
            label. CFX interfaces use names, which are set in CFX-Pre.

        label1
            Sets the surface load label for the field solver of the server code
            with a character string of up to 80 characters. ANSYS uses a
            combination of the label and option to determine what data is
            transferred (e.g., heat flows and not fluxes are sent with the
            label/option pair HFLU/CPP). ANSYS cannot serve total force or
            total force density to CFX for either formulation. CFX will send
            the data requested by the label regardless of the option. CFX
            labels that have more than one word must be enclosed in single
            quotes. Note that this field is case-sensitive; i.e., FORC will
            work, but forc will not.

        fname2
            Sets the field solver name for the client (receiving) code with a
            character string of up to 80 characters.

        intname2
            Sets the interface name or number for the field solver of the
            client code with a character string of up to 80 characters. ANSYS
            interfaces are numbered and are defined by the SF family of
            commands (SF, SFA, or SFE) with the FSIN surface load label. CFX
            interfaces use names, which are set in CFX-Pre.

        label2
            Sets the surface load label for the field solver of the client code
            with a character string of up to 80 characters. ANSYS uses a
            combination of the label and option to determine what data is
            transferred (e.g., heat flows and not fluxes are sent with the
            label-option pair HFLU/CPP). CFX will send the data requested by
            the label regardless of the option. CFX labels that have more than
            one word must be enclosed in single quotes. Note that this field is
            case-sensitive; i.e., FORC will work, but forc will not.

        option
            NONC

            NONC - Profile preserving: Sets the interface load transfer to the nonconservative
                   formulation (default for displacement and temperature). In
                   the nonconservative formulation, the force density (or heat
                   flux) is transferred across the interface, preserving the
                   density profile between the two fields.

            CPP - Conservative: Uses a local conservative formulation while preserving the
                  density profile (default for total force and wall heat flow).
                  In the conservative formulation, total force (or heat flow)
                  must be transferred across the interface from the CFX field
                  solver to the ANSYS field solver.

        Notes
        -----
        ANSYS input should always be in consistent units for its model.

        ANSYS uses a combination of the label and option to determine what data
        to transfer. CFX will send exactly the data requested by the label,
        regardless of the option. However, for the NONC option, the CFX label
        must be Total Force Density or Wall Heat Flux and for the CPP option,
        the CFX label must be Total Force or Wall Heat Flow.

        For more information on profile preserving and conservative load
        transfer, see Load Interpolation in the Coupled-Field Analysis Guide.
        Mapping Diagnostics are also available; however, if the improperly-
        mapped nodes are based on the CFX mesh, you should ignore the ANSYS-
        generated components because the CFX nodes are not present in the ANSYS
        database.

        If you are working interactively, you can choose two pre-defined
        combinations, Mechanical or Thermal, or you can choose a Custom option.
        If you choose the Mechanical load type, then the Total Force Density
        and Total Mesh Displacement data (corresponding to the ANSYS FORC and
        DISP labels, respectively) is transferred. If you choose the Thermal
        load type, then the Temperature and Wall Heat Flux data (corresponding
        to the ANSYS TEMP and HFLU labels, respectively) is transferred. If you
        choose Custom, you can select any valid combination of label and option
        as described above.

        The ANSYS Multi-field solver solver does not allow you to switch the
        load transfer direction for the same load quantity across the same
        interfaces for a restart run. For example, if Field1 sends temperature
        to and receives heat flow from Field2 across Interface 1 in a previous
        solution, then you cannot make Field1 send heat flow to and receive
        temperatures from Field2 across the same interface in a restart run,
        even if you cleared the corresponding load transfer command.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFLCOMM,%s,%s,%s,%s,%s,%s,%s,%s" % (str(type), str(fname1), str(intname1), str(label1), str(fname2), str(intname2), str(label2), str(option))
        return self.run(command, **kwargs)

    def madapt(self, errtargt="", nadapt="", nmax="", kplt="", ksmooth="",
               klst="", kcd="", device="", **kwargs):
        """APDL Command: MADAPT

        Adaptively meshes and solves an edge-based model.

        Parameters
        ----------
        errtargt
            Target percentage for Zienkiewitz Zhu magnetic flux error (defaults
            to 5).

        nadapt
            Maximum number of adaptive steps (defaults to 5).

        nmax
            Maximum number of elements at which the iterations may continue
            (defaults to 50,000). Limits the number of elements that can be
            chosen for refinement.

        kplt
            Plotting options:

            0 - No plot (default)

            1 - Elements and H

            2 - BERR error estimates

            3 - BDSG, BEPC error estimates

            4 - Adaptive details

        ksmooth
            Smoothing options for refinement

            0 - No postprocessing will be done (default).

            1 - Smoothing will be done.  Node locations may change.

            2 - Smoothing and cleanup will be done.  Existing elements may be deleted, and node
                locations may change.

        klst
            Listing options

            0 - No printing (default)

            1 - Final report

            2 - Report at each iteration step

            3 - Report Zienkiewitz Zhu magnetic errors BERR and BSGD

            4 - Regular details

            5 - Full details

            6 - Refine details

            7 - Track

        kcd
            Allows you to issue a CDWRITE or CDREAD at every iteration.

            0 - Do not issue CDWRITE or CDREAD (default).

            1 - Issue CDWRITE at every iteration (to save every mesh variation). This option
                issues CDWRITE,geom, writing the information to jobnameN.cdb.

            2 - Issue CDREAD at every iteration (to read every mesh variation). Reads from an
                existing jobnameN.cdb.

        device
            Defines the output device for plotting.

            0 - Screen only (default)

            1 - JPEG frames. Each frame is written to a file (jobnameN.jpg by default). See
                /SHOW.

        Notes
        -----
        MADAPT invokes a predefined ANSYS macro for adaptive meshing and
        solution of edge-based magnetic analyses.  The macro causes repeated
        runs of the PREP7, SOLUTION, and POST1 phases of the ANSYS program with
        mesh density refinements based upon the percentage error in energy
        norm.

        The MADAPT command macro requires a second, user-defined macro, which
        must be named madaptld.mac and must reside in the same directory where
        ANSYS is being run. This madaptld macro must contain loads and boundary
        conditions, based on permanent geometry or solid model features (such
        as sides or vertices). Loads specified in the madaptld macro cannot be
        based on node numbers because the node numbers will change throughout
        the refinement process. This secondary macro is required because the
        MADAPT macro process must delete all loads and boundary conditions at
        every refinement step.

        MADAPT refines tetrahedral volume elements based on error. Hexahedra,
        wedges, and pyramids are not refined (see NREFINE).

        This command is also valid at the Begin level.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MADAPT,%s,%s,%s,%s,%s,%s,%s,%s" % (str(errtargt), str(nadapt), str(nmax), str(kplt), str(ksmooth), str(klst), str(kcd), str(device))
        return self.run(command, **kwargs)

    def edcsc(self, key="", **kwargs):
        """APDL Command: EDCSC

        Specifies whether to use subcycling in an explicit dynamics analysis.

        Parameters
        ----------
        key
            Subcycling key:

            OFF - Do not use subcycling (default).

            ON - Use subcycling.

        Notes
        -----
        Subcycling can be used to speed up an analysis when element sizes
        within a model vary significantly. Relatively small elements will
        result in a small time step size. When subcycling is on, the minimum
        time step size is increased for the smallest elements.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDCSC,%s" % (str(key))
        return self.run(command, **kwargs)

    def rename(self, fname1="", ext1="", fname2="", ext2="", distkey="",
               **kwargs):
        """APDL Command: /RENAME

        Renames a file.

        Parameters
        ----------
        fname1
            The file to be renamed. You can also include an optional directory
            path as part of the specified file name; if not, the default file
            location is the working directory.

        ext1
            Filename extension (eight-character maximum).

        --
            Unused field.

        fname2
            The new name for the file. You can also include an optional
            directory path as part of the new file name; if not, the default is
            the working directory. A maximum of 248 characters is allowed for
            the file name (or combined file name and directory path, if both
            are specified).

        ext2
            Filename extension (eight-character maximum).

        --
            Unused field.

        distkey
            Key that specifies whether the rename operation is performed on all
            processes in distributed parallel mode (Distributed ANSYS):

            1 (ON or YES) - The program performs the rename operation locally on each process.

            0 (OFF or NO) - The program performs the rename operation only on the master process (default).

        Notes
        -----
        Renames a file.  Ex:  /RENAME,A,,,B renames file A to B in the same
        directory.  /RENAME,A,DAT,,,INP renames file A.DAT to A.INP. On all
        systems, this command will overwrite any existing file named B. See the
        Operations Guide for details. Only ANSYS binary files should be
        renamed. Use /SYS and system renaming commands for other files.

        In distributed parallel mode (Distributed ANSYS), only the master
        process will rename Fname1.Ext1 to Fname2.Ext2 by default. However,
        when DistKey is set to 1 (or ON or YES), the command is executed by all
        processes. In this case, Fname1 and Fname2 will automatically have the
        process rank appended to them. This means Fname1N.Ext1 will be renamed
        to Fname2N.Ext2 by all processes, where N is the Distributed ANSYS
        process rank. For more information see Differences in General Behavior
        in the Parallel Processing Guide.

        Renaming across system partitions may be internally done by a copy and
        delete operation on some systems.

        This command is valid only at the Begin Level.
        """
        command = "/RENAME,%s,%s,%s,%s,%s" % (str(fname1), str(ext1), str(fname2), str(ext2), str(distkey))
        return self.run(command, **kwargs)

    def lesize(self, nl1="", size="", angsiz="", ndiv="", space="", kforc="",
               layer1="", layer2="", kyndiv="", **kwargs):
        """APDL Command: LESIZE

        Specifies the divisions and spacing ratio on unmeshed lines.

        Parameters
        ----------
        nl1
            Number of the line to be modified.  If ALL, modify all selected
            lines [LSEL].  If NL1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  A
            component name may also be substituted for NL1.

        size
            If NDIV is blank, SIZE is the division (element edge) length.  The
            number of divisions is automatically calculated from the line
            length (rounded upward to next integer).  If SIZE is zero (or
            blank), use ANGSIZ or NDIV.

        angsiz
            The division arc (in degrees) spanned by the element edge (except
            for straight lines, which always result in one division).  The
            number of divisions is automatically calculated from the line
            length (rounded upward to next integer).

        ndiv
            If positive, NDIV is the number of element divisions per line.  If
            -1 (and KFORC = 1), NDIV is assumed to be zero element divisions
            per line. TARGE169 with a rigid specification ignores NDIV and will
            always mesh with one element division.

        space
            Spacing ratio.  If positive, nominal ratio of last division size to
            first division size (if > 1.0, sizes increase, if < 1.0, sizes
            decrease).  If negative, |SPACE| is nominal ratio of center
            division(s) size to end divisions size.  Ratio defaults to 1.0
            (uniform spacing). For layer-meshing, a value of 1.0 normally is
            used. If SPACE = FREE, ratio is determined by other considerations

        kforc
            KFORC 0-3 are used only with NL1 = ALL.  Specifies which selected
            lines are to be modified.

            0 - Modify only selected lines having undefined (zero) divisions.

            1 - Modify all selected lines.

            2 - Modify only selected lines having fewer divisions (including zero) than
                specified with this command.

            3 - Modify only selected lines having more divisions than specified with this
                command.

            4 - Modify only nonzero settings for SIZE, ANGSIZ, NDIV,  SPACE, LAYER1, and
                LAYER2.  If KFORC = 4, blank or 0 settings remain unchanged.

        layer1
            Layer-meshing control parameter.  Distance which defines the
            thickness of the inner mesh layer, LAYER1.  Elements in this layer
            are uniformly-sized with edge lengths equal to the specified
            element size for the line (either through SIZE or line-
            length/NDIV).  A positive value for LAYER1 is interpreted as an
            absolute length, while a negative value in interpreted as a
            multiplier on the specified element size for the line.  As a
            general rule, the resulting thickness of the inner mesh layer
            should be greater than or equal to the specified element size for
            the line.  If LAYER1 = OFF, layer-meshing control settings are
            cleared for the selected lines.  The default value is 0.0

        layer2
            Layer-meshing control parameter.  Distance which defines the
            thickness of the outer mesh layer, LAYER2.  Elements in this layer
            transition in size from those in LAYER1 to the global element size.
            A positive value of LAYER2 is interpreted as an absolute length,
            while a negative value is interpreted as a mesh transition factor.
            A value of LAYER2 = -2 would indicate that elements should
            approximately double in size as the mesh progresses normal to
            LAYER1. The default value is 0.0.

        kyndiv
            0, No, and Off means that SmartSizing cannot override specified
            divisions and spacing ratios. Mapped mesh fails if divisions do not
            match. This defines the specification as "hard".

        Notes
        -----
        Defines the number of divisions and the spacing ratio on selected
        lines.  Lines with previously specified divisions may also be changed.

        This command is also valid for rezoning.
        """
        command = "LESIZE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nl1), str(size), str(angsiz), str(ndiv), str(space), str(kforc), str(layer1), str(layer2), str(kyndiv))
        return self.run(command, **kwargs)

    def einfin(self, compname="", pnode="", **kwargs):
        """APDL Command: EINFIN

        Generates structural infinite elements from selected nodes.

        Parameters
        ----------
        compname
            Component name containing one node to be used as the pole node for
            generating INFIN257 structural infinite elements. The pole node is
            generally located at or near the geometric center of the finite
            element domain.

        pnode
            Node number for the direct input of the pole node. A parameter or
            parametric expression is also valid. Specify this value when no
            CompName has been specified. If CompName is specified, this value
            is ignored.

        Notes
        -----
        The EINFIN command generates structural infinite elements (INFIN257)
        directly from the selected face of valid base elements (existing
        standard elements in your model). The command scans all base elements
        for the selected nodes and generates a compatible infinite element type
        for each base element. A combination of different base element types is
        allowed if the types are all compatible with the infinite elements.

        The infinite element type requires no predefinition (ET).

        The faces of base elements are determined from the selected node set
        (NSEL), and the geometry of the infinite element is determined based on
        the shape of the face. Element characteristics and options are
        determined according to the base element. For the face to be used, all
        nodes on the face of a base element must be selected

        Use base elements to model the near-field domain that interacts with
        the solid structures or applied loads. To apply the truncated far-field
        effect, a single layer of infinite elements must be attached to the
        near-field domain. The outer surface of the near-field domain must be
        convex.

        After the EINFIN command executes, you can verify the newly created
        infinite element types and elements (ETLIST, ELIST, EPLOT).

        Infinite elements do not account for any subsequent modifications made
        to the base elements. It is good practice to issue the EINFIN command
        only after the base elements are finalized. If you delete or modify
        base elements, remove all affected infinite elements and reissue the
        EINFIN command; doing so prevents inconsistencies.
        """
        command = "EINFIN,%s,%s" % (str(compname), str(pnode))
        return self.run(command, **kwargs)

    def cycphase(self, type="", option="", **kwargs):
        """APDL Command: CYCPHASE

        Provides tools for determining minimum and maximum possible result
        values from frequency couplets produced in a modal cyclic symmetry
        analysis.

        Parameters
        ----------
        type
            The type of operation requested:

            DISP - Calculate the maximum and minimum possible displacement at each node in the
                   original sector model.  Store the values and the phase angle
                   at which they occurred.

            STRESS - Calculate the maximum and minimum possible stresses at each node in the
                     original sector model.  Store the values and the phase
                     angle at which they occurred.

            STRAIN - Calculate the maximum and minimum possible strains at each node in the original
                     sector model.  Store the values and the phase angle at
                     which they occurred.

            ALL - Calculate the maximum and minimum possible displacement, stress and strain at
                  each node in the original sector model.  Store the values and
                  the phase angle at which they occurred.

            GET - Places the value of a MAX or MIN item into the _CYCVALUE parameter, the node
                  for that value in the _CYCNODE parameter, and the phase angle
                  for the value in the _CYCPHASE parameter.

            PUT - Put resulting sweep values for printing (via the PRNSOL command ) or plotting
                  (via the PLNSOL command).

            LIST - List the current minimum/maximum displacement, stress and strain nodal values.

            STAT - Summarize the results of the last phase sweep.

            CLEAR - Clear phase-sweep information from the database.

        option
            If TYPE = DISP, STRAIN, STRESS or ALL, controls the sweep angle
            increment to use in the search:

            Angle - The sweep angle increment in degrees, greater than 0.1 and less than 10. The
                    default is 1.

        Notes
        -----
        When you expand the results of a modal cyclic symmetry analysis (via
        the /CYCEXPAND or EXPAND command), ANSYS combines the real and
        imaginary results for a given nodal diameter, assuming no phase shift
        between them; however, the modal response can occur at any phase shift.

        CYCPHASE response results are valid only for the first cyclic sector.
        To obtain the response at any part of the expanded model, ANSYS, Inc.
        recommends using cyclic symmetry results expansion at the phase angle
        obtained via CYCPHASE.

        The phase angles returned by CYCPHASE contain the minimum and maximum
        values for USUM, SEQV and other scalar principal stress and strain
        quantities; however, they do not always return the true minimum and
        maximum values for directional quantities like UX or SX unless the
        values fall in the first sector.

        CYCPHASE does not consider midside node values when evaluating maximum
        and minimum values, which may affect DISPLAY quantities but no others.
        (Typically, ANSYS ignores midside node stresses and strains during
        postprocessing.)

        Issuing CYCPHASE,PUT clears the result values for midside nodes on high
        order elements; therefore, this option sets element faceting (/EFACET)
        to 1. The command reports that midside nodal values are set to zero and
        indicates that element faceting is set to 1.

        If the sweep values are available after issuing a CYCPHASE,PUT command,
        the PRNSOL or PLNSOL command will print or plot (respectively) the
        sweep values of structure displacement Ux, Uy, Uz, component
        stress/strain X, Y, Z, XY, YZ, ZX, principal stress/strain 1, 2, 3 and
        equivalent stress/strain EQV.  The vector sum of displacement (USUM)
        and stress/strain intensity (SINT) are not valid phase-sweep results.

        You can specify any coordinate system via the RSYS command for
        displaying or printing CYCPHASE results. However, after CYCPHASE
        results have been extracted, you cannot then transform them via the
        RSYS command. If you try to do so, ANSYS issues a warning message.

        The CYCPHASE command is valid in /POST1 and for cyclically symmetric
        models only.

        To learn more about analyzing a cyclically symmetric structure, see the
        Cyclic Symmetry Analysis Guide.
        """
        command = "CYCPHASE,%s,%s" % (str(type), str(option))
        return self.run(command, **kwargs)

    def pcopy(self, key="", **kwargs):
        """APDL Command: /PCOPY

        Automatically generates hard copies for HP UNIX work stations.

        Parameters
        ----------
        key
            Copy key:

            0 - No specification setting for automatic hard copy of display.

            1 - Set specification for automatic hard copy after each display.

            NOW - (Action) Produce hard copy of current display (KEY is not reset to 1).

        Notes
        -----
        Sets automatic hard copy specification.  This command is available only
        on HP work stations, and only during interactive runs with the /SHOW
        specification active (for terminals with hard copy capability).

        This command is valid in any processor.
        """
        command = "/PCOPY,%s" % (str(key))
        return self.run(command, **kwargs)

    def nsort(self, item="", comp="", order="", kabs="", numb="", sel="",
              **kwargs):
        """APDL Command: NSORT

        Sorts nodal data.

        Parameters
        ----------
        item
            Label identifying the item to be sorted on.  Valid item labels are
            shown in the table below.  Some items also require a component
            label.

        comp
            Component of the item (if required).  Valid component labels are
            shown in the table below.

        order
            Order of sort operation:

            0 - Sort into descending order.

            1 - Sort into ascending order.

        kabs
            Absolute value key:

            0 - Sort according to real value.

            1 - Sort according to absolute value.

        numb
            Number of nodal data records to be sorted in ascending or
            descending order (ORDER) before sort is stopped (remainder will be
            in unsorted sequence) (defaults to all nodes).

        sel
            Allows selection of nodes in the sorted field.

            (blank) - No selection (default).

            SELECT - Select the nodes in the sorted list.

        Notes
        -----
        Values are in the active coordinate system [CSYS for input data or RSYS
        for results data].  Various element results also depend upon the
        recalculation method and the selected results location [AVPRIN, RSYS,
        SHELL, ESEL, and NSEL].  If simultaneous load cases are stored, the
        last sorted sequence formed from any load case applies to all load
        cases.  Use NUSORT to restore the original order.   This command is not
        valid with PowerGraphics.

        Table: 213:: : NSORT - Valid Item and Component Labels

        Table: 214:: : NSORT - Valid Item and Component Labels for Nodal DOF
        Result Values

        Table: 215:: : NSORT - Valid Item and Component Labels for Element
        Result Values

        Works only if failure criteria information is provided. (For more
        information, see the documentation for the FC and TB commands.)

        Must be added via the FCTYP command first.
        """
        command = "NSORT,%s,%s,%s,%s,%s,%s" % (str(item), str(comp), str(order), str(kabs), str(numb), str(sel))
        return self.run(command, **kwargs)

    def fjlist(self, elem="", **kwargs):
        """APDL Command: FJLIST

        Lists forces and moments applied on joint elements.

        Parameters
        ----------
        elem
            Element number or ALL (or blank). Lists joint element forces and
            moments on the specified element(s).

        Notes
        -----
        Valid for MPC184 joint elements. See FJ for information on specifying
        forces and moments.
        """
        command = "FJLIST,%s" % (str(elem))
        return self.run(command, **kwargs)

    def sfllist(self, line="", lab="", **kwargs):
        """APDL Command: SFLLIST

        Lists the surface loads for lines.

        Parameters
        ----------
        line
            Line at which surface load is to be listed.  If ALL (or blank),
            list for all selected lines [LSEL].  If LINE = P, graphical picking
            is enabled and all remaining command fields are ignored (valid only
            in the GUI).  A component name may be substituted for LINE.

        lab
            Valid surface load label.  If ALL (or blank), use all appropriate
            labels.  See the SFL command for labels.

        Notes
        -----
        Lists the surface loads for the specified line.

        This command is valid in any processor.
        """
        command = "SFLLIST,%s,%s" % (str(line), str(lab))
        return self.run(command, **kwargs)

    def larc(self, p1="", p2="", pc="", rad="", **kwargs):
        """APDL Command: LARC

        Defines a circular arc.

        Parameters
        ----------
        p1
            Keypoint at one end of circular arc line.  If P1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).

        p2
            Keypoint at other end of circular arc line.

        pc
            Keypoint defining plane of arc and center of curvature side (with
            positive radius).  Must not lie along the straight line from P1 to
            P2.  PC need not be at the center of curvature.

        rad
            Radius of curvature of the arc.  If negative, assume center of
            curvature side is opposite to that defined by PC.  If RAD is blank,
            RAD will be calculated from a curve fit through P1, PC, and P2.

        Notes
        -----
        Defines a circular arc line from P1 to P2.  The line shape is generated
        as circular, regardless of the active coordinate system.  The line
        shape is invariant with coordinate system after it is generated.

        When dealing with a large radius arc (1e3), or if the location of the
        arc you create is far away from the origin of your coordinate system,
        anomalies may occur. You can prevent this by creating the arc at a
        smaller scale, and then scaling the model back to full size (LSSCALE).
        """
        command = "LARC,%s,%s,%s,%s" % (str(p1), str(p2), str(pc), str(rad))
        return self.run(command, **kwargs)

    def nslv(self, type="", nkey="", **kwargs):
        """APDL Command: NSLV

        Selects those nodes associated with the selected volumes.

        Parameters
        ----------
        type
            Label identifying the type of node select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        nkey
            Specifies whether only interior volume nodes are to be selected:

            0 - Select only nodes interior to selected volumes.

            1 - Select all nodes (interior to volume, interior to areas, interior to lines, and
                at keypoints) associated with the selected volumes.

        Notes
        -----
        Valid only if the nodes were generated by a volume meshing operation
        [VMESH] on a solid model that contains the selected volumes.

        This command is valid in any processor.
        """
        command = "NSLV,%s,%s" % (str(type), str(nkey))
        return self.run(command, **kwargs)

    def plcfreq(self, spec="", sectbeg="", sectend="", **kwargs):
        """APDL Command: PLCFREQ

        Plots the frequency response for the given CYCSPEC specification.

        Parameters
        ----------
        spec
            CYCSPEC specification number (ordered 1 to N in the order input;
            use CYCSPEC,LIST to view the current list order). Defaults to 1.

        sectbeg
            Beginning sector number to plot. Defaults to 1.

        sectend
            Ending sector number to plot. Defaults to the total number of
            sectors expanded (/CYCEXPAND).

        Notes
        -----
        Following a cyclic mode-superposition harmonic analysis, this command
        plots the result item given by a CYCSPEC specification versus the
        harmonic frequency, one curve for each of the specified sectors. A
        CYCCALC command must have been issued prior to this command.
        """
        command = "PLCFREQ,%s,%s,%s" % (str(spec), str(sectbeg), str(sectend))
        return self.run(command, **kwargs)

    def cycopt(self, option="", value1="", value2="", value3="", value4="",
               value5="", value6="", value7="", **kwargs):
        """APDL Command: CYCOPT

        Specifies solution options for a cyclic symmetry analysis.

        Parameters
        ----------
        option
            One of the following options:

            BCMULT - Controls whether cyclic sector array parameter names are reused or created new
                     for multiple entities.

            Value1 - The flag value.

            0 (OFF or NO) - Create new array parameter names (default)

            1(ON or YES) - Reuse array parameter names

            COMBINE - For linear static cyclic symmetry analysis with non-cyclically symmetric
                      loading only, expands and combines all harmonic index
                      solutions and writes them to the results file during the
                      solution phase of the analysis.

            Value1 - The flag value.

            0 (OFF or NO) - Disable combining of harmonic index solutions (default)

            1 (ON or YES) - Enable combining of harmonic index solutions

            DEFAULT - Set the default cyclic solution settings.

            DOF - The degrees of freedom to couple from the nodes on the low sector boundary to
                  nodes on the high boundary:

            Value1 - The component pair ID number.

            Value2, Value3, Value4,  . . . ,  Value7 - The constraint-equation/-coupling degree of freedom (DOF) for this pair. Repeat
                              the command to add other DOFs. The default is
                              constraint-equation/-coupling all applicable
                              DOFs.

            FACETOL - Tolerance for inclusion of surface nodes into your basic sector. Autodetect
                      defaults to 15°, accommodating most sections. Specify a
                      new Value1 only when extreme cut angles or complex model
                      geometry cause surface nodes to be excluded. See Notes
                      (below) for more information.

            ANSYS, Inc. recommends that successful auto-detection depends more on the value of ANGTOL than the value of FACETOL. Please refer to CYCOPT Auto Detection Tolerance Adjustments for Difficult Cases for more information about auto-detection and the CYCOPT command. - Value1

            The face tolerance applies only to auto detection from node/element models (already meshed and no solid model), and it defaults to 15°.   - HINDEX

            The harmonic index solution ranges for modal or buckling cyclic symmetry analyses. The SOLVE command initiates a cyclic symmetry solution sequence at the harmonic indices specified. (By default, the SOLVE command solves for all available harmonic indices.) Static and harmonic cyclic symmetry solutions always use all harmonic indices required for the applied loads. - EVEN / ODD

            For low-frequency electromagnetic analysis only, EVEN specifies a symmetric solution and ODD specifies an antisymmetric solution.  - The value you specify is based on the harmonic index: EVEN (default) indicates
                              harmonic index = 0, and ODD indicates harmonic
                              index = N / 2 (where N is an integer representing
                              the number of sectors in 360°). A value of ODD
                              applies only when N is an even number.

            The CYCOPT command with this HINDEX option is cumulative. To remove an option (for example, EVEN), issue this command: CYCOPT,HINDEX,EVEN,,,-1 - ALL

            Solve all applicable harmonic indices. - Note:  Value2 must be blank.

            Value1, Value2, Value3 - Solve harmonic indices in range Value1 through Value2 in steps of Value3.
                              Repeat the command to add other ranges. The
                              default solves all applicable harmonic indices.

            Value4 - The only valid value is -1. If specified, it removes Value1 through Value2 in
                     steps of Value3 from the set to solve. By default, if
                     Value4 = -1 then Value1 = 0, Value2 = 0, and Value3 = 1.

            Value5 - For static and harmonic analyses, the tolerance for determining if a Fourier
                     contribution of a load contributes to the response
                     (default = 1.0E-5).

            If Value5=STATIC, it forces the program to solve only the specified harmonic indices (even if a load may have a Fourier contribution in an index not specified). - LDSECT

            Restricts subsequently defined force loads and surface loads to a specified sector. The restriction remains in effect until you change or reset it. This option is not available for harmonic analyses based on mode-superposition (CYCOPT,MSUP,1) - Value1

            The sector number. A value other than 0 (default) is valid for a cyclic symmetry analysis with non-cyclically symmetric loading only. A value of 0 (or ALL) resets the default behavior for cyclic loading (where the loads are identical on all sectors). - MOVE

            Specifies if the program should move high- or low-edge component nodes paired within the specified tolerance (TOLER) to create precisely matching pairs.  - Value1

            The flag value. - 0

            Do not move edge component nodes (default) - 1 or HIGH

            Move the high-edge component nodes to precisely match the low-edge component nodes - -1 or LOW

            Move the low-edge component nodes to precisely match the high-edge component nodes - MSUP

            For modal cyclic symmetry analysis only, this flag is used to limit the results written to the Jobname.MODE and Jobname.RST files in preparation for a subsequent mode-superposition-based analysis. In a linear perturbation modal analysis, this option must be specified in the first load step of the preceding base analysis.  - m         """
        command = "CYCOPT,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(value1), str(value2), str(value3), str(value4), str(value5), str(value6), str(value7))
        return self.run(command, **kwargs)

    def eqslv(self, lab="", toler="", mult="", keepfile="", **kwargs):
        """APDL Command: EQSLV

        Specifies the type of equation solver.

        Parameters
        ----------
        lab
            Equation solver type:

            SPARSE - Sparse direct equation solver.  Applicable to real-value or complex-value
                     symmetric and unsymmetric matrices. Available only for
                     STATIC, HARMIC (full method only), TRANS (full method
                     only), SUBSTR, and PSD spectrum analysis types [ANTYPE].
                     Can be used for nonlinear and linear analyses, especially
                     nonlinear analysis where indefinite matrices are
                     frequently encountered. Well suited for contact analysis
                     where contact status alters the mesh topology. Other
                     typical well-suited applications are: (a) models
                     consisting of shell/beam or shell/beam and solid elements
                     (b) models with a multi-branch structure, such as an
                     automobile exhaust or a turbine fan. This is an
                     alternative to iterative solvers since it combines both
                     speed and robustness. Generally, it requires considerably
                     more memory (~10x) than the PCG solver to obtain optimal
                     performance (running totally in-core). When memory is
                     limited, the solver works partly in-core and out-of-core,
                     which can noticeably slow down the performance of the
                     solver. See the BCSOPTION command for more details on the
                     various modes of operation for this solver.

            This solver can be run in shared memory parallel or distributed memory parallel (Distributed ANSYS) mode. When used in Distributed ANSYS, this solver preserves all of the merits of the classic or shared memory sparse solver. The total sum of memory (summed for all processes) is usually higher than the shared memory sparse solver. System configuration also affects the performance of the distributed memory parallel solver. If enough physical memory is available, running this solver in the in-core memory mode achieves optimal performance. The ideal configuration when using the out-of-core memory mode is to use one processor per machine on multiple machines (a cluster), spreading the I/O across the hard drives of each machine, assuming that you are using a high-speed network such as Infiniband to efficiently support all communication across the multiple machines.  - This solver supports use of the GPU accelerator capability.

            JCG - Jacobi Conjugate Gradient iterative equation solver. Available only for STATIC,
                  HARMIC (full method only), and TRANS (full method only)
                  analysis types [ANTYPE]. Can be used for structural, thermal,
                  and multiphysics applications. Applicable for symmetric,
                  unsymmetric, complex, definite, and indefinite matrices.
                  Recommended for 3-D harmonic analyses in structural and
                  multiphysics applications. Efficient for heat transfer,
                  electromagnetics, piezoelectrics, and acoustic field
                  problems.

            This solver can be run in shared memory parallel or distributed memory parallel (Distributed ANSYS) mode. When used in Distributed ANSYS, in addition to the limitations listed above, this solver only runs in a distributed parallel fashion for STATIC and TRANS (full method) analyses in which the stiffness is symmetric and only when not using the fast thermal option (THOPT). Otherwise, this solver runs in shared memory parallel mode inside Distributed ANSYS. - This solver supports use of the GPU accelerator capability. When using the GPU
                              accelerator capability, in addition to the
                              limitations listed above, this solver is
                              available only for STATIC and TRANS (full method)
                              analyses where the stiffness is symmetric and
                              does not support the fast thermal option (THOPT).

            ICCG - Incomplete Cholesky Conjugate Gradient iterative equation solver. Available for
                   STATIC, HARMIC (full method only), and TRANS (full method
                   only) analysis types [ANTYPE].  Can be used for structural,
                   thermal, and multiphysics applications, and for symmetric,
                   unsymmetric, complex, definite, and indefinite matrices. The
                   ICCG solver requires more memory than the JCG solver, but is
                   more robust than the JCG solver for ill-conditioned
                   matrices.

            This solver can only be run in shared memory parallel mode. This is also true when the solver is used inside Distributed ANSYS. - This solver does not support use of the GPU accelerator capability.

            QMR - Quasi-Minimal Residual iterative equation solver. Available for the HARMIC
                  (full method only) analysis type [ANTYPE]. Can be used for
                  high-frequency electromagnetic applications, and for
                  symmetric, complex, definite, and indefinite matrices. The
                  QMR solver is more stable than the ICCG solver.

            This solver can only be run in shared memory parallel mode. This is also true when the solver is used inside Distributed ANSYS. - This solver does not support use of the GPU accelerator capability.

            PCG - Preconditioned Conjugate Gradient iterative equation solver (licensed from
                  Computational Applications and Systems Integration, Inc.).
                  Requires less disk file space than SPARSE and is faster for
                  large models. Useful for plates, shells, 3-D models, large
                  2-D models, and other problems having symmetric, sparse,
                  definite or indefinite matrices for nonlinear analysis.
                  Requires twice as much memory as JCG. Available only for
                  analysis types [ANTYPE] STATIC, TRANS (full method only), or
                  MODAL (with PCG Lanczos option only). Also available for the
                  use pass of substructure analyses (MATRIX50). The PCG solver
                  can robustly solve equations with constraint equations (CE,
                  CEINTF, CPINTF, and CERIG).  With this solver, you can use
                  the MSAVE command to obtain a considerable memory savings.

            The PCG solver can handle ill-conditioned problems by using a higher level of difficulty (see PCGOPT). Ill-conditioning arises from elements with high aspect ratios, contact, and plasticity. - This solver can be run in shared memory parallel or distributed memory parallel
                              (Distributed ANSYS) mode. When used in
                              Distributed ANSYS, this solver preserves all of
                              the merits of the classic or shared memory PCG
                              solver. The total sum of memory (summed for all
                              processes) is about 30% more than the shared
                              memory PCG solver.

        toler
            Iterative solver tolerance value. Used only with the Jacobi
            Conjugate Gradient, Incomplete Cholesky Conjugate Gradient, Pre-
            conditioned Conjugate Gradient, and Quasi-Minimal Residual equation
            solvers. For the PCG solver, the default is 1.0E-8. The value
            1.0E-5 may be acceptable in many situations. When using the PCG
            Lanczos mode extraction method, the default solver tolerance value
            is 1.0E-4. For the JCG and ICCG solvers with symmetric matrices,
            the default is 1.0E-8. For the JCG and ICCG solvers with
            unsymmetric matrices, and for the QMR solver, the default is
            1.0E-6. Iterations continue until the SRSS norm of the residual is
            less than TOLER times the norm of the applied load vector. For the
            PCG solver in the linear static analysis case, 3 error norms are
            used. If one of the error norms is smaller than TOLER, and the SRSS
            norm of the residual is smaller than 1.0E-2, convergence is assumed
            to have been reached. See Iterative Solver in the Mechanical APDL
            Theory Reference for details.

        mult
            Multiplier (defaults to 2.5 for nonlinear analyses; 1.0 for linear
            analyses) used to control the maximum number of iterations
            performed during convergence calculations. Used only with the Pre-
            conditioned Conjugate Gradient equation solver (PCG). The maximum
            number of iterations is equal to the multiplier (MULT) times the
            number of degrees of freedom (DOF). If MULT is input as a negative
            value, then the maximum number of iterations is equal to abs(MULT).
            Iterations continue until either the maximum number of iterations
            or solution convergence has been reached. In general, the default
            value for MULT is adequate for reaching convergence.  However, for
            ill-conditioned matrices (that is, models containing elements with
            high aspect ratios or material type discontinuities) the multiplier
            may be used to increase the maximum number of iterations used to
            achieve convergence.  The recommended range for the multiplier is
            1.0 MULT 3.0.  Normally, a value greater than 3.0 adds no further
            benefit toward convergence, and merely increases time requirements.
            If the solution does not converge with 1.0 MULT 3.0, or in less
            than 10,000 iterations, then convergence is highly unlikely and
            further examination of the model is recommended. Rather than
            increasing the default value of MULT, consider increasing the level
            of difficulty (Lev_Diff) on the PCGOPT command.

        --
            Unused field.

        keepfile
            Determines whether files from a SPARSE solver run should be deleted
            or retained. Applies only to Lab = SPARSE for static and full
            transient analyses.
        """
        command = "EQSLV,%s,%s,%s,%s" % (str(lab), str(toler), str(mult), str(keepfile))
        return self.run(command, **kwargs)

    def lvscale(self, fact="", ldstep="", **kwargs):
        """APDL Command: LVSCALE

        Scales the load vector for mode-superposition analyses.

        Parameters
        ----------
        fact
            Scale factor applied to both the real and imaginary (if they exist)
            components of the load vector. Defaults to 0.0.

        ldstep
            Specifies the load step number from the modal analysis
            (MODCONT,ON). It corresponds to the load vector number. Defaults to
            1. The maximum value is 240.

        Notes
        -----
        Specifies the scale factor for the load vector that was created in a
        modal (ANTYPE,MODAL) analysis.  Applies only to the mode-superposition
        transient analysis (ANTYPE,TRANS), mode-superposition harmonic analysis
        (ANTYPE,HARMIC), random vibration analysis (ANTYPE,SPECTR with
        SPOPT,PSD), and multiple point response spectrum analysis
        (ANTYPE,SPECTR with SPOPT,MPRS).  For PSD and MPRS analyses, LVSCALE is
        only applicable for pressure loading.

        The LVSCALE command supports tabular boundary conditions (%TABNAME_X%)
        for FACT input values only as a function of time in the mode-
        superposition transient (ANTYPE,TRANS) or as a function of frequency in
        mode-superposition harmonic (ANTYPE,HARMIC).

        MPC contact generates constraint equations that can include constant
        terms (included on the right-hand side of the system equation). The
        LVSCALE command scales the constant terms.

        In mode-superposition transient and harmonic analyses, all of the load
        vectors need to be scaled in the first load step. Use a zero scale
        factor if they are not actually used in this first load step. :
        Similarly, in random vibration and multipoint response spectrum
        analyses, all of the load vectors need to be scaled in the first
        participation factor calculation (PFACT). : Use a zero scale factor if
        they are not actually used for the first input table.

        This command is also valid in PREP7.
        """
        command = "LVSCALE,%s,%s" % (str(fact), str(ldstep))
        return self.run(command, **kwargs)

    def pduser(self, fname="", ext="", **kwargs):
        """APDL Command: PDUSER

        Specifies options for user-specified sampling methods.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        If user-specified sampling methods are requested with the PDMETH, MCS,
        USER command or the PDMETH, RSM, USER command, then you need to specify
        which file contains the sample data. For more information on the format
        of this file, see Probabilistic Design in the Advanced Analysis Guide.
        """
        command = "PDUSER,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def target(self, nlist="", **kwargs):
        """APDL Command: TARGET

        Specifies the target nodes for mapping pressures onto surface effect
        elements.

        Parameters
        ----------
        nlist
            Nodes defining the surface upon which the pressures will be mapped.
            Use the label ALL or specify a nodal component name. If ALL, all
            selected nodes [NSEL] are used (default). Individual nodes may not
            be entered.

        Notes
        -----
        The node list specified by Nlist must contain a sufficient number of
        nodes to define an element surface. The surface must be meshed (ESURF
        command) with SURF154 elements prior to issuing this command.
        """
        command = "TARGET,%s" % (str(nlist))
        return self.run(command, **kwargs)

    def aslv(self, type="", **kwargs):
        """APDL Command: ASLV

        Selects those areas contained in the selected volumes.

        Parameters
        ----------
        type
            Label identifying the type of area select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "ASLV,%s" % (str(type))
        return self.run(command, **kwargs)

    def numexp(self, num="", begrng="", endrng="", elcalc="", **kwargs):
        """APDL Command: NUMEXP

        Specifies solutions to be expanded from mode-superposition analyses or
        substructure analyses.

        Parameters
        ----------
        num
            The number of solutions to expand. This value is required.

            Num - Number of solutions to expand.

            ALL - Expand all substeps between BEGRNG and ENDRNG (provided that ENDRNG > 0). If
                  BEGRNG and ENDRNG have no specified values, this option
                  expands all substeps of all load steps.

        begrng, endrng
            Beginning and ending time (or frequency) range for expanded
            solutions. The default is 0 for both values.

        elcalc
            The element-calculation key:

            YES - Calculate element results, nodal loads, and reaction loads. This value is the
                  default.

            NO - Do not calculate these items.

        Notes
        -----
        Specifies a range of solutions to be expanded from analyses that use
        mode-superposition methods (ANTYPE,HARMIC or TRANS) or substructuring
        (ANTYPE,SUBSTR).

        For ANTYPE,TRANS, NUM, evenly spaced solutions are expanded between
        time BEGRNG and time ENDRNG.

        For ANTYPE,HARMIC, NUM, evenly spaced solutions are expanded between
        frequency BEGRNG and frequency ENDRNG.

        The first expansion in all cases is done at the first point beyond
        BEGRNG (that is, at BEGRNG + (ENDRNG - BEGRNG) / NUM)).

        The resulting results file will maintain the same load step, substep,
        and time (or frequency) values as the use pass.

        For a single expansion of a solution, or for multiple expansions when
        the solutions are not evenly spaced (such as in a mode-superposition
        harmonic analysis with the cluster option), ANSYS, Inc. recommends
        issuing one or more EXPSOL commands.

        The NUMEXP command is invalid in these cases:

        In a substructing analysis (ANTYPE,SUBST) when a factorized matrix file
        (the .LN22 file generated by the sparse solver) does not exist, causing
        ANSYS to employ the full-resolve method.

        If the full-resolve option is selected using the SEOPT command.

        In both situations, use the EXPSOL command to perform a single
        expansion for each solution desired.

        This command is also valid in PREP7.
        """
        command = "NUMEXP,%s,%s,%s,%s" % (str(num), str(begrng), str(endrng), str(elcalc))
        return self.run(command, **kwargs)

    def nerr(self, nmerr="", nmabt="", ifkey="", num="", **kwargs):
        """APDL Command: /NERR

        Limits the number of warning and error messages displayed.

        Parameters
        ----------
        nmerr
            Maximum number of warning and error messages displayed per command.
            Defaults to 5 for interactive runs with the GUI turned on, 20 for
            interactive runs with the GUI turned off, 200 for batch runs.  If
            NMERR is negative, the absolute value of NMERR is used as the
            maximum number of warning and error messages written to the error
            file (file.ERR) per command, as well as the maximum number of
            messages displayed per command.

        nmabt
            Maximum number of warning and error messages allowed per command
            before run aborts (must be greater than zero).  Maximum value is
            99,999,999. Defaults to 10,000.

        --
            Unused field.

        ifkey
            Specifies whether or not to abort if an error occurs during a
            /INPUT operation:

            0 or OFF - Do not abort. This option is the default.

            1 or ON - Abort.

        num
            The number of invalid command warnings before a stop warning will
            be issued:

            0 - Disables the stop warning/error function.

            n - An integer value representing the number of warnings that will be encountered
                before prompting the user to stop (default = 5). The first
                error encountered will ALWAYS result in a prompt.

        Notes
        -----
        Limits the number of warning and error messages displayed for any one
        command in an interactive run.

        Warning and error messages continue to be written to Jobname.ERR
        regardless of these limits (unless NMERR is negative).

        Issue this command with NUM = n to specify the number of "invalid
        command" warnings to be encountered before the user is prompted to
        stop. You can then continue or abort the run. If you choose to abort
        the run, the log file can be saved so that any of the processing up to
        that point can be appended to an input that rectifies the condition. A
        batch run always aborts on the first error.  Issue /NERR,STAT to list
        current settings.

        Issue /NERR,DEFA to reset values to initial defaults.

        An IFKEY value of 1 or ON causes the ANSYS program to abort immediately
        upon encountering an error during a file /INPUT operation. However, use
        of this option may cause the following conditions to occur:

        The /INPUT command may abort if issued for a log file (jobname.log).

        Some macros may abort.

        A CAD connection may fail after reading only a small portion of a CAD
        model.

        The command is valid in any processor.
        """
        command = "/NERR,%s,%s,%s,%s" % (str(nmerr), str(nmabt), str(ifkey), str(num))
        return self.run(command, **kwargs)

    def ctype(self, key="", dotd="", dots="", dshp="", tlen="", **kwargs):
        """APDL Command: /CTYPE

        Specifies the type of contour display.

        Parameters
        ----------
        key
            Type of display:

            0 - Standard contour display.

            1 - Isosurface display.

            2 - Particle gradient display.

            3 - Gradient triad display.

        dotd
            Maximum dot density for particle gradient display (KEY = 2).
            Density is expressed as dots per screen width (defaults to 30).

        dots
            Dot size for particle gradient display (KEY = 2).  Size is
            expressed as a fraction of the screen width (defaults to 0.0
            (single dot width)).

        dshp
            Spherical dot shape precision for particle gradient display (KEY =
            2).  (3-D options are supported only on 3-D devices):

            0 - Flat 2-D circular dot.

            1 - Flat-sided 3-D polyhedron.

            n - 3-D sphere with n (>1) polygon divisions per 90° of radius.

        tlen
            Maximum length of triads for gradient triad display (KEY = 3).
            Value is expressed as a fraction of the screen width (defaults to
            0.067).

        Notes
        -----
        Use /CTYPE,STAT to display the current settings.     Only the standard
        contour display [/CTYPE,0) and the isosurface contour display
        [/CTYPE,1] are supported by PowerGraphics [/GRAPHICS,POWER].

        This command is valid in any processor.
        """
        command = "/CTYPE,%s,%s,%s,%s,%s" % (str(key), str(dotd), str(dots), str(dshp), str(tlen))
        return self.run(command, **kwargs)

    def plmap(self, item="", nodekey="", imagkey="", **kwargs):
        """APDL Command: PLMAP

        Plots target and source pressures.

        Parameters
        ----------
        item
            Items to plot:

            BOTH - Plot both target and source pressures (default).

            TARGET - Plot only the target pressures.

            SOURCE - Plot only the source pressures.

        --
            Unused field.

        nodekey
            If the source data contains faces (that is, surface elements were
            created upon the READ command), set NODEkey = 1 to plot only the
            source nodes rather than both the nodes and the elements.

        imagkey
            1

            1 - Plot the real pressures (default).

            0 - Plot the imaginary pressures.

        Notes
        -----
        Pressures on the target faces are displayed as a color contour plot
        using the command /PSF,PRES,,3. If the source data contains faces (that
        is, surface elements were created upon the READ command), the source
        faces are also displayed using a color contour plot by default. If
        NODEkey = 1 or no source faces are available, the source pressures are
        displayed as colored node symbols (/PSYMB,DOT,1 command).
        """
        command = "PLMAP,%s,%s,%s" % (str(item), str(nodekey), str(imagkey))
        return self.run(command, **kwargs)

    def wmid(self, key="", **kwargs):
        """APDL Command: WMID

        Specifies reordering options for the WAVES command.

        Parameters
        ----------
        key
             Determines whether midside nodes are considered when reordering.

            NO - Do not consider midside nodes when reordering (default).

            YES - Consider midside nodes when reordering. This option is useful for models where
                  line elements are only attached to midside nodes of solid
                  elements.

        Notes
        -----
        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "WMID,%s" % (str(key))
        return self.run(command, **kwargs)

    def psdgraph(self, tblno1="", tblno2="", **kwargs):
        """APDL Command: PSDGRAPH

        Displays input PSD curves

        Parameters
        ----------
        tblno1
            PSD table number to display.

        tblno2
            Second PSD table number to display. TBLNO2 is used only in
            conjunction with the COVAL or the QDVAL commands.

        Notes
        -----
        The input PSD tables are displayed in log-log format as dotted lines.
        The best-fit curves, used to perform the closed-form integration, are
        displayed as solid lines. If there is a significant discrepancy between
        the two, then you should add one or more intermediate points to the
        table to obtain a better fit.

        If TBLNO2 is zero, blank, or equal to TBLNO1, then the autospectra
        (PSDVAL) are displayed for TBLNO1. If TBLNO2 is also specified, then
        the autospectra for TBLNO1 and TBLNO2 are displayed, along with the
        corresponding cospectra (COVAL) and quadspectra (QDVAL), if they are
        defined.

        This command is valid in any processor.
        """
        command = "PSDGRAPH,%s,%s" % (str(tblno1), str(tblno2))
        return self.run(command, **kwargs)

    def nopr(self, **kwargs):
        """APDL Command: /NOPR

        Suppresses the expanded interpreted input data listing.

        Notes
        -----
        Suppresses printout of interpreted input data, including information
        labeled as "Notes."  When this printout is not suppressed, the data
        input to the analysis is echoed to the output file in an expanded
        format.  Printout is suppressed until a /GOPR or /GO command is read.

        Use of /NOPR is not recommended when the graphical user interface (GUI)
        is active.  The GUI sometimes issues "hidden" /NOPR and /GOPR command
        sequences, which will countermand user-issued /NOPR commands, thus
        making the use of /NOPR in the GUI environment unpredictable.

        This command is valid in any processor.
        """
        command = "/NOPR," % ()
        return self.run(command, **kwargs)

    def lcfile(self, lcno="", fname="", ext="", **kwargs):
        """APDL Command: LCFILE

        Creates a load case from an existing load case file.

        Parameters
        ----------
        lcno
            Arbitrary (1-99) pointer number assigned to this load case.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Creates a load case by establishing a pointer to an existing load case
        file [LCWRITE].  This pointer (LCNO) can then be used on the LCASE or
        LCOPER commands to read the load case data into the database.  This
        command is typically used to reestablish load case pointers in a new
        ANSYS session (pointers are not saved on the database file), or when
        more than one pointer to a single load case is desired.  See the LCDEF
        command for status and erase operations.  See also LCDEF to establish a
        pointer to a set of results on a results file (written during the ANSYS
        solution phase).
        """
        command = "LCFILE,%s,%s,%s" % (str(lcno), str(fname), str(ext))
        return self.run(command, **kwargs)

    def allsel(self, labt="", entity="", **kwargs):
        """APDL Command: ALLSEL

        Selects all entities with a single command.

        Parameters
        ----------
        labt
            Type of selection to be made:

            ALL - Selects all items of the specified entity type and all items of lower entity
                  types (default).

            BELOW - Selects all items directly associated with and below the selected items of the
                    specified entity type.

        entity
            Entity type on which selection is based:

            ALL - All entity types (default).

            VOLU - Volumes.

            AREA - Areas.

            LINE - Lines.

            KP - Keypoints.

            ELEM - Elements.

            NODE - Nodes.

        Notes
        -----
        ALLSEL is a convenience command that allows the user to select all
        items of a specified entity type or to select items associated with the
        selected items of a higher entity.

        An entity hierarchy is used to decide what entities will be available
        in the selection process.  This hierarchy from top to bottom is as
        follows:  volumes, areas, lines, keypoints, elements, and nodes.  The
        hierarchy may also be divided into two branches:  the solid model and
        the finite element model.  The label ALL selects items based on one
        branch only, while BELOW uses the entire entity hierarchy.  For
        example, ALLSEL,ALL,VOLU selects all volumes, areas, lines, and
        keypoints in the data base.  ALLSEL,BELOW,AREA selects all lines
        belonging to the selected areas; all keypoints belonging to those
        lines; all elements belonging to those areas, lines, and keypoints; and
        all nodes belonging to those elements.

        The $ character should not be used after the  ALLSEL  command.

        This command is valid in any processor.
        """
        command = "ALLSEL,%s,%s" % (str(labt), str(entity))
        return self.run(command, **kwargs)

    def pdresu(self, fname="", ext="", **kwargs):
        """APDL Command: PDRESU

        Reads the probabilistic model data and loads it into the database.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Reads the probabilistic model data from the specified file and loads it
        into the database. Probabilistic analyses results are not stored in the
        database with the PDRESU command, rather they reside in separate
        results files. Analyses results are loaded automatically (one-by-one
        and on demand) when a probabilistic postprocessing command is issued.
        """
        command = "PDRESU,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def dscale(self, rfact="", ifact="", tb_ase="", **kwargs):
        """APDL Command: DSCALE

        Scales DOF constraint values.

        Parameters
        ----------
        rfact
            Scale factor for the real component.  Zero (or blank) defaults to
            1.0.  Use a small number for a zero scale factor.

        ifact
            Scale factor for the imaginary component.  Zero (or blank) defaults
            to 1.0.  Use a small number for a zero scale factor.

        tbase
            Base temperature for temperature difference.  For temperatures, the
            scale factor is applied to the temperature difference (T-TBASE) and
            then added to TBASE.  T is the current temperature.

        Notes
        -----
        Scales degree of freedom constraint values (displacement, temperature,
        etc.) in the database.  If velocity and acceleration boundary
        conditions are applied in a structural analysis, they are also scaled
        by this command. Solid model boundary conditions are not scaled by this
        command, but boundary conditions on the FE model are scaled.

        Note:: : Such scaled FE boundary conditions may still be overwritten by
        unscaled solid model boundary conditions if a subsequent boundary
        condition transfer occurs.

        Scaling applies to the previously defined values for the selected nodes
        [NSEL] and the selected degree of freedom labels [DOFSEL].  Issue DLIST
        command to review results.

        DSCALE does not work for tabular boundary conditions.

        This command is also valid in PREP7.
        """
        command = "DSCALE,%s,%s,%s" % (str(rfact), str(ifact), str(tb_ase))
        return self.run(command, **kwargs)

    def plpath(self, lab1="", lab2="", lab3="", lab4="", lab5="", lab6="",
               **kwargs):
        """APDL Command: PLPATH

        Displays path items on a graph.

        Parameters
        ----------
        lab1, lab2, lab3, . . . , lab6
            Labels identifying the path items to be displayed.  Up to six items
            may be drawn per frame.  Predefined path geometry items XG, YG, ZG,
            and S [PDEF] may also be displayed.

        Notes
        -----
        The path must have been defined by the PATH and PPATH commands.  Path
        items and their labels must have been defined with the PDEF, PVECT,
        PCALC, PDOT, PCROSS, or PLNEAR commands.  Path items may also be
        printed with the PRPATH command.  Graph scaling may be controlled with
        the /XRANGE, /YRANGE, and PRANGE commands. You need to type all six
        characters to issue this command.
        """
        command = "PLPATH,%s,%s,%s,%s,%s,%s" % (str(lab1), str(lab2), str(lab3), str(lab4), str(lab5), str(lab6))
        return self.run(command, **kwargs)

    def mshmid(self, key="", **kwargs):
        """APDL Command: MSHMID

        Specifies placement of midside nodes.

        Parameters
        ----------
        key
            Key indicating placement of midside nodes:

            0 - Midside nodes (if any) of elements on a region boundary follow the curvature of
                the boundary line or area (the default).

            1 - Place midside nodes of all elements so that element edges are straight.  Allows
                coarse mesh along curves.

            2 - Do not create midside nodes (elements will have removed midside nodes).

        Notes
        -----
        The MSHMID, MSHAPE, and MSHKEY commands replace the functionality that
        was provided by the ESHAPE command in ANSYS 5.3 and earlier releases.

        This command is also valid for rezoning.
        """
        command = "MSHMID,%s" % (str(key))
        return self.run(command, **kwargs)

    def outpr(self, item="", freq="", cname="", **kwargs):
        """APDL Command: OUTPR

        Controls the solution printout.

        Parameters
        ----------
        item
            Item for print control:

            BASIC - Basic quantities (nodal DOF solution, nodal reaction loads, and element
                    solution) (default).

            NSOL - Nodal DOF solution.

            RSOL - Nodal reaction loads.

            ESOL - Element solution.

            NLOAD - Element nodal loads. When nonlinear stabilization is active, the stabilization
                    force/moments are also printed.

            SFOR - Stabilization force/moment at the applicable nodes (valid only when nonlinear
                   stabilization is active).

            VENG - Element energies. When nonlinear stabilization is active, the energy
                   dissipation due to stabilization is also printed.

            V - Nodal velocity (applicable to structural transient analysis  only
                (ANTYPE,TRANS)).

            A - Nodal acceleration (applicable to structural transient analysis only
                (ANTYPE,TRANS)).

            ALL - All of the above solution items.

        freq
            Print solution for this item every Freqth (and the last) substep of
            each load step.  If -n, print up to n equally spaced solutions
            (only applies to static or full transient analyses when automatic
            time stepping is enabled).  If NONE, suppress all printout for this
            item for this load step.  If ALL, print solution for this item for
            every substep.  If LAST, print solution for this item only for the
            last substep of each load step.  For a modal analysis, use NONE or
            ALL.

        cname
            Name of the component, created with the CM command, defining the
            selected set of nodes or elements for which this specification is
            active.  If blank, the set is all entities.

        Notes
        -----
        Controls the solution items to be printed, the frequency with which
        they are printed (in static, transient, or full harmonic analyses), and
        the set of nodes or elements to which this specification applies (in
        static, transient, or full harmonic analyses).  An item is associated
        with either a node (NSOL, RFORCE, V, and A items) or an element (all of
        the remaining items).  The specifications are processed in the order
        that they are input.  Up to 50 specifications (OUTPR and  OUTRES
        commands combined) may be defined.  Use OUTPR,STAT to list the current
        specifications and use OUTPR,ERASE to erase all the current
        specifications.

        As described above, OUTPR writes some or all items (depending on
        analysis type) for all elements.  To restrict the solution printout,
        use OUTPR to selectively suppress (Freq = NONE) the writing of solution
        data, or first suppress the writing of all solution data
        (OUTPR,ALL,NONE) and then selectively turn on the writing of solution
        data with subsequent OUTPR commands.

        If the generalized plane strain feature is active and OUTPR is issued,
        the change of fiber length at the ending point during deformation and
        the rotation of the ending plane about X and Y during deformation will
        be printed if any displacement at the nodes is printed. The reaction
        forces at the ending point will be printed if any reaction force at the
        nodes is printed.

        Nodal reaction loads (Item = RSOL) are processed according to the
        specifications listed for the PRRSOL command.

        Result printouts for interactive sessions are suppressed for models
        with more than 10 elements.

        This command is also valid in PREP7.
        """
        command = "OUTPR,%s,%s,%s" % (str(item), str(freq), str(cname))
        return self.run(command, **kwargs)

    def aptn(self, na1="", na2="", na3="", na4="", na5="", na6="", na7="",
             na8="", na9="", **kwargs):
        """APDL Command: APTN

        Partitions areas.

        Parameters
        ----------
        na1, na2, na3, . . . , na9
            Numbers of areas to be operated on.  If NA1 = ALL, NA2 to NA9 are
            ignored and all selected areas are used.  If NA1 = P, graphical
            picking is enabled and all remaining arguments are ignored (valid
            only in the GUI).  A component name may be substituted for NA1.

        Notes
        -----
        Partitions areas that intersect.  This command is similar to the
        combined functionality of the ASBA and AOVLAP commands.  If the
        intersection of two or more areas is an area (i.e., planar), new areas
        will be created with boundaries that conform to the area of
        intersection and to the boundaries of the non-intersecting portions of
        the input areas [AOVLAP].  If the intersection is a line (i.e., not
        planar), the areas will be subtracted, or divided, along the line(s) of
        intersection [ASBA].  Both types of intersection can occur during a
        single APTN operation.  Areas that do not intersect will not be
        modified.  See the Modeling and Meshing Guide for an illustration.  See
        the BOPTN command for an explanation of the options available to
        Boolean operations.  Element attributes and solid model boundary
        conditions assigned to the original entities will not be transferred to
        the new entities generated.
        """
        command = "APTN,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(na1), str(na2), str(na3), str(na4), str(na5), str(na6), str(na7), str(na8), str(na9))
        return self.run(command, **kwargs)

    def vext(self, na1="", na2="", ninc="", dx="", dy="", dz="", rx="", ry="",
             rz="", **kwargs):
        """APDL Command: VEXT

        Generates additional volumes by extruding areas.

        Parameters
        ----------
        na1, na2, ninc
            Set of areas (NA1 to NA2 in steps of NINC) that defines the pattern
            to be extruded.  NA2 defaults to NA1, NINC defaults to 1.  If NA1 =
            ALL, NA2 and NINC are ignored and the pattern is defined by all
            selected areas.  If NA1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  A
            component name may also be substituted for NA1 (NA2 and NINC are
            ignored).

        dx, dy, dz
            Increments to be applied to the X, Y, and Z keypoint coordinates in
            the active coordinate system (DR, Dθ, DZ for cylindrical; DR, Dθ,
            DΦ for spherical).

        rx, ry, rz
            Scale factors to be applied to the X, Y, and Z keypoint coordinates
            in the active coordinate system (RR, Rθ, RZ for cylindrical; RR,
            Rθ, RΦ for spherical).  Note that the Rθ and RΦ scale factors are
            interpreted as angular offsets.  For example, if CSYS = 1, RX, RY,
            RZ input of (1.5,10,3) would scale the specified keypoints 1.5
            times in the radial and 3 times in the Z direction, while adding an
            offset of 10 degrees to the keypoints.  Zero, blank, or negative
            scale factor values are assumed to be 1.0.  Zero or blank angular
            offsets have no effect.

        Notes
        -----
        Generates additional volumes (and their corresponding keypoints, lines,
        and areas) by extruding and scaling a pattern of areas in the active
        coordinate system.

        If element attributes have been associated with the input area via the
        AATT command, the opposite area generated by the VEXT operation will
        also have those attributes (i.e., the element attributes from the input
        area are copied to the opposite area).  Note that only the area
        opposite the input area will have the same attributes as the input
        area; the areas adjacent to the input area will not.

        If the areas are meshed or belong to meshed volumes, a 3-D mesh can be
        extruded with this command.  Note that the NDIV argument on the ESIZE
        command should be set before extruding the meshed areas.

        Scaling of the input areas, if specified, is performed first, followed
        by the extrusion.

        In a non-Cartesian coordinate system, the VEXT command locates the end
        face of the volume based on the active coordinate system.  However, the
        extrusion is made along a straight line between the end faces.  Note
        that solid modeling in a toroidal coordinate system is not recommended.

        Caution:: : Use of the VEXT command can produce unexpected results when
        operating in a non-Cartesian coordinate system.  For a detailed
        description of the possible problems that may occur, see Solid Modeling
        in the Modeling and Meshing Guide.
        """
        command = "VEXT,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(na1), str(na2), str(ninc), str(dx), str(dy), str(dz), str(rx), str(ry), str(rz))
        return self.run(command, **kwargs)

    def edmp(self, lab="", mat="", val1="", val2="", val3="", val4="", val5="",
             val6="", **kwargs):
        """APDL Command: EDMP

        Defines material properties for an explicit dynamics analysis.

        Parameters
        ----------
        lab
            Valid material property label. Applicable labels are listed under
            "Material Properties" in the input table for each explicit dynamics
            element type in the Element Reference.

            HGLS - Hourglass and bulk viscosity properties (valid for PLANE162, SHELL163, SOLID164
                   using reduced integration, and SOLID168).  VAL1 through VAL6
                   are also used. For those elements using full integration,
                   HGLS is not applicable and the input has no effect.

            RIGID - Rigid body constraint (valid for LINK160, BEAM161, PLANE162, SHELL163,
                    SOLID164, and SOLID168). VAL1 and VAL2 are also used.

            CABLE - Cable properties (valid for LINK167).  VAL1 is optional input (see Notes).

            ORTHO - Defines a material coordinate system for the orthotropic material model (valid
                    for PLANE162, SHELL163, SOLID164, and SOLID168) or the
                    anisotropic material model (valid for SOLID164 and
                    SOLID168).  VAL1 is also used.

            FLUID - Fluid properties (valid for PLANE162, SOLID164, and SOLID168). VAL1 is optional
                    input (see Notes).

        mat
            Material reference number (defaults to the current MAT setting on
            MAT command).

        val1, val2, val3, . . . , val6
            Additional input for specified Lab material property. The meaning
            of VAL1 through VAL6 will vary, depending on Lab. See the table
            below for VAL1 through VAL6 definitions.

            VAL1 - Hourglass control type. For solid elements (PLANE162, SOLID164, and SOLID168),
                   5 options are available. For quadrilateral shell and
                   membrane elements (SHELL163) with reduced integration, the
                   hourglass control is based on the formulation of Belytschko
                   and Tsay; i.e., options 1-3 are identical and options 4-5
                   are identical.

            0, 1 - Standard LS-DYNA viscous form (default).

            2 - Flanagan-Belytschko viscous form.

            3 - Flanagan-Belytschko viscous form with exact volume integration for solid
                elements.

            4 - Flanagan-Belytschko stiffness form.

            5 - Flanagan-Belytschko stiffness form with exact volume integration for solid
                elements.

            VAL2 - Hourglass coefficient. (Defaults to 0.1.) Values greater than 0.15 may cause
                   instabilities. The recommended default applies to all
                   options.  The stiffness forms can stiffen the response
                   (especially if deformations are large) and, therefore,
                   should be used with care. For the shell and membrane
                   elements, the value input for VAL1 is the membrane hourglass
                   coefficient. VAL5 and VAL6 can also be input, but generally
                   VAL2 = VAL5 = VAL6 is adequate.

            VAL3 - Quadratic bulk viscosity coefficient. (Defaults to 1.5.)

            VAL4 - Linear bulk viscosity coefficient. (Defaults to 0.06.)

            VAL5 - Hourglass coefficient for shell bending. (Defaults to VAL2.)

            VAL6 - Hourglass coefficient for shell warping. (Defaults to VAL2.)
        """
        command = "EDMP,%s,%s,%s,%s,%s,%s,%s,%s" % (str(lab), str(mat), str(val1), str(val2), str(val3), str(val4), str(val5), str(val6))
        return self.run(command, **kwargs)

    def mrep(self, name="", arg1="", arg2="", arg3="", arg4="", arg5="",
             arg6="", arg7="", arg8="", arg9="", arg10="", arg11="", arg12="",
             arg13="", arg14="", arg15="", arg16="", arg17="", arg18="",
             **kwargs):
        """APDL Command: /MREP

        Enables you to reissue the graphics command macro "name" during a
        replot or zoom operation.

        Parameters
        ----------
        name
            The name identifying the macro file or macro block on a macro
            library file.  The name can contain up to eight characters maximum
            and must begin with a letter.

        arg1, arg2, arg3, . . . , arg18
            Values to be passed into the file or block.

        Notes
        -----
        This command reissues the graphics command macro "name" during a replot
        operation [/REPLOT] or a zoom [/ZOOM] operation.  The ANSYS program
        passes the command macro arguments to the replot and zoom feature for
        use by the graphics macro.  You should place the s-MREP command at the
        end of the graphics command macro, following the last graphics command
        within the macro, to enable the replot or zoom feature.
        """
        command = "/MREP,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(name), str(arg1), str(arg2), str(arg3), str(arg4), str(arg5), str(arg6), str(arg7), str(arg8), str(arg9), str(arg10), str(arg11), str(arg12), str(arg13), str(arg14), str(arg15), str(arg16), str(arg17), str(arg18))
        return self.run(command, **kwargs)

    def lptn(self, nl1="", nl2="", nl3="", nl4="", nl5="", nl6="", nl7="",
             nl8="", nl9="", **kwargs):
        """APDL Command: LPTN

        Partitions lines.

        Parameters
        ----------
        nl1, nl2, nl3, . . . , nl9
            Numbers of lines to be operated on.  If NL1 = ALL, NL2 to NL9 are
            ignored all selected lines are used.  If NL1 = P, graphical picking
            is enabled and all remaining command fields are ignored (valid only
            in the GUI).  A component name may be substituted for NL1.

        Notes
        -----
        Partitions lines.  Generates new lines which encompass the geometry of
        all the input lines.  The new lines are defined by both the regions of
        intersection of the input lines and the complementary (non-
        intersecting) regions.  See the Modeling and Meshing Guide for an
        illustration. See the BOPTN command for an explanation of the options
        available to Boolean operations.  Element attributes and solid model
        boundary conditions assigned to the original entities will not be
        transferred to the new entities generated.
        """
        command = "LPTN,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nl1), str(nl2), str(nl3), str(nl4), str(nl5), str(nl6), str(nl7), str(nl8), str(nl9))
        return self.run(command, **kwargs)

    def mstart(self, label="", key="", **kwargs):
        """APDL Command: /MSTART

        Controls the initial GUI components.

        Parameters
        ----------
        label
            Label identifying the GUI component:

            ZOOM - Pan, Zoom, Rotate dialog box, off by default.

            WORK - Offset Working Plane dialog box, off by default.

            WPSET - Working Plane Settings dialog box, off by default.

            ABBR - Edit Toolbar/Abbreviations dialog box, off by default.

            PARM - Scalar Parameters dialog box, off by default.

            SELE - Select Entities dialog box, off by default.

            ANNO - Annotation dialog box, off by default.

            HARD - Hard Copy dialog box, off by default.

            UTIL - Turns on the pre-ANSYS 6.1 (UIDL) GUI, off by default.

        key
            Switch value:

            OFF or 0 - Component does not appear when GUI is initialized.

            ON or 1 - Component appears when GUI is initialized.

        Notes
        -----
        Controls which components appear when the Graphical User Interface
        (GUI) is initially brought up.  This command is valid only before the
        GUI is brought up [/MENU,ON] and is intended to be used in the
        start162.ans file.  It only affects how the GUI is initialized; you can
        always bring up or close any component once you are in the GUI.

        This command is valid only at the Begin Level.
        """
        command = "/MSTART,%s,%s" % (str(label), str(key))
        return self.run(command, **kwargs)

    def gresume(self, fname="", ext="", **kwargs):
        """APDL Command: /GRESUME

        Sets graphics settings to the settings on a file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Causes a file to be read to reset the graphics slash (/) commands as
        they were at the last  /GSAVE command.

        This command is valid in any processor.
        """
        command = "/GRESUME,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def fs(self, node="", nev="", nlod="", stitm="", c1="", c2="", c3="",
           c4="", c5="", c6="", **kwargs):
        """APDL Command: FS

        Stores fatigue stress components at a node.

        Parameters
        ----------
        node
            Node number corresponding to this location.  Used only to associate
            a node with a new location or to find an existing location.

        nev
            Event number to be associated with these stresses (defaults to 1).

        nlod
            Loading number to be associated with these stresses (defaults to
            1).

        stitm
            Starting item number for entering stresses (defaults to 1).  If 1,
            data input in field C1 of this command is entered as the first item
            in the list; if 7, data input in field C1 of this command is
            entered as the seventh item in the list; etc.  Items are as
            follows:

            1-6 - SX, SY, SZ, SXY, SYZ, SXZ total stress components

            7 - Temperature

            8-13 - SX, SY, SZ, SXY, SYZ, SXZ membrane-plus-bending stress components.

            14 - Time

        c1, c2, c3, . . . , c6
            Stresses assigned to six locations starting with STITM.  If a value
            is already in one of these locations, it will be redefined.  A
            blank retains the previous value (except in the C1 field, which
            resets the STITM item to zero).

        Notes
        -----
        Stores fatigue stress components at a node as input on this command
        instead of from the current data in the database.  Stresses are stored
        according to the event number and loading number specified.  The
        location is associated with that previously defined for this node [FL]
        or else it is automatically defined.  May also be used to modify any
        previously stored stress components.  Stresses input with this command
        should be consistent with the global coordinate system for any FSNODE
        or FSSECT stresses used at the same location.
        """
        command = "FS,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(node), str(nev), str(nlod), str(stitm), str(c1), str(c2), str(c3), str(c4), str(c5), str(c6))
        return self.run(command, **kwargs)

    def bsplin(self, p1="", p2="", p3="", p4="", p5="", p6="", xv1="", yv1="",
               zv1="", xv6="", yv6="", zv6="", **kwargs):
        """APDL Command: BSPLIN

        Generates a single line from a spline fit to a series of keypoints.

        Parameters
        ----------
        p1, p2, p3, . . . , p6
            Keypoints through which a spline is fit.  At least two keypoints
            must be defined.  If P1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).

        Notes
        -----
        One line is generated between keypoint P1 and the last keypoint
        entered.  The line will pass through each entered keypoint.  Solid
        modeling in a toroidal coordinate system is not recommended.
        """
        command = "BSPLIN,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(p1), str(p2), str(p3), str(p4), str(p5), str(p6), str(xv1), str(yv1), str(zv1), str(xv6), str(yv6), str(zv6))
        return self.run(command, **kwargs)

    def dnsol(self, node="", item="", comp="", v1="", v2="", v3="", v4="",
              v5="", v6="", **kwargs):
        """APDL Command: DNSOL

        Defines or modifies solution results at a node.

        Parameters
        ----------
        node
            Node for which results are specified.  If ALL, apply to all
            selected nodes [NSEL].  If NODE = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).  A component name may also be substituted for NODE.

        item
            Label identifying results, see Table 131: DNSOL - Valid Item and
            Component Labels.   Items also require a component label.

        comp
            Component of the item.  Valid component labels are shown
            Table 131: DNSOL - Valid Item and Component Labels below.

        v1, v2, v3, . . . , v6
            Value assigned to result.  If zero, a zero value will be assigned.
            If blank, the value remains unchanged.  Additional values (if any)
            assigned to the remaining components (in the order corresponding to
            the Comp list shown below for the specified Item (starting from the
            specified Comp label and proceeding to the right).

        Notes
        -----
        DNSOL can be used only with FULL graphics activated (/GRAPHICS,FULL);
        it will not work correctly with PowerGraphics activated.

        DNSOL defines or modifies solution results in the database at a node.
        For example, DNSOL,35,U,X,.001,.002,.001 assigns values 0.001, 0.002,
        and 0.001 to UX, UY, and UZ (respectively) for node 35.  All results
        that are changed in the database, including the nodal degree of freedom
        results, are available for all subsequent operations.   All data is
        stored in the solution coordinate system, but will be displayed in the
        results coordinate system [RSYS].  Use the PRNSOL command to list the
        current results.

        Data input by DNSOL is stored in temporary space and does not replace
        information in the database. Therefore, data input by this command may
        be overwritten if a change is made to the selected set of nodes.

        Issuing the DNSOL command or its GUI equivalent requires you to place
        the data type (stress/strain) in the element nodal records.  To get
        around this requirement, use the DESOL command or equivalent path to
        add a "dummy" element stress/strain record.

        Result items are available depending on element type; check the
        individual element for availability. Valid item and component labels
        for element results are:

        Table: 131:: : DNSOL - Valid Item and Component Labels

        For SHELL131 and SHELL132 elements with KEYOPT(3) = 0 or 1, use the
        labels TBOT, TE2, TE3, ..., TTOP instead of TEMP.
        """
        command = "DNSOL,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(node), str(item), str(comp), str(v1), str(v2), str(v3), str(v4), str(v5), str(v6))
        return self.run(command, **kwargs)

    def keyw(self, keyword="", key="", **kwargs):
        """APDL Command: KEYW

        Sets a keyword used by the GUI for context filtering (GUI).

        Parameters
        ----------
        keyword
            A keyword which, when set to either true or false, changes the
            behavior of the GUI.

        key
            Keyword switch:

            0 - Sets the keyword to "false."

            1 - Sets the keyword to "true."

        Notes
        -----
        Defines a keyword used by the GUI for context filtering.  This is a
        command generated by the GUI and may appear in the log file
        (Jobname.LOG) if the GUI is used.  This command is usually not typed in
        directly in an ANSYS session.

        This command is valid in any processor.
        """
        command = "KEYW,%s,%s" % (str(keyword), str(key))
        return self.run(command, **kwargs)

    def do(self, par="", ival="", fval="", inc="", **kwargs):
        """APDL Command: *DO

        Defines the beginning of a do-loop.

        Parameters
        ----------
        par
            The name of the scalar parameter to be used as the loop index.  See
            *SET for name restrictions.  Any existing parameter of the same
            name will be redefined.  There is no character parameter
            substitution for the Par field.

        ival, fval, inc
            Initially assign IVAL to Par.  Increment IVAL by INC for each
            successive loop.  If IVAL exceeds FVAL and INC is positive, the
            loop is not executed.  INC defaults to 1.  Negative increments and
            non-integer numbers are allowed.

        Notes
        -----
        The block of commands following the *DO command (up to the *ENDDO
        command) is executed repeatedly until some loop control is satisfied.
        Printout is automatically suppressed on all loops after the first
        (include a /GOPR command to restore the printout).  The command line
        loop control (Par,IVAL,FVAL,INC) must be input; however, a Use the *IF
        within the block can also be used to control looping [*EXIT, *CYCLE].
        One level of internal file switching is used for each nested *DO.
        Twenty levels of nested do-loops are allowed.

        Note:: : Do-loops that include /INPUT, *USE, or an "Unknown Command"
        macro, have less nesting available because each of these operations
        also uses a level of file switching.  The *DO, *ENDDO, and any  *CYCLE
        and *EXIT commands for a do-loop must all be read from the same file
        (or keyboard).  You cannot use the MULTIPRO or *CREATE commands within
        a *DO-loop. Picking operations should also not be used within a *DO-
        loop.

        This command is valid in any processor.
        """
        command = "*DO,%s,%s,%s,%s" % (str(par), str(ival), str(fval), str(inc))
        return self.run(command, **kwargs)

    def damorph(self, area="", xline="", rmshky="", **kwargs):
        """APDL Command: DAMORPH

        Move nodes in selected areas to conform to structural displacements.

        Parameters
        ----------
        area
            Non-structural area to which mesh movement (morph) applies.  If
            ALL, apply morphing to all selected areas [ASEL].  If AREA = P,
            graphical picking is enabled.  A component may be substituted for
            AREA.

        xline
            Lines to be excluded from morphing.  If ALL, exclude all selected
            lines [LSEL] from morphing.  If XLINE = P, graphical picking is
            enabled.  A component may be substituted for XLINE.  If XLINE is
            blank (default), allow morphing of nodes attached to lines of the
            selected areas (AREA) which are not shared by unselected areas.
            See Notes for clarification.

        rmshky
            Remesh flag option:

            0 - Remesh the selected non-structural areas only if mesh morphing fails.

            1 - Remesh the selected non-structural areas and bypass mesh morphing.

            2 - Perform mesh morphing only and do not remesh.

        Notes
        -----
        The selected areas should include only non-structural regions adjacent
        to structural regions. DAMORPH will morph the non-structural areas to
        coincide with the deflections of the structural regions.

        Nodes in the structural regions move in accordance with computed
        displacements. Displacements from a structural analysis must be in the
        database prior to issuing DAMORPH.

        By default, nodes attached to lines can move along the lines, or off
        the lines (if a line is interior to the selected areas). You can use
        XLINE to restrain nodes on certain lines.

        By default (RMSHKEY = 0), DAMORPH will remesh the selected non-
        structural areas entirely if a satisfactory morphed mesh cannot be
        provided.

        If boundary conditions and loads are applied directly to nodes and
        elements, the DAMORPH command requires that these be removed before
        remeshing can take place.

        Exercise care with initial conditions defined by the IC command. Before
        a structural analysis is performed for a sequentially coupled analysis,
        the DAMORPH command requires that initial conditions be removed from
        all null element type nodes in the non-structural regions. Use ICDELE
        to delete the initial conditions.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "DAMORPH,%s,%s,%s" % (str(area), str(xline), str(rmshky))
        return self.run(command, **kwargs)

    def facet(self, lab="", **kwargs):
        """APDL Command: /FACET

        Specifies the facet representation used to form solid model displays.

        Parameters
        ----------
        lab
            Valid labels:

            FINE - Use finer tessellation to increase the number of facets for the display.
                   Provides the best representation (but decreases speed of
                   operation).

            NORML - Use the basic number of facets for the display (default).

            COAR - Use a limited number of facets for the display. This option will increase the
                   speed of the operations, but may produce poor
                   representations for some imported models.

            WIRE - Display model with a wireframe representation (fast, but surfaces will not be
                   shown).

        Notes
        -----
        Specifies the facet (or polygon) representation used to form solid
        model displays.  Used only with the APLOT, ASUM, VPLOT, and VSUM
        commands.

        This command is valid in any processor.
        """
        command = "/FACET,%s" % (str(lab))
        return self.run(command, **kwargs)

    def ftwrite(self, fname="", ext="", **kwargs):
        """APDL Command: FTWRITE

        Writes all currently stored fatigue data on a file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Data are written in terms of the equivalent POST1 fatigue commands
        [FTSIZE, FL, FS, etc.] which you can then edit and resubmit to POST1
        (with a /INPUT command).

        Once you have created a fatigue data file, each subsequent use of the
        FTWRITE command overwrites the contents of that file.
        """
        command = "FTWRITE,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def cat5in(self, name="", extension="", path="", entity="", fmt="",
               nocl="", noan="", **kwargs):
        """APDL Command: ~CAT5IN

        Transfers a .CATPart file into the ANSYS program.

        Parameters
        ----------
        name
            The name of a valid .CATPart file, created with CATIA Version 5.0.
            The first character of the file name must be an alphanumeric.

        extension
            The extension for the file. The default extension is .CATPart.

        path
            The path name of the directory in which the file resides enclosed
            in single quotes. The default path name is the current working
            directory.

        entity
            Entity to be imported.

            SOLIDS - Solids only, imported as ANSYS volumes (default).

            SURFACES - Surfaces only, imported as ANSYS areas.

            ALL - All entities. Use this option when the file contains different types of
                  entities.

        fmt
            The format in which ANSYS will store the model.

            0 - Neutral format (default). Defeaturing after import is restricted.

            1 - Solid format; this allows defeaturing after import.

        nocl
            Remove tiny objects.

            0 - Remove tiny objects without checking model validity (default).

            1 - Do not remove tiny objects.

        noan
            Perform an analysis of the model.

            0 - Analyze the model (default).

            1 - Do not analyze the model.

        Notes
        -----
        If defeaturing is specified (FMT = 1), this command must be the last
        line of any file, script, or other interactive input.

        More information on importing CATIA Version 5 parts is available in
        CATIA V5 in the Connection User's Guide.
        """
        command = "~CAT5IN,%s,%s,%s,%s,%s,%s,%s" % (str(name), str(extension), str(path), str(entity), str(fmt), str(nocl), str(noan))
        return self.run(command, **kwargs)

    # def if(self, val1="", oper1="", val2="", b_ase1="", val3="", oper2="",
    #        val4="", b_ase2="", **kwargs):
    #     """APDL Command: *IF

    #     Conditionally causes commands to be read.

    #     Parameters
    #     ----------
    #     val1
    #         First numerical value (or parameter which evaluates to a numerical
    #         value) in the conditional comparison operation.  VAL1, VAL2, VAL3,
    #         and VAL4 can also be character strings (enclosed in quotes) or
    #         parameters for Oper = EQ and NE only.

    #     oper1
    #         Operation label.  A tolerance of 1.0E-10 is used for comparisons
    #         between real numbers:

    #         Equal (for VAL1 = VAL2). - Not equal (for VAL1 ≠ VAL2).

    #         Less than (for VAL1 < VAL2). - Greater than (for VAL1 > VAL2).

    #         Less than or equal (for VAL1   VAL2). - Greater than or equal (for VAL1   VAL2).

    #         Absolute values of VAL1 and VAL2 before < operation. - Absolute values of VAL1 and VAL2 before > operation.

    #     val2
    #         Second numerical value (or parameter which evaluates to a numerical
    #         value) in the conditional comparison operation.

    #     base1
    #         Action based on the logical expression (Oper1) being true.  If
    #         false, continue reading at the next line. This is conditional,
    #         except for the IF-THEN-ELSE constructs described below; any of the
    #         following constructs (through Base1 = THEN) cause all subsequent
    #         fields to be ignored:

    #         A user-defined label (beginning with a colon (:), 8 characters maximum).  The command reader will skip (and wrap to the beginning of the file, if necessary) to the first line that begins with the matching :label. - Caution:   This label option may not be mixed with do-loop or if-then-else
    #                           constructs.

    #         This action will cause an exit from the ANSYS program at this line, unless running in interactive mode. In interactive mode, the program will not stop. - Exit the current do-loop [*EXIT].

    #         Skip to the end of the current do-loop [*CYCLE]. - Make this *IF an if-then-else construct (see below).

    #     val3
    #         Third numerical value (or parameter which evaluates to a numerical
    #         value).

    #     oper2
    #         Operation label. This will have the same labels as Oper1, except it
    #         uses Val3 and Val4. A tolerance of 1.0E-10 is used for comparisons
    #         between real numbers.

    #     val4
    #         Fourth numerical value (or parameter value which evaluates to a
    #         numerical value).

    #     base2
    #         Action based on the logical expression (Oper1 and Oper2) being
    #         true. They will be the same values as Base1, except as noted.

    #     Notes
    #     -----
    #     Conditionally causes commands to be read from a specific block or at a
    #     specific location.  Twenty levels of nested *IF blocks are allowed.
    #     Jumping to a :label line is not allowed with keyboard entry.  Jumping
    #     into, out of, or within a do-loop or an if-then-else construct to a
    #     :label line is not allowed. Using *IF interactively or from the command
    #     line prevents rereading the file to find a label. To do so, use batch
    #     mode or /INPUT.

    #     The following is an example of an if-then-else construct:

    #     *IF,VAL1,Oper,VAL2,THEN

    #     ----

    #     *ELSEIF,VAL1,Oper,VAL2

    #     ----

    #     *ELSEIF,VAL1,Oper,VAL2

    #     ----

    #     *ELSE

    #     ----

    #     *ENDIF

    #     where "----" represents a block of any number of commands.  Any number
    #     of *ELSEIF clauses (or none) may be included (in the location shown).
    #     One *ELSE clause (at most) may be included (in the location shown).
    #     The *IF command is executed by evaluating its logical expression.  If
    #     it is true, the block of commands following it is executed.  The
    #     construct is considered to be complete and the command following the
    #     *ENDIF is executed next.  If the logical expression is false, the next
    #     *ELSEIF command (if any) following the block is executed.  The
    #     execution logic is the same as for *IF.  The effect is that the logical
    #     expressions in the *IF and the *ELSEIF commands are sequentially tested
    #     until one is found to be true.  Then the block of commands immediately
    #     following the expression is executed, which completes the execution of
    #     the if-then-else construct.  If all *IF and *ELSEIF expressions are
    #     false, the block following the *ELSE command is executed, if there is
    #     one.  Only one block of commands (at most) is executed within the if-
    #     then-else construct.  If a batch input stream hits an end-of-file
    #     during a false *IF condition, the ANSYS run will not terminate
    #     normally. You will need to terminate it externally (use either the
    #     Linux “kill” function or the Windows task manager). The *IF, *ELSEIF,
    #     *ELSE, and *ENDIF commands for each if-then-else construct must all be
    #     read from the same file (or keyboard).

    #     This command is valid in any processor.
    #     """
    #     command = "*IF,%s,%s,%s,%s,%s,%s,%s,%s" % (str(val1), str(oper1), str(val2), str(b_ase1), str(val3), str(oper2), str(val4), str(b_ase2))
    #     return self.run(command, **kwargs)

    def lsla(self, type="", **kwargs):
        """APDL Command: LSLA

        Selects those lines contained in the selected areas.

        Parameters
        ----------
        type
            Label identifying the type of line select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "LSLA,%s" % (str(type))
        return self.run(command, **kwargs)

    def sload(self, secid="", plnlab="", kinit="", kfd="", fdvalue="",
              lsload="", lslock="", **kwargs):
        """APDL Command: SLOAD

        Load a pretension section.

        Parameters
        ----------
        secid
            Unique section number. The number must already be assigned to a
            pretension section.

        plnlab
            Label representing the pretension load sequence number in the
            format "PLnn" where nn is an integer from 1 through 99 (for
            example, PL01 through PL99).

        kinit
            Initial action key for pretension load PL01. (This field is omitted
            for PL02 and up.) Three scenarios are possible:

            LOCK - Constrains (connects) the cutting plane on the pretension section. This value
                   is the default.

            SLID - Unconstrains (disconnects) the cutting plane on the pretension section.

            TINY - Applies a very small pretension load (0.1% of FDVALUE) before the desired load
                   is established. The small load prevents convergence problems
                   which can occur when the desired load is not established in
                   the first load step. This value is valid only if KFD = FORC.

        kfd
            Force/Displacement key. Specifies whether FDVALUE is a force or a
            displacement:

            FORC - Apply a force on the specified pretension section. This value is the default.

            DISP - Apply a displacement (adjustment) on the specified pretension section.

        fdvalue
            Pretension load value. If KFD = FORC, this value is a pretension
            force. If KFD = DISP, this value is a pretension displacement
            (adjustment).

        lsload
            Load step in which to apply the FDVALUE.

        lslock
            The load step in which the displacement value resulting from the
            pretension force is locked. This value is valid only if KFD = FORC.

        Notes
        -----
        The SLOAD command applies pretension loads to specified pretension
        sections (created via the PSMESH command). A pretension load is ramp-
        applied (KBC = 0) if it is a force (KFD = FORC), and step-applied (KBC
        = 1) if it is a displacement (KFD = DISP).

        You can “lock” the load value at a specified load step. When locked,
        the load changes from a force to a displacement, and ANSYS applies the
        load as a constant displacement in all future load steps. Locking is
        useful when applying additional loadings. The additional loadings alter
        the effect of the initial load value, but because locking transforms
        the load into a displacement, it preserves the initial load's effect.

        In modal and harmonic analyses, any pretension load (force,
        displacement, or locked) is ignored and no load is produced.

        The following command shows how to establish loads on a pretension
        section:

        SLOAD,1,PL01,TINY,FORC,5000,2,3

        In this example, the load is applied to pretension section 1, and the
        sequence begins with the initial action key, KINIT, set to TINY. A
        small stabilization load (5 = 0.10% of 5000) is applied in the first
        load step, as the actual pretension force is not applied until the
        second load step. The next four fields set the actual load: the KFD
        value FORC specifies the type of load, FDVALUE defines the pretension
        load value (5000), LSLOAD specifies the load step in which the force is
        applied (2), and the LSLOCK field specifies the load step in which the
        force is locked (3). Additional sets of four fields can be used to
        define additional loads.

        You can use the SLOAD command to edit (overwrite) existing loads on a
        pretension section. This example changes the load on pretension section
        1 (set above) to 6000:

        SLOAD,1,PL01,,,6000,2,3

        Unspecified values (blank fields), as shown in this example, remain
        unchanged from prior settings. If no prior specifications exist, then
        default values (KINIT = LOCK and KFD = FORC) apply.

        The command can also delete all loads on a specified pretension
        section, as shown here:

        SLOAD,1,DELETE

        For a prestressed modal analysis, this command locks the pretension
        element:

        SLOAD,1,PL01,LOCK,DISP,0,1,2
        """
        command = "SLOAD,%s,%s,%s,%s,%s,%s,%s" % (str(secid), str(plnlab), str(kinit), str(kfd), str(fdvalue), str(lsload), str(lslock))
        return self.run(command, **kwargs)

    def small(self, ir="", ia="", ib="", ic="", name="", facta="", factb="",
              factc="", **kwargs):
        """APDL Command: SMALL

        Finds the smallest of three variables.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        ia, ib, ic
            Reference numbers of the three variables to be operated on.  If
            only two, leave IC blank.  If only one, leave IB blank also.

        name
            Thirty-two character name identifying the variable on printouts and
            displays.  Embedded blanks are compressed for output.

        --, --
            Unused fields.

        facta, factb, factc
            Scaling factors (positive or negative) applied to the corresponding
            variables (defaults to 1.0).

        Notes
        -----
        Finds the smallest of three variables according to the operation:

        IR = smallest of (FACTA x IA, FACTB x IB, FACTC x IC)
        """
        command = "SMALL,%s,%s,%s,%s,%s,%s,%s,%s" % (str(ir), str(ia), str(ib), str(ic), str(name), str(facta), str(factb), str(factc))
        return self.run(command, **kwargs)

    def fp(self, stitm="", c1="", c2="", c3="", c4="", c5="", c6="", **kwargs):
        """APDL Command: FP

        Defines the fatigue S vs. N and Sm vs. T tables.

        Parameters
        ----------
        stitm
            Starting item number for entering properties (defaults to 1).  If
            1, data input in field C1 of this command is entered as the first
            item in the list; if 7, data input in field C1 of this command is
            entered as the seventh item in the list; etc.  If the item number
            is negative, C1-C6 are ignored and the item is deleted.  If -ALL,
            the table is erased.  Items are as follows (items 41-62 are
            required only if simplified elastic-plastic code calculations are
            to be performed):

            1,2,...20 - N1, N2, ... N20

            21,22,...40 - S1, S2, ... S20

            41,42,...50 - T1, T2, ... T10

            51,52,...60 - Sm1, Sm2, ... Sm10

            61 - M (first elastic-plastic material parameter)

            62 - N (second elastic-plastic material parameter)

        c1, c2, c3, . . . , c6
            Data inserted into six locations starting with STITM.  If a value
            is already in one of these locations, it will be redefined.  A
            blank retains the previous value.

        Notes
        -----
        Defines the fatigue alternating stress (S) vs. cycles (N) table and the
        design stress-intensity value (Sm) vs. temperature (T) table.  May also
        be used to modify any previously stored property tables.  Log-log
        interpolation is used in the S vs. N table and linear interpolation is
        used in the Sm vs. T table.  Cycles and temperatures must be input in
        ascending order; S and Sm values in descending order.  Table values
        must be supplied in pairs, i.e., every N entry must have a
        corresponding S entry, etc.  Not all property pairs per curve need be
        used.  If no S vs. N table is defined, the fatigue evaluation will not
        produce usage factor results.  See the Structural Analysis Guide for
        details.
        """
        command = "FP,%s,%s,%s,%s,%s,%s,%s" % (str(stitm), str(c1), str(c2), str(c3), str(c4), str(c5), str(c6))
        return self.run(command, **kwargs)

    def units(self, label="", lenfact="", m_assfact="", timefact="",
              tempfact="", toffset="", chargefact="", forcefact="",
              heatfact="", **kwargs):
        """APDL Command: /UNITS

        Annotates the database with the system of units used.

        Parameters
        ----------
        label
            Label to denote the system of units used in this job:

            USER - User-defined system (default).

            SI - International system (m, kg, s, K).

            MKS - MKS system (m, kg, s, °C).

            uMKS - μMKS system (μm, kg, s, °C).

            CGS - CGS system (cm, g, s, °C).

            MPA - MPA system (mm, Mg, s, °C).

            BFT - U. S. Customary system using feet (ft, slug, s, °F).

            BIN - U. S. Customary system using inches (in, lbf*s2/in, s, °F).

        Notes
        -----
        Allows the user to set a marker in the database indicating the system
        of units used.  The setting may be reviewed with the /STATUS command at
        the Begin level.  The units label and conversion factors on this
        command are for user convenience only and have no effect on the
        analysis or data.  That is, /UNITS will not convert database items from
        one system to another (e.g., from U. S. Customary to SI, etc.).  The
        units setting will be written to the file of IGES data [IGESOUT or
        CDWRITE], which can then be read by many programs that read IGES files.
        The user must still use consistent units for the results to be valid.

        If you choose the MKS system of units, the EPZRO option for the EMUNIT
        command is set to 8.85 e-12 F/m.  (EPZRO specifies alternate free-space
        permittivity.)

        For micro-electromechanical systems (MEMS), where dimensions are on the
        order of microns, see the conversion factors in System of Units in the
        Coupled-Field Analysis Guide.

        If you use the ANSYS ADAMS Interface to export model information to the
        ADAMS program, the /UNITS command is required to ensure the correct
        transfer of data between ANSYS and ADAMS. You may choose a predefined
        unit system label (Label = SI, CGS, etc.) or you can select the user-
        defined system option (Label = USER) and input the appropriate
        conversion factors (LENFACT, MASSFACT, TIMEFACT, and FORCEFACT). The
        conversion factors will be written to the ADAMS input file Jobname.MNF
        in order to correctly generate the load. For more information, see
        Export to ADAMS in the Substructuring Analysis Guide.

        All differences between the base solution units used by the ANSYS and
        CFX solvers will be noted in the ANSYS output file.   Unit conversions
        are automatically applied to all loads transferred unless Label = USER.
        Unit conversions are not applied to any of the loads transferred
        between the ANSYS and CFX solvers if they use a user-defined unit
        system.

        This command is valid in any processor.
        """
        command = "/UNITS,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(label), str(lenfact), str(m_assfact), str(timefact), str(tempfact), str(toffset), str(chargefact), str(forcefact), str(heatfact))
        return self.run(command, **kwargs)

    def term(self, kywrd="", opt1="", opt2="", opt3="", **kwargs):
        """APDL Command: TERM

        Specifies various terminal driver options.

        Parameters
        ----------
        ncopy
            Activate hard copy device for NCOPY (0,1,2, etc.) copies.

        Notes
        -----
        Used only with terminal driver names on /SHOWDISP command.

        This command is also valid in PREP7.
        """
        command = "TERM,%s,%s,%s,%s" % (str(kywrd), str(opt1), str(opt2), str(opt3))
        return self.run(command, **kwargs)

    def ngen(self, itime="", inc="", node1="", node2="", ninc="", dx="", dy="",
             dz="", space="", **kwargs):
        """APDL Command: NGEN

        Generates additional nodes from a pattern of nodes.

        Parameters
        ----------
        itime, inc
            Do this generation operation a total of ITIME times, incrementing
            all nodes in the given pattern by INC each time after the first.
            ITIME must be > 1 for generation to occur.

        node1, node2, ninc
            Generate nodes from the pattern of nodes beginning with NODE1 to
            NODE2 (defaults to NODE1) in steps of NINC (defaults to 1).  If
            NODE1 = ALL, NODE2 and NINC are ignored and the pattern is all
            selected nodes [NSEL].  If NODE1 = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).  A component name may also be substituted for NODE1 (NODE2
            and NINC are ignored).

        dx, dy, dz
            Node location increments in the active coordinate system (DR, Dθ,
            DZ for cylindrical, DR, Dθ, DΦ for spherical or toroidal).

        space
            Spacing ratio.  Ratio of last division size to first division size.
            If > 1.0, divisions increase.  If < 1.0, divisions decrease.  Ratio
            defaults to 1.0 (uniform spacing).

        Notes
        -----
        Generates additional nodes from a given node pattern.  Generation is
        done in the active coordinate system.  Nodes in the pattern may have
        been generated in any coordinate system.

        This command is also valid in the /MAP processor.
        """
        command = "NGEN,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(itime), str(inc), str(node1), str(node2), str(ninc), str(dx), str(dy), str(dz), str(space))
        return self.run(command, **kwargs)

    def soluopt(self, **kwargs):
        """APDL Command: SOLUOPT

        Specifies "Solution options" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "SOLUOPT," % ()
        return self.run(command, **kwargs)

    def lextnd(self, nl1="", nk1="", dist="", keep="", **kwargs):
        """APDL Command: LEXTND

        Extends a line at one end by using its slope.

        Parameters
        ----------
        nl1
            Number of the line to be extended.  If NL1 = P, graphical picking
            is enabled and all remaining command fields are ignored (valid only
            in the GUI).

        nk1
            Number of keypoint at the end of line NL1 to be extended.

        dist
            Distance that the line will be extended.

        keep
            Specifies whether to keep the input entities:

            0 - Modify old line to use new keypoints and slopes.

            1 - Do not modify old line.  New line will overlay old line and have unique
                keypoints.

        Notes
        -----
        Extends a line at one end by using its slope.  Lines may be redefined
        only if not yet attached to an area.  Line divisions are set to zero
        (use LESIZE, etc. to modify).  Note that solid modeling in a toroidal
        coordinate system is not recommended.
        """
        command = "LEXTND,%s,%s,%s,%s" % (str(nl1), str(nk1), str(dist), str(keep))
        return self.run(command, **kwargs)

    def emunit(self, lab="", value="", **kwargs):
        """APDL Command: EMUNIT

        Specifies the system of units for magnetic field problems.

        Parameters
        ----------
        lab
            Label specifying the type of units:

            MKS - Rationalized MKS system of units (meters, amperes, henries, webers, etc.).
                  Free-space permeability is set to 4 πe-7 henries/meter. Free-
                  space permittivity is set to 8.85 e-12 F/m.

            MUZRO - User defined system of units. Free-space permeability is set to the value input
                    for VALUE. Other units must correspond to the permeability
                    units. Relative permeability may be altered to absolute
                    values.

            EPZRO - User defined system of units. Free-space permittivity is set to the value input
                    for VALUE. Other units must correspond to the permittivity
                    units.

        value
            User value of free-space permeability (defaults to 1) if Lab =
            MUZRO, or free-space permittivity (defaults to 1) if Lab = EPZRO.

        Notes
        -----
        Specifies the system of units to be used for electric and magnetic
        field problems. The free-space permeability and permittivity values may
        be set as desired. These values are used with the relative property
        values [MP] to establish absolute property values.

        Note:: : If the magnetic source field strength (Hs) has already been
        calculated [BIOT], switching EMUNIT will not change the values.

        For micro-electromechanical systems (MEMS), where dimensions are on the
        order of microns, see the conversion factors in System of Units in the
        Coupled-Field Analysis Guide.

        This command is also valid in SOLUTION.
        """
        command = "EMUNIT,%s,%s" % (str(lab), str(value))
        return self.run(command, **kwargs)

    def line(self, **kwargs):
        """APDL Command: LINE

        Specifies "Lines" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "LINE," % ()
        return self.run(command, **kwargs)

    def dim(self, par="", type="", imax="", jmax="", kmax="", var1="", var2="",
            var3="", csysid="", **kwargs):
        """APDL Command: *DIM

        Defines an array parameter and its dimensions.

        Parameters
        ----------
        par
            Name of parameter to be dimensioned.  See *SET for name
            restrictions.

        type
            Array type:

            Arrays are similar to standard FORTRAN arrays (indices are integers) (default).  Index numbers for the rows, columns, and planes are sequential values beginning with one. Used for 1-, 2-, or 3-D arrays. - Same as ARRAY, but used to specify 4-D arrays.

            Same as ARRAY, but used to specify 5-D arrays. - Array entries are character strings (up to 8 characters each).  Index numbers
                              for rows, columns, and planes are sequential
                              values beginning with one.

            Array indices are real (non-integer) numbers which must be defined when filling the table.  Index numbers for the rows and columns are stored in the zero column and row "array elements" and are initially assigned a near-zero value.  Index numbers must be in ascending order and are used only for retrieving an array element.  When retrieving an array element with a real index that does not match a specified index, linear interpolation is done among the nearest indices and the corresponding array element values [*SET]. Used for 1-, 2-, or 3-D tables. - Same as TABLE, but used to specify 4-D tables.

            Same as TABLE, but used to specify 5-D tables. - Array entries are character strings (up to IMAX each). Index numbers for
                              columns and planes are sequential values
                              beginning with 1. Row index is character position
                              in string.

        imax
            Extent of first dimension (row). (For Type = STRING, IMAX is
            rounded up to the next multiple of eight and has a limit of 248).
            Defaults to 1.

        jmax
            Extent of second dimension (column).  Defaults to 1.

        kmax
            Extent of third dimension (plane).  Defaults to 1.

        var1
            Variable name corresponding to the first dimension (row) for Type =
            TABLE.  Defaults to Row.

        var2
            Variable name corresponding to the second dimension (column) for
            Type = TABLE.  Defaults to Column.

        var3
            Variable name corresponding to the third dimension (plane) for Type
            = TABLE.  Defaults to Plane.

        csysid
            An integer corresponding to the coordinate system ID Number.

        Notes
        -----
        Up to three dimensions (row, column, and plane) may be defined using
        ARRAY and TABLE.  Use ARR4, ARR5, TAB4, and TAB5 to define up to five
        dimensions (row, column, plane, book, and shelf). An index number is
        associated with each row, column, and plane.  For array and table type
        parameters, element values are initialized to zero.  For character and
        string parameters, element values are initialized to (blank).  A
        defined parameter must be deleted [*SET] before its dimensions can be
        changed.  Scalar (single valued) parameters should not be dimensioned.
        *DIM,A,,3 defines a vector array with elements A(1), A(2), and A(3).
        *DIM,B,,2,3 defines a 2x3 array with elements B(1,1), B(2,1), B(1,2),
        B(2,2), B(1,3), and B(2,3).  Use *STATUS,Par to display elements of
        array Par. You can write formatted data files (tabular formatting) from
        data held in arrays through the *VWRITE command.

        If you use table parameters to define boundary conditions, then Var1,
        Var2, and/or Var3 can either specify a primary variable (listed in
        Table: 130:: *DIM - Primary Variables) or can be an independent
        parameter.  If specifying an independent parameter, then you must
        define an additional table for the independent parameter.  The
        additional table must have the same name as the independent parameter
        and may be a function of one or more primary variables or another
        independent parameter.  All independent parameters must relate to a
        primary variable.

        Tabular load arrays can be defined in both global Cartesian (default)
        or local (see below) coordinate systems by specifying CSYSID, as
        defined in LOCAL. For batch operations, you must specify your
        coordinate system first.

        The following constraints apply when you specify a local coordinate
        system for your tabular loads:

        If you are specifying a 4- or 5-D array or table, four additional
        fields (LMAX, MMAX, Var4, and Var5) are available. Thus, for a 4-D
        table, the command syntax would be:

        For a 5-D table, the command syntax would be:

        You cannot create or edit 4- or 5-D arrays or tables using the GUI.

        See Array Parameters for a detailed discussion on and examples for
        using array parameters.

        Table: 130:: : *DIM - Primary Variables

        Specify PRESSURE as the independent variable (not PRES).

        The X, Y, and Z coordinate locations listed above are valid in global
        Cartesian, or local (Cartesian, cylindrical and spherical) coordinate
        systems. The VELOCITY label is applicable only to the calculated fluid
        velocity in element FLUID116.

        When using PRESSURE as a primary variable, the underlying element must
        have the pressure DOF associated with it, or it must be a supported
        contact element.

        The gap/penetration label (GAP) is only used for defining certain
        contact element real constants.

        The frequency label (FREQ) is valid for harmonic analyses only.

        The OMEGS, ECCENT, and THETA primary variables only apply to the
        COMBI214 element. The amplitude of the rotational velocity (OMEGS) is
        an absolute value, so only positive values of OMEGS are valid. The
        eccentricity (ECCENT) and phase shift (THETA) labels are only valid for
        nonlinear analyses.

        If you use table parameters to define boundary conditions, the table
        names (Par) must not exceed 32 characters.

        In thermal analyses, if you apply tabular loads as a function of
        temperature but the rest of the model is linear (e.g., includes no
        temperature-dependent material properties or radiation ), you should
        turn on Newton-Raphson iterations (NROPT,FULL) to evaluate the
        temperature-dependent tabular boundary conditions correctly.

        This command is valid in any processor.
        """
        command = "*DIM,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(par), str(type), str(imax), str(jmax), str(kmax), str(var1), str(var2), str(var3), str(csysid))
        return self.run(command, **kwargs)

    def emtgen(self, ncomp="", ecomp="", pncomp="", dof="", gap="", gapmin="",
               fkn="", epzero="", **kwargs):
        """APDL Command: EMTGEN

        Generates a set of TRANS126 elements.

        Parameters
        ----------
        ncomp
             Component name of the surface nodes of a structure which attach to
            the TRANS126 elements. You must enclose name-strings in single
            quotes in the EMTGEN command line.

        ecomp
             Component name of the TRANS126 elements generated. You must
            enclose name-strings in single quotes in the EMTGEN command line.
            Defaults to EMTELM.

        pncomp
            Component name of the plane nodes generated by the command at an
            offset (GAP) from the surface nodes. You must enclose name-strings
            in single quotes in the EMTGEN command line. Defaults to EMTPNO.

        dof
            Active structural degree of freedom (DOF) for TRANS126 elements
            (UX, UY, or UZ) in the Cartesian coordinate system. You must
            enclose the DOF in single quotes.

        gap
            Initial gap distance from the surface nodes to the plane. Be sure
            to use the correct sign with respect to Ncomp node location.

        gapmin
            Minimum gap distance allowed (GAPMIN real constant) for TRANS126
            elements. Defaults to the absolute value of (GAP)*0.05.

        fkn
            Contact stiffness factor used as a multiplier for a contact
            stiffness appropriate for bulk deformation. Defaults to 0.1.

        epzero
            Free-space permittivity. Defaults to 8.854e-6 (μMKS units).

        Notes
        -----
        The EMTGEN command generates a set of TRANS126 elements between the
        surface nodes of a moveable structure and a plane of nodes, typically
        representing a ground plane. The plane of nodes are created by the
        command at a specified offset (GAP). Each element attaches to a surface
        node and to a corresponding node representing the plane. The created
        elements are set to the augmented stiffness method (KEYOPT(6) = 1),
        which can help convergence. The generated plane nodes should be
        constrained appropriately for the analysis.

        You can use TRANS126 elements for simulating fully coupled
        electrostatic structural coupling between a MEMS device and a plane, if
        the gap distance between the device and the plane is small compared to
        the overall surface area dimensions of the device. This assumption
        allows for a point-wise closed-form solution of capacitance between the
        surface nodes and the plane; i.e. CAP = EPZERO*AREA/GAP, where EPZERO
        if the free-space permittivity, AREA is the area associated with the
        node, and GAP is the gap between the node and the plane. The area for
        each node is computed using the ARNODE function in ANSYS. See the *GET
        command description for more information on the ARNODE function.

        With a distributed set of TRANS126 elements attached directly to the
        structure and a plane (such as a ground plane), you can perform a full
        range of coupled electrostatic-structural simulations, including:

        Static analysis (due to a DC voltage or a mechanical load)

        Prestressed modal analysis (eigenfrequencies, including frequency-shift
        effects of a DC bias voltage)

        Prestressed harmonic analysis (system response to a small-signal AC
        excitation with a DC bias voltage or mechanical load)

        Large signal transient analysis (time-transient solution due to an
        arbitrary time-varying voltage or mechanical excitation)

        The TRANS126 element also employs a node-to-node gap feature so you can
        perform contact-type simulations where the structure contacts a plane
        (such as a ground plane). The contact stiffness factor, FKN, is used to
        control contact penetration once contact is initiated. A smaller value
        provides for easier convergence, but with more penetration.
        """
        command = "EMTGEN,%s,%s,%s,%s,%s,%s,%s,%s" % (str(ncomp), str(ecomp), str(pncomp), str(dof), str(gap), str(gapmin), str(fkn), str(epzero))
        return self.run(command, **kwargs)

    def secwrite(self, fname="", ext="", elem_type="", **kwargs):
        """APDL Command: SECWRITE

        Creates an ASCII file containing user mesh section information.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        elem_type
            Element type attribute pointer (ET) for the elements that are part
            of the section.  See   SECREAD for a detailed description.

        Notes
        -----
        Before creating a user mesh file, first create a model using 2-D
        meshing. Use PLANE183 or MESH200 with KEYOPT(1) = 7 (quadrilateral with
        8 nodes option) to model the cells.  SECWRITE creates an ASCII file
        that contains information about the nodes and cells that describe a
        beam section. For detailed information on how to create a user mesh
        file, see Creating Custom Cross Sections with a User-defined Mesh in
        the Structural Analysis Guide.
        """
        command = "SECWRITE,%s,%s,%s" % (str(fname), str(ext), str(elem_type))
        return self.run(command, **kwargs)

    def arsym(self, ncomp="", na1="", na2="", ninc="", kinc="", noelem="",
              imove="", **kwargs):
        """APDL Command: ARSYM

        Generates areas from an area pattern by symmetry reflection.

        Parameters
        ----------
        ncomp
            Symmetry key:

            X - X symmetry (default).

            Y - Y symmetry.

            Z - Z symmetry.

        na1, na2, ninc
            Reflect areas from pattern beginning with NA1 to NA2 (defaults to
            NA1) in steps of NINC (defaults to 1).  If NA1 = ALL, NA2 and NINC
            are ignored and the pattern is all selected areas [ASEL].  If Ncomp
            = P, use graphical picking to specify areas and ignore NL2 and
            NINC.  A component name may also be substituted for NA1 (NA2 and
            NINC are ignored).

        kinc
            Keypoint increment between sets.  If zero, the lowest available
            keypoint numbers are assigned [NUMSTR].

        noelem
            Specifies whether nodes and elements are also to be generated:

            0 - Generate nodes and elements associated with the original areas, if they exist.

            1 - Do not generate nodes and elements.

        imove
            Specifies whether areas will be moved or newly defined:

            0 - Generate additional areas.

            1 - Move original areas to new position retaining the same keypoint numbers (KINC
                and NOELEM are ignored).  Valid only if the old areas are no
                longer needed at their original positions.  Corresponding
                meshed items are also moved if not needed at their original
                position.

        Notes
        -----
        Generates a reflected set of areas (and their corresponding keypoints,
        lines and mesh) from a given area pattern by a symmetry reflection (see
        analogous node symmetry command, NSYM).  The MAT, TYPE, REAL, ESYS, and
        SECNUM attributes are based upon the areas in the pattern and not upon
        the current settings.  Reflection is done in the active coordinate
        system by changing a particular coordinate sign.  The active coordinate
        system must be a Cartesian system.  Areas in the pattern may have been
        generated in any coordinate system.  However, solid modeling in a
        toroidal coordinate system is not recommended.  Areas are generated as
        described in the AGEN command.

        See the ESYM command for additional information about symmetry
        elements.
        """
        command = "ARSYM,%s,%s,%s,%s,%s,%s,%s" % (str(ncomp), str(na1), str(na2), str(ninc), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def rexport(self, target="", lstep="", sbstep="", fname="", ext="",
                **kwargs):
        """APDL Command: REXPORT

        Exports displacements from an implicit run to ANSYS LS-DYNA.

        Parameters
        ----------
        target
            The type of analysis run to which displacements are exported.

            OFF - Ignore initial displacements.

            DYNA - Get initial displacements from an earlier implicit (ANSYS) run and export to an
                   explicit ANSYS LS-DYNA run (Default).

        --, --
            Unused fields.

        lstep
            Load step number of data to be exported.  Defaults to the last load
            step.

        sbstep
            Substep number of data to be exported.  Defaults to the last
            substep.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        This command exports the displacements, rotations, and temperatures
        calculated in an ANSYS implicit analysis into the `drelax' file, which
        is subsequently read in by ANSYS LS-DYNA when a dynamic relaxation or
        stress initialization is conducted [EDDRELAX].

        This command is not written to the Jobname.CDB file when the CDWRITE
        command is issued.
        """
        command = "REXPORT,%s,%s,%s,%s,%s" % (str(target), str(lstep), str(sbstep), str(fname), str(ext))
        return self.run(command, **kwargs)

    def eddbl(self, key="", **kwargs):
        """APDL Command: EDDBL

         Selects a numerical precision type of the explicit dynamics analysis.

        Parameters
        ----------
        key
            Number or name identifying numerical precision to be used.

            0 or SINGLE - Select single precision version of LS-DYNA (default).

            1 or DOUBLE - Select double precision version of LS-DYNA.

            STAT - Check the status of the numerical precision in effect.

        Notes
        -----
        Sets the single or double precision version of LS-DYNA into effect.
        Please check the availability of the double precision version of LS-
        DYNA on your system before using the command. If it is not available,
        use the command default.

        The double precision version may be up to 20% slower than the single
        precision version. The results may also vary based on problem
        specifications.

        In addition to EDDBL,STAT, you can use the GUI dialog box to verify
        which precision version is currently chosen. The GUI is based on the
        database and is updated to reflect changes.

        See Double Precision LS-DYNA for more information.

        This command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDDBL,%s" % (str(key))
        return self.run(command, **kwargs)

    def edhgls(self, hgco="", **kwargs):
        """APDL Command: EDHGLS

        Specifies the hourglass coefficient for an explicit dynamics analysis.

        Parameters
        ----------
        hgco
            Hourglass coefficient value (defaults to 0.1). Values greater than
            0.15 may cause instabilities.

        Notes
        -----
        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDHGLS,%s" % (str(hgco))
        return self.run(command, **kwargs)

    def smat(self, matrix="", type="", method="", val1="", val2="", val3="",
             **kwargs):
        """APDL Command: *SMAT

        Creates a sparse matrix.

        Parameters
        ----------
        matrix
            Name used to identify the matrix. Must be specified.

        type
            Matrix type:

            Double precision real values (default). - Complex double precision values.

        method
            Method used to create the matrix:

            Copy an existing matrix. - Import the matrix from a file.

        val1, val2, val3
            Additional input. The meaning of Val1 through Val3 will vary
            depending on the specified Method. See details below.

        Notes
        -----
        Use the *DMAT command to create a dense matrix.

        Unlike the *DMAT command, the *SMAT command cannot be used to allocate
        a sparse matrix.

        For more information on the NOD2BCS and USR2BCS mapping vectors, see
        Degree of Freedom Ordering in the ANSYS Parametric Design Language
        Guide.

        For more information about .FULL file contents, see the HBMAT in the
        Command Reference.
        """
        command = "*SMAT,%s,%s,%s,%s,%s,%s" % (str(matrix), str(type), str(method), str(val1), str(val2), str(val3))
        return self.run(command, **kwargs)

    def hpgl(self, kywrd="", opt1="", opt2="", **kwargs):
        """APDL Command: HPGL

        Specifies various HP options.

        Parameters
        ----------
        pmod
            Valid plotter model:  7475A (default), 7550A, 7580B, 7585B, 7586B,
            COLORPRO, DRAFTPRO, or DRAFTMASTER.

        Notes
        -----
        This command is available in both the ANSYS and DISPLAY programs.  It
        is valid for Hewlett Packard Graphics Language (HPGL) format files
        selected in the ANSYS program with /SHOW,HPGL (or HPGL2), or with
        /SHOWDISP,HPGL (or HPGL2) in the DISPLAY program.

        An output file is generated for each plot.  The ANSYS file is named
        JobnameNN.HPGL.  In the DISPLAY program, this file is named HPGLnn.
        This file remains open for a subsequent /NOERASE plot, and will be
        incomplete until the program is closed (/EXIT), or until the next file
        is opened by the next /ERASE plot request.
        """
        command = "HPGL,%s,%s,%s" % (str(kywrd), str(opt1), str(opt2))
        return self.run(command, **kwargs)

    def vscfun(self, parr="", func="", par1="", **kwargs):
        """APDL Command: *VSCFUN

        Determines properties of an array parameter.

        Parameters
        ----------
        parr
            The name of the resulting scalar parameter.  See *SET for name
            restrictions.

        func
            Functions:

            Maximum: the maximum Par1 array element value. - Minimum: the minimum Par1 array element value.

            Index location of the maximum Par1 array element value.  Array Par1 is searched starting from its specified index. - Index location of the minimum Par1 array element value.  Array Par1 is searched
                              starting from its specified index.

            Index location of the first nonzero value in array Par1.  Array Par1 is searched starting from its specified index. - Index location of the last nonzero value in array Par1.  Array Par1 is searched
                              starting from its specified index.

            Sum:  Par1 (the summation of the Par1 array element values). - Median: value of Par1 at which there are an equal number of values above and
                              below.

            Mean: (σ Par1)/NUM, where NUM is the number of summed values. - Variance: (σ ((Par1-MEAN)**2))/NUM.

            Standard deviation: square root of VARI. - Root-mean-square: square root of (σ (Par1**2))/NUM.

        par1
            Array parameter vector in the operation.

        Notes
        -----
        Operates on one input array parameter vector and produces one output
        scalar parameter according to:

        ParR = f(Par1)

        where the functions (f) are described below. The starting array element
        number must be defined for the array parameter vector.  For example,
        *VSCFUN,MU,MEAN,A(1) finds the mean of the A vector values, starting
        from the first value and stores the result as parameter MU.  Operations
        use successive array elements [*VLEN, *VMASK] with the default being
        all successive array elements.  Absolute values and scale factors may
        be applied to all parameters [*VABS, *VFACT].  Results may be
        cumulative [*VCUM].  See the *VOPER command for details.

        This command is valid in any processor.
        """
        command = "*VSCFUN,%s,%s,%s" % (str(parr), str(func), str(par1))
        return self.run(command, **kwargs)

    def aux3(self, **kwargs):
        """APDL Command: /AUX3

        Enters the results file editing processor.

        Notes
        -----
        Enters the results file editing processor (ANSYS auxiliary processor
        AUX3).  This processor is used to edit ANSYS results files.

        This command is valid only at the Begin Level.
        """
        command = "/AUX3," % ()
        return self.run(command, **kwargs)

    def cyl4(self, xcenter="", ycenter="", rad1="", theta1="", rad2="",
             theta2="", depth="", **kwargs):
        """APDL Command: CYL4

        Creates a circular area or cylindrical volume anywhere on the working
        plane.

        Parameters
        ----------
        xcenter, ycenter
            Working plane X and Y coordinates of the center of the circle or
            cylinder.

        rad1, rad2
            Inner and outer radii (either order) of the circle or cylinder.  A
            value of zero or blank for either RAD1 or RAD2, or the same value
            for both RAD1 and RAD2, defines a solid circle or cylinder.

        theta1, theta2
            Starting and ending angles (either order) of the circle or faces of
            the cylinder.  Used for creating a partial annulus or partial
            cylinder.  The sector begins at the algebraically smaller angle,
            extends in a positive angular direction, and ends at the larger
            angle.  The starting angle defaults to 0° and the ending angle
            defaults to 360°.  See the Modeling and Meshing Guide for an
            illustration.

        depth
            The perpendicular distance (either positive or negative based on
            the working plane Z direction) from the working plane representing
            the depth of the cylinder.  If DEPTH = 0 (default), a circular area
            is created on the working plane.

        Notes
        -----
        Defines a circular area anywhere on the working plane or a cylindrical
        volume with one face anywhere on the working plane.  For a solid
        cylinder of 360°, the top and bottom faces will be circular (each area
        defined with four lines) and they will be connected with two surface
        areas (each spanning 180°).  See the CYL5, PCIRC, and CYLIND commands
        for alternate ways to create circles and cylinders.

        When working with a model imported from an IGES file (DEFAULT import
        option), you must provide a value for DEPTH or the command will be
        ignored.
        """
        command = "CYL4,%s,%s,%s,%s,%s,%s,%s" % (str(xcenter), str(ycenter), str(rad1), str(theta1), str(rad2), str(theta2), str(depth))
        return self.run(command, **kwargs)

    def bflist(self, node="", lab="", **kwargs):
        """APDL Command: BFLIST

        Lists the body force loads on nodes.

        Parameters
        ----------
        node
            Node at which body load is to be listed.  If ALL (or blank), list
            for all selected nodes [NSEL].  If NODE = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for NODE.

        lab
            Valid body load label. If ALL (or blank), use all appropriate
            labels. See the BF command for labels. In an explicit dynamic
            analysis, the only valid body load label is TEMP.

        Notes
        -----
        Lists the body force loads for the specified node and label.  Nodal
        body loads may be defined with the BF command (except in an explicit
        dynamic analysis).

        The command BFLIST,TEMP can be used in an explicit dynamic analysis to
        list temperature loads that are read in by the LDREAD command. BFLIST
        cannot be used to list temperature loads defined by the EDLOAD command
        (use EDLOAD,LIST to list this type of load).

        This command is valid in any processor.
        """
        command = "BFLIST,%s,%s" % (str(node), str(lab))
        return self.run(command, **kwargs)

    def pmap(self, form="", discon="", **kwargs):
        """APDL Command: PMAP

        Creates mapping of the path geometry by defining path interpolation
        division points.

        Parameters
        ----------
        form
            Defines the mapping method:

            UNIFORM - Maps uniform divisions (specified on the nDiv argument of the PATH command)
                      between specified points.  This is the default.

            ACCURATE - Map geometry using a small division at the beginning and end of each segment.
                       This gives you accurate derivatives, integrals,
                       tangents, and normals for curves which do not have
                       continuous slopes at the specified points. To create
                       nonuniform divisions, the nDiv argument of the PATH
                       command must be greater than 2.

        discon
            Sets mapping for discontinuities in the field.  The divisions are
            modified to put a point just before and just after the
            discontinuity.  The valid label is MAT, for a material
            discontinuity.  No discontinuity is the default.  Discontinuity
            mapping involves the NOAV option on the PDEF command.
        """
        command = "PMAP,%s,%s" % (str(form), str(discon))
        return self.run(command, **kwargs)

    def cbte(self, alpha="", **kwargs):
        """APDL Command: CBTE

        Specifies a thermal expansion coefficient for a composite beam section.

        Parameters
        ----------
        alpha
            Coefficient of thermal expansion for the cross section.

        Notes
        -----
        The CBTE command, one of several composite beam section commands,
        specifies a thermal expansion coefficient for a beam section. The value
        specified is associated with the section most recently defined
        (SECTYPE) at the specified temperature (CBTMP).

        Unspecified values default to zero.

        Related commands are CBTMP, CBMX, and CBMD.

        For complete information, see Using Preintegrated Composite Beam
        Sections.
        """
        command = "CBTE,%s" % (str(alpha))
        return self.run(command, **kwargs)

    def save(self, fname="", ext="", slab="", **kwargs):
        """APDL Command: SAVE

        Saves all current database information.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        slab
            Mode for saving the database:

            ALL - Save the model data, solution data and post data (element tables, etc.). This
                  value is the default.

            MODEL - Save the model data (solid model, finite element model, loadings, etc.) only.

            SOLU - Save the model data and the solution data (nodal and element results).

        Notes
        -----
        Saves all current database information to a file (File.DB).  In
        interactive mode, an existing File.DB is first written to a backup file
        (File.DBB).  In batch mode, an existing File.DB is replaced by the
        current database information with no backup.  The command should be
        issued periodically to ensure a current file backup in case of a system
        "crash" or a "line drop."  It may also be issued before a "doubtful"
        command so that if the result is not what was intended the database may
        be easily restored to the previous state.  A save may be time consuming
        for large models.  Repeated use of this command overwrites the previous
        data on the file (but a backup file is first written during an
        interactive run).  When issued from within POST1, the nodal boundary
        conditions in the database (which were read from the results file) will
        overwrite the nodal boundary conditions existing on the database file.

        Internal nodes may be created during solution (for example, via the
        mixed u-P formulation or generalized plane strain option for current-
        technology elements, the Lagrangian multiplier method for contact
        elements or the MPC184 elements, or the quadratic or cubic option of
        the BEAM188 and PIPE288 elements). It is sometimes necessary to save
        the internal nodes in the database for later operations, such as
        cutting boundary interpolations (CBDOF) for submodeling. To do so,
        issue the SAVE command after the first SOLVE command.

        In general, saving after solving is always a good practice.

        This command is valid in any processor.
        """
        command = "SAVE,%s,%s,%s" % (str(fname), str(ext), str(slab))
        return self.run(command, **kwargs)

    def circle(self, pcent="", rad="", paxis="", pzero="", arc="", nseg="",
               **kwargs):
        """APDL Command: CIRCLE

        Generates circular arc lines.

        Parameters
        ----------
        pcent
            Keypoint defining the center of the circle (in the plane of the
            circle).  If PCENT = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).

        rad
            Radius of the circle.  If RAD is blank and PCENT = P, the radius is
            the distance from PCENT to PZERO.

        paxis
            Keypoint defining axis of circle (along with PCENT).  If PCENT = P
            and PAXIS is omitted, the axis is normal to the working plane.

        pzero
            Keypoint defining the plane normal to circle (along with PCENT and
            PAXIS) and the zero degree location.  Need not be in the plane of
            the circle. This value is not required if PAXIS is defined along
            the Y axis (that is, a circle in the XZ plane).

        arc
            Arc length (in degrees).  Positive follows right-hand rule about
            PCENT-PAXIS vector.  Defaults to 360°.

        nseg
            Number of lines around circumference (defaults to minimum required
            for 90°-maximum arcs, i.e., 4 for 360°).  Number of keypoints
            generated is NSEG for 360° or NSEG + 1 for less than 360°.

        Notes
        -----
        Generates circular arc lines (and their corresponding keypoints).
        Keypoints are generated at regular angular locations (based on a
        maximum spacing of 90°).  Arc lines are generated connecting the
        keypoints.  Keypoint and line numbers are automatically assigned,
        beginning with the lowest available values [NUMSTR].  Adjacent lines
        use a common keypoint.  Line shapes are generated as arcs, regardless
        of the active coordinate system.  Line shapes are invariant with
        coordinate system after they are generated.
        """
        command = "CIRCLE,%s,%s,%s,%s,%s,%s" % (str(pcent), str(rad), str(paxis), str(pzero), str(arc), str(nseg))
        return self.run(command, **kwargs)

    def plnsol(self, item="", comp="", kund="", fact="", fileid ="", **kwargs):
        """APDL Command: PLNSOL

        Displays results as continuous contours.

        Parameters
        ----------
        item
            Label identifying the item.  Valid item labels are shown in
            Table 220: PLNSOL - Valid Item and Component Labels below.  Some
            items also require a component label.

        comp
            Component of the item (if required).  Valid component labels are
            shown in  Table 220: PLNSOL - Valid Item and Component Labels
            below.

        kund
            Undisplaced shape key:

            0 - Do not overlay undeformed structure display

            1 - Overlay displaced contour plot with undeformed display (appearance is system-
                dependent)

            2 - Overlay displaced contour plot with undeformed edge display (appearance is
                system-dependent)

        fact
            Scale factor for 2-D display for contact items.  Default value is
            1.  A negative scaling factor may be used to invert the display.

        fileid
            The file index number (obtained via the NLDIAG,NRRE,ON command).
            Valid only for Item = NRRE.

        Notes
        -----
        Displays the solution results as continuous contours across element
        boundaries for the selected nodes and elements. For example, PLNSOL,S,X
        displays the X component of stress S (that is,  the SX stress
        component). Various element results depend upon the recalculation
        method and the selected results location [AVPRIN, RSYS, LAYER, SHELL,
        and NSEL].  Contours are determined by linear interpolation within each
        element from the nodal values, which are averaged at a node whenever
        two or more elements connect to the same node (except for FMAG, which
        is summed at the node).

        For PowerGraphics displays [/GRAPHICS,POWER], results are plotted only
        for the model exterior surface.  The items marked with [2] are not
        supported by PowerGraphics. To plot midside nodes, you must first issue
        /EFACET,2.

        Table: 220:: : PLNSOL - Valid Item and Component Labels
        """
        command = "PLNSOL,%s,%s,%s,%s,%s" % (str(item), str(comp), str(kund), str(fact), str(fileid ))
        return self.run(command, **kwargs)

    def cmedit(self, aname="", oper="", cnam1="", cnam2="", cnam3="", cnam4="",
               cnam5="", cnam6="", cnam7="", **kwargs):
        """APDL Command: CMEDIT

        Edits an existing assembly.

        Parameters
        ----------
        aname
            Name of the assembly to be edited.

        oper
            Operation label:

            ADD - To add more components.  The level of any assembly to be added must be lower
                  than that of the assembly Aname (see CMGRP command).

            DELE - To remove components.

        cnam1, cnam2, cnam3, . . . , cnam7
            Names of components and assemblies to be added to or deleted from
            the assembly.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "CMEDIT,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(aname), str(oper), str(cnam1), str(cnam2), str(cnam3), str(cnam4), str(cnam5), str(cnam6), str(cnam7))
        return self.run(command, **kwargs)

    def aoffst(self, narea="", dist="", kinc="", **kwargs):
        """APDL Command: AOFFST

        Generates an area, offset from a given area.

        Parameters
        ----------
        narea
            Area from which generated area is to be offset.  If NAREA = ALL,
            offset from all selected areas [ASEL].  If NAREA = P, graphical
            picking is enabled and all remaining arguments are ignored (valid
            only in the GUI).

        dist
            Distance normal to given area at which keypoints for generated area
            are to be located.  Positive normal is determined from the right-
            hand-rule keypoint order.

        kinc
            Keypoint increment between areas.  If zero, the lowest available
            keypoint numbers are assigned [NUMSTR].

        Notes
        -----
        Generates an area (and its corresponding keypoints and lines) offset
        from a given area.  The direction of the offset varies with the given
        area normal.  End slopes of the generated lines remain the same as
        those of the given pattern.  Area and line numbers are automatically
        assigned, beginning with the lowest available values [NUMSTR].
        """
        command = "AOFFST,%s,%s,%s" % (str(narea), str(dist), str(kinc))
        return self.run(command, **kwargs)

    def lcoper(self, oper="", lc_ase1="", oper2="", lc_ase2="", **kwargs):
        """APDL Command: LCOPER

        Performs load case operations.

        Parameters
        ----------
        oper
            Valid operations are:

            ZERO - Zero results portion of database (LCASE1 ignored).

            SQUA - Square database values (LCASE1 ignored).

            SQRT - Square root of database (absolute) values (LCASE1 ignored).

            LPRIN - Recalculate line element principal stresses (LCASE1 ignored).  Stresses are as
                    shown for the NMISC items of the ETABLE command for the
                    specific line element type.

            ADD - Add LCASE1 to database values.

            SUB - Subtract LCASE1 from database values.

            SRSS - Square root of the sum of the squares of database and LCASE1.

            MIN - Compare and save in database the algebraic minimum of database and LCASE1.

            MAX - Compare and save in database the algebraic maximum of database and LCASE1.

            ABMN - Compare and save in database the absolute minimum of database and LCASE1 (based
                   on magnitudes, then apply the corresponding sign).

            ABMX - Compare and save in database the absolute maximum of database and LCASE1 (based
                   on magnitudes, then apply the corresponding sign).

        lcase1
            First load case in the operation (if any).  See LCNO of the LCDEF
            command. If ALL, repeat operations using all selected load cases
            [LCSEL].

        oper2
            Valid operations are:

            MULT - Multiplication: LCASE1*LCASE2

            CPXMAX - This option does a phase angle sweep to calculate the maximum of derived
                     stresses and equivalent strain for a complex solution
                     where LCASE1 is the real part and LCASE2 is the imaginary
                     part. The Oper field is not applicable with  this option.
                     Also, the LCABS and SUMTYPE commands have no effect on
                     this option. The value of S3 will be a minimum.   This
                     option does not apply to derived displacement amplitude
                     (USUM). Load case writing (LCWRITE) is not supported. See
                     POST1 and POST26 – Complex Results Postprocessing in the
                     Mechanical APDL Theory Reference for more information.

        lcase2
            Second load case.  Used only with Oper2 operations.

        Notes
        -----
        LCOPER operates on the database and one or two load cases according to:

        Database = Database Oper (LCASE1 Oper2 LCASE2)

        where operations Oper and Oper2 are as described above.  Absolute
        values and scale factors may be applied to the load cases before the
        operations [LCABS, LCFACT].  If LCASE1 is not specified, only operation
        Oper is performed on the current database.  If LCASE2 is specified,
        operation Oper2 will be performed before operation Oper.  If LCASE2 is
        not specified, operation Oper2 is ignored.  Solution items not
        contained [OUTRES] in either the database or the applicable load cases
        will result in a null item during a load case operation.  Harmonic
        element data read from a result file load case are processed at zero
        degrees.  All load case combinations are performed in the solution
        coordinate system, and the data resulting from load case combinations
        are stored in the solution coordinate system.  The resultant data are
        then transformed to the active results coordinate system [RSYS] when
        listed or displayed. Except in the cases of Oper = LPRIN, ADD, or SUB,
        you must use RSYS,SOLU to list or display, and in the case of layered
        elements, the layer (LAYER) must also be specified.

        Use the FORCE command prior to any combination operation to correctly
        combine the requested force type.

        If Oper2=CPXMAX, the derived stresses and strain calculation do not
        apply to line elements.
        """
        command = "LCOPER,%s,%s,%s,%s" % (str(oper), str(lc_ase1), str(oper2), str(lc_ase2))
        return self.run(command, **kwargs)

    def psdspl(self, tblno="", rmin="", rmax="", **kwargs):
        """APDL Command: PSDSPL

        Defines a partially correlated excitation in a PSD analysis.

        Parameters
        ----------
        tblno
            Input PSD table number defined with PSDVAL command.

        rmin
            Minimum distance between excitation points which are partially
            correlated. Excited nodes closer than RMIN will be fully
            correlated.

        rmax
            Maximum distance between excitation points which are partially
            correlated. Excited nodes farther apart than RMAX will be
            uncorrelated.

        Notes
        -----
        Defines a partially correlated excitation in terms of a sphere of
        influence relating excitation point geometry (in a PSD analysis).  If
        the distance between any two excitation points is less than RMIN, then
        the excitation is fully correlated.  If the distance is greater than
        RMAX, then the excitation is uncorrelated.  If the distance lies
        between RMIN and RMAX, then the excitation is partially correlated with
        the degree of correlation dependent on the separation distance between
        the points. This command is not available for a pressure PSD analysis.

        This command is also valid in PREP7.
        """
        command = "PSDSPL,%s,%s,%s" % (str(tblno), str(rmin), str(rmax))
        return self.run(command, **kwargs)

    def linp(self, nl1="", nl2="", nl3="", nl4="", nl5="", nl6="", nl7="",
             nl8="", nl9="", **kwargs):
        """APDL Command: LINP

        Finds the pairwise intersection of lines.

        Parameters
        ----------
        nl1, nl2, nl3, . . . , nl9
            Numbers of lines to be intersected pairwise.  If NL1 =  ALL, find
            the pairwise intersection of all selected lines and NL2 to NL9 are
            ignored.  If NL1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  A
            component name may be substituted for NL1.

        Notes
        -----
        Finds the pairwise intersection of lines.  The pairwise intersection is
        defined as any and all regions shared by at least two lines listed on
        this command.  New lines will be generated where the original lines
        intersect pairwise.  If the regions of pairwise intersection are only
        points, new keypoints will be generated.  See the Modeling and Meshing
        Guide for an illustration.  See the BOPTN command for the options
        available to Boolean operations.  Element attributes and solid model
        boundary conditions assigned to the original entities will not be
        transferred to the new entities generated.
        """
        command = "LINP,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nl1), str(nl2), str(nl3), str(nl4), str(nl5), str(nl6), str(nl7), str(nl8), str(nl9))
        return self.run(command, **kwargs)

    def slashdelete(self, fname="", ext="", distkey="", **kwargs):
        """APDL Command: /DELETE

        Deletes a file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        distkey
            Key that specifies whether the file deletion is performed on all
            processes in distributed parallel mode (Distributed ANSYS):

            1 (ON or YES) - The program performs the file deletion locally on each process.

            0 (OFF or NO) - The program performs the file deletion only on the master process (default).

        Notes
        -----
        In distributed parallel mode (Distributed ANSYS), only the master
        process will delete Fname.Ext by default. However, when DistKey is set
        to 1 (or ON or YES), the command is executed by all processes. In this
        case, Fname will automatically have the process rank appended to it.
        This means FnameN.Ext will be deleted by all processes, where N is the
        Distributed ANSYS process rank. For more information see Differences in
        General Behavior  in the Parallel Processing Guide.
        """
        command = "/DELETE,%s,%s,%s" % (str(fname), str(ext), str(distkey))
        return self.run(command, **kwargs)

    def et(self, itype="", ename="", kop1="", kop2="", kop3="", kop4="",
           kop5="", kop6="", inopr="", **kwargs):
        """APDL Command: ET

        Defines a local element type from the element library.

        Parameters
        ----------
        itype
            Arbitrary local element type number. Defaults to 1 + current
            maximum.

        ename
            Element name (or number) as given in the element library in Chapter
            4 of the Element Reference. The name consists of a category prefix
            and a unique number, such as PIPE288.  The category prefix of the
            name (PIPE for the example) may be omitted but is displayed upon
            output for clarity. If Ename = 0, the element is defined as a null
            element.

        kop1, kop2, kop3, . . . , kop6
            KEYOPT values (1 through 6) for this element, as described in the
            Element Reference.

        inopr
            If 1, suppress all element solution printout for this element type.

        Notes
        -----
        The ET command selects an element type from the element library and
        establishes it as a local element type for the current model.
        Information derived from the element type is used for subsequent
        commands, so the ET command(s) should be issued early. (The Element
        Reference describes the available elements.)

        A special option, Ename = 0, permits the specified element type to be
        ignored during solution without actually removing the element from the
        model. Ename may be set to zero only after the element type has been
        previously defined with a nonzero Ename.  The preferred method of
        ignoring elements is to use the select commands (such as ESEL).

        KOPn are element option keys. These keys (referred to as KEYOPT(n)) are
        used to turn on certain element options for this element. These options
        are listed under "KEYOPT" in the input table for each element type in
        the Element Reference.  KEYOPT values include stiffness formulation
        options, printout controls, and various other element options. If
        KEYOPT(7) or greater is needed, input their values with the KEYOPT
        command.

        The ET command only defines an element type local to your model (from
        the types in the element library). The TYPE or similar [KATT, LATT,
        AATT, or VATT] command must be used to point to the desired local
        element type before meshing.

        To activate the ANSYS program's LS-DYNA explicit dynamic analysis
        capability,  use the ET command or its GUI equivalent to choose an
        element that works only with LS-DYNA (such as SHELL163).  Choosing LS-
        DYNA in the Preferences dialog box does not activate LS-DYNA; it simply
        makes items and options related to LS-DYNA accessible in the GUI.
        """
        command = "ET,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(itype), str(ename), str(kop1), str(kop2), str(kop3), str(kop4), str(kop5), str(kop6), str(inopr))
        return self.run(command, **kwargs)

    def anharm(self, nfram="", delay="", ncycl="", nperiod="", cms_antype="",
               cms_modopt="", **kwargs):
        """APDL Command: ANHARM

        Produces an animated sequence of time-harmonic results or complex mode
        shapes.

        Parameters
        ----------
        nfram
            Number of frame captures per cycle.  Defaults to 12.

        delay
            Time delay (seconds) during animation.  Defaults to 0.1 seconds.

        ncycl
            Number of animation cycles.  Defaults to 5.  Not available in the
            GUI.

        nperiod
            Period number for the second set of frames showing the decay or
            growth of a mode shape. Only applies to complex mode shape
            animation. Defaults to 1, animating the decay or growth on the
            first period. Issue -1 to animate without decay or growth.

        cms_antype
            Analysis type performed in the CMS use pass. No default.

            MODAL - Modal analysis

            HARMIC - Harmonic analysis

        cms_modopt
            Mode extraction method selected in the CMS use pass. No default.

            UNSYM - Unsymmetric matrix

            DAMP - Damped system

            QRDAMP - Damped system using QR algorithm

        Notes
        -----
        ANHARM invokes an ANSYS macro which produces an animated sequence of:

        Time-harmonic results in the case of a harmonic analysis
        (ANTYPE,HARMIC)

        Complex mode shapes in the case of a modal analysis (ANTYPE,MODAL).

        In both cases, the results are those of the last plot action (for
        example, PLNSOL,B,SUM).

        The animation converts the complex solution variables (real and
        imaginary sets) into time varying results over one period. For example,
        if NFRAM = 12, then the frame captures are in increments of 30 degree
        phase angles.

        A second set of NFRAM frames will be generated for damped eigenmodes
        from complex eigensolvers to visualize any exponential decay or growth
        of the oscillations. The second set generated will display frames from
        the period number specified by NPERIOD.

        In a CMS analysis, the ANHARM command can be used after the CMS
        expansion pass or the use pass. To use ANHARM after the expansion pass,
        you must indicate whether a modal analysis or a harmonic analysis was
        performed in the CMS use pass by setting CMS_ANTYPE to either MODAL or
        HARMIC. If the use pass was a modal analysis, you must also set the
        CMS_MODOPT field to indicate the mode extraction method that was used
        (UNSYM, DAMP, or QRDAMP). If CMS_MODOPT = QRDAMP, it is assumed that
        CPXMOD was set to ON in the MODOPT command to request complex
        eigenmodes. If the ANHARM command is used after the use pass, it is not
        necessary to set the CMS_ANTYPE or CMS_MODOPT arguments.

        For more information about complex results postprocessing, see POST1
        and POST26 – Complex Results Postprocessing in the Mechanical APDL
        Theory Reference
        """
        command = "ANHARM,%s,%s,%s,%s,%s,%s" % (str(nfram), str(delay), str(ncycl), str(nperiod), str(cms_antype), str(cms_modopt))
        return self.run(command, **kwargs)

    def bfllist(self, line="", lab="", **kwargs):
        """APDL Command: BFLLIST

        Lists the body force loads on a line.

        Parameters
        ----------
        line
            Line at which body load is to be listed.  If ALL (or blank), list
            for all selected lines [LSEL].  If LINE = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for LINE.

        lab
            Valid body load label. If ALL, use all appropriate labels. Load
            labels are listed under "Body Loads" in the input table for each
            element type in the Element Reference. See the BFL command for
            labels.

        Notes
        -----
        Lists the body force loads for the specified line and label.  Body
        loads may be defined on a line with the BFL command.

        This command is valid in any processor.
        """
        command = "BFLLIST,%s,%s" % (str(line), str(lab))
        return self.run(command, **kwargs)

    def pcircle(self, xcentr="", ycentr="", xlrad="", **kwargs):
        """APDL Command: /PCIRCLE

        Creates an annotation circle (GUI).

        Parameters
        ----------
        xcentr
            Circle X center location (-1.0 < X < 2.0).

        ycentr
            Circle Y center location (-1.0 < Y < 1.0).

        xlrad
            Circle radius length.

        Notes
        -----
        Creates an annotation circle to be written directly onto the display at
        a specified location.  This is a command generated by the Graphical
        User Interface (GUI) and will appear in the log file (Jobname.LOG) if
        annotation is used.  This command is not intended to be typed in
        directly in an ANSYS session (although it can be included in an input
        file for batch input or for use with the /INPUT command).

        All circles are shown on subsequent displays unless the annotation is
        turned off or deleted.  Use the /LSPEC and the /PSPEC command to set
        the attributes of the circle.

        This command is valid in any processor.
        """
        command = "/PCIRCLE,%s,%s,%s" % (str(xcentr), str(ycentr), str(xlrad))
        return self.run(command, **kwargs)

    def sesymm(self, sename="", ncomp="", inc="", file="", ext="", **kwargs):
        """APDL Command: SESYMM

        Performs a symmetry operation on a superelement within the use pass.

        Parameters
        ----------
        sename
            The name (case-sensitive) of the superelement matrix file created
            by the substructure generation pass (Sename.SUB).  Defaults to the
            current Jobname.  If a number, it is the element number of a
            previously defined superelement in the current use pass.

        ncomp
            Symmetry key:

            X - X symmetry (default).

            Y - Y symmetry.

            Z - Z symmetry.

        inc
            Increment all nodes in the superelement by INC.

        file
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Performs a symmetry operation on a superelement within the substructure
        use pass by reversing the sign of component Ncomp in the global
        Cartesian coordinate system.  The node numbers are incremented by INC.
        The new superelement is written to File.SUB in the current directory
        (by default).  All master node nodal coordinate systems must be global
        Cartesian (no rotated nodes allowed).

        The maximum number of transformations for a given superelement is five
        (including SETRAN, SESYMM, and the large rotation transformation if
        NLGEOM is ON in the use pass).

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "SESYMM,%s,%s,%s,%s,%s" % (str(sename), str(ncomp), str(inc), str(file), str(ext))
        return self.run(command, **kwargs)

    def plopts(self, label="", key="", **kwargs):
        """APDL Command: /PLOPTS

        Controls graphics options on subsequent displays.

        Parameters
        ----------
        label
            Apply display items as selected from the following labels:

            INFO - Controls the display of the legend (ON or OFF) and allows the choice of preset
                   or Multi-legend placement. Control is provided by the KEY
                   values. (Defaults to KEY=3 when the GUI is on. Defaults to
                   KEY= 2 otherwise.)

            LEG1 - Header portion of legend column (defaults to ON).

            LEG2 - View portion of legend column (defaults to ON (except off with contour
                   displays)).

            LEG3 - View the contour section of the legend column (defaults to ON).

            FRAME - Frame border lines around windows (defaults to ON).

            TITLE - Title (bottom left text) (defaults to ON).

            MINM - Min-Max symbols on contour displays (defaults to ON).

            LOGO - ANSYS logo (defaults to OFF (displayed as text at top of legend column)).  If
                   KEY = ON, the text is removed from legend column but the
                   logo symbol is displayed in whichever active window is
                   either in the uppermost right corner and on top, or if there
                   is no window in that location, then in the window to the
                   furthest right of the screen.  Version information remains
                   in the legend column.

            WINS - Controls whether graphics windows automatically stretch or shrink to adjust to
                   screen size as the legend column is turned off or on
                   [/PLOPTS,INFO] (defaults to ON).  If WINS is on and the
                   legend column is changed from off to on, all windows are
                   shrunk regardless of what their correct size is.

            WP - Working plane (defaults to OFF).  The working plane is drawn as part of the
                 display (not just an overlaid image as in WPSTYL).  This
                 option is best used in combination with a hidden-line
                 technique [/TYPE].

            DATE - Controls the display of the date and time in your legend. Subsequent KEY values
                   control the display as follows:

            FILE - Controls the display of the ANSYS jobname in your legend. Subsequent KEY values
                   control the display as follows:

        key
            Switch:

            OFF or 0 - Do not apply this display item. For Label = DATE, no time or date are
                       displayed.

            ON or 1 - Apply this display item. For Label = DATE, show only the date.

            AUTO or 2 - For Label = INFO, initiate Auto-legend mode.  If the display has contours, the
                        legend is ON; if the display has no contours, the
                        legend is OFF. For Label = DATE, display both the date
                        and time.

            3 - For Label = INFO , switch to Multi-legend mode. See the /UDOC command for the
                available legend configurations.

        Notes
        -----
        Use /PLOPTS,STAT to display settings.  Use /PLOPTS,DEFA to reset all
        specifications back to their defaults.

        When you perform multiple results displays, contours on the legend
        column may be truncated.  To avoid this, specify /PLOPTS,LEG1,0.

        The Multi-legend mode provides a number of legend data item priority
        and placement options. These options are accessed via the GUI at
        Utility Menu> PlotCtrls> Window Controls> Window Options. The /UDOC
        command provides command line options for this capability.

        This command is valid in any processor.

        This command is not available for Academic Research or Teaching level
        products
        """
        command = "/PLOPTS,%s,%s" % (str(label), str(key))
        return self.run(command, **kwargs)

    def spval(self, tblno="", curvno="", sv1="", sv2="", sv3="", sv4="",
              sv5="", sv6="", sv7="", **kwargs):
        """APDL Command: SPVAL

        Defines multi-point response spectrum values.

        Parameters
        ----------
        tblno
            Input table number. It corresponds to TBLNO on the SPFREQ command.

        curvno
            Input curve number. It corresponds to CURVNO on the SPDAMP command
            (optional).

        sv1, sv2, sv3, , , . . . , sv7
            Spectral values corresponding to the frequency points (SPFREQ) and
            damping ratio (SPDAMP). Values are interpreted as defined with the
            SPUNIT command.

        Notes
        -----
        Defines multi-point response spectrum values to be associated with the
        previously defined frequency points (SPFREQ). It can also be associated
        with the previously defined damping value (SPDAMP). If CURVNO is not
        specified, the input spectrum is not associated with a damping value.

        Repeat SPVAL command for additional values, up to the number of
        frequency points (SPFREQ). Values are added after the last nonzero
        value.

        The interpolation method between response spectrum points and curves is
        specified using KeyInterp on the SPUNIT command. It is logarithmic by
        default.

        Use the SPTOPT and STAT commands to list current spectrum curve values.

        This command is also valid in PREP7.
        """
        command = "SPVAL,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(tblno), str(curvno), str(sv1), str(sv2), str(sv3), str(sv4), str(sv5), str(sv6), str(sv7))
        return self.run(command, **kwargs)

    def clog(self, ir="", ia="", name="", facta="", factb="", **kwargs):
        """APDL Command: CLOG

        Forms the common log of a variable

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]).  If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        ia
            Reference number of the variable to be operated on.

        --, --
            Unused fields.

        name
            Thirty-two character name for identifying the variable on printouts
            and displays.  Embedded blanks are compressed for output.

        --, --
            Unused fields.

        facta
            Scaling factor applied to variable IA (defaults to 1.0).

        factb
            Scaling factor (positive or negative) applied to the operation
            (defaults to 1.0).

        Notes
        -----
        Forms the common log of a variable according to the operation:

        IR = FACTB*LOG(FACTA x IA)
        """
        command = "CLOG,%s,%s,%s,%s,%s" % (str(ir), str(ia), str(name), str(facta), str(factb))
        return self.run(command, **kwargs)

    def vstat(self, **kwargs):
        """APDL Command: *VSTAT

        Lists the current specifications for the array parameters.

        Notes
        -----
        Lists the current specifications for the *VABS, *VCOL, *VCUM, *VFACT,
        *VLEN, and *VMASK commands.

        This command is valid in any processor.
        """
        command = "*VSTAT," % ()
        return self.run(command, **kwargs)

    def tb(self, lab="", mat="", ntemp="", npts="", tbopt="", eosopt="",
           funcname="", **kwargs):
        """APDL Command: TB

        Activates a data table for material properties or special element
        input.

        Parameters
        ----------
        lab
            Material model data table type:

            AFDM - Acoustic frequency-dependent material.

            AHYPER - Anisotropic hyperelasticity.

            ANEL - Anisotropic elasticity.

            ANISO - Anisotropic plasticity.

            BB - Bergstrom-Boyce.

            BH - Magnetic field data.

            BISO - Bilinear isotropic hardening using von Mises or Hill plasticity.

            BKIN - Bilinear kinematic hardening using von Mises or Hill plasticity.

            CAST - Cast iron.

            CDM - Mullins effect (for isotropic hyperelasticity models).

            CGCR - Fracture criterion for crack-growth simulation (CGROW).

            CHABOCHE - Chaboche nonlinear kinematic hardening using von Mises or Hill plasticity.

            COMP - Composite damage (explicit dynamic analysis).

            CONCR - Concrete element data.

            CREEP - Creep. Pure creep, creep with isotropic hardening plasticity, or creep with
                    kinematic hardening plasticity using both von Mises or Hill
                    potentials.

            CTE - Secant coefficient of thermal expansion.

            CZM - Cohesive zone.

            DISCRETE - Explicit spring-damper (discrete).

            DMGE - Damage evolution law.

            DMGI - Damage initiation criteria.

            DP - Classic Drucker-Prager plasticity.

            DPER - Anisotropic electric permittivity.

            EDP - Extended Drucker-Prager (for granular materials such as rock, concrete, soil,
                  ceramics and other pressure-dependent materials).

            ELASTIC - Elasticity. For full harmonic analyses, properties can be defined as frequency-
                      or temperature-dependent (TBFIELD).

            EOS - Equation of state (explicit dynamic analysis).

            EVISC - Viscoelastic element data (explicit dynamic analysis).

            EXPE - Experimental data.

            FCON - Fluid conductance data (explicit dynamic analysis).

            FCLI - Material strength limits for calculating failure criteria.

            FLUID - Fluid.

            FOAM - Foam (explicit dynamic analysis).

            FRIC - Coefficient of friction based on Coulomb's Law or user-defined friction.

            GASKET - Gasket.

            GCAP - Geological cap (explicit dynamic analysis).

            GURSON - Gurson pressure-dependent plasticity for porous metals.

            HFLM - Film coefficient data.

            HILL - Hill anisotropy. When combined with other material options, simulates
                   plasticity, viscoplasticity, and creep -- all with the Hill
                   potential.

            HONEY - Honeycomb (explicit dynamic analysis).

            HYPER - Hyperelasticity material models (Arruda-Boyce, Blatz-Ko, Extended Tube, Gent,
                    Mooney-Rivlin [default], Neo-Hookean, Ogden, Ogden Foam,
                    Polynomial Form, Response Function, Yeoh, and user-
                    defined).
        """
        command = "TB,%s,%s,%s,%s,%s,%s,%s" % (str(lab), str(mat), str(ntemp), str(npts), str(tbopt), str(eosopt), str(funcname))
        return self.run(command, **kwargs)

    def mkdir(self, dir="", **kwargs):
        """APDL Command: /MKDIR

        Creates a directory.

        Parameters
        ----------
        dir
            The directory to create (248 characters maximum on Linux; 233 on
            Windows). If no path is provided, it will be created in the current
            working directory. Must be a valid name (and path) for the system
            you are working on.

        Notes
        -----
        Creates a directory on the computer ANSYS is currently running on.
        """
        command = "/MKDIR,%s" % (str(dir))
        return self.run(command, **kwargs)

    def mptres(self, lab="", mat="", **kwargs):
        """APDL Command: MPTRES

        Restores a temperature table previously defined.

        Parameters
        ----------
        lab
            Material property label [MP].

        mat
            Material reference number.

        Notes
        -----
        Restores into the database (from virtual space) a temperature table
        previously defined [MP] for a particular property.  The existing
        temperature table in the database is erased before this operation.

        This command is also valid in SOLUTION.
        """
        command = "MPTRES,%s,%s" % (str(lab), str(mat))
        return self.run(command, **kwargs)

    def edlcs(self, option="", cid="", x1="", y1="", z1="", x2="", y2="",
              z2="", x3="", y3="", z3="", **kwargs):
        """APDL Command: EDLCS

        Defines a local coordinate system for use in explicit dynamics
        analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed:

            ADD - Define a coordinate system (default).

            DELE - Delete a coordinate system. If CID is blank, all coordinate systems are
                   deleted.

            LIST - List defined coordinate systems. If CID is blank, all coordinate systems are
                   listed.

        cid
            Coordinate system ID.

        x1, y1, z1
            X, Y, and Z coordinates of a point on the local x-axis.

        x2, y2, z2
            X, Y, and Z coordinates of a point on the local x-y plane.

        x3, y3, z3
            X, Y, and Z coordinates of the origin. X3, Y3, and Z3 all default
            to zero.

        Notes
        -----
        Local coordinate systems defined by this command are used in an
        explicit dynamic analysis. For example, a local coordinate system may
        be used when defining orthotropic material properties (see EDMP).

        The coordinate system is defined by 2 vectors, one from the origin (X3,
        Y3, Z3) to a point on the x-axis (X1, Y1, Z1), and one from the origin
        to a point on the x-y plane (X2, Y2, Z2).  The cross product of these
        two vectors determines the z-axis, and the cross product of the z-axis
        vector and x-axis vector determines the y-axis. If X3, Y3, and Z3 are
        not specified, the global origin (0,0,0) is used by default (as shown
        in the figure below).

        The x-axis vector and the xy vector should be separated by a reasonable
        angle to avoid numerical inaccuracies.

        When you use the local coordinate system (defined by the EDLCS command)
        to define a load (EDLOAD command), the direction of the load will
        depend on the load type. For force and moment loads (Lab = FX, MX, etc.
        on EDLOAD), the load will be applied in the direction of the local
        coordinate system defined by EDLCS. For prescribed motion degrees of
        freedom (Lab = UX, ROTX, VX, AX, etc. on EDLOAD), the motion will act
        in the direction of a vector from point (X1, Y1, Z1) to point (X2, Y2,
        Z2) as input on EDLCS. See the EDLOAD command for more information.

        This command is also valid in SOLUTION.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDLCS,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(cid), str(x1), str(y1), str(z1), str(x2), str(y2), str(z2), str(x3), str(y3), str(z3))
        return self.run(command, **kwargs)

    def vimp(self, vol="", chgbnd="", implevel="", **kwargs):
        """APDL Command: VIMP

        Improves the quality of the tetrahedral elements in the selected
        volume(s).

        Parameters
        ----------
        vol
            Number of the volume containing the tetrahedral elements to be
            improved.  If VOL = ALL (default), improve the tetrahedral elements
            in all selected volumes.  If VOL = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).  A component name may also be substituted for VOL.

        chgbnd
            Specifies whether to allow boundary modification.  Boundary
            modification includes such things as changes in the connectivity of
            the element faces on the boundary and the addition of boundary
            nodes.  (Also see "Notes" below for important usage information for
            CHGBND.)

            0 - Do not allow boundary modification.

            1 - Allow boundary modification (default).

        implevel
            Identifies the level of improvement to be performed on the
            elements.  (Improvement occurs primarily through the use of face
            swapping and node smoothing techniques.)

            0 - Perform the least amount of swapping/smoothing.

            1 - Perform an intermediate amount of swapping/smoothing.

            2 - Perform the greatest amount of swapping/smoothing.

            3 - Perform the greatest amount of swapping/smoothing, plus additional improvement
                techniques (default).

        Notes
        -----
        VIMP is useful for further improving a volume mesh created in ANSYS
        [VMESH], especially quadratic tetrahedral element meshes.

        The VIMP command enables you to improve a given tetrahedral mesh by
        reducing the number of poorly-shaped tetrahedral elements (in
        particular, the number of sliver tetrahedral elements)--as well as the
        overall number of elements--in the mesh.  It also improves the overall
        quality of the mesh.

        Regardless of the value of the CHGBND argument, boundary mid-nodes can
        be moved.

        When loads or constraints have been placed on boundary nodes or mid-
        nodes, and boundary mid-nodes are later moved, ANSYS issues a warning
        message to let you know that it will not update the loads or
        constraints.

        Even when CHGBND = 1, no boundary modification is performed on areas
        and lines that are not modifiable (for example, areas that are adjacent
        to other volumes or that contain shell elements, or lines that are not
        incident on modifiable areas, contain beam elements, or have line
        divisions specified for them [LESIZE]).
        """
        command = "VIMP,%s,%s,%s" % (str(vol), str(chgbnd), str(implevel))
        return self.run(command, **kwargs)

    def vsla(self, type="", vlkey="", **kwargs):
        """APDL Command: VSLA

        Selects those volumes containing the selected areas.

        Parameters
        ----------
        type
            Label identifying the type of volume select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

        vlkey
            Specifies whether all contained volume areas must be selected
            [ASEL]:

            0 - Select volume if any of its areas are in the selected area set.

            1 - Select volume only if all of its areas are in the selected area set.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "VSLA,%s,%s" % (str(type), str(vlkey))
        return self.run(command, **kwargs)

    def anorm(self, anum="", noeflip="", **kwargs):
        """APDL Command: ANORM

        Reorients area normals.

        Parameters
        ----------
        anum
            Area number having the normal direction that the reoriented areas
            are to match.

        noeflip
            Indicates whether you want to change the normal direction of the
            existing elements on the reoriented area(s) so that they are
            consistent with each area's new normal direction.

            0 - Make the normal direction of existing elements on the reoriented area(s)
                consistent with each area's new normal direction (default).

            1 - Do not change the normal direction of existing elements on the reoriented
                area(s).

        Notes
        -----
        Reorients areas so that their normals are consistent with that of a
        specified area.

        If any of the areas have inner loops, the ANORM command will consider
        the inner loops when it reorients the area normals.

        You cannot use the ANORM command to change the normal direction of any
        element that has a body or surface load.  We recommend that you apply
        all of your loads only after ensuring that the element normal
        directions are acceptable.

        Real constants (such as nonuniform shell thickness and tapered beam
        constants) may be invalidated by an element reversal.

        See Revising Your Model of the Modeling and Meshing Guide for more
        information.
        """
        command = "ANORM,%s,%s" % (str(anum), str(noeflip))
        return self.run(command, **kwargs)

    def kwplan(self, wn="", korig="", kxax="", kplan="", **kwargs):
        """APDL Command: KWPLAN

        Defines the working plane using three keypoints.

        Parameters
        ----------
        wn
            Window number whose viewing direction will be modified to be normal
            to the working plane (defaults to 1).  If WN is a negative value,
            the viewing direction will not be modified.  If fewer than three
            points are used, the viewing direction of window WN will be used
            instead to define the normal to the working plane.

        korig
            Keypoint number defining the origin of the working plane coordinate
            system.  If KORIG = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).

        kxax
            Keypoint number defining the x-axis orientation (defaults to the
            x-axis being parallel to the global X-axis; or if the normal to the
            working plane is parallel to the global X-axis, then defaults to
            being parallel to the global Y-axis).

        kplan
            Keypoint number defining the working plane (the normal defaults to
            the present display view [/VIEW] of window WN).

        Notes
        -----
        Defines a working plane to assist in picking operations using three
        keypoints as an alternate to the WPLANE command.  The three keypoints
        also define the working plane coordinate system.  A minimum of one
        keypoint (at the working plane origin) is required.  Immediate mode may
        also be active.  See WPSTYL command to set the style of working plane
        display.

        This command is valid in any processor.
        """
        command = "KWPLAN,%s,%s,%s,%s" % (str(wn), str(korig), str(kxax), str(kplan))
        return self.run(command, **kwargs)

    def seccontrol(self, val1="", val2="", val3="", val4="", val5="", val6="",
                   val7="", val8="", val9="", val10="", val11="", val12="",
                   val13="", **kwargs):
        """APDL Command: SECCONTROL

        Supplements or overrides default section properties.

        Parameters
        ----------
        val1, val2, val3, . . . , val13
            Values, such as the length of a side or the numbers of cells along
            the width, that describe the geometry of a section. See the "Notes"
            section of this command description for details about these values
            for the various section types.

        Notes
        -----
        The  SECCONTROL command is divided into these operation types: Beams,
        Links, Pipes, Shells, and Reinforcings.

        Values are associated with the most recently issued SECTYPE command.
        The data required is determined by the section type and is different
        for each type.

        SECCONTROL overrides the program-calculated transverse-shear stiffness.

        The command does not apply to thermal shell elements SHELL131 and
        SHELL132 or thermal solid elements SOLID278 and SOLID279.
        """
        command = "SECCONTROL,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(val1), str(val2), str(val3), str(val4), str(val5), str(val6), str(val7), str(val8), str(val9), str(val10), str(val11), str(val12), str(val13))
        return self.run(command, **kwargs)

    def vsbw(self, nv="", sepo="", keep="", **kwargs):
        """APDL Command: VSBW

        Subtracts intersection of the working plane from volumes (divides
        volumes).

        Parameters
        ----------
        nv
            Volume (or volumes, if picking is used) to be subtracted from.  If
            NV = ALL, use all selected volumes.  If NV = P, graphical picking
            is enabled (valid only in the GUI).  A component name may also be
            input for NV.

        sepo
            Behavior of the created boundary.

            (blank) - The resulting volumes will share area(s) where they touch.

            SEPO - The resulting volumes will have separate, but coincident area(s).

        keep
            Specifies whether NV volumes are to be deleted.

            (blank) - Use the setting of KEEP on the BOPTN command.

            DELETE - Delete NV volumes after VSBW operation (override BOPTN command settings).

            KEEP - Keep NV volumes after VSBW operation (override BOPTN command settings).

        Notes
        -----
        Generates new volumes by subtracting the intersection of the working
        plane from the NV volumes.  The intersection will be an area(s).  If
        SEPO is blank, the volume is divided at the area and the resulting
        volumes will be connected, sharing a common area where they touch.  If
        SEPO is set to SEPO, the volume is divided into two unconnected volumes
        with separate areas.  The SEPO option may cause unintended consequences
        if any keypoints exist along the cut plane. See the Modeling and
        Meshing Guide for an illustration.  See the BOPTN command for an
        explanation of the options available to Boolean operations.  Element
        attributes and solid model boundary conditions assigned to the original
        entities will not be transferred to the new entities generated.

        Issuing the VSBW command under certain conditions may generate a
        topological degeneracy error. Do not issue the command if:

        A sphere or cylinder has been scaled. (A cylinder must be scaled
        unevenly in the XY plane.)

        A sphere or cylinder has not been scaled but the work plane has been
        rotated.
        """
        command = "VSBW,%s,%s,%s" % (str(nv), str(sepo), str(keep))
        return self.run(command, **kwargs)

    def fccheck(self, **kwargs):
        """APDL Command: FCCHECK

         Checks both the strain and stress input criteria for all materials.

        Notes
        -----
        Issue the FCCHECK command to check the completeness of the input during
        the input phase.
        """
        command = "FCCHECK," % ()
        return self.run(command, **kwargs)

    def eread(self, fname="", ext="", **kwargs):
        """APDL Command: EREAD

        Reads elements from a file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        This read operation is not necessary in a standard ANSYS run but is
        provided as a convenience to users wanting to read a coded element
        file, such as from another mesh generator or from a CAD/CAM program.
        Data should be formatted as produced with the EWRITE command. If
        issuing EREAD to acquire element information generated from ANSYS
        EWRITE, you must also issue NREAD before the EREAD command. The element
        types [ET] must be defined before the file is read so that the file may
        be read properly. Only elements that are specified with the ERRANG
        command are read from the file. Also, only elements that are fully
        attached to the nodes specified on the NRRANG command are read from the
        file. Elements are assigned numbers consecutively as read from the
        file, beginning with the current highest database element number plus
        one. The file is rewound before and after reading. Reading continues
        until the end of the file.
        """
        command = "EREAD,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def nsol(self, nvar="", node="", item="", comp="", name="", sector="",
             **kwargs):
        """APDL Command: NSOL

        Specifies nodal data to be stored from the results file.

        Parameters
        ----------
        nvar
            Arbitrary reference number or name assigned to this variable.
            Variable numbers can be 2 to NV (NUMVAR) while the name can be an
            eight byte character string. Overwrites any existing results for
            this variable.

        node
            Node for which data are to be stored.

        item
            Label identifying the item.  Valid item labels are shown in the
            table below.  Some items also require a component label.

        comp
            Component of the item (if required).  Valid component labels are
            shown in the table below.

        name
            Thirty-two character name identifying the item on printouts and
            displays.  Defaults to a label formed by concatenating the first
            four characters of the Item and Comp labels.

        sector
            For a full harmonic cyclic symmetry solution, the sector number for
            which the results from NODE are to be stored.

        Notes
        -----
        Stores nodal degree of freedom and solution results in a variable. For
        more information, see Data Interpreted in the Nodal Coordinate System
        in the Modeling and Meshing Guide.

        For SECTOR>1, the result is in the nodal coordinate system of the base
        sector, and it is rotated to the expanded sector’s location. Refer to
        Using the /CYCEXPAND Command in the Cyclic Symmetry Analysis Guide for
        more information.

        Table: 211:: : NSOL - Valid Item and Component Labels

        Table: 212:: : NSOL - Valid Item and Component Labels for ANSYS LS-DYNA
        Nodal Results

         For SHELL131 and SHELL132 elements with KEYOPT(3) = 0 or 1, use the
        labels TBOT, TE2, TE3, . . ., TTOP instead of TEMP.
        """
        command = "NSOL,%s,%s,%s,%s,%s,%s" % (str(nvar), str(node), str(item), str(comp), str(name), str(sector))
        return self.run(command, **kwargs)

    def spdamp(self, tblno="", curvno="", dampratio ="", **kwargs):
        """APDL Command: SPDAMP

        Defines input spectrum damping in a multi-point response spectrum
        analysis.

        Parameters
        ----------
        tblno
            Input table number. Corresponds to the frequency table number
            (TBLNO on the SPFREQ command).

        curvno
            Input curve number. Corresponds to the spectrum values curve number
            (CURVNO on the SPVAL command).

        dampratio
            Damping ratio for the response spectrum curve. Up to 20 different
            curves may be defined, each with a different damping ratio. Damping
            values must be input in ascending order.

        Notes
        -----
        Defines multi-point response spectrum damping value to be associated
        with:

        Previously defined frequency points (SPFREQ).

        Subsequently defined spectrum points (SPVAL).

        Damping values are used only to identify input spectrum values for the
        mode coefficients calculation.

        The curve number must be input in ascending order starting with 1.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "SPDAMP,%s,%s,%s" % (str(tblno), str(curvno), str(dampratio ))
        return self.run(command, **kwargs)

    def sumtype(self, label="", **kwargs):
        """APDL Command: SUMTYPE

        Sets the type of summation to be used in the following load case
        operations.

        Parameters
        ----------
        label
            Summation type

            COMP - Combine element component stresses only.  Stresses such as average nodal
                   stresses, principal stresses, equivalent stresses, and
                   stress intensities are derived from the combined element
                   component stresses. Default.

            PRIN - Combine principal stress, equivalent stress, and stress intensity directly as
                   stored on the results file.  Component stresses are not
                   available with this option.

        Notes
        -----
        Issue SUMTYPE,PRIN when you want to have a load case operation (LCOPER)
        act on the principal / equivalent stresses instead of the component
        stresses. Also issue SUMTYPE,PRIN when you want to read in load cases
        (LCASE). Note that the SUMTYPE setting is not maintained between /POST1
        sessions.

        SUMTYPE,PRIN also causes principal nodal values to be the average of
        the contibuting principal element nodal values (see AVPRIN,1).

        BEAM188 and BEAM189 elements compute principal stress, equivalent
        stress, and stress intensity values on request instead of storing them
        on the results file;  SUMTYPE,PRIN does not apply for these elements.
        """
        command = "SUMTYPE,%s" % (str(label))
        return self.run(command, **kwargs)

    def seclock(self, dof1="", minvalue1="", maxvalue1="", dof2="",
                minvalue2="", maxvalue2="", dof3="", minvalue3="",
                maxvalue3="", **kwargs):
        """APDL Command: SECLOCK

        Specifies locks on the components of relative motion in a joint
        element.

        Parameters
        ----------
        dof
            Local degree of freedom to be locked.

        minvalue
            Low end of the range of allowed movement for the specified DOF.

        maxvalue
            High end of the range of allowed movement for the specified DOF.

        Notes
        -----
        Specify up to three DOFs to be locked. Locks are activated when the
        limit values are reached, and further motion in that DOF is frozen. If
        necessary, you may repeat the command.
        """
        command = "SECLOCK,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(dof1), str(minvalue1), str(maxvalue1), str(dof2), str(minvalue2), str(maxvalue2), str(dof3), str(minvalue3), str(maxvalue3))
        return self.run(command, **kwargs)

    def lgen(self, itime="", nl1="", nl2="", ninc="", dx="", dy="", dz="",
             kinc="", noelem="", imove="", **kwargs):
        """APDL Command: LGEN

        Generates additional lines from a pattern of lines.

        Parameters
        ----------
        itime
            Do this generation operation a total of ITIMEs, incrementing all
            keypoints in the given pattern automatically (or by KINC) each time
            after the first.  ITIME must be > 1 for generation to occur.

        nl1, nl2, ninc
            Generate lines from pattern beginning with NL1 to NL2 (defaults to
            NL1) in steps of NINC (defaults to 1).  If NL1 = ALL, NL2 and NINC
            are ignored and pattern is all selected lines [LSEL].  If NL1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NL1 (NL2 and NINC are ignored).

        dx, dy, dz
            Keypoint location increments in the active coordinate system (--,
            Dθ, DZ for cylindrical, --, Dθ, -- for spherical).

        kinc
            Keypoint increment between generated sets.  If zero, the lowest
            available keypoint numbers are assigned [NUMSTR].

        noelem
            Specifies if elements and nodes are also to be generated:

            0 - Generate nodes and elements associated with the original lines, if they exist.

            1 - Do not generate nodes and elements.

        imove
            Specifies whether to redefine the existing lines:

            0 - Generate additional lines as requested with the ITIME argument.

            1 - Move original lines to new position retaining the same keypoint numbers (ITIME,
                KINC, and NOELM are ignored).  Valid only if the old lines are
                no longer needed at their original positions.  Corresponding
                meshed items are also moved if not needed at their original
                position.

        Notes
        -----
        Generates additional lines (and their corresponding keypoints and mesh)
        from a given line pattern.  The MAT, TYPE, REAL, and ESYS attributes
        are based upon the lines in the pattern and not upon the current
        settings.  End slopes of the generated lines remain the same (in the
        active coordinate system) as those of the given pattern.  For example,
        radial slopes remain radial, etc.  Generations which produce lines of a
        size or shape different from the pattern (i.e., radial generations in
        cylindrical systems, radial and phi generations in spherical systems,
        and theta generations in elliptical systems) are not allowed.  Note
        that solid modeling in a toroidal coordinate system is not recommended.
        New line numbers are automatically assigned (beginning with the lowest
        available values [NUMSTR]).
        """
        command = "LGEN,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(itime), str(nl1), str(nl2), str(ninc), str(dx), str(dy), str(dz), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def synchro(self, ratio="", cname="", **kwargs):
        """APDL Command: SYNCHRO

        Specifies whether the excitation frequency is synchronous or
        asynchronous with the rotational velocity of a structure.

        Parameters
        ----------
        ratio
            The ratio between the frequency of excitation and the frequency of
            the rotational velocity of the structure. This value must be
            greater than 0. The default is an unbalance excitation (RATIO =
            1.0).

        cname
            The name of the rotating component on which to apply the harmonic
            excitation.

        Notes
        -----
        The SYNCHRO command specifies whether the excitation frequency is
        synchronous or asynchronous with the rotational velocity of a structure
        in a harmonic analysis. Use the command to take into account rotating
        harmonic forces on rotating structures.

        Mechanical APDL calculatestes the rotational velocity Ω of the
        structure from the excitation frequency f, defined (via the HARFRQ
        command) as Ω = 2πf / RATIO. The rotational velocity is applied along
        the direction cosines of the rotation axis (specified via an OMEGA or
        CMOMEGA command).

        Specifying any value for RATIO causes a general rotational force
        excitation and not an unbalance force. To define an unbalance
        excitation force (F = Ω2 * Unb), RATIO should be left blank (the nodal
        unbalance Unb is specified via the F command).

        The SYNCHRO command is valid only for a full-solution harmonic analysis
        (HROPT,Method = FULL) and the Variational Technology method
        (HROPT,Method = VT) involving a rotating structure (OMEGA or CMOMEGA)
        with Coriolis enabled in a stationary reference frame
        (CORIOLIS,,,,RefFrame = ON).
        """
        command = "SYNCHRO,%s,%s" % (str(ratio), str(cname))
        return self.run(command, **kwargs)

    def move(self, node="", kc1="", x1="", y1="", z1="", kc2="", x2="", y2="",
             z2="", **kwargs):
        """APDL Command: MOVE

        Calculates and moves a node to an intersection.

        Parameters
        ----------
        node
            Move this node.  If NODE = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  A
            component name may also be substituted for NODE.

        kc1
            First coordinate system number.  Defaults to 0 (global Cartesian).

        x1, y1, z1
            Input one or two values defining the location of the node in this
            coordinate system.  Input "U" for unknown value(s) to be calculated
            and input "E" to use an existing coordinate value.  Fields are R1,
            θ1, Z1 for cylindrical, or R1, θ1, Φ1 for spherical or toroidal.

        kc2
            Second coordinate system number.

        x2, y2, z2
            Input two or one value(s) defining the location of the node in this
            coordinate system.  Input "U" for unknown value(s) to be calculated
            and input "E" to use an existing coordinate value.  Fields are R2, 
            θ2, Z2 for cylindrical, or R2,  θ2, Φ2 for spherical or toroidal.

        Notes
        -----
        Calculates and moves a node to an intersection location.  The node may
        have been previously defined (at an approximate location) or left
        undefined (in which case it is internally defined at the SOURCE
        location).  The actual location is calculated from the intersection of
        three surfaces (implied from three coordinate constants in two
        different coordinate systems).  The three (of six) constants easiest to
        define should be used.  The program will calculate the remaining three
        coordinate constants.  All arguments, except KC1, must be input.  Use
        the repeat command [*REPEAT] after the MOVE command to define a line of
        intersection by repeating the move operation on all nodes of the line.

        Surfaces of constant value are implied by some commands by specifying a
        single coordinate value.  Implied surfaces are used with various
        commands [MOVE, KMOVE, NSEL, etc.].  Three surfaces are available with
        each of the four coordinate system types.  Values or X, Y, or Z may be
        constant for the Cartesian coordinate system; values of R,: θ, or Z for
        the cylindrical system; and values of R, θ,: Φ for the spherical and
        toroidal systems.  For example, an X value of 3 represents the Y-Z
        plane (or surface) at X=3.  In addition, the parameters for the
        cylindrical and spherical coordinate systems may be adjusted [CS,
        LOCAL] to form elliptical surfaces.  For surfaces in elliptical
        coordinate systems, a surface of "constant" radius is defined by the
        radius value at the X-axis.  Surfaces of constant value may be located
        in local coordinate systems [LOCAL, CLOCAL, CS, or CSKP] to allow for
        any orientation.

        The intersection calculation is based on an iterative procedure (250
        iterations maximum) and a tolerance of 1.0E-4.  The approximate
        location of a node should be sufficient to determine a unique
        intersection if more than one intersection point is possible.  Tangent
        "intersections" should be avoided.  If an intersection is not found,
        the node is placed at the last iteration location.

        This command is also valid in the /MAP processor.
        """
        command = "MOVE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(node), str(kc1), str(x1), str(y1), str(z1), str(kc2), str(x2), str(y2), str(z2))
        return self.run(command, **kwargs)

    def ansol(self, nvar="", node="", item="", comp="", name="", mat="",
              real="", ename="", **kwargs):
        """APDL Command: ANSOL

        Specifies averaged nodal data to be stored from the results file in the
        solution coordinate system.

        Parameters
        ----------
        nvar
            Arbitrary reference number assigned to this variable (2 to NV
            [NUMVAR]). Overwrites any existing results for this variable.

        node
            Node number for which data are to be stored.

        item
            Label identifying the item. General item labels are shown in
            Table 126: ANSOL - General Item and Component Labels below. Some
            items also require a component label.

        comp
            Component of the item (if required). General component labels are
            shown in Table 126: ANSOL - General Item and Component Labels
            below.

        name
            Thirty-two character name for identifying the item on the printout
            and displays. Defaults to an eight character label formed by
            concatenating the first four characters of the Item and Comp
            labels.

        mat
            The material number. Average will be computed based on the subset
            of elements with the specified material number. DEFAULT: Use all
            elements in the active set unless Real and/or Ename is specified.

        real
            The real number. Average will be computed based on the subset of
            elements with the specified real number. DEFAULT: Use all elements
            in the active set unless Mat and/or Ename is specified.

        ename
            The element type name. Average will be computed based on the subset
            of elements with the specified element type name. DEFAULT: Use all
            elements in the active set unless Mat and/or Real is specified.

        Notes
        -----
        Valid item and component labels for averaged nodal results are listed
        in Table: 126:: ANSOL - General Item and Component Labels, below.

        All element nodal quantities are obtained in RSYS, Solu and then
        averaged.

        The ANSOL command defines averaged nodal results data to be stored from
        a results file [FILE]. Not all items are valid for all nodes. See the
        input and output summary tables of the Element Reference of each
        element that is attached to the node for the available items.

        COORDINATE SYSTEMS: All element nodal results used by ANSOL for
        averaging are in the element coordinate system, except for layered
        elements. Layered element results are in the layer coordinate system.
        You can further specify the element nodal results, for some elements,
        with the SHELL, LAYERP26, and FORCE commands.

        ANSOL does not transform results from RSYS, SOLU to other coordinate
        systems. Verify that all elements attached to the subject node have the
        same coordinate system before using ANSOL.

        SHELL ELEMENTS: The default shell element coordinate system is based on
        node ordering. For shell elements the adjacent elements could have a
        different RSYS,SOLU, making the resultant averaged data inconsistent. A
        note to this effect is issued when ANSOL is used in models containing
        shell elements. Ensure that consistent coordinate systems are active
        for all associated elements used by the ANSOL command.

        DERIVED QUANTITIES: Some of the result items supported by ANSOL (see
        Table: 126:: ANSOL - General Item and Component Labels) are derived
        from the component quantities. Use AVPRIN to specify the principal and
        vector sum quantity averaging methods.

        DEFAULT: If Mat, Real , and Ename are not specified, all of the
        elements attached to the node will be considered. When a material ID,
        real constant ID, or element type discontinuity is detected at a node,
        a note is issued. For example, in a FSI analysis, a FLUID30 element at
        the structure interface would be considered. But since it contains no
        SX result, it will not be used during STORE operations.

        Table: 126:: : ANSOL - General Item and Component Labels

        For more information on the meaning of contact status and its possible
        values, see Reviewing Results in POST1 in the Contact Technology Guide.
        """
        command = "ANSOL,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nvar), str(node), str(item), str(comp), str(name), str(mat), str(real), str(ename))
        return self.run(command, **kwargs)

    def paput(self, parray="", popt="", **kwargs):
        """APDL Command: PAPUT

        Retrieves path information from an array variable.

        Parameters
        ----------
        parray
            Name of the array variable containing the path information.

        popt
            Specifies which path data to retrieve:

            POINTS - Retrieve path point information (specified with the PPATH command and stored
                     with the PAGET,POINTS command).  The path data name will
                     be assigned to the path points.

            TABLE - Retrieve path data items (defined via the PDEF command and stored with the
                    PAGET,,TABLE command).

            LABEL - Retrieve path labels stored with the PAGET,,LABEL command.

        Notes
        -----
        When retrieving path information, restore path points (POINTS option)
        first, then the path data (TABLE option), and then the path labels
        (LABEL option).
        """
        command = "PAPUT,%s,%s" % (str(parray), str(popt))
        return self.run(command, **kwargs)

    def psdunit(self, tblno="", type="", gvalue="", **kwargs):
        """APDL Command: PSDUNIT

        Defines the type of input PSD.

        Parameters
        ----------
        tblno
            Input table number.

        type
            Label identifying the type of spectrum:

            DISP - Displacement spectrum (in terms of displacement2/Hz ).

            VELO - Velocity spectrum (in terms of velocity2/Hz ).

            ACEL - Acceleration spectrum (in terms of acceleration2/Hz ).

            ACCG - Acceleration spectrum (in terms of g2/Hz ).

            FORC - Force spectrum (in terms of force2/Hz ).

            PRES - Pressure spectrum (in terms of pressure2/Hz ).

        gvalue
            Value of acceleration due to gravity in any arbitrary units for
            Type=ACCG.  Default is 386.4 in/sec2.

        Notes
        -----
        Defines the type of PSD defined by the PSDVAL, COVAL, and QDVAL
        commands.

        Force (FORC) and pressure (PRES) type spectra can be used only as a
        nodal excitation.

        GVALUE is valid only when type ACCG is specified.  A zero or negative
        value cannot be used.  A parameter substitution can also be performed.

        This command is also valid in PREP7.
        """
        command = "PSDUNIT,%s,%s,%s" % (str(tblno), str(type), str(gvalue))
        return self.run(command, **kwargs)

    def alphad(self, value="", **kwargs):
        """APDL Command: ALPHAD

        Defines the mass matrix multiplier for damping.

        Parameters
        ----------
        value
            Mass matrix multiplier for damping.

        Notes
        -----
        This command defines the mass matrix multiplier α used to form the
        viscous damping matrix [C] = α[M] where [M] is the mass matrix.

        Values of  α may also be input as a material property (use the ALPD
        label on the MP command). If ALPD is included, the ALPD value is added
        to the ALPHAD value as appropriate (see Damping Matrices in the
        Mechanical APDL Theory Reference). Damping is not used in the static
        (ANTYPE,STATIC) or buckling (ANTYPE,BUCKLE) analyses.

        This command is also valid in PREP7.
        """
        command = "ALPHAD,%s" % (str(value))
        return self.run(command, **kwargs)

    def triad(self, lab="", **kwargs):
        """APDL Command: /TRIAD

        Shows the global XYZ coordinate triad on displays.

        Parameters
        ----------
        lab
            Display triad as follows:

            ORIG - Display triad at global origin (default).

            OFF - Turn off triad display.

            LBOT - Display triad in lower left screen corner.

            RBOT - Display triad in lower right screen corner.

            LTOP - Display triad in upper left screen corner.

            RTOP - Display triad in upper right screen corner.

        Notes
        -----
        For efficiency, ANSYS 3-D graphics logic maintains a single data
        structure (segment), which includes the triad as a 3-D data object.  If
        a 3-D device is involved (/SHOW,3D), and the ANSYS graphics are not
        being displayed as multi-plots, then the triad location is determined
        by the view settings for Window #1.  A request for triad display
        anywhere except for the origin could yield an improper display in
        windows 2 through 5. The program displays the same segment in all
        windows.  The view settings of each window constitute the only
        difference in the display in the active windows.

        This command is valid in any processor.
        """
        command = "/TRIAD,%s" % (str(lab))
        return self.run(command, **kwargs)

    def devdisp(self, label="", key="", **kwargs):
        """APDL Command: /DEVDISP

        Controls graphics device options.

        Parameters
        ----------
        label
            Device function label:

            BBOX - Disables display information sorting for PowerGraphics displays. When activated
                   (KEY = 1 or ON), model rotations and replots are performed
                   without recalculating edge and surface data. This will speed
                   up the rotation (especially for 2-D displays) of large
                   models, although the display information will not be
                   resolved as quickly (you will see a bounding box instead of
                   the model during dynamic rotations). The default is OFF (KEY
                   = 0).

            DITHER - Dithering.  When turned on (default), dithering smooths transitions in color
                     intensity.  Applies only to Z-buffered displays.

            FONT - Font selection for the ANSYS graphics window.  When Label = FONT, the command
                   format is: /DEVDISP,FONT,KEY,Val1,Val2,Val3,VAL4,Val5,Val6,
                   where KEY determines the type of font being controlled, and
                   values 1 through 6 control various font parameters. Note
                   that these values are device specific; using the same
                   command input file [/INPUT] on different machines may yield
                   different results.The following KEY values determine the
                   font information that will be supplied to the appropriate
                   driver (e.g., Postscript, X11, Win32, JPEG, ...):

            KEY = 1 - The command controls the LEGEND (documentation column) font.

            KEY = 2 - The command controls the ENTITY (node and keypoint number) font.

            KEY = 3 - The command controls the ANNOTATION/GRAPH font.

            Linux: Values 1 through 4 are used to find a match in the X11 database of font strings.  Values 1, 2, and 3 are character strings; value 4 is a nonzero integer:    - Val1

            Family name (e.g., Courier*New). Substitute an asterisk (*) for any blank character that appears in a family name. If Val1 = MENU, all other values are ignored, and a font selection menu appears (GUI must be active).  - Val2

            Weight (e.g., medium) - Val3

            Slant (e.g., r) - Val4

            Pixel size (e.g., 14). Note that this value does not affect the annotation fonts (KEY = 3). Use the /TSPEC command to control the pixel size of your annotation fonts.  - Val5

            unused - Val6

            unused - PC: The values are encoded in a PC logical font structure.  Value 1 is a
                     character string, and the remaining values are integers:

            Val1 - Family name (e.g., Courier*New) Substitute an asterisk (*) for any blank
                   character that appears in a family name. If Val1 = MENU, all
                   other values are ignored and a font selection menu appears
                   (GUI must be active). A value containing all blank
                   characters causes ANSYS to use the first available resource
                   it finds.

            Val2 - Weight (0 - 1000)

            Val3 - Orientation (in tenths of a degree)

            Val4 - Height (in logical units) Note that this value does not affect the annotation
                   fonts (KEY =3). Use the /TSPEC command to control the height
                   of your annotation fonts.

            Val5 - Width (in logical units)

            Val6 - Italics (0 = OFF, 1 = ON)

            TEXT - Text size specification for the ANSYS Graphics window. When Label = TEXT, the
                   command format is: /DEVDISP,TEXT,KEY,PERCENT, where KEY
                   determines the type of text being controlled (1 for LEGEND,
                   and 2 for ENTITY), and PERCENT specifies the new text size
                   as a percent of the default text size.  If PERCENT = 100,
                   the new text size is precisely the default size.  If PERCENT
                   = 200, the new text size is twice the default text size.

        key
            Control key:

            OFF or 0 - Turns specified function off.

            ON or 1 - Turns specified function on.
        """
        command = "/DEVDISP,%s,%s" % (str(label), str(key))
        return self.run(command, **kwargs)

    def nusort(self, **kwargs):
        """APDL Command: NUSORT

        Restores original order for nodal data.

        Notes
        -----
        This command restores the nodal data to its original order (sorted in
        ascending node number sequence) after an NSORT command.  Changing the
        selected nodal set [NSEL] also restores the original nodal order.
        """
        command = "NUSORT," % ()
        return self.run(command, **kwargs)

    def biot(self, label="", **kwargs):
        """APDL Command: BIOT

        Calculates the Biot-Savart source magnetic field intensity.

        Parameters
        ----------
        label
            Controls the Biot-Savart calculation:

            NEW - Calculate the magnetic source field intensity (Hs) from the selected set of
                  source elements to the selected set of nodes.  Overwrite any
                  existing Hs field values.

            SUM - Calculate the Hs field from the selected set of source elements to the selected
                  set of nodes.  Accumulate with any existing Hs field values.

        Notes
        -----
        Calculates the Biot-Savart source magnetic field intensity (Hs) at the
        selected nodes from the selected source elements.  The calculation is
        done at the time the BIOT command is issued.

        Source elements include primitives described by element SOURC36, and
        coupled-field elements SOLID5, LINK68, and SOLID98.  Current conduction
        elements do not have a solved-for current distribution from which to
        calculate a source field until after the first substep.  Inclusion of a
        current conduction element Hs field will require a subsequent BIOT,SUM
        command (with SOURC36 elements unselected) and a SOLVE command.

        The units of Hs are as specified by the current EMUNIT command setting.

        This command is also valid in PREP7.
        """
        command = "BIOT,%s" % (str(label))
        return self.run(command, **kwargs)

    def shrink(self, ratio="", **kwargs):
        """APDL Command: /SHRINK

        Shrinks elements, lines, areas, and volumes for display clarity.

        Parameters
        ----------
        ratio
            Shrinkage ratio (input as a decimal (0.0 to 0.5)).  Defaults to 0.0
            (no shrinkage).  Values greater than 0.5 default to 0.1 (10%
            shrinkage).

        Notes
        -----
        Shrinks the elements, lines, areas, and volumes so that adjacent
        entities are separated for clarity.  Portions of this command are not
        supported by PowerGraphics [/GRAPHICS,POWER].

        If only the common lines of non-coplanar faces are drawn (as per the
        /EDGE command), then this command is ignored.

        This command is valid in any processor.
        """
        command = "/SHRINK,%s" % (str(ratio))
        return self.run(command, **kwargs)

    def perbc2d(self, loc1="", loc2="", loctol="", r1="", r2="", tolr="",
                opt="", plnopt="", **kwargs):
        """APDL Command: PERBC2D

        Generates periodic constraints for 2-D planar magnetic field analyses.

        Parameters
        ----------
        loc1
            Constant coordinate location of the first plane of nodes.  For
            PLNOPT = 1 or 2, the constant coordinate location is the global
            Cartesian coordinate system [CSYS,0] location in the X or Y
            direction respectively.  For PLNOPT = 0, the location is the angle
            in the global cylindrical coordinate system [CSYS,1].

        loc2
            Constant coordinate location of the second plane of nodes.  For
            PLNOPT  = 1 or 2, the constant coordinate location is the global
            Cartesian coordinate system [CSYS,0] location in the X or Y
            direction respectively.  For PLNOPT = 0, the location is the angle
            (in degrees) in the global cylindrical coordinate system [CSYS,1].

        loctol
            Tolerance on the constant coordinate location for node selection.
            Defaults to .00001 for PLNOPT  = 1 or 2 and .001 degrees for PLNOPT
            = 0.

        r1
            Minimum coordinate location along the second plane of nodes.  For
            PLNOPT = 1 or 2, the coordinate location is the global Cartesian
            coordinate system location in the Y or X direction respectively.
            For PLNOPT = 0, the coordinate location is the radial coordinate
            value in the global cylindrical coordinate system.   Periodic
            conditions are not applied to nodes at this location.

        r2
            Maximum coordinate location along the second plane of nodes.  For
            PLNOPT = 1 or 2, the coordinate location is the global Cartesian
            coordinate system location in the Y or X direction respectively.
            For PLNOPT = 0, the coordinate location is the radial coordinate
            value in the global cylindrical coordinate system. Periodic
            conditions are not applied to nodes at this location.

        tolr
            Tolerance dimension on node selection along the plane of nodes.
            Defaults to .00001.

        opt
            Periodic option:

            0 - Odd symmetry (default).  Apply constraint equations such that AZ(i) = -AZ(j).

            1 - Even symmetry.  Apply node coupling such that AZ(i) = AZ(j).

        plnopt
            Symmetry plane option:

            0 - Planes of constant angle in the global cylindrical coordinate system [CSYS,1].

            1 - Planes parallel to the global Cartesian X axis [CSYS,0].

            2 - Planes parallel to the global Cartesian Y axis [CSYS,0].

        Notes
        -----
        PERBC2D invokes an ANSYS macro which generates periodic boundary
        condition constraints for 2-D planar magnetic field analysis.  The
        macro is restricted to node pairs sharing common coordinate values
        along symmetry planes separated by a constant coordinate value.  Planes
        (or lines) must lie at either constant  angles (PLNOPT = 0), constant X
        values (PLNOPT = 1), or constant Y values (PLNOPT = 2).  PERBC2D
        applies constraint equations (OPT = 0, odd symmetry) or node coupling
        (OPT = 1, even symmetry) to each node pair sharing a common coordinate
        value along the symmetry planes.  By default, periodic conditions are
        not applied at the first and last node pairs on the symmetry planes
        unless the input location values, R1 and R2, are adjusted to be less
        than or greater than the actual node coordinate values.  Nodes are
        selected for application of the constraints using the NSEL command with
        tolerances on the constant coordinate location (LOCTOL) and the
        coordinate location along the plane (RTOL).

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "PERBC2D,%s,%s,%s,%s,%s,%s,%s,%s" % (str(loc1), str(loc2), str(loctol), str(r1), str(r2), str(tolr), str(opt), str(plnopt))
        return self.run(command, **kwargs)

    def numoff(self, label="", value="", **kwargs):
        """APDL Command: NUMOFF

        Adds a number offset to defined items.

        Parameters
        ----------
        label
            Apply offset number to one of the following sets of items:

            NODE - Nodes

            ELEM - Elements

            KP - Keypoints

            LINE - Lines

            AREA - Areas

            VOLU - Volumes

            MAT - Materials

            TYPE - Element types

            REAL - Real constants

            CP - Coupled sets

            SECN - Section numbers

            CE - Constraint equations

            CSYS - Coordinate systems

        value
            Offset number value (cannot be negative).

        Notes
        -----
        Useful for offsetting current model data to prevent overlap if another
        model is read in. CDWRITE automatically writes the appropriate NUMOFF
        commands followed by the model data to File.CDB.  Therefore, when the
        file is read, any model already existing in the database is offset
        before the model data on the file is read.

        Offsetting material numbers with this command  [NUMOFF,MAT] does not
        update the material number referenced by either of the following:

        A temperature-dependent convection or surface-to-surface radiation load
        [SF, SFE, SFL, SFA]

        Real constants for multi-material elements (such as SOLID65).

        Therefore, a mismatch may exist between the material definitions and
        the material numbers referenced.
        """
        command = "NUMOFF,%s,%s" % (str(label), str(value))
        return self.run(command, **kwargs)

    def mfsorder(self, gname1="", gname2="", **kwargs):
        """APDL Command: MFSORDER

        Sets up the solution sequence of simultaneous field solver groups for
        code coupling analyses.

        Parameters
        ----------
        gname1, gname2
            Specifies the group name for groups defined by the MFPSIMUL command
            with a character string of up to 80 characters.

        Notes
        -----
        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFSORDER,%s,%s" % (str(gname1), str(gname2))
        return self.run(command, **kwargs)

    def lclear(self, nl1="", nl2="", ninc="", **kwargs):
        """APDL Command: LCLEAR

        Deletes nodes and line elements associated with selected lines.

        Parameters
        ----------
        nl1, nl2, ninc
            Delete mesh for lines NL1 to NL2 (defaults to NL1) in steps of NINC
            (defaults to 1).  If NL1 = ALL, NL2 and NINC are ignored and the
            mesh for all selected lines [LSEL] is deleted.  If NL1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NL1 (NL2 and NINC are ignored).

        Notes
        -----
        Deletes all nodes and line elements associated with selected lines
        (regardless of whether the nodes or elements are selected).  Nodes
        shared by adjacent meshed lines and nodes associated with non-line
        elements will not be deleted.  Attributes assigned as a result of LATT
        are maintained.  In the program's response to the command, if a line or
        keypoint is tallied as "cleared," it means either its node or element
        reference was deleted.
        """
        command = "LCLEAR,%s,%s,%s" % (str(nl1), str(nl2), str(ninc))
        return self.run(command, **kwargs)

    def fslist(self, nloc1="", nloc2="", ninc="", nev="", nlod="", **kwargs):
        """APDL Command: FSLIST

        Lists the stresses stored for fatigue evaluation.

        Parameters
        ----------
        nloc1, nloc2, ninc
            List stresses from NLOC1 (defaults to 1) to NLOC2 (defaults to
            NLOC1) in steps of NINC (defaults to 1).  If NLOC1 = ALL, NLOC2 and
            NINC are ignored and stresses for all locations are listed.

        nev
            Event number for stress listing (defaults to ALL).

        nlod
            Loading number for stress listing (defaults to ALL).

        Notes
        -----
        Stresses may be listed per location, per event, per loading, or per
        stress condition.  Use FELIST and FLLIST if only event and location
        parameters (no stresses) are to be listed.
        """
        command = "FSLIST,%s,%s,%s,%s,%s" % (str(nloc1), str(nloc2), str(ninc), str(nev), str(nlod))
        return self.run(command, **kwargs)

    def end(self, **kwargs):
        """APDL Command: *END

        Closes a macro file.

        Notes
        -----
        Closes a file opened with *CREATE. The *END command is an 8-character
        command (to differentiate it from *ENDIF).   If you add commented text
        on that same line but do not allow enough spaces between *END and the
        "!" that indicates the comment text, the *END will attempt to interpret
        the "!" as the 8th character and will fail.

        This command is valid in any processor.
        """
        command = "*END," % ()
        return self.run(command, **kwargs)

    def nrlsum(self, signif="", label="", labelcsm="", forcetype="", **kwargs):
        """APDL Command: NRLSUM

        Specifies the Naval Research Laboratory (NRL) sum mode combination
        method.

        Parameters
        ----------
        signif
            Combine only those modes whose significance level exceeds the
            SIGNIF threshold. For single point, multipoint, or DDAM response
            (SPOPT,SPRS, MPRS or DDAM), the significance level of a mode is
            defined as the mode coefficient of the mode, divided by the maximum
            mode coefficient of all modes. Any mode whose significance level is
            less than SIGNIF is considered insignificant and is not contributed
            to the mode combinations. The higher the SIGNIF threshold, the
            fewer the number of modes combined. SIGNIF defaults to 0.001. If
            SIGNIF is specified as 0.0, it is taken as 0.0. (This mode
            combination method is not valid for SPOPT,PSD.)

        label
            Label identifying the combined mode solution output.

            DISP - Displacement solution (default). Displacements, stresses, forces, etc., are
                   available.

            VELO - Velocity solution. Velocities, "stress velocities," "force velocities," etc.,
                   are available.

            ACEL - Acceleration solution. Accelerations, "stress accelerations," "force
                   accelerations," etc., are available.

        labelcsm
            Label identifying the CSM (Closely Spaced Modes) method.

            CSM - Use the CSM method.

            Blank  - Do not use the CSM method (default).

        forcetype
            Label identifying the forces to be combined:

            STATIC - Combine the modal static forces (default).

            TOTAL - Combine the modal static plus inertial forces.

        Notes
        -----
        This command is also valid in PREP7. This mode combination method is
        usually used for SPOPT,DDAM.

        This CSM method is only applicable in a DDAM analysis (SPOPT,DDAM). The
        CSM method combines two closely spaced modes into one mode when their
        frequencies are within 10 percent of the common mean frequency and
        their responses are opposite in sign. The contribution of these closely
        spaced modes is then included in the NRL sum as a single effective
        mode. Refer to Closely Spaced Modes (CSM) Method in the Mechanical APDL
        Theory Reference for more information.

        NRLSUM is not allowed in ANSYS Professional.
        """
        command = "NRLSUM,%s,%s,%s,%s" % (str(signif), str(label), str(labelcsm), str(forcetype))
        return self.run(command, **kwargs)

    def sfldele(self, line="", lab="", **kwargs):
        """APDL Command: SFLDELE

        Deletes surface loads from lines.

        Parameters
        ----------
        line
            Line to which surface load deletion applies.  If ALL, delete load
            from all selected lines [LSEL].  If LINE = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may be substituted for LINE.

        lab
            Valid surface load label.  If ALL, use all appropriate labels.  See
            the SFL command for labels.

        Notes
        -----
        Deletes surface loads (and all corresponding finite element loads) from
        selected lines.

        This command is also valid in PREP7.
        """
        command = "SFLDELE,%s,%s" % (str(line), str(lab))
        return self.run(command, **kwargs)

    def list(self, level="", **kwargs):
        """APDL Command: LIST

        Lists out the sets in the results file.

        Notes
        -----
        This command lists the results set number, the load step, substep, and
        time step for each set. It also shows all sets marked for deletion.
        """
        command = "LIST,%s" % (str(level))
        return self.run(command, **kwargs)

    def antime(self, nfram="", delay="", ncycl="", autocntrky="", rsltdat="",
               min="", max="", **kwargs):
        """APDL Command: ANTIME

        Produces a  sequential contour animation over a range of time.

        Parameters
        ----------
        nfram
            Number of frame captures (defaults to 5).

        delay
            Time delay during animation (defaults to 0.1 seconds).

        ncycl
            Number of animation cycles (defaults to 5).  Available in non-UI
            mode only.

        autocntrky
            Auto-scales contour values, based on the overall subset range of
            values.  The auto-scaling option defaults to 0, no auto-scaling.

        rsltdat
            The results data to be used for the animation sequence.  This can
            be:

            0 - Current load step data (default).

            1 - Range of load step data.

            2 - Range of time data.

        min
            The range minimum value.  If left blank defaults to the first data
            point.

        max
            The range maximum value.  If left blank defaults to the last data
            point.

        Notes
        -----
        The ANTIME command operates only on graphic display platforms
        supporting the /SEG command. It uses an ANSYS macro to produce an
        animation of contour values for the last plot action command (for
        example, PLDISP).  After executing ANTIME, the ANIM command will replay
        the animated sequence.

        This command functions only in the postprocessor.
        """
        command = "ANTIME,%s,%s,%s,%s,%s,%s,%s" % (str(nfram), str(delay), str(ncycl), str(autocntrky), str(rsltdat), str(min), str(max))
        return self.run(command, **kwargs)

    def cisol(self, n="", id="", node="", cont="", dtype="", **kwargs):
        """APDL Command: CISOL

        Stores fracture parameter information in a variable.

        Parameters
        ----------
        n
            Arbitrary reference number or name assigned to this variable.
            Number must be >1 but </= NUMVAR.

        id
            Crack ID number.

        node
            Crack tip node number.

        cont
            Contour number.

        dtype
            Data type to output:

            JINT - J-integral

            IIN1 - Interaction integral 1

            IIN2  - Interaction integral 2

            IIN3 - Interaction integral 3

            K1 - Mode 1 stress-intensity factor

            K2 - Mode 2 stress-intensity factor

            K3 - Mode 3 stress-intensity factor

            G1 - Mode 1 energy release rate

            G2  - Mode 2 energy release rate

            G3  - Mode 3 energy release rate

            GT - Total energy release rate

            MFTX - Total material force X

            MFTY - Total material force Y

            MFTZ - Total material force Z

            CEXT - Crack extension
        """
        command = "CISOL,%s,%s,%s,%s,%s" % (str(n), str(id), str(node), str(cont), str(dtype))
        return self.run(command, **kwargs)

    def llist(self, nl1="", nl2="", ninc="", lab="", **kwargs):
        """APDL Command: LLIST

        Lists the defined lines.

        Parameters
        ----------
        nl1, nl2, ninc
            List lines from NL1 to NL2 (defaults to NL1) in steps of NINC
            (defaults to 1).  If NL1 = ALL (default), NL2 and NINC are ignored
            and all selected lines [LSEL] are listed.  If NL1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).  A component name may also be substituted
            for NL1 (NL2 and NINC are ignored).

        lab
            Determines what type of listing is used (one of the following):

            (blank) - Prints information about all lines in the specified range.

            RADIUS - Prints the radius of certain circular arcs, along with the keypoint numbers of
                     each line.  Straight lines, non-circular curves, and
                     circular arcs not internally identified as arcs (which
                     depends upon how each arc is created) will print a radius
                     value of zero.

            LAYER - Prints layer-mesh control specifications.

            HPT - Prints information about only those lines that contain hard points. HPT is not
                  supported in the GUI.

            ORIENT - Prints a list of lines, and identifies any orientation keypoints and any cross
                     section IDs that are associated with the lines.  Used for
                     beam meshing with defined orientation nodes and cross
                     sections.

        Notes
        -----
        There are 2 listings for the number of element divisions and the
        spacing ratio. The first listing shows assignments from LESIZE only,
        followed by the “hard” key (KYNDIV). See LESIZE for more information.
        The second listing shows NDIV and SPACE for the existing mesh, if one
        exists. Whether this existing mesh and the mesh generated by LESIZE
        match at any given point depends upon meshing options and the sequence
        of meshing operations.

        A "-1" in the "nodes" column indicates that the line has been meshed
        but that there are no interior nodes.

        An attribute (TYPE, MAT, REAL, or ESYS) listed as a zero is unassigned;
        one listed as a positive value indicates that the attribute was
        assigned with the LATT command (and will not be reset to zero if the
        mesh is cleared); one listed as a negative value indicates that the
        attribute was assigned using the attribute pointer [TYPE, MAT, REAL, or
        ESYS] that was active during meshing (and will be reset to zero if the
        mesh is cleared).

        This command is valid in any processor.
        """
        command = "LLIST,%s,%s,%s,%s" % (str(nl1), str(nl2), str(ninc), str(lab))
        return self.run(command, **kwargs)

    def awave(self, wavenum="", wavetype="", opt1="", opt2="", val1="",
              val2="", val3="", val4="", val5="", val6="", val7="", val8="",
              val9="", val10="", val11="", val12="", val13="", **kwargs):
        """APDL Command: AWAVE

        Specifies input data for an acoustic incident wave.

        Parameters
        ----------
        wavenum
            Wave number. You specify the integer number for an acoustic
            incident wave inside or outside the model.  The number must be
            between 1 and 20.

        wavetype
            Wave type:

            PLAN - Planar incident wave

            MONO - Monopole or pulsating sphere incident wave

            DIPO - Dipole incident wave

            BACK - Back enclosed loudspeaker

            BARE - Bare loudspeaker

            STATUS - Displays the status of the acoustic wave settings if Wavenum = a number between
                     1 and 20 or ALL.

            DELE - Deletes the acoustic wave settings if Wavenum = a number between 1 and 20 or
                   ALL.

        opt1
            PRES

            PRES - Pressure

            VELO - Velocity

        opt2
            EXT

            EXT - Incident wave outside the model.

            INT - Incident wave inside the model. This option is only available for pure
                  scattered pressure formulation.

        val1, val2, val3, . . . , val13
            If Wavetype = PLAN, MONO, DIPO, BACK, or BARE:

            VAL1 - Amplitude of pressure or normal velocity to the sphere surface.

            VAL2 - Phase angle of the applied pressure or velocity (in degrees). Defaults to 0
                   degrees.

        Notes
        -----
        Use the ASOL command to activate the scattered field algorithm and the
        ASCRES command for output control with the scattered field algorithm.
        Refer to Acoustics in the Mechanical APDL Theory Reference for more
        information about pure scattered field formulation.
        """
        command = "AWAVE,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(wavenum), str(wavetype), str(opt1), str(opt2), str(val1), str(val2), str(val3), str(val4), str(val5), str(val6), str(val7), str(val8), str(val9), str(val10), str(val11), str(val12), str(val13))
        return self.run(command, **kwargs)

    def sf(self, nlist="", lab="", value="", value2="", **kwargs):
        """APDL Command: SF

        Specifies surface loads on nodes.

        Parameters
        ----------
        nlist
            Nodes defining the surface upon which the load is to be applied.
            Use the label ALL or P, or a component name.  If ALL, all selected
            nodes [NSEL] are used (default).  If P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).

        lab
            Valid surface load label. Load labels are listed under "Surface
            Loads" in the input table for each element type in the Element
            Reference.

        value
            Surface load value or table name reference for specifying tabular
            boundary conditions.

        value2
            Second surface load value (if any).

        Notes
        -----
        Individual nodes may not be entered for this command.  The node list is
        to identify a surface and the Nlist field must contain a sufficient
        number of nodes to define an element surface.  The loads are internally
        stored on element faces defined by the specified nodes.  All nodes on
        an element face (including midside nodes, if any) must be specified for
        the face to be used, and the element must be selected.

        If all nodes defining a face are shared by an adjacent face of another
        selected element, the face is not free and will not have a load
        applied.  If more than one element can share the same nodes (for
        example, a surface element attached to a solid element), select the
        desired element type before issuing the SF command. The SF command
        applies only to area and volume elements.

        For shell elements, if the specified nodes include face one (which is
        usually the bottom face) along with other faces (such as edges), only
        face one is used.  Where faces cannot be uniquely determined from the
        nodes, or where the face does not fully describe the load application,
        use the SFE command.  A load key of 1 (which is typically the first
        loading condition on the first face) is used if the face determination
        is not unique.  A uniform load value is applied over the element face.
        """
        command = "SF,%s,%s,%s,%s" % (str(nlist), str(lab), str(value), str(value2))
        return self.run(command, **kwargs)

    def prnear(self, lab="", opt="", kcn="", val1="", val2="", val3="",
               val4="", val5="", val6="", val7="", val8="", val9="", **kwargs):
        """APDL Command: PRNEAR

        Prints the pressure in the near zone exterior to the equivalent source
        surface.

        Parameters
        ----------
        lab
            Print the maximum pressure or sound pressure level:

            POINT - at the point (x,y,z)

            SPHERE - on the spherical structure

            PATH - along the path

        opt
            PSUM

            PSUM  - Maximum complex pressure for acoustics.

            PHAS  - Phase angle of complex pressure for acoustics.

            SPL  - Sound pressure level for acoustics.

            SPLA - A-weighted sound pressure level for acoustics (dBA).

        kcn
            KCN is the coordinate system reference number. It may be 0
            (Cartesian) or any previously defined local coordinate system
            number (>10). Defaults to 0.

        val1, val2, val3, . . . , val9
            For Lab = POINT:

            VAL1 - x coordinate value

            VAL2 - y coordinate value

            VAL3 - z coordinate value

            VAL4 - VAL8 - not used

            VAL9 - Thickness of model in z direction (defaults to 0).

        Notes
        -----
        The command uses the equivalent source principle to calculate the
        pressure in the near zone exterior to the equivalent source surface
        (flagged with the Maxwell surface flag in the preprocessor) for one of
        the following locations:

        A point X, Y, Z in the KCN coordinate system

        A spherical surface in the KCN coordinate system

        A path defined by the PATH and PPATH commands

        To list the pressure results for a path, use the PRPATH command. See
        HFSYM command for the model symmetry.

        To retrieve saved equivalent source data, issue the
        SET,Lstep,Sbstep,,REAL command.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "PRNEAR,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(lab), str(opt), str(kcn), str(val1), str(val2), str(val3), str(val4), str(val5), str(val6), str(val7), str(val8), str(val9))
        return self.run(command, **kwargs)

    def mode(self, mode="", isym="", **kwargs):
        """APDL Command: MODE

        Specifies the harmonic loading term for this load step.

        Parameters
        ----------
        mode
            Number of harmonic waves around circumference for this harmonic
            loading term (defaults to 0).

        isym
            Symmetry condition for this harmonic loading term (not used when
            MODE = 0):

            1 - Symmetric (UX, UY, ROTZ, TEMP use cosine terms; UZ uses sine term) (default).

            -1 - Antisymmetric (UX, UY, ROTZ, TEMP use sine terms; UZ uses cosine term).

        Notes
        -----
        Used with axisymmetric elements having nonaxisymmetric loading
        capability (for example, PLANE25, SHELL61, etc.).  For analysis types
        ANTYPE,MODAL, HARMIC, TRANS, and SUBSTR, the term must be defined in
        the first load step and may not be changed in succeeding load steps.

        This command is also valid in PREP7.
        """
        command = "MODE,%s,%s" % (str(mode), str(isym))
        return self.run(command, **kwargs)

    def plfar(self, lab="", option="", phi1="", phi2="", nph1="", theta1="",
              theta2="", ntheta="", val1="", val2="", val3="", **kwargs):
        """APDL Command: PLFAR

        Plots pressure far fields and far field parameters.

        Parameters
        ----------
        lab
            Parameters to plot :

            PRES - Acoustic parameters

            PROT - Acoustic parameters with the y-axis rotated extrusion

        option
            Plot option, based on the specified plot parameter type:

        phi1, phi2
            Starting and ending φ angles (degrees) in the spherical coordinate
            system. Defaults to 0.

        nphi
            Number of divisions between the starting and ending φ angles for
            data computations. Defaults to 0.

        theta1, theta2
            Starting and ending θ angles (degrees) in the spherical coordinate
            system. Defaults to 0 in 3-D and 90 in 2-D.

        ntheta
            Number of divisions between the starting and ending θ angles for
            data computations. Defaults to 0.

        val1
            Radius of the sphere surface. Used only when Option = SUMC, SUMP,
            PHSC, PHSP, SPLC, SPLP, SPAC, SPAP, PSCT, PSPL, TSCT, or TSPL.

        val2
            When Option = SPLC, SPLP, SPAC, or SPAP: Reference rms sound
            pressure. Defaults to 2x10-5 Pa.

        val3
            When Lab = PRES: Thickness of 2-D model extrusion in the z
            direction (no default).

        Notes
        -----
        The PLFAR command plots pressure far fields and far field parameters as
        determined by the equivalent source principle. Use this command to plot
        pressure and acoustic    parameters. See the HFSYM command for the
        model symmetry and the     HFANG command for spatial radiation angles.

        When Option = PWL no plot is generated, but the sound power level
        appears in the output.

        To retrieve saved equivalent source data, issue the
        SET,Lstep,Sbstep,,REAL command.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "PLFAR,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(lab), str(option), str(phi1), str(phi2), str(nph1), str(theta1), str(theta2), str(ntheta), str(val1), str(val2), str(val3))
        return self.run(command, **kwargs)

    def svplot(self, optionscale="", damp1="", damp2="", damp3="", damp4="",
               **kwargs):
        """APDL Command: SVPLOT

        Displays input spectrum curves.

        Parameters
        ----------
        optionscale
            Flag to activate or deactivate input spectrum value scaling:

            OFF  - Do not scale the input spectrum values with scale factor FACT (SVTYP command).
                   This is the default value.

            ON  - Scale the input spectrum values with scale factor FACT (SVTYP command)

        damp1
            Damping ratio corresponding to DAMP (SV command) defining the first
            spectrum curve.

        damp2
            Damping ratio corresponding to DAMP (SV command) defining the
            second spectrum curve.

        damp3
            Damping ratio corresponding to DAMP (SV command) defining the third
            spectrum curve.

        damp4
            Damping ratio corresponding to DAMP (SV command) defining the
            fourth spectrum curve.

        Notes
        -----
        You can display up to four input spectrum tables (SV and FREQ commands)
        with log X scale. If no damping ratio is specified, all spectrum tables
        are displayed.

        This command is valid in any processor.
        """
        command = "SVPLOT,%s,%s,%s,%s,%s" % (str(optionscale), str(damp1), str(damp2), str(damp3), str(damp4))
        return self.run(command, **kwargs)

    def cgrow(self, action="", par1="", par2="", **kwargs):
        """APDL Command: CGROW

        Defines crack-growth information

        Parameters
        ----------
        action
            Specifies the action for defining or manipulating crack-growth
            data:

            NEW - Initiate a new set of crack-growth simulation data (default).

            CID - Specify the crack-calculation (CINT) ID for energy-release rates to be used in
                  the fracture criterion calculation.

            FCOPTION - Specify the fracture criterion for crack-growth/delamination.

            CPATH - Specify the element component for crack growth.

            DTIME - Specify the initial time step for crack growth.

            DTMIN - Specify the minimum time step for crack growth.

            DTMAX - Specify the maximum time step for crack growth.

            FCRAT - Fracture criterion ratio (fc).

            STOP - Stops the analysis when the specified maximum crack extension is reached.

            METHOD - Define the method of crack propagation.

        Notes
        -----
        When Action = NEW, the CGROW command initializes a crack-growth
        simulation set. Subsequent CGROW commands define the parameters
        necessary for the simulation.

        For multiple cracks, issue multiple CGROW,NEW commands (and any
        subsequent CGROW commands necessary to define the parameters) for each
        crack.

        If the analysis is restarted (ANTYPE,,RESTART), the CGROW command must
        be re-issued.

        For VCCT crack growth:

        Crack-growth element components must use the crack tip nodes as the
        starting nodes of the crack path.

        Fracture criteria (Action = FCOPTION) use energy-release rates
        calculated via VCCT technology (CINT,TYPE,VCCT). For information about
        the fracture criteria available, see Fracture Criteria in the Fracture
        Analysis Guide or the documentation for the TB,CGCR command.

        For XFEM-based crack growth:

        When using XFEM to grow the crack (CGROW,METHOD,XFEM), the crack
        specification originates via the XFENRICH and XFDATAa   >       c   o
        m   m   a   n   d   s   .       /   p   >   /   l   i   >   l   i
        c   l   a   s   s   =   "   l   i   s   t   i   t   e   m   "   >   p
        >   I   n       a   n       X   F   E   M   -   b   a   s   e   d
        c   r   a   c   k       g   r   o   w   t   h       a   n   a   l   y
        s   i   s   ,       e   m       c   l   a   s   s   =   "   r   e   p
        l   a   c   e   a   b   l   e   "   >   c   o   d   e   >   A   c   t
        i   o   n   /   c   o   d   e   >   /   e   m   >       =       C   P
        A   T   H   ,   D   T   M   I   N   ,   D   T   M   A   X       a   n
        d       S   T   O   P       h   a   v   e       n   o       e   f   f
        e   c   t   .   /   p   >   /   l   i   >   /   u   l   >   /   d   i
        v   >   /   d   i   v   >   d   i   v       c   l   a   s   s   =   "
        r   e   f   s   e   c   t   1   "       t   i   t   l   e   =   "   M
        e   n   u       P   a   t   h   s   "   >   a       n   a   m   e   =
        "   C   G   R   O   W   .   m   e   n   u   p   a   t   h   "   >   /
        a   >   h   2   >   M   e   n   u       P   a   t   h   s   /   h   2
        >   t   a   b   l   e       b   o   r   d   e   r   =   "   0   "
        s   u   m   m   a   r   y   =   "   S   i   m   p   l   e       l   i
        s   t   "       c   l   a   s   s   =   "   s   i   m   p   l   e   l
        i   s   t   "   >   t   r   >   t   d   >   s   p   a   n       c   l
        a   s   s   =   "   g   u   i   m   e   n   u   "   >   s   t   r   o
        n   g   >   T   h   i   s       c   o   m   m   a   n   d       c   a
        n   n   o   t       b   e       a   c   c   e   s   s   e   d       f
        r   o   m       a       m   e   n   u   .   /   s   t   r   o   n   g
        >   /   s   p   a   n   >   /   t   d   >   /   t   r   >   /   t   a
        b   l   e   >   /   d   i   v   >   /   d   i   v   >   h   r   >   p
        c   l   a   s   s   =   "   l   e   g   a   l   f   o   o   t   e   r
        "   >   s   m   a   l   l   >   i   >   R   e   l   e   a   s   e
        1   6   .   2       -       &c   o   p   y   ;       S   A   S       I
        P   ,       I   n   c   .       A   l   l       r   i   g   h   t   s
        r   e   s   e   r   v   e   d   .   /   i   >   /   s   m   a   l   l
        >   /   p   >   /   b   o   d   y   >   /   h   t   m   l   >
        """
        command = "CGROW,%s,%s,%s" % (str(action), str(par1), str(par2))
        return self.run(command, **kwargs)

    def kcalc(self, kplan="", mat="", kcsym="", klocpr="", **kwargs):
        """APDL Command: KCALC

        Calculates stress intensity factors in fracture mechanics analyses.

        Parameters
        ----------
        kplan
            Key to indicate stress state for calculation of stress intensity
            factors:

            0 - Plane strain and axisymmetric condition (default).

            1 - Plane stress condition.

        mat
            Material number used in the extrapolation (defaults to 1).

        kcsym
            Symmetry key:

            0 or 1  - Half-crack model with symmetry boundary conditions [DSYM] in the crack-tip
                      coordinate system.  KII = KIII = 0.  Three nodes are
                      required on the path.

            2 - Like 1 except with antisymmetric boundary conditions (KI = 0).

            3 - Full-crack model (both faces).  Five nodes are required on the path (one at the
                tip and two on each face).

        klocpr
            Local displacements print key:

            0 - Do not print local crack-tip displacements.

            1 - Print local displacements used in the extrapolation technique.

        Notes
        -----
        Calculates the stress intensity factors (KI, KII, and KIII) associated
        with homogeneous isotropic linear elastic fracture mechanics.  A
        displacement extrapolation method is used in the calculation (see POST1
        -  Crack Analysis in the Mechanical APDL Theory Reference). This method
        assumes that the displacement calculations are for the plane strain
        state. If the displacement calculations are performed using a plane
        stress formulation, the calculation of the stress intensity factors can
        be converted to the plane strain state by using KPLAN = 1. ANSYS Uses
        minor Poisson's ratio (MP,NUXY) for the stress intensity factor
        calculation, therefore the material's Poisson's ratio must be defined
        using MP,NUXY command. The PATH and PPATH commands must be used to
        define a path with the crack face nodes (NODE1 at the crack tip, NODE2
        and NODE3 on one face, NODE4 and NODE5 on the other (optional) face).
        A crack-tip coordinate system, having x parallel to the crack face (and
        perpendicular to the crack front) and y perpendicular to the crack
        face, must be the active RSYS and CSYS before KCALC is issued.
        """
        command = "KCALC,%s,%s,%s,%s" % (str(kplan), str(mat), str(kcsym), str(klocpr))
        return self.run(command, **kwargs)

    def rescombine(self, numfiles="", fname="", ext="", lstep="", sbstep="",
                   fact="", kimg="", time="", angle="", nset="", order="",
                   **kwargs):
        """APDL Command: RESCOMBINE

        Reads results from local results files into the database after a
        distributed memory parallel (Distributed ANSYS) solution.

        Parameters
        ----------
        numfiles
            Number of local results files that are to be read into the database
            from the distributed memory parallel solution. This number should
            be equal to the number of processes used in the parallel solution.

        fname
            File name (jobname) used during the distributed parallel solution.
            The file name must be an alphanumeric string (up to 32 characters)
            enclosed in single quotes.

        ext
            File extension for the results files (for example, RST, RTH, RMG,
            etc.). The file extension must be an alphanumeric string (up to 8
            characters) enclosed in single quotes.

        lstep
            Load step number of the data set to be read (defaults to 1):

            N - Read load step N.

            FIRST - Read the first data set (Sbstep and TIME are ignored).

            LAST - Read the last data set (Sbstep and TIME are ignored).

            NEXT - Read the next data set (Sbstep and TIME are ignored).  If at the last data set,
                   the first data set will be read as the next.

            PREVIOUS - Read the previous data set (Sbstep and TIME are ignored).  If at the first data
                       set, the last data set will be read as the previous.

            NEAR - Read the data set nearest to TIME (Sbstep is ignored).  If TIME is blank, read
                   the first data set.

            LIST - Scan the results files and list a summary of each load step (KIMG, TIME, ANGLE,
                   NSET, and ORDER are ignored.)

        sbstep
            Substep number within Lstep (defaults to the last substep of the
            load step). For a buckling (ANTYPE,BUCKLE) or modal (ANTYPE,MODAL)
            analysis, Sbstep corresponds to the mode number (defaults to the
            first mode). Specify Sbstep = LAST to store the last substep for
            the specified load step.

        fact
            Scale factor applied to data read from the files. If zero (or
            blank), a value of 1.0 is used. A nonzero factor excludes non-
            summable items. Harmonic velocities or accelerations may be
            calculated from the displacement results from a modal
            (ANTYPE,MODAL) or harmonic (ANTYPE,HARMIC) analysis. If Fact =
            VELO, the harmonic velocities (v) are calculated from the
            displacements (d) at a particular frequency (f) according to the
            relationship v = 2πfd. Similarly, if Fact = ACEL, the harmonic
            accelerations (a) are calculated as a = (2πf)2d.

        kimg
            Used only with complex results (harmonic and complex modal
            analyses).

            0 or REAL - Store the real part of a complex solution (default).

            1, 2 or IMAG - Store the imaginary part of a complex solution.

            3 or AMPL - Store the amplitude.

            4 or PHAS - Store the phase angle. The angle value, expressed in degrees, will be between
                        -180°  and +180°.

        time
            Time-point identifying the data set to be read. For a harmonic
            analysis, time corresponds to the frequency. For a buckling
            analysis, time corresponds to the load factor.  Used only in the
            following cases:  If Lstep = NEAR, read the data set nearest to
            TIME. If both Lstep and Sbstep are zero (or blank), read data set
            at time = TIME. If TIME is between two solution time points on the
            results file, a linear interpolation is done between the two data
            sets. Solution items not written to the results file (OUTRES) for
            either data set will result in a null item after data set
            interpolation. If TIME is beyond the last time point on the file,
            the last time point will be used.

        angle
            Circumferential location (0.0 to 360°). Defines the circumferential
            location for the harmonic calculations used when reading from the
            results file. The harmonic factor (based on the circumferential
            angle) is applied to the harmonic elements (PLANE25, PLANE75,
            PLANE78, PLANE83, and SHELL61) of the load case. See the Mechanical
            APDL Theory Reference for details. Note that factored values of
            applied constraints and loads will overwrite any values existing in
            the database.

        nset
            Data set number of the data set to be read. If a positive value for
            NSET is entered, Lstep, Sbstep, KIMG, and TIME are ignored.
            Available set numbers can be determined by RESCOMBINE,,,,LIST.

        order
            Key to sort the harmonic index results. This option applies to
            cyclic symmetry buckling and modal analyses only, and is valid only
            when Lstep = FIRST, LAST, NEXT, PREVIOUS, NEAR or LIST.

            ORDER  - Sort the harmonic index results in ascending order of eigenfrequencies or
                     buckling load multipliers.

            (blank)  - No sorting takes place.

        Notes
        -----
        RESCOMBINE is an ANSYS command macro that allows you to combine results
        from a distributed memory parallel (Distributed ANSYS) solution. In a
        distributed memory parallel solution, a global results file is saved by
        default. However, if you issued DMPOPTION,RST,NO in the parallel
        solution, no global results file is written and all local results files
        will be kept. In this case, you can use the RESCOMBINE command macro in
        the general postprocessor (/POST1) to read results into the database
        for postprocessing.

        In order to use the RESCOMBINE command, all local results files from
        the distributed memory parallel solution must be in the current working
        directory. If running on a single machine, the local results files are
        saved in the working directory by default. If running on a cluster, the
        local results files are kept in the working directory on each compute
        node. For this latter case, you must copy the local results files to
        the working directory on the primary compute node.

        Similar to the SET command, the RESCOMBINE command macro defines the
        data set to be read from the results files into the database. Various
        operations may also be performed during the read operation (see the SET
        command for more details). The database must have the model data
        available (or use the RESUME command before the RESCOMBINE command to
        restore the geometry from Jobname.DB).

        After a set of data is combined into the database using RESCOMBINE, the
        RESWRITE command can be used to write this set of data into a new
        results file. This new results file will essentially contain the
        current set of results data for the entire (i.e., global) model.
        """
        command = "RESCOMBINE,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(numfiles), str(fname), str(ext), str(lstep), str(sbstep), str(fact), str(kimg), str(time), str(angle), str(nset), str(order))
        return self.run(command, **kwargs)

    def path(self, name="", npts="", nsets="", ndiv="", **kwargs):
        """APDL Command: PATH

        Defines a path name and establishes parameters for the path.

        Parameters
        ----------
        name
            Name for this path (eight characters maximum. If nPts is blank, set
            the current path to the path with this name. If nPts is greater
            than zero, create a path of this name. If a path with this name
            already exists, replace it with a new path. If the NAME value is
            STATUS, display the status for path settings.

        npts
            The number of points used to define this path.  The minimum number
            is two, and the maximum is 1000. Default is 2.

        nsets
            The number of sets of data which you can map to this path.  You
            must specify at least four:  X, Y, Z, and S.  Default is 30.

        ndiv
            The number of divisions between adjacent points.  Default is 20.
            There is no maximum number of divisions.

        Notes
        -----
        The PATH command is used to define parameters for establishing a path.
        The path geometry is created by the PPATH command.  Multiple paths may
        be defined and named; however, only one path may be active for data
        interpolation [PDEF] and data operations [PCALC, etc.].  Path geometry
        points and data are stored in memory while in POST1.  If you leave
        POST1, the path information is erased.  Path geometry and data may be
        saved in a file by archiving the data using the PASAVE command.  Path
        information may be restored by retrieving the data using the PARESU
        command.

        For overlapping nodes, the lowest numbered node is assigned to the
        path.

        The number of divisions defined using nDiv does NOT affect the number
        of divisions used by PLSECT and PRSECT.

        For information on displaying paths you have defined, see  the Basic
        Analysis Guide.
        """
        command = "PATH,%s,%s,%s,%s" % (str(name), str(npts), str(nsets), str(ndiv))
        return self.run(command, **kwargs)

    def bool(self, **kwargs):
        """APDL Command: BOOL

        Specifies "Booleans" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "BOOL," % ()
        return self.run(command, **kwargs)

    def cpsgen(self, itime="", inc="", nset1="", nset2="", ninc="", **kwargs):
        """APDL Command: CPSGEN

        Generates sets of coupled nodes from existing sets.

        Parameters
        ----------
        itime, inc
            Do this generation operation a total of ITIMEs, incrementing all
            nodes in the existing sets by INC each time after the first.  ITIME
            must be > 1 for generation to occur.

        nset1, nset2, ninc
            Generate sets from sets beginning with NSET1 to NSET2 (defaults to
            NSET1) in steps of NINC (defaults to 1).  If NSET1 is negative,
            NSET2 and NINC are ignored and the last |NSET1| sets (in sequence
            from the maximum set number) are used as the sets to be repeated.

        Notes
        -----
        Generates additional sets of coupled nodes (with the same labels) from
        existing sets.  Node numbers between sets may be uniformly incremented.
        """
        command = "CPSGEN,%s,%s,%s,%s,%s" % (str(itime), str(inc), str(nset1), str(nset2), str(ninc))
        return self.run(command, **kwargs)

    def nrefine(self, nn1="", nn2="", ninc="", level="", depth="", post="",
                retain="", **kwargs):
        """APDL Command: NREFINE

        Refines the mesh around specified nodes.

        Parameters
        ----------
        nn1, nn2, ninc
            Nodes (NN1 to NN2 in increments of NINC) around which the mesh is
            to be refined.  NN2 defaults to NN1, and NINC defaults to 1.  If
            NN1 = ALL, NN2 and NINC are ignored and all selected nodes are used
            for refinement.  If NN1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  A
            component name may also be substituted for NN1 (NN2 and NINC are
            ignored).

        level
            Amount of refinement to be done.  Specify the value of LEVEL as an
            integer from 1 to 5, where a value of 1 provides minimal
            refinement, and a value of 5 provides maximum refinement (defaults
            to 1).

        depth
            Depth of mesh refinement in terms of number of elements outward
            from the indicated nodes (defaults to 1).

        post
            Type of postprocessing to be done after element splitting, in order
            to improve element quality:

            OFF - No postprocessing will be done.

            SMOOTH - Smoothing will be done.  Node locations may change.

            CLEAN - Smoothing and cleanup will be done.  Existing elements may be deleted, and node
                    locations may change (default).

        retain
            Flag indicating whether quadrilateral elements must be retained in
            the refinement of an all-quadrilateral mesh.  (The ANSYS program
            ignores the RETAIN argument when you are refining anything other
            than a quadrilateral mesh.)

            ON - The final mesh will be composed entirely of quadrilateral elements, regardless
                 of the element quality (default).

            OFF - The final mesh may include some triangular elements in order to maintain
                  element quality and provide transitioning.

        Notes
        -----
        NREFINE performs local mesh refinement around the specified nodes.  By
        default, the indicated elements are split to create new elements with
        1/2 the edge length of the original elements (LEVEL = 1).

        NREFINE refines all area elements and tetrahedral volume elements that
        are adjacent to the specified nodes.  Any volume elements that are
        adjacent to the specified nodes, but are not tetrahedra (for example,
        hexahedra, wedges, and pyramids), are not refined.

        You cannot use mesh refinement on a solid model that contains initial
        conditions at nodes [IC], coupled nodes [CP family of commands],
        constraint equations [CE family of commands], or boundary conditions or
        loads applied directly to any of its nodes or elements.  This applies
        to nodes and elements anywhere in the model, not just in the region
        where you want to request mesh refinement.  For additional restrictions
        on mesh refinement, see Revising Your Model in the Modeling and Meshing
        Guide.

        This command is also valid for rezoning.
        """
        command = "NREFINE,%s,%s,%s,%s,%s,%s,%s" % (str(nn1), str(nn2), str(ninc), str(level), str(depth), str(post), str(retain))
        return self.run(command, **kwargs)

    def xvar(self, n="", **kwargs):
        """APDL Command: XVAR

        Specifies the X variable to be displayed.

        Parameters
        ----------
        n
            X variable number:

            0 or 1 - Display PLVAR values vs. time (or frequency).

            n - Display PLVAR values vs. variable n (2 to NV [NUMVAR]).

            1 - Interchange time and PLVAR variable numbers with time as the curve parameter.
                PLVAR variable numbers are displayed uniformly spaced along
                X-axis from position 1 to 10.

        Notes
        -----
        Defines the X variable (displayed along the abscissa) against which the
        Y variable(s) [PLVAR] are to be displayed.
        """
        command = "XVAR,%s" % (str(n))
        return self.run(command, **kwargs)

    def iclwid(self, factor="", **kwargs):
        """APDL Command: /ICLWID

        Scales the line width of circuit builder icons.

        Parameters
        ----------
        factor
            Multiplication factor applied to the default line width (defaults
            to 1). The minimum is 1 and the maximum is 6.

        Notes
        -----
        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "/ICLWID,%s" % (str(factor))
        return self.run(command, **kwargs)

    def sspm(self, dens="", t="", **kwargs):
        """APDL Command: SSPM

        Specifies mass density for a preintegrated shell section.

        Parameters
        ----------
        dens
            Mass density.

        t
            Temperature.

        Notes
        -----
        The SSPM command, one of several preintegrated shell section commands,
        specifies the mass density (assuming a unit thickness) for a
        preintegrated shell section. The value specified is associated with the
        section most recently defined (via the SECTYPE command).

        Related commands are SSPA, SSPB, SSPD, SSPE, SSMT, and SSBT.

        For complete information, see Using Preintegrated General Shell
        Sections.
        """
        command = "SSPM,%s,%s" % (str(dens), str(t))
        return self.run(command, **kwargs)

    def mffr(self, fname="", lab="", rfini="", rfmin="", rfmax="", **kwargs):
        """APDL Command: MFFR

        Setup Multi-Field relaxation factors for field solutions.

        Parameters
        ----------
        fname
             Field name (MFX) or number (MFS). Must be the ANSYS field (cannot
            be a CFX field).

        lab
            Label name. Valid values are DISP and TEMP.

        rfini
            Initial relaxation factor. Defaults to 0.75.

        rfmin
            Minimum relaxation factor. Defaults to RFINI.

        rfmax
            Maximum relaxation factor. Defaults to RFINI.

        Notes
        -----
        Use this command to relax the field solutions in fluid-solid
        interaction analyses and thermal-thermal analyses for a better
        convergence rate in coupled problems, especially cases that need
        dynamic relaxation. The ANSYS field that has the MFFR command applied
        will do only one nonlinear stagger iteration within each multi-field
        stagger; the convergence of the ANSYS field solver will be satisfied
        through multiple multi-field staggers. Note that the CFX field solver
        can have multiple iterations within the field solver; see the CFX
        documentation for more details. ANSYS will not terminate the nonlinear
        field solution until the ANSYS field solver converges or reaches the
        maximum number of multi-field staggers as specified on MFITER.

        The interface load relaxation (MFRELAX) will be automatically turned
        off for the corresponding surface loads that have MFFR applied. The
        automatic change of the relaxation factor for accelerating the
        nonlinear convergence of the coupled field solution is based on
        Aitken's acceleration scheme.

        This command is valid only with coupled problems involving surface load
        transfer only. No subcycling is allowed for the field solver if using
        this command.
        """
        command = "MFFR,%s,%s,%s,%s,%s" % (str(fname), str(lab), str(rfini), str(rfmin), str(rfmax))
        return self.run(command, **kwargs)

    def race(self, xc="", yc="", rad="", tcur="", dy="", dz="", cname="",
             **kwargs):
        """APDL Command: RACE

        Defines a "racetrack" current source.

        Parameters
        ----------
        xc
            Location of the mid-thickness of the vertical leg along the working
            plane X-axis.

        yc
            Location of the mid-thickness of the horizontal leg along the
            working plane Y-axis.

        rad
            Radius of curvature of the mid-thickness of the curves in the
            racetrack source.  Defaults to .501 * DY

        tcur
            Total current, amp-turns (MKS), flowing in the source.

        dy
            In-plane thickness of the racetrack source.

        dz
            Out-of-plane thickness (depth) of the racetrack source.

        --, --
            Unused fields

        cname
            An alphanumeric name assigned as a component name to the group of
            SOURC36 elements created by the command macro.  Cname must be
            enclosed in single quotes in the RACE command line.  Cname may be
            up to 32 characters, beginning with a letter and containing only
            letters, numbers, and underscores.  Component names beginning with
            an underscore (e.g., _LOOP) are reserved for use by ANSYS and
            should be avoided.  If blank, no component name is assigned.

        Notes
        -----
        RACE invokes an ANSYS macro which defines a "racetrack" current source
        in the working plane coordinate system.  The current source is
        generated from bar and arc source primitives using the SOURC36 element
        (which is assigned the next available element type number).  The macro
        is valid for use in 3-D magnetic field analysis using a scalar
        potential formulation.  Current flows in a counterclockwise direction
        with respect  to the working plane.

        The diagram below shows you a racetrack current source.
        """
        command = "RACE,%s,%s,%s,%s,%s,%s,%s" % (str(xc), str(yc), str(rad), str(tcur), str(dy), str(dz), str(cname))
        return self.run(command, **kwargs)

    def vitrp(self, parr="", part="", pari="", parj="", park="", **kwargs):
        """APDL Command: *VITRP

        Forms an array parameter by interpolation of a table.

        Parameters
        ----------
        parr
            The name of the resulting array parameter.  See *SET for name
            restrictions.

        part
            The name of the TABLE array parameter.  The parameter must exist as
            a dimensioned array of type TABLE [*DIM].

        pari
            Array parameter vector of I (row) index values for interpolation in
            ParT.

        parj
            Array parameter vector of J (column) index values for interpolation
            in ParT (which must be at least 2-D).

        park
            Array parameter vector of K (depth) index values for interpolation
            in ParT (which must be 3-D).

        Notes
        -----
        Forms an array parameter (of type ARRAY) by interpolating values of an
        array parameter (of type TABLE) at specified table index locations
        according to:

        ParR = f(ParT, Parl, ParJ, ParK)

        where ParT is the type TABLE array parameter, and ParI, ParJ, ParK are
        the type ARRAY array parameter vectors of index values for
        interpolation in ParT.  See the *DIM command for TABLE and ARRAY
        declaration types.  Linear interpolation is used.  The starting array
        element number for the TABLE array (ParT) is not used (but a value must
        be input).  Starting array element numbers must be defined for each
        array parameter vector if it does not start at the first location. For
        example, *VITRP,R(5),TAB(1,1),X(2),Y(4) uses the second element of X
        and the fourth element of Y as index values (row and column) for a 2-D
        interpolation in TAB and stores the result in the fifth element of R.
        Operations continue on successive array elements [*VLEN, *VMASK] with
        the default being all successive elements.  Absolute values and scale
        factors may be applied to the result parameter [*VABS, *VFACT].
        Results may be cumulative [*VCUM].  See the *VOPER command for details.

        This command is valid in any processor.
        """
        command = "*VITRP,%s,%s,%s,%s,%s" % (str(parr), str(part), str(pari), str(parj), str(park))
        return self.run(command, **kwargs)

    def mapsolve(self, maxsbstep="", **kwargs):
        """APDL Command: MAPSOLVE

        Maps solved node and element solutions from an original mesh to a new
        mesh.

        Parameters
        ----------
        maxsbstep
            The maximum number of substeps for rebalancing the residuals. The
            default value is 5.

        Notes
        -----
        Used during the rezoning process, the MAPSOLVE command maps solved node
        and element solutions from the original mesh to the new mesh and
        achieves equilibrium based on the new mesh.

        Additional substeps are necessary to reduce the residuals to zero.

        During the rebalancing stage, the external loads and time remain
        unchanged.

        The MAPSOLVE command is valid only for rezoning (REZONE).

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MAPSOLVE,%s" % (str(maxsbstep))
        return self.run(command, **kwargs)

    def rimport(self, source="", type="", loc="", lstep="", sbstep="",
                fname="", ext="", spscale="", mscale="", **kwargs):
        """APDL Command: RIMPORT

        Imports initial stresses from an explicit dynamics run into ANSYS.

        Parameters
        ----------
        source
            The type of analysis run from which stresses are imported.

            OFF - Ignore initial stresses.

            DYNA - Get initial stresses from an earlier explicit (ANSYS LS-DYNA) run (default).

        type
            Type of data imported.  Note that this is an ANSYS-defined field;
            the only valid value is STRESS.

        loc
            Location where the data is imported.  Note that this is an ANSYS-
            defined field; the only valid value is ELEM (data imported at the
            element integration points).

        lstep
            Load step number of data to be imported.  Defaults to the last load
            step.

        sbstep
            Substep number of data to be imported.  Defaults to the last
            substep.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        spscale
            Stabilization factor. This factor is used in a springback analysis
            to scale (up or down) the initial stiffness of the applied spring.
            No default; input a value only if you want to activate
            stabilization. If SPSCALE is blank, stabilization is not activated.

        mscale
            Acceptable stabilization stiffness (defaults to 1.0 X 10--4). In a
            springback analysis, iterations will stop when the applied spring
            stiffness comes down to this value. MSCALE is not used if SPSCALE
            is blank.

        Notes
        -----
        This command imports initial stress information into ANSYS from an
        earlier explicit (ANSYS LS-DYNA) run.  The stress state from SHELL163
        and SOLID164 elements in the explicit analysis is imported to the
        corresponding SHELL181 and SOLID185 implicit elements. For the shell
        elements, the current shell element thickness is also imported. This
        command is valid only before the first SOLVE command of the implicit
        analysis (which comes after the explicit analysis) and is ignored if
        issued after subsequent SOLVE commands (that is, stresses will not be
        re-imported).

        RIMPORT is typically used to perform springback analysis of sheet metal
        forming. We recommend that you use SHELL163 elements in the explicit
        analysis with 3 to 5 integration points through the thickness. This
        ensures that the through-thickness stress distribution is transferred
        accurately to the SHELL181 elements. If more than 5 integration points
        are used, ANSYS imports resultants (forces and moments) to the SHELL181
        elements. This implies that linearization of the through-thickness
        stress distribution is assumed in SHELL181 elements. If SHELL163 uses
        full integration in the shell plane, stress and thickness data are
        averaged and then transferred. For the solid elements, the stress at
        the SOLID164 element centroid is transferred to the SOLID185 element
        centroid. If SOLID164 has full integration, the stress is averaged and
        then transferred.

        When the  SPSCALE argument is specified, artificial springs with
        exponentially decaying stiffness (as a function of iterations) are
        applied. This technique is recommended only for those cases in which
        there are severe convergence difficulties. In general, you should first
        attempt a springback analysis without using the stabilization factors
        SPSCALE and MSCALE. (For more information on springback stabilization,
        see the ANSYS LS-DYNA User's Guide.)

        This command is not written to the Jobname.CDB file when the CDWRITE
        command is issued. Further, the RIMPORT information is not saved to the
        database; therefore, the RIMPORT command must be reissued if the
        database is resumed.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RIMPORT,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(source), str(type), str(loc), str(lstep), str(sbstep), str(fname), str(ext), str(spscale), str(mscale))
        return self.run(command, **kwargs)

    def edread(self, nstart="", label="", num="", step1="", step2="",
               **kwargs):
        """APDL Command: EDREAD

        Reads explicit dynamics output into variables for time-history
        postprocessing.

        Parameters
        ----------
        nstart
            Starting reference number assigned to the first variable. Allowed
            range is 2 (the default) to NV [NUMVAR].  (NV defaults to 30 for an
            explicit dynamics analysis.)

        label
            Label identifying the output file to be read. No default.

            GLSTAT - Read data from the GLSTAT file.

            MATSUM - Read data from the MATSUM file.

            SPCFORC - Read data from the SPCFORC file.

            RCFORC - Read data from the RCFORC file.

            SLEOUT - Read data from the SLEOUT file.

            NODOUT - Read data from the NODOUT file.

            RBDOUT - Read data from the RBDOUT file.

        num
            Number identifying the data set to be read in (defaults to 1). If
            Label = GLSTAT, NUM is ignored. If Label = MATSUM or RBDOUT, NUM is
            the PART number [EDPART] for which output is desired. If Label =
            SPCFORC or NODOUT, NUM is the node number for which output is
            desired. If Label  = SLEOUT or RCFORC, NUM is the number of the
            contact entity for which output is desired.

        step1, step2
            Load step range of data to be read in. If STEP1 and STEP2 are
            blank, all load steps are read in.

        Notes
        -----
        EDREAD reads data from the specified ascii output file so that it may
        be used during postprocessing. After EDREAD, you must issue the STORE
        command to store the data in time history variables. Once stored, the
        variables can be viewed as plots of output item versus time.

        The number of variables stored depends on the file specified. The
        following table shows the items in each file and the order in which
        they are stored.  If data items were previously stored in variables
        NSTART to NSTART+15, they will be overwritten. If more variables are
        needed, change NV on the NUMVAR command. (Note that hourglass energy
        will not be available if it was not specified for the model
        [EDENERGY,1].)

        The following items under MATSUM are listed in the MATSUM ASCII file
        (in the Mat no. field) for each part number at time intervals specified
        by the EDHTIME command. Use EDREAD,,MATSUM,NUM to specify the part
        number that corresponds to the mat number in the MATSUM file.

        Resultant contact forces and sliding interface energies are available
        from the RCFORC and SLEOUT files, respectively. The RCFORC file is
        written for surface based contact types that include target and contact
        (master and slave) definitions.  You should ensure that this file
        contains valid force results before issuing EDREAD,,RCFORC. Only the
        resultant contact forces on the master surface are available for time-
        history postprocessing.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDREAD,%s,%s,%s,%s,%s" % (str(nstart), str(label), str(num), str(step1), str(step2))
        return self.run(command, **kwargs)

    def nforce(self, item="", **kwargs):
        """APDL Command: NFORCE

        Sums the nodal forces and moments of elements attached to nodes.

        Parameters
        ----------
        item
            Specifies the selected set of nodes for summing forces and moments
            for contact elements.

            (blank) - Sums the nodal forces of elements for all selected nodes and excludes contact
                      elements (elements 169-177).

            CONT - Sums the nodal forces of elements for contact nodes only.

            BOTH - Sums the nodal forces of elements for all selected nodes, including contact
                   elements.

        Notes
        -----
        Sums and prints, in each component direction for each selected node,
        the nodal force and moment contributions of the selected elements
        attached to the node.  If all elements are selected, the sums are
        usually zero except where constraints or loads are applied.  The nodal
        forces and moments may be displayed [/PBC,FORC and /PBC,MOME].  Use
        PRESOL to print nodal forces and moments on an element-by-element
        basis.  You can use the FORCE command to specify which component
        (static, damping, inertia, or total) of the nodal load is to be used.
        Nodal forces associated with surface loads are not included.

        This vector sum is printed in the global Cartesian system. Moment
        summations are about the global origin unless another point is
        specified with the SPOINT command.  The summations for each node are
        printed in the global Cartesian system unless transformed [RSYS].  This
        command is generally not applicable to axisymmetric models because
        moment information from the NFORCE command is not correct for
        axisymmetric elements.

        Selecting a subset of elements [ESEL] and then issuing this command
        will give the forces and moments required to maintain equilibrium of
        that set of elements.  The effects of nodal coupling and constraint
        equations are ignored. The option ITEM = CONT provides the forces and
        moments for the contact elements (CONTA171, CONTA172, CONTA173,
        CONTA174, CONTA175, CONTA176, and CONTA177). Setting ITEM = BOTH
        provides the forces and moments for all selected nodes, including
        contact elements.

        This command also includes the FSUM command function which vectorially
        sums and prints, in each component direction for the total selected
        node set, the nodal force and moment contributions of the selected
        elements attached to the selected node set.
        """
        command = "NFORCE,%s" % (str(item))
        return self.run(command, **kwargs)

    def plsect(self, item="", comp="", rho="", kbr="", **kwargs):
        """APDL Command: PLSECT

        Displays membrane and membrane-plus-bending linearized stresses.

        Parameters
        ----------
        item
            Label identifying the item to be processed.  Valid item labels are
            shown in Table 221: PLSECT - Valid Item and Component Labels below.
            Items also require a component label.

        comp
            Component of the item.  Valid component labels are shown in
            Table 221: PLSECT - Valid Item and Component Labels below.

        rho
            In-plane (X-Y) average radius of curvature of the inside and
            outside surfaces of an axisymmetric section.  If zero (or blank), a
            plane or 3-D structure is assumed.  If nonzero, an axisymmetric
            structure is assumed.  Use a very large number (or -1) for an
            axisymmetric straight section.

        kbr
            Through-thickness bending stresses key for an axisymmetric analysis
            (RHO ≠ 0):

            0 - Include the thickness-direction bending stresses.

            1 - Ignore the thickness-direction bending stresses.

            2 - Include the thickness-direction bending stress using the same formula as the Y
                (axial direction ) bending stress. Also use the same formula
                for the shear stress.

        Notes
        -----
        Calculates and displays the membrane and membrane-plus-bending
        linearized stresses (as described for the PRSECT command) along a path
        section [PATH] as a graph.  The path section is defined by two points
        specified with the PPATH command. For linearized stress calculations,
        the path must be defined with nodes. The path must be entirely within
        the selected elements (that is, there must not be any element gaps
        along the path). The total stress (equivalent to the PLPATH display) is
        also displayed.  This command always uses 48 divisions along the path,
        regardless of the number of divisions defined by PATH.

        Portions of this command are not supported by PowerGraphics
        [/GRAPHICS,POWER].

        Table: 221:: : PLSECT - Valid Item and Component Labels
        """
        command = "PLSECT,%s,%s,%s,%s" % (str(item), str(comp), str(rho), str(kbr))
        return self.run(command, **kwargs)

    def veorient(self, vnum="", option="", value1="", value2="", **kwargs):
        """APDL Command: VEORIENT

        Specifies brick element orientation for volume mapped (hexahedron)
        meshing.

        Parameters
        ----------
        vnum
            Number identifying volume for which elements are to be oriented (no
            default).

        option
            Option for defining element orientation:

            KP - Orientation is determined by two keypoints on the volume. Input the keypoint
                 numbers (KZ1 and KZ2) in fields VALUE1 and VALUE2,
                 respectively. The element z-axis points from KZ1 toward KZ2.
                 Element x and y directions point away from KZ1 along edges of
                 the volume to make a right-hand triad. (The element x- and
                 y-axes are uniquely determined by this specification.)

            LINE - Orientation is determined by one of the lines defining the volume. Input the
                   line number in field VALUE1. The element z direction follows
                   the direction of the line. Input a negative value if the
                   desired z direction is opposite to the direction of the
                   specified line. (The element x- and y-axes are uniquely
                   determined by this specification.) (VALUE2 is not used.)

            AREA - Orientation is determined by one of the areas defining the volume. The area
                   represents the desired element top surface. Input the area
                   number as VALUE1. The shortest line in the volume connected
                   to the area will be used to specify the element z direction.
                   (If more than one shortest line exists, the lowest numbered
                   of those is used.) Element x and y directions are not
                   uniquely specified by this option. (VALUE2 is not used.)

            THIN - Align the element z normal to the thinnest dimension of the volume. The
                   shortest line in the volume is used to specify the element z
                   direction. (If more than one shortest line exists, the
                   lowest numbered of those is used.) Element x and y
                   directions are not uniquely specified by this option.
                   (VALUE1 and VALUE2 are not used.)

            DELE - Delete the previously defined volume orientation for the specified volume
                   (VNUM).  (VALUE1 and VALUE2 are not used.)

        value1, value2
            Parameters required for the element z-axis direction specification.
            The meaning of VALUE1 and VALUE2 will depend on the chosen Option.
            See the description of Option above for details.

        Notes
        -----
        Use VEORIENT before the VMESH command to specify the desired
        orientation of brick elements in a mapped mesh. VEORIENT has no effect
        on tetrahedron meshes, extruded meshes (VROTAT, VDRAG, VEXT, etc.), or
        swept meshes (VSWEEP).

        Proper brick orientation is essential for certain element types such as
        SOLID185 Layered Solid, SOLID186 Layered Solid, and SOLSH190. In such
        cases, use VEORIENT or EORIENT to achieve the desired orientation. For
        other brick element types, you may need to specify element orientation
        to control orthotropic material property directions without concern for
        the element connectivity. For those cases, the ESYS command is the
        preferred method of specifying the material property directions.

        For Option = LINE, AREA, and THIN, the orientation will be internally
        converted to an equivalent Option = KP specification (KP,KZ1,KZ2). Use
        the VLIST command to view the element orientations (in terms of KZ1 and
        KZ2) associated with each volume.
        """
        command = "VEORIENT,%s,%s,%s,%s" % (str(vnum), str(option), str(value1), str(value2))
        return self.run(command, **kwargs)

    def bfint(self, fname1="", ext1="", fname2="", ext2="", kpos="", clab="",
              kshs="", tolout="", tolhgt="", **kwargs):
        """APDL Command: BFINT

        Activates the body force interpolation operation.

        Parameters
        ----------
        fname1
            File name and directory path (248 characters maximum, including
            directory) from which to read data for interpolation. If you do not
            specify a directory path, it will default to your working directory
            and you can use all 248 characters for the file name.

        ext1
            Filename extension (eight-character maximum).

        --
            Unused field.

        fname2
            File name and directory path (248 characters maximum, including
            directory) to which BF commands are written. If you do not specify
            a directory path, it will default to your working directory and you
            can use all 248 characters for the file name.

        ext2
            Filename extension (eight-character maximum).

        --
            Unused field.

        kpos
            Position on Fname2 to write block of BF commands:

            0 - Beginning of file (overwrite existing file).

            1 - End of file (append to existing file).

        clab
            Label (8 characters maximum, including the colon) for this block of
            BF commands in Fname2.  This label is appended to the colon (:).
            Defaults to BFn, where n is the cumulative iteration number for the
            data set currently in the database.

        kshs
            Shell-to-solid submodeling key:

            0 - Solid-to-solid or shell-to-shell submodel.

            1 - Shell-to-solid submodel.

        tolout
            Extrapolation tolerance about elements, based on a fraction of the
            element dimension. Submodel nodes outside the element by more than
            TOLOUT are not accepted as candidates for DOF extrapolation.
            Defaults to 0.5 (50%).

        tolhgt
            Height tolerance above or below shell elements, in units of length.
            Used only for shell-to-shell submodeling (KSHS = 0). Submodel nodes
            off the element surface by more than TOLHGT are not accepted as
            candidates for DOF interpolation or extrapolation. Defaults to
            0.0001 times the maximum element dimension.

        Notes
        -----
        File Fname1 should contain a node list for which body forces are to be
        interpolated [NWRITE].  File Fname2 is created, and contains
        interpolated body forces written as a block of nodal BF commands.

        Body forces are interpolated from elements having TEMP as a valid body
        force or degree of freedom, and only the label TEMP is written on the
        nodal BF commands.  Interpolation is performed for all nodes on file
        Fname1 using the results data currently in the database. For layered
        elements, use the LAYER command to select the locations of the
        temperatures to be used for interpolation. Default locations are the
        bottom of the bottom layer and the top of the top layer.

        The block of BF commands begins with an identifying colon label command
        and ends with a /EOF command.  The colon label command is of the form
        :Clab, where Clab is described above.  Interpolation from multiple
        results sets can be performed by looping through the results file in a
        user-defined macro.  Additional blocks can be appended to Fname2 by
        using KPOS and unique colon labels.  A /INPUT command, with the
        appropriate colon label, may be used to read the block of commands.

        If the model has coincident (or very close) nodes, BFINT must be
        applied to each part of the model separately to ensure that the mapping
        of the nodes is correct.  For example, if nodes belonging to two
        adjacent parts linked by springs are coincident, the operation should
        be performed on each part of the model separately.
        """
        command = "BFINT,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(fname1), str(ext1), str(fname2), str(ext2), str(kpos), str(clab), str(kshs), str(tolout), str(tolhgt))
        return self.run(command, **kwargs)

    def mdele(self, node="", lab1="", nend="", ninc="", lab2="", lab3="",
              lab4="", lab5="", lab6="", **kwargs):
        """APDL Command: MDELE

        Deletes master degrees of freedom.

        Parameters
        ----------
        node, lab1, nend, ninc
            Delete master degrees of freedom in the Lab1 direction [M] from
            NODE to NEND (defaults to NODE) in steps of NINC (defaults to 1).
            If NODE = ALL, NEND and NINC are ignored and masters for all
            selected nodes [NSEL] are deleted.  If Lab1 = ALL, all label
            directions will be deleted.  If NODE = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for NODE.

        lab2, lab3, lab4, . . . , lab6
            Delete masters in these additional directions.

        Notes
        -----
        Deletes master degrees of freedom.  If used in SOLUTION, this command
        is valid only within the first load step.

        This command is also valid in PREP7.
        """
        command = "MDELE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(node), str(lab1), str(nend), str(ninc), str(lab2), str(lab3), str(lab4), str(lab5), str(lab6))
        return self.run(command, **kwargs)

    def export(self, matrix="", format="", fname="", val1="", val2="", val3="",
               **kwargs):
        """APDL Command: *EXPORT

        Exports a matrix to a file in the specified format.

        Parameters
        ----------
        matrix
            Name of the matrix to export (must be a matrix previously created
            with *DMAT or *SMAT, or a vector previously created with *VEC).

        format
            Format of the output file:

            Export the matrix in the Matrix Market Format. - Export the matrix in the SUB file format.

            Export the matrix in the Harwell-Boeing file format. - Export the matrix in a native format, to be re-imported using the *DMAT or
                              *SMAT command.

            Export the matrix to an existing EMAT file. - Export the matrix to an APDL array parameter.

            Export the matrix profile to a Postscript file. - Export the matrix in the DMIG file format.

        fname
            Name of the file, or name of the array parameter if Format = APDL.

        val1, val2, val3
            Additional input. The meaning of Val1 through Val3 will vary
            depending on the specified Format. See table below for details.

        Notes
        -----
        Only sparse matrices can be exported to Postscript files. This option
        plots the matrix profile as a series of dots.

        If you want to create a .SUB file from several matrices, you need to
        set Val3 = WAIT for all matrices but the last, and Val3 = DONE for the
        last one. The export will be effective at the last *EXPORT command.

        To create a .SUB file or .DMIG file from scratch, you must supply the
        row information array. (Specify this array in the Val2 field for .SUB
        or in the Val1 field for .DMIG.) This must be an m x 2 array, where m
        is the size of the matrix. The first column is the node number and the
        second column is the DOF number corresponding to each row of the
        matrix.

        The *EXPORT command is not applicable to sparse matrices initialized
        from .FULL files by means of the NOD2BCS option on the *SMAT command
        (i.e., *SMAT,,,IMPORT,FULL,,NOD2BCS).
        """
        command = "*EXPORT,%s,%s,%s,%s,%s,%s" % (str(matrix), str(format), str(fname), str(val1), str(val2), str(val3))
        return self.run(command, **kwargs)

    def swadd(self, ecomp="", shrd="", ncm1="", ncm2="", ncm3="", ncm4="",
              ncm5="", ncm6="", ncm7="", ncm8="", ncm9="", **kwargs):
        """APDL Command: SWADD

        Adds more surfaces to an existing spot weld set.

        Parameters
        ----------
        ecomp
            Name of an existing spot weld set that was previously defined using
            SWGEN.

        shrd
            Search radius. Defaults to 4 times the spot weld radius defined for
            the spot weld set (SWRD on SWGEN).

        ncm1, ncm2, ncm3, . . . , ncm9
            Surfaces to be added to the spot weld set. Each surface can be
            input as a predefined node component or a meshed area number.

        Notes
        -----
        This command adds surfaces to an existing spot weld set defined by the
        SWGEN command. You can add additional surfaces by repeating the SWADD
        command. However, the maximum number of allowable surfaces (including
        the 2 surfaces used for the original set defined by SWGEN) for each
        spot weld set is 11. See Adding Surfaces to a Basic Set for more
        information.
        """
        command = "SWADD,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(ecomp), str(shrd), str(ncm1), str(ncm2), str(ncm3), str(ncm4), str(ncm5), str(ncm6), str(ncm7), str(ncm8), str(ncm9))
        return self.run(command, **kwargs)

    def esel(self, type="", item="", comp="", vmin="", vmax="", vinc="",
             kabs="", **kwargs):
        """APDL Command: ESEL

        Selects a subset of elements.

        Parameters
        ----------
        type
            Label identifying the type of select:

            S - Select a new set (default).

            R - Reselect a set from the current set.

            A - Additionally select a set and extend the current set.

            U - Unselect a set from the current set.

            ALL - Restore the full set.

            NONE - Unselect the full set.

            INVE - Invert the current set (selected becomes unselected and vice versa).

            STAT - Display the current select status.

        Notes
        -----
        Selects elements based on values of a labeled item and component. For
        example, to select a new set of elements based on element numbers 1
        through 7, use ESEL,S,ELEM,,1,7.  The subset is used when the ALL label
        is entered (or implied) on other commands, such as ELIST,ALL.  Only
        data identified by element number are selected. Selected data are
        internally flagged; no actual removal of data from the database occurs.
        Different element subsets cannot be used for different load steps
        [SOLVE] in a /SOLU sequence.  The subset used in the first load step
        will be used for all subsequent load steps regardless of subsequent
        ESEL specifications.

        This command is valid in any processor.

        Elements crossing the named path (see PATH command) will be selected.
        This option is only available in PREP7 and POST1. If no geometry data
        has been mapped to the path (i.e., via PMAP and PDEF commands), the
        path will assume the default mapping option (PMAP,UNIFORM) to map the
        geometry prior to selecting the elements. If an invalid path name is
        given, the ESEL command is ignored (status of selected elements is
        unchanged). If there are no elements crossing the path, the ESEL
        command will return zero elements selected.

        For selections based on non-integer numbers (coordinates, results,
        etc.), items that are within the range VMIN -Toler and VMAX + Toler are
        selected. The default tolerance Toler is based on the relative values
        of VMIN and VMAX as follows:

        If VMIN = VMAX, Toler = 0.005 x VMIN.

        If VMIN = VMAX = 0.0, Toler = 1.0E-6.

        If VMAX ≠ VMIN, Toler = 1.0E-8 x (VMAX - VMIN).

        Use the SELTOL command to override this default and specify Toler
        explicitly.

        Table: 133:: : ESEL - Valid Item and Component Labels
        """
        command = "ESEL,%s,%s,%s,%s,%s,%s,%s" % (str(type), str(item), str(comp), str(vmin), str(vmax), str(vinc), str(kabs))
        return self.run(command, **kwargs)

    def sfe(self, elem="", lkey="", lab="", kval="", val1="", val2="", val3="",
            val4="", **kwargs):
        """APDL Command: SFE

        Specifies surface loads on elements.

        Parameters
        ----------
        elem
            Element to which surface load applies.  If ALL, apply load to all
            selected elements [ESEL].  If Elem = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may be substituted for Elem.

        lkey
            Load key or face number associated with surface load (defaults to
            1).  Load keys (1,2,3, etc.) are listed under "Surface Loads" in
            the input data table for each element type in the Element
            Reference.

        lab
            Valid surface load label.  Load labels are listed under "Surface
            Loads" in the input table for each element type in the Element
            Reference.

        kval
            Value key.  If Lab = PRES:

            0 or 1 - VAL1 through VAL4 are used as real components of pressures.

            2 - VAL1 through VAL4 are used as imaginary components of pressures.

        val1
            First surface load value (typically at the first node of the face)
            or the name of a table for specifying tabular boundary conditions.
            Face nodes are listed in the order given for "Surface Loads" in the
            input data table for each element type in the Element Reference.
            For example, for SOLID185, the item 1-JILK associates LKEY = 1
            (face 1) with nodes J, I, L, and K.  Surface load value VAL1 then
            applies to node J of face 1.  To specify a table, enclose the table
            name in percent signs (%), e.g., %tabname%.  Use the *DIM command
            to define a table.  Only one table can be specified, and it must be
            specified in the VAL1 position; tables specified in the VAL2, VAL3,
            or VAL4 positions will be ignored. VAL2 applies to node I, etc.
        """
        command = "SFE,%s,%s,%s,%s,%s,%s,%s,%s" % (str(elem), str(lkey), str(lab), str(kval), str(val1), str(val2), str(val3), str(val4))
        return self.run(command, **kwargs)

    def secfunction(self, table="", kcn="", **kwargs):
        """APDL Command: SECFUNCTION

        Specifies shell section thickness as a tabular function.

        Parameters
        ----------
        table
            Table name or array parameter reference for specifying thickness.

        kcn
            Local coordinate system reference number or array interpretation
            pattern for this tabular function evaluation.

        Notes
        -----
         The SECFUNCTION command is associated with the section most recently
        defined via the SECTYPE command.

        A table (TABLE) can define tabular thickness as a function of
        coordinates. Alternatively, you can use an array parameter (indexed by
        node number) that expresses the function to be mapped. (For example,
        func (17) should be the desired shell thickness at node 17.)  To
        specify a table, enclose the table or array name in percent signs (%)
        (SECFUNCTION,%tablename%). Use the *DIM command to define a table.

        The table or array defines the total shell thickness at any point in
        space. In multilayered sections, the total thickness and each layer
        thickness are scaled accordingly.

        The Function Tool is a convenient way to define your thickness tables.
        For more information, see Using the Function Tool in the Basic Analysis
        Guide.

        If you do not specify a local coordinate system (KCN), the program
        interprets TABLE in global XYZ coordinates. (For information about
        local coordinate systems, see the LOCAL command documentation.)

        When KCN = NODE, the program interprets TABLE as an array parameter
        (indexed by node number) that expresses the function to be mapped.

        When KCN = NOD2, the program interprets TABLE as a 2-D array parameter
        (where columns contain node numbers and rows contain the corresponding
        thicknesses) that expresses the function to be mapped.
        """
        command = "SECFUNCTION,%s,%s" % (str(table), str(kcn))
        return self.run(command, **kwargs)

    def eddrelax(self, option="", nrcyck="", drtol="", dffctr="", drterm="",
                 tssfdr="", irelal="", edttl="", **kwargs):
        """APDL Command: EDDRELAX

        Activates initialization to a prescribed geometry or dynamic relaxation
        for the explicit analysis.

        Parameters
        ----------
        option
            Specifies when dynamic relaxation is activated.

            ANSYS - Stresses are initialized in ANSYS LS-DYNA to a prescribed geometry for small
                    strains, according to the solution of an ANSYS (implicit)
                    run. The explicit solution is based on the implicit X,Y,Z
                    displacements and rotations contained in the drelax file
                    (created with the REXPORT command).

            DYNA - Dynamic relaxation is on. When you use this option, you can specify some or all
                   of the parameters NRCYCK, DRTOL, DFFCTR, DRTERM, TSSFDR,
                   IRELAL, and EDTTL. Any parameters that you do not specify
                   are set to their default values.

            OFF - Turn off initialization to a prescribed geometry (Option = ANSYS) or dynamic
                  relaxation (Option = DYNA).

        nrcyck
            Number of iterations between convergence checks for dynamic
            relaxation option. Default = 250.

        drtol
            Convergence tolerance for dynamic relaxation option. Default =
            0.001.

        dffctr
            Dynamic relaxation factor. Default = 0.995.

        drterm
            Optional termination time for dynamic relaxation. Termination
            occurs at this time, or when convergence is attained, whichever
            comes first. Default = infinity.

        tssfdr
            Scale factor for computed time step during dynamic relaxation. If
            zero, the value is set to TSSFAC (defined on the EDCTS command).
            After converging, the scale factor is reset to TSSFAC.

        irelal
            Automatic control for dynamic relaxation option based on algorithm
            of Papadrakakis.

            0 - Not active (default).

            1 - Active.

        edttl
            Convergence tolerance on automatic control of dynamic relaxation
            (default = 0.04).

        Notes
        -----
        Use Option = ANSYS when running an implicit-to-explicit sequential
        solution to initialize the structure to a static solution performed
        earlier by the ANSYS implicit solver. Use Option = DYNA to perform
        dynamic relaxation within the LS-DYNA program. Use Option = OFF to turn
        off previously specified stress initialization or dynamic relaxation.
        You must specify the Option you want; there is no default.

        In LS-DYNA, the dynamic relaxation is performed before the regular
        transient analysis. The convergence process of the dynamic relaxation
        is not written to the ANSYS history file. The ANSYS results files only
        include the converged result of the dynamic relaxation, which is the
        result at time zero in the Jobname.HIS and Jobname.RST files.

        You can restart a dynamic relaxation analysis (EDSTART,2 or EDSTART,3)
        from a previous transient analysis or a previous dynamic relaxation
        analysis. In the restart, you can change or set the convergence
        criteria with the EDDRELAX command. Only the load curves that are
        flagged for dynamic relaxation (PHASE = 1 or 2 on EDLOAD) are applied
        after restarting. If you restart the explicit portion of an implicit-
        to-explicit sequential solution, you do not need to reissue the REXPORT
        command because displacement information contained in the drelax file
        is already included in the LS-DYNA restart file. If the dynamic
        relaxation is activated from a regular transient analysis, LS-DYNA
        continues the output of data to ANSYS results files. This is unlike the
        dynamic relaxation phase at the beginning of the calculation for which
        only the converged solution is written.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDDRELAX,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(nrcyck), str(drtol), str(dffctr), str(drterm), str(tssfdr), str(irelal), str(edttl))
        return self.run(command, **kwargs)

    def rcon(self, **kwargs):
        """APDL Command: RCON

        Specifies "Real constants" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "RCON," % ()
        return self.run(command, **kwargs)

    def pdwrite(self, file="", fnam="", lnam="", **kwargs):
        """APDL Command: PDWRITE

        Generates an HTML report for the probabilistic analyses.

        Parameters
        ----------
        file
            File name and directory path (248 characters maximum, including
            directory) from which to read the report. If you do not specify a
            directory path, it will default to your working directory and you
            can use all 248 characters for the file name.

        fnam
            First name of the author of the report (32 characters maximum).
            This first name must not include blanks.

        lnam
            Last name of the author of the report (32 characters maximum). This
            last name must not include blanks.

        Notes
        -----
        Generates an HTML report for the probabilistic analysis. An HTML report
        includes a description of the deterministic model, the probabilistic
        model, the probabilistic methods used for the analyses and the results
        obtained from the analyses.
        """
        command = "PDWRITE,%s,%s,%s" % (str(file), str(fnam), str(lnam))
        return self.run(command, **kwargs)

    def cntr(self, option="", key="", **kwargs):
        """APDL Command: CNTR

        Redirects contact pair output quantities to a text file.

        Parameters
        ----------
        option
            Output option:

            OUT - Contact output control.

        key
            Control key:

            NO - Write contact information to the output file or to the screen (default).

            YES - Write contact information to the Jobname.CNM file.

        Notes
        -----
        Issue the command CNTR,OUT,YES to redirect contact pair output
        quantities to the Jobname.CNM file.

        To ensure that the contact information is written to Jobname.CNM,
        reissue CNTR,OUT,YES each time you reenter the solution processor
        (/SOLU).
        """
        command = "CNTR,%s,%s" % (str(option), str(key))
        return self.run(command, **kwargs)

    def rmrplot(self, refname="", type="", mode1="", mode2="", **kwargs):
        """APDL Command: RMRPLOT

        Plots response surface of ROM function or its derivatives with respect
        to the dominant mode(s).

        Parameters
        ----------
        refname
            Reference name of ROM function. Valid reference names are "SENE"
            for the strain energy of the mechanical domain and any capacitance
            definition, previously defined by means of the RMCAP command, for
            the electrostatic domain.

        type
            Type of data to be plotted. Valid types are:

            FUNC - Response surface (default)

        mode1
            First mode number (used for Type = "FIRST" and Type = "SECOND"
            only).

        mode2
            Second mode number (used for Type = "SECOND" only).

        Notes
        -----
        The objective of response surface fit is to compute an analytical
        expression for the strain energy and the capacitance as functions of
        modal amplitudes. This command assumes that the coefficient files
        jobnam_ijk.pcs are available [RMRGENERATE]. Visualization of the
        response surface will help to evaluate the validity of the function
        fit.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMRPLOT,%s,%s,%s,%s" % (str(refname), str(type), str(mode1), str(mode2))
        return self.run(command, **kwargs)

    def fplist(self, **kwargs):
        """APDL Command: FPLIST

        Lists the property table stored for fatigue evaluation.
        """
        command = "FPLIST," % ()
        return self.run(command, **kwargs)

    def boptn(self, lab="", value="", **kwargs):
        """APDL Command: BOPTN

        Specifies Boolean operation options.

        Parameters
        ----------
        lab
            Default/status key:

            DEFA  - Resets settings to default values.

            STAT  - Lists status of present settings.

        value
            Option settings if Lab = KEEP:

            NO  - Delete entities used as input with a Boolean operation (default).  Entities
                  will not be deleted if meshed or if attached to a higher
                  entity.

            YES  - Keep input solid modeling entities.

        Notes
        -----
        Boolean operations at Revision 5.2 may produce a different number of
        entities than previous revisions of ANSYS.   When running input files
        created at earlier revisions of ANSYS, match the Boolean compatibility
        option (VERSION) to the revision originally used. For instance,  if you
        are running Revision 5.2 and are reading an input file (/INPUT) created
        at Revision 5.1, it is recommended that you set VERSION to RV51 before
        reading the input.

        See the Modeling and Meshing Guide for further details on the functions
        of the RV51 and RV52 labels.

        This command is valid in any processor.
        """
        command = "BOPTN,%s,%s" % (str(lab), str(value))
        return self.run(command, **kwargs)

    def resvec(self, key="", **kwargs):
        """APDL Command: RESVEC

        Calculates or includes residual vectors.

        Parameters
        ----------
        key
            Residual vector key:

            OFF - Do not calculate or include residual vectors. This option is the default.

            ON  - Calculate or include residual vectors.

        Notes
        -----
        In a modal analysis, the RESVEC command calculates residual vectors. In
        a mode-superposition transient dynamic, mode-superposition harmonic,
        PSD or spectrum analysis, the command includes residual vectors.

        In a component mode synthesis (CMS) generation pass, the RESVEC command
        calculates one residual vector which is included in the normal modes
        basis used in the transformation matrix. It is supported for the three
        available CMS methods. RESVEC,ON can only be specified in the first
        load step of a generation pass and is ignored if issued at another load
        step.

        If rigid-body modes exist, pseudo-constraints are required for the
        calculation. Issue the D,,,SUPPORT command to specify only the minimum
        number of pseudo-constraints necessary to prevent rigid-body motion.

        For more information about residual vector formulation, see Residual
        Vector Method in the Mechanical APDL Theory Reference.
        """
        command = "RESVEC,%s" % (str(key))
        return self.run(command, **kwargs)

    def uis(self, label="", value="", **kwargs):
        """APDL Command: /UIS

        Controls the GUI behavior.

        Parameters
        ----------
        label
            Behavior control key:

            BORD - Controls the functionality of the mouse buttons for dynamic viewing mode only.
                   When Label = BORD, the three values that follow control the
                   functionality of the LEFT, MIDDLE and RIGHT buttons,
                   respectively (see below).

            MSGPOP - Controls which messages from the ANSYS error message subroutine are displayed
                     in a message dialog box.

            REPLOT - Controls whether or not an automatic replot occurs after functions affecting
                     the model are executed.

            ABORT - Controls whether or not ANSYS displays dialog boxes to show the status of an
                    operation in progress and to cancel that operation.

            DYNA - Controls whether the dynamic mode preview is a bounding box or the edge outline
                   of the model.  This label only applies to 2-D display
                   devices (i.e., /SHOW,XII or /SHOW,WIN32).  This "model edge
                   outline" mode is only supported in PowerGraphics
                   [/GRAPHICS,POWER] and is intended for element, line,
                   results, area, or volume displays.

            PICK - Controls how graphical entities are highlighted from within the ANSYS Select
                   menu.

            POWER - Controls whether or not PowerGraphics is active when the GUI is initiated. The
                    ANSYS program default status is PowerGraphics “ON”;  this
                    command is used (placed in the start.ans file) when full
                    graphics is desired on start up.

            DPRO - Controls whether or not the ANSYS input window displays a dynamic prompt. The
                   dynamic prompt shows the correct command syntax for the
                   command, as you are entering it.

            UNDO - Controls whether or not the session editor includes nonessential commands or
                   comments in the file it creates. You can use this option to
                   include comments and other materials in the session editor
                   file.

            LEGE - Controls whether or not the multi-legend is activated when you start the GUI.
                   The multi-legend enables you to specify the location of your
                   legend items in each of the five graphics windows. You can
                   place this option in your start.ans file and have the GUI
                   start with the legend items in a pre-specified location.

            PBAK - Controls whether or not the background shading is activated when you start the
                   GUI. You can place this option in your start.ans file.

            ZPIC - Controls the sorting order for entities that are coincident (directly in front
                   of or behind each other) to a picked spot on your model.
                   When you pick a spot on your model that could indicate two
                   or more entities, a message warns you of this condition, and
                   a list of the coincident entities can be generated. The
                   VALUE term (below) will determine the sort order.

            HPOP - Controls the prioritization of your GUI windows when the contents are ported to
                   a plot or print file (/UI,COPY,SAVE). OpenGL (3D) graphics
                   devices require that the ANSYS Graphics Screen contents be
                   set in front of all overlying windows in order to port them
                   to a printer or a file. This operation can sometimes
                   conflict with /NOERASE settings. See the VALUE term (below)
                   to determine the available control options.

        value
            Values controlling behavior if Label = BORD:

            1 - PAN, controls dynamic translations.

            2 - ZOOM, controls zoom, and dynamic rotation about the view vector.

            3 - ROTATE, controls dynamic rotation about the screen X and Y axes.
        """
        command = "/UIS,%s,%s" % (str(label), str(value))
        return self.run(command, **kwargs)

    def tbtemp(self, temp="", kmod="", **kwargs):
        """APDL Command: TBTEMP

        Defines a temperature for a material data table.

        Parameters
        ----------
        temp
            Temperature value (defaults to 0.0 if KMOD is blank).

        kmod
            If blank, TEMP defines a new temperature. (Issue TBLIST to list
            temperatures and data.)

        Notes
        -----
        The TBTEMP command defines a temperature to be associated with the data
        on subsequent TBPT or TBDATA commands.

        The defined temperature remains active until the next TBTEMP command is
        issued.

        Data values must be defined with the temperatures in ascending order.

        This command is also valid in SOLUTION.
        """
        command = "TBTEMP,%s,%s" % (str(temp), str(kmod))
        return self.run(command, **kwargs)

    def spower(self, inletport="", outletport="", **kwargs):
        """APDL Command: SPOWER

        Calculates sound power parameters.

        Parameters
        ----------
        inletport
            Inlet source port number.

        outletport
            Outlet port number.

        Notes
        -----
        The SPOWER command calculates the input sound power level, reflected
        sound power level, return loss, and absorption coefficient for an inlet
        port.

        If a matched outlet port is defined, the command also calculates the
        transmission loss.

        The sound power parameters are output to the file
        jobname%ARG1%%ARG2%.anp (where n = 1 or 2).

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "SPOWER,%s,%s" % (str(inletport), str(outletport))
        return self.run(command, **kwargs)

    def edopt(self, option="", value="", **kwargs):
        """APDL Command: EDOPT

        Specifies the type of output for an explicit dynamics analysis.

        Parameters
        ----------
        option
            Label identifying the option to be performed:

            ADD - Define an output type specification (default).

            DELE - Delete an output type specification.

            LIST - List the current output type specification.

        --
            Unused field.

        value
            Label identifying the type of output that the LS-DYNA solver should
            produce:

            ANSYS - Write results files for the ANSYS postprocessors (default). The files that will
                    be written are Jobname.RST and Jobname.HIS (see "Notes"
                    below).

            LSDYNA - Write results files for the LS-DYNA postprocessor (LS-POST). The files that
                     will be written are D3PLOT, and files specified by EDOUT
                     and EDHIST (see "Notes" below).

            BOTH - Write results files for both ANSYS and LS-DYNA postprocessors.

        Notes
        -----
        By default, LS-DYNA will write the ANSYS results file Jobname.RST (see
        the EDRST command.)  If Jobname.HIS is desired, you must also issue
        EDHIST.

        Value = LSDYNA or BOTH will cause LS-DYNA to write results files for
        the LS-POST postprocessor. The D3PLOT file is always written for these
        two options. If other LS-POST files are desired, you must issue the
        appropriate EDHIST and EDOUT commands.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDOPT,%s,%s" % (str(option), str(value))
        return self.run(command, **kwargs)

    def selm(self, **kwargs):
        """APDL Command: SELM

        Specifies "Superelements" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "SELM," % ()
        return self.run(command, **kwargs)

    def spread(self, value="", **kwargs):
        """APDL Command: SPREAD

        Turns on a dashed tolerance curve for the subsequent curve plots.

        Parameters
        ----------
        value
            Amount of tolerance.  For example, 0.1 is ± 10%.
        """
        command = "SPREAD,%s" % (str(value))
        return self.run(command, **kwargs)

    def vlen(self, nrow="", ninc="", **kwargs):
        """APDL Command: *VLEN

        Specifies the number of rows to be used in array parameter operations.

        Parameters
        ----------
        nrow
            Number of rows to be used with the *VXX or *MXX operations.
            Defaults to the number of rows needed to fill the result array.

        ninc
            Perform the operation on every NINC row (defaults to 1).

        Notes
        -----
        Specifies the number of rows to be used in array parameter operations.
        The size of the submatrix used is determined from the upper left
        starting array element (defined on the operation command) to the lower
        right array element (defined by the number of rows on this command and
        the number of columns on the *VCOL command).  NINC allows skipping row
        operations for some operation commands.  Skipped rows are included in
        the row count.  The starting row number must be defined on the
        operation command for each parameter read and for the result written.

        The default NROW is calculated from the maximum number of rows of the
        result array (the *DIM row dimension) minus the starting location + 1.
        For example, *DIM,R,,10 and a starting location of R(7) gives a default
        of 4 loops (filling R(7), R(8), R(9), and R(10)).  Repeat operations
        automatically terminate at the last row of the result array.  Existing
        values in the rows and columns of the results matrix remain unchanged
        where not overwritten by the requested input or operation values.

        The stride (NINC) allows operations to be performed at regular
        intervals.  It has no effect on the total number of row operations.
        Skipped operations retain the previous result.  For example, *DIM,R,,6,
        with a starting location of R(1), NROW = 10, and NINC = 2 calculates
        values for locations R(1), R(3), and R(5) and retains values for
        locations R(2), R(4), and R(6).  A more general skip control may be
        done by masking [*VMASK].  The row control settings are reset to the
        defaults after each *VXX or *MXX operation.  Use *VSTAT to list
        settings.

        This command is valid in any processor.
        """
        command = "*VLEN,%s,%s" % (str(nrow), str(ninc))
        return self.run(command, **kwargs)

    def cgloc(self, xloc="", yloc="", zloc="", **kwargs):
        """APDL Command: CGLOC

        Specifies the origin location of the acceleration coordinate system.

        Parameters
        ----------
        xloc, yloc, zloc
            Global Cartesian X, Y, and Z coordinates of the acceleration
            coordinate system origin.

        Notes
        -----
        Specifies the origin location of the acceleration coordinate system
        with respect to the global Cartesian system.  The axes of this
        acceleration coordinate system are parallel to the global Cartesian
        axes.

        A structure may be rotating about the global Cartesian origin [OMEGA,
        DOMEGA], which may in turn be rotating about another point (the origin
        of the acceleration coordinate system), introducing Coriolis effects.
        The location of this point (relative to the global Cartesian origin) is
        specified with this CGLOC command.  For example, if Y is vertical and
        the global system origin is at the surface of the earth while the
        acceleration system origin is at the center of the earth, YLOC should
        be -4000 miles (or equivalent) if the rotational effects of the earth
        are to be included.  The rotational velocity of the global Cartesian
        system about this point is specified with the CGOMGA command, and the
        rotational acceleration is specified with the DCGOMG command.

        The rotational velocities and accelerations are mainly intended to
        include mass effects in a static (ANTYPE,STATIC) analysis.  If used in
        dynamic analyses, no coupling exists between the user input terms and
        the time history response of the structure.  See Acceleration Effect in
        the Mechanical APDL Theory Reference for details.  Related commands are
        ACEL, CGOMGA, DCGOMG, DOMEGA, and OMEGA.

        See Analysis Tools in the Mechanical APDL Theory Reference for more
        information.

        This command is also valid in PREP7.
        """
        command = "CGLOC,%s,%s,%s" % (str(xloc), str(yloc), str(zloc))
        return self.run(command, **kwargs)

    def dcgomg(self, dcgox="", dcgoy="", dcgoz="", **kwargs):
        """APDL Command: DCGOMG

        Specifies the rotational acceleration of the global origin.

        Parameters
        ----------
        dcgox, dcgoy, dcgoz
            Rotational acceleration of the global origin about the acceleration
            system X, Y, and Z axes.

        Notes
        -----
        Specifies the rotational acceleration of the global origin about each
        of the acceleration coordinate system axes [CGLOC].  Rotational
        accelerations may be defined in analysis types ANTYPE,STATIC, HARMIC
        (full or mode-superposition), TRANS (full or mode-superposition), and
        SUBSTR. See Acceleration Effect in the Mechanical APDL Theory Reference
        for details.  Units are radians/time2.

        The DCGOMG command supports tabular boundary conditions (%TABNAME_X%,
        %TABNAME_Y%, and %TABNAME_Z%) for DCGOMG_X, DCGOMG_Y, and DCGOMG_Z
        input values (*DIM) for full transient and harmonic analyses.

         Related commands are ACEL, CGLOC, CGOMGA, DOMEGA, and OMEGA.

        See Analysis Tools in the Mechanical APDL Theory Reference for more
        information.

        This command is also valid in PREP7.
        """
        command = "DCGOMG,%s,%s,%s" % (str(dcgox), str(dcgoy), str(dcgoz))
        return self.run(command, **kwargs)

    def psdcom(self, signif="", comode="", forcetype="", **kwargs):
        """APDL Command: PSDCOM

        Specifies the power spectral density mode combination method.

        Parameters
        ----------
        signif
            Combine only those modes whose significance level exceeds theSIGNIF
            threshold.  For PSD response (SPOPT,PSD), the significance level is
            defined as the modal covariance matrix term, divided by the maximum
            modal covariance matrix term.  Any term whose significance level is
            less than SIGNIF is considered insignificant and is not contributed
            to the mode combinations.  The higher the SIGNIF threshold, the
            fewer the number of terms used. SIGNIF defaults to 0.0001.  If
            SIGNIF is specified as 0.0, it is taken as 0.0.

        comode
            First COMODE number of modes to be actually combined.  COMODE must
            always be less than or equal to NMODE (input quantity NMODE on the
            SPOPT command).  COMODE defaults to NMODE.  COMODE performs a
            second level of control for the first sequential COMODE number of
            modes to be combined.  It uses the significance level threshold
            indicated by SIGNIF and operates only on the significant modes.

        forcetype
            Label identifying the forces to be combined:

            STATIC - Combine the modal static forces (default).

            TOTAL - Combine the modal static plus inertial forces.

        Notes
        -----
        This command is also valid for PREP7.   This command is valid only for
        SPOPT,PSD.

        PSDCOM is not allowed in ANSYS Professional.
        """
        command = "PSDCOM,%s,%s,%s" % (str(signif), str(comode), str(forcetype))
        return self.run(command, **kwargs)

    def timp(self, elem="", chgbnd="", implevel="", **kwargs):
        """APDL Command: TIMP

        Improves the quality of tetrahedral elements that are not associated
        with a volume.

        Parameters
        ----------
        elem
            Identifies the tetrahedral elements to be improved.  Valid values
            are ALL and P.  If ELEM = ALL (default), improve all selected
            tetrahedral elements.  If ELEM = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).

        chgbnd
            Specifies whether to allow boundary modification.  Boundary
            modification includes such things as changes in the connectivity of
            the element faces on the boundary and the addition of boundary
            nodes.  (Also see the Notes section below for important usage
            information for CHGBND.)

            0 - Do not allow boundary modification.

            1 - Allow boundary modification (default).

        implevel
            Identifies the level of improvement to be performed on the
            elements.  (Improvement occurs primarily through the use of face
            swapping and node smoothing techniques.)

            0 - Perform the least amount of swapping/smoothing.

            1 - Perform an intermediate amount of swapping/smoothing.

            2 - Perform the greatest amount of swapping/smoothing.

            3 - Perform the greatest amount of swapping/smoothing, plus additional improvement
                techniques (default).

        Notes
        -----
        The TIMP command enables you to improve a given tetrahedral mesh by
        reducing the number of poorly-shaped tetrahedral elements (in
        particular, the number of sliver tetrahedral elements)--as well as the
        overall number of elements--in the mesh.  It also improves the overall
        quality of the mesh.

        TIMP is particularly useful for an imported tetrahedral mesh for which
        no geometry information is attached.

        Regardless of the value of the CHGBND argument, boundary mid-nodes can
        be moved.

        When loads or constraints have been placed on boundary nodes or mid-
        nodes, and boundary mid-nodes are later moved, ANSYS issues a warning
        message to let you know that it will not update the loads or
        constraints.

        No boundary modification is performed if shell or beam elements are
        present in the mesh, even when CHGBND = 1.
        """
        command = "TIMP,%s,%s,%s" % (str(elem), str(chgbnd), str(implevel))
        return self.run(command, **kwargs)

    def perturb(self, type="", matkey="", contkey="", loadcontrol="",
                **kwargs):
        """APDL Command: PERTURB

        Sets linear perturbation analysis options.

        Parameters
        ----------
        type
            Type of linear perturbation analysis to be performed:

            STATIC - Perform a linear perturbation static analysis.

            MODAL - Perform a linear perturbation modal analysis.

            BUCKLE - Perform a linear perturbation eigenvalue buckling analysis.

            HARMONIC - Perform a linear perturbation full harmonic analysis.

            SUBSTR - Perform a linear perturbation substructure generation pass.

            OFF - Do not perform a linear perturbation analysis (default).

        matkey
            Key for specifying how the linear perturbation analysis uses
            material properties, valid for all structural elements except
            contact elements. For more information, see Linear Perturbation
            Analysis in the Mechanical APDL Theory Reference.

            AUTO - The program selects the material properties for the linear perturbation
                   analysis automatically (default). The materials are handled
                   in the following way:

            For pure linear elastic materials used in the base analysis, the same properties are used in the linear perturbation analysis. - For hyperelastic materials used in the base analysis, the material properties
                              are assumed to be linear elastic in the linear
                              perturbation analysis. The material property data
                              (or material Jacobian) is obtained based on the
                              tangent of the hyperelastic material's
                              constitutive law at the point where restart
                              occurs.

            For any nonlinear materials other than hyperelastic materials used in the base analysis, the material properties are assumed to be linear elastic in the linear perturbation analysis. The material data is the same as the linear portion of the nonlinear materials (that is, the parts defined by MP commands). - For COMBIN39, the stiffness is that of the first segment of the force-
                              deflection curve.

            TANGENT - Use the tangent (material Jacobian) on the material constitutive curve as the
                      material property. The material property remains linear
                      in the linear perturbation analysis and is obtained at
                      the point of the base analysis where restart occurs. The
                      materials are handled in the following way:

            For pure linear elastic materials used in the base analysis, the same properties are used in the linear perturbation analysis. Because the material constitutive curve is linear, the tangent is the same as the base analysis.  - For hyperelastic materials used in the base analysis, the program uses the same
                              tangent as that used for MatKey = AUTO, and the
                              results are therefore identical.

            For any nonlinear materials other than hyperelastic materials used in the base analysis, the material properties are obtained via the material tangent on the material constitutive curve at the restart point of the base analysis.  - The materials and properties typically differ from Matkey = AUTO, but it is
                              possible the results could be identical or very
                              similar if a.) the material is elasto-plastic
                              rate-independent and is unloading (or has neutral
                              loading) at the restart point, or b.) the
                              material is rate-dependent, depending on the
                              material properties and loading conditions.

            For COMBIN39, the stiffness is equal to the tangent of the current segment of the force-deflection curve. - In a modal restart solution that follows a linear perturbation modal analysis,
                              the TANGENT option is overridden by the AUTO
                              option and linear material properties are used
                              for stress calculations in the modal restart. See
                              the discussion in the Notes for more information.

        contkey
            Key that controls contact status for the linear perturbation
            analysis. This key controls all contact elements (TARGE169,
            TARGE170, and CONTA171 through CONTA178) globally for all contact
            pairs. Alternatively, contact status can be controlled locally per
            contact pair by using the CNKMOD command. Note that the contact
            status from the base analysis solution is always adjusted by the
            local contact controls specified by CNKMOD first and then modified
            by the global sticking or bonded control (ContKey = STICKING or
            BONDED). The tables in the Notes section show how the contact
            status is adjusted by CNKMOD and/or the ContKey setting.

            CURRENT - Use the current contact status from the restart snapshot (default). If the
                      previous run is nonlinear, then the nonlinear contact
                      status at the point of restart is frozen and used
                      throughout the linear perturbation analysis.

            STICKING - For frictional contact pairs (MU > 0), use sticking contact (e.g., MU*KN for
                       tangential contact stiffness)  everywhere the contact
                       state is closed (i.e., status is sticking or sliding).
                       This option only applies to contact pairs that are in
                       contact and have a frictional coefficient MU greater
                       than zero. Contact pairs without friction (MU = 0) and
                       in a sliding state remain free to slide in the linear
                       perturbation analysis.

            BONDED - Any contact pairs that are in the closed (sticking or sliding) state are moved
                     to bonded (for example, KN for both normal and tangential
                     contact stiffness). Contact pairs that have a status of
                     far-field or near-field remain open.

        loadcontrol
            Key that controls how the load vector of {Fperturbed} is
            calculated. This control is provided for convenience of load
            generation for linear perturbation analysis. In general, a new set
            of loads is required for a linear perturbation analysis. This key
            controls all mechanical loads; it does not affect non-mechanical
            loads. Non-mechanical loads (including thermal loads) are always
            kept (i.e., not deleted).

            ALLKEEP - Keep all the boundary conditions (loads and constraints) from the end of the
                      load step of the current restart point. This option is
                      convenient for further load application and is useful for
                      a linear perturbation analysis restarted from a previous
                      linear analysis. For this option, {Fend} is the total
                      load vector at the end of the load step at the restart
                      point.

            INERKEEP - Delete all loads and constraints from the restart step, except for displacement
                       constraints and inertia loads (default). All
                       displacement constraints and inertia loads are kept for
                       convenience when performing the linear perturbation
                       analysis. Note that nonzero and tabular displacement
                       constraints can be considered as external loads;
                       however, they are not deleted when using this option.

            PARKEEP - Delete all loads and constraints from the restart step, except for displacement
                      constraints. All displacement constraints are kept for
                      convenience when performing the linear perturbation
                      analysis. Note that nonzero and tabular displacement
                      constraints can be considered as external loads; however,
                      they are not deleted when using this option.

            DZEROKEEP - Behaves the same as the PARKEEP option, except that all nonzero displacement
                        constraints are set to zero upon the onset of linear
                        perturbation.

            NOKEEP - Delete all the loads and constraints, including all displacement constraints.
                     For this option, {Fend} is zero unless non-mechanical
                     loads (e.g., thermal loads) are present.

        Notes
        -----
        This command controls options relating to linear perturbation analyses.
        It must be issued in the first phase of a linear perturbation analysis.

        This command is also valid in PREP7.
        """
        command = "PERTURB,%s,%s,%s,%s" % (str(type), str(matkey), str(contkey), str(loadcontrol))
        return self.run(command, **kwargs)

    def v2dopt(self, geom="", ndiv="", hidopt="", nzone="", **kwargs):
        """APDL Command: V2DOPT

        Specifies 2-D/axisymmetric view factor calculation options.

        Parameters
        ----------
        geom
            Choice of geometry:

            0 - Planar (default).

            1 - Axisymmetric

        ndiv
             Number of divisions for axisymmetric geometry (that is, the number
            of circumferential segments). Default is 20. Maximum is 90.

        hidopt
            Viewing option:

            0 - Hidden (default).

            1 - Non-hidden

        nzone
            Number of zones (that is, the number of rays emanating from a
            surface) for view factor calculation. Default is 200. Maximum is
            1000.
        """
        command = "V2DOPT,%s,%s,%s,%s" % (str(geom), str(ndiv), str(hidopt), str(nzone))
        return self.run(command, **kwargs)

    def cycle(self, **kwargs):
        """APDL Command: *CYCLE

        Bypasses commands within a do-loop.

        Notes
        -----
        Bypasses all commands between this command and the  *ENDDO command
        within a do-loop.  The next loop (if applicable) is initiated.  The
        cycle option may also be conditionally executed [Use the *IF].  The
        *CYCLE command must appear on the same file as the *DO command.

        This command is valid in any processor.
        """
        command = "*CYCLE," % ()
        return self.run(command, **kwargs)

    def modmsh(self, lab="", **kwargs):
        """APDL Command: MODMSH

        Controls the relationship of the solid model and the FE model.

        Parameters
        ----------
        lab
            Relationship key:

            STAT - Gives status of command (default).   This applies only to the CHECK option  (no
                   status is provided for the DETACH option).

            NOCHECK - Deactivates the checking of the solid model and the finite element model.
                      Allows elements and nodes generated with the mesh
                      commands to be modified directly (EMODIF, NMODIF, EDELE,
                      NDELE, etc.). Also deactivates solid model hierarchical
                      checking so that areas attached to volumes may be deleted
                      etc.

            CHECK - Reactivates future checking of the solid model.

            DETACH - Releases all associativity between the current solid model and finite element
                     model.  ANSYS deletes any element attributes that were
                     assigned to the affected solid model entities through
                     default attributes (that is, through the TYPE, REAL, MAT,
                     SECNUM, and ESYS command settings and a subsequent meshing
                     operation). However, attributes that were assigned
                     directly to the solid model entities (via the KATT, LATT,
                     AATT, and VATT commands) are not deleted.

        Notes
        -----
        Affects the relationship of the solid model (keypoints, lines, areas,
        volumes) and the finite element model (nodes, elements, and boundary
        conditions).

        Specify Lab = NOCHECK carefully. By deactivating checking, the solid
        model database can be corrupted by subsequent operations.

        After specifying Lab = DETACH, it is no longer possible to select or
        define finite element model items in terms of the detached solid model
        or to clear the mesh.
        """
        command = "MODMSH,%s" % (str(lab))
        return self.run(command, **kwargs)

    def smooth(self, vect1="", vect2="", datap="", fitpt="", vect3="",
               vect4="", disp="", **kwargs):
        """APDL Command: SMOOTH

        Allows smoothing of noisy data and provides a graphical representation
        of the data.

        Parameters
        ----------
        vect1
            Name of the first vector that contains the noisy data set (i.e.,
            independent variable). You must create and fill this vector before
            issuing SMOOTH.

        vect2
            Name of the second vector that contains the dependent set of data.
            Must be the same length as the first vector. You must create and
            fill this vector before issuing SMOOTH.

        datap
            Number of data points to be fitted, starting from the beginning of
            the vector. If left blank, the entire vector will be fitted. The
            maximum number of data points is 100,000 (or greater, depending on
            the memory of the computer).

        fitpt
            Order of the fitting curve that will be used as a smooth
            representation of the data. This number should be less than or
            equal to the number of the data points. Default (blank) is one-half
            the number of data points. Maximum number of smoothed data fitting
            order is the number of data points up to 50.  Depending on this
            number, the smoothed curve will be one of the following:

            1 - Curve is the absolute average of all of the data points.

            2 - Curve is the least square average of all of the data points.

            3 or more - Curve is a polynomial of the order (n-1), where n is the number of data fitting
                        order points.

        vect3
            Name of the vector that contains the smoothed data of the
            independent variable. This vector should have a length equal to or
            greater than the number of smoothed data points. In batch (command)
            mode, you must create this vector before issuing the SMOOTH
            command. In interactive mode, the GUI automatically creates this
            vector (if it does not exist). If you do not specify a vector name,
            the GUI will name the vector smth_ind.

        vect4
            Name of the vector that contains the smoothed data of the dependent
            variable.  This vector must be the same length as Vect3.  In batch
            (command) mode, you must create this vector before issuing the
            SMOOTH command. In interactive mode, the GUI automatically creates
            this vector (if it does not exist). If you do not specify a vector
            name, the GUI will name the vector smth_dep.

        disp
            Specifies how you want to display data. No default; you must
            specify an option.

            1 - Unsmoothed data only

            2 - Smoothed data only

            3 - Both smoothed and unsmoothed data

        Notes
        -----
        You can control the attributes of the graph using standard ANSYS
        controls (/GRID, /GTHK, /COLOR, etc.). If working interactively, these
        controls appear in this dialog box for convenience, as well as in their
        standard dialog boxes. You must always create Vect1 and Vect2 (using
        *DIM) and fill these vectors before smoothing the data. If you're
        working interactively, ANSYS automatically creates Vect3 and Vect4, but
        if you're working in batch (command) mode, you must create Vect3 and
        Vect4 (using *DIM) before issuing SMOOTH.  Vect3 and Vect4 are then
        filled automatically by ANSYS.  In addition, ANSYS creates an
        additional TABLE type array that contains the smoothed array and the
        unsmoothed data to allow for plotting later with *VPLOT.  Column 1 in
        this table corresponds to Vect1, column 2 to Vect2, and column 3 to
        Vect4.  This array is named Vect3_SMOOTH, up to a limit of 32
        characters. For example, if the array name is X1, the table name is
        X1_SMOOTH.

        This command is also valid in PREP7 and SOLUTION.
        """
        command = "SMOOTH,%s,%s,%s,%s,%s,%s,%s" % (str(vect1), str(vect2), str(datap), str(fitpt), str(vect3), str(vect4), str(disp))
        return self.run(command, **kwargs)

    def mpchg(self, mat="", elem="", **kwargs):
        """APDL Command: MPCHG

        Changes the material number attribute of an element.

        Parameters
        ----------
        mat
            Assign this material number to the element.  Material numbers are
            defined with the material property commands [MP].

        elem
            Element for material change.  If ALL, change materials for all
            selected elements [ESEL].

        Notes
        -----
        Changes the material number of the specified element.  Between load
        steps in SOLUTION, material properties cannot be changed from linear to
        nonlinear, or from one nonlinear option to another.

        If you change from one MKIN model to another MKIN model, the different
        MKIN models need to have the same number of data points. This
        requirement also applies if you change from one KINH model to another
        KINH model, or from one CHABOCHE model to another CHABOCHE model.
        """
        command = "MPCHG,%s,%s" % (str(mat), str(elem))
        return self.run(command, **kwargs)

    def sfscale(self, lab="", fact="", fact2="", **kwargs):
        """APDL Command: SFSCALE

        Scales surface loads on elements.

        Parameters
        ----------
        lab
            Valid surface load label.  If ALL, use all appropriate labels.

        fact
            Scale factor for the first surface load value.  Zero (or blank)
            defaults  to 1.0.  Use a small number for a zero scale factor.

        fact2
            Scale factor for the second surface load value.  Zero (or blank)
            defaults  to 1.0.  Use a small number for a zero scale factor.

        Notes
        -----
        Scales surface loads (pressure, convection, etc.) in the database on
        the selected elements.  Surface loads are applied with the SF, SFE, or
        SFBEAM commands.  Issue the SFELIST command to list the surface loads.
        Solid model boundary conditions are not scaled by this command, but
        boundary conditions on the FE model are scaled.

        Note:: : Such scaled FE boundary conditions may still be overwritten by
        unscaled solid model boundary conditions if a subsequent boundary
        condition transfer occurs.

        SFSCALE does not work for tabular boundary conditions.

        This command is also valid in PREP7 and in the /MAP processor.
        """
        command = "SFSCALE,%s,%s,%s" % (str(lab), str(fact), str(fact2))
        return self.run(command, **kwargs)

    def segen(self, mode="", nsuper="", mdof="", stopstage="", **kwargs):
        """APDL Command: SEGEN

        Automatically generate superelements.

        Parameters
        ----------
        mode
            Specify action to take (must be specified as one of the following):

            AUTO - Turn on feature.

            OFF - Turn off feature.

        nsuper
            Number of superelements to create. The minimum number of
            superelements is 2, and the maximum number of superelements is 999.
            Note that the number of requested superelements may not be the same
            as the number of defined superelements (see "Notes" for more
            details).

        mdof
            Specifies whether to use the master DOF defined by the user.

            YES - Use master DOF defined by the user with the M command.

            NO - Use the master DOF defined by the automatic generation process. Be aware that
                 this option can generate a large number of master DOFs (see
                 "Notes"  for more details).

        stopstage
            Specifies when to stop the automatic superelement generation
            process.

            PREVIEW - Preview the superelements only; stop after creating the domains which will
                      become the superelements, and after creating master DOF
                      on the interfaces between each domain.

            GEN - Create (generate) the superelements.

        Notes
        -----
        This command can be used to quickly generate a set of superelements.
        Each superelement is created in a separate file (jobnameXXX.sub, where
        XXX is a positive number from 1 to 999).

        Due to the heuristics in the automatic domain decomposer, which is used
        to define the domains that will become superelements, the number of
        defined superelements may exceed the number of requested superelements.
        Use the mDof and stopStage options to determine exactly how many
        superelements will be created, the interfaces between each
        superelement, and where master DOF will be defined. With the
        /PNUM,DOMAIN command, you can graphically (visually) preview the
        elements in each superelement.  Then, if required, you can add
        additional master DOF to (or remove from) the boundaries of the
        superelements. Use the SEGEN command again with stopStage = GEN to
        actually create the superelements.

        ANSYS automatically defines master DOF at each of the following: all
        interface DOF between superelements, all DOF attached to contact
        elements (TARGE169 to CONTA177), and all DOF associated with nodes
        having a point load defined.  Note that for regular superelements, all
        interface DOFs must be defined as master DOFs for the correct solution
        to be obtained. However, for CMS superelements, some of the interface
        DOFs can be removed without a significant loss of accuracy.

        For the case when mDof = YES, you should select the preview option
        first (stopStage = PREVIEW) to verify exactly how many superelements
        will be created and where the superelement boundaries are located.  If
        more superelements will be created than were requested, you should
        define master DOF on the interface(s) between all superelements.

        This command is valid only for substructuring analyses (ANTYPE,SUBSTR).
        Use SEOPT to specify any options for all of the superelements (e.g.,
        which matrices to reduce), and possibly CMSOPT for any CMS
        substructuring analysis.  Note that the created superelements will
        follow the current /FILNAME instead of SENAME from SEOPT.  Also, only
        one load vector will be written to each .SUB file.  Multiple load steps
        are not supported with the automatic superelement generation process.

        During the actual creation of the superelements, the output is
        redirected to jobname.autoTemp.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "SEGEN,%s,%s,%s,%s" % (str(mode), str(nsuper), str(mdof), str(stopstage))
        return self.run(command, **kwargs)

    def bfcum(self, lab="", oper="", fact="", tb_ase="", **kwargs):
        """APDL Command: BFCUM

        Specifies that nodal body force loads are to be accumulated.

        Parameters
        ----------
        lab
            Valid body load label.  If ALL, use all appropriate labels.

        oper
            Accumulation key:

            REPL - Subsequent values replace the previous values (default).

            ADD - Subsequent values are added to the previous values.

            IGNO - Subsequent values are ignored.

        fact
            Scale factor for the nodal body load values.  Zero (or blank)
            defaults to 1.0.  Use a small number for a zero scale factor.  The
            scale factor is not applied to body load phase angles.

        tbase
            Used (only with Lab = TEMP) to calculate the temperature used in
            the add or replace operation (see Oper) as:

        Notes
        -----
        Allows repeated nodal body force loads to be replaced, added, or
        ignored.  Nodal body loads are applied with the BF command.  Issue the
        BFLIST command to list the nodal body loads.  The operations occur when
        the next body loads are defined.  For example, issuing the BF command
        with a temperature of 250 after a previous BF command with a
        temperature of 200 causes the new value of the temperature to be 450
        with the add operation, 250 with the replace operation, or 200 with the
        ignore operation.  A scale factor is also available to multiply the
        next value before the add or replace operation.  A scale factor of 2.0
        with the previous "add" example results in a temperature of 700.  The
        scale factor is applied even if no previous values exist.  Issue
        BFCUM,STAT to show the current label, operation, and scale factors.
        Solid model boundary conditions are not affected by this command, but
        boundary conditions on the FE model are affected.

        Note:: : FE boundary conditions may still be overwritten by existing
        solid model boundary conditions if a subsequent boundary condition
        transfer occurs.

        BFCUM does not work for tabular boundary conditions.

        This command is also valid in PREP7.
        """
        command = "BFCUM,%s,%s,%s,%s" % (str(lab), str(oper), str(fact), str(tb_ase))
        return self.run(command, **kwargs)

    def andscl(self, nfram="", delay="", ncycl="", **kwargs):
        """APDL Command: ANDSCL

        Produces an animated sequence of a deformed shape.

        Parameters
        ----------
        nfram
            Number of frames captured (defaults to 5).

        delay
            Time delay during animation (defaults to 0.1 seconds).

        ncycl
            Number of animation cycles (defaults to 5).  Available in non-UI
            mode only.

        Notes
        -----
        ANDSCL involves an ANSYS macro which produces an animation of
        displacement of the last plot action command (for example, PLDISP).
        This command operates only on graphic display platforms supporting the
        /SEG command.  After executing ANDSCL, you can replay the animated
        sequence by issuing the ANIM command.

        The command functions only in the postprocessor.
        """
        command = "ANDSCL,%s,%s,%s" % (str(nfram), str(delay), str(ncycl))
        return self.run(command, **kwargs)

    def toper(self, parr="", par1="", oper="", par2="", fact1="", fact2="",
              con1="", **kwargs):
        """APDL Command: *TOPER

        Operates on table parameters.

        Parameters
        ----------
        parr
            Name of the resulting table parameter. The command will create a
            table array parameter with this name.  Any existing parameter with
            this name will be overwritten.

        par1
            Name of the first table parameter.

        oper
            The operation to be performed: ADD.  The operation is:  ParR(i,j,k)
            =   FACT1*Par1(i,j,k) + FACT2 *Par2(i,j,k) +CON1

        par2
            Name of the second table parameter.

        fact1
            The first table parameter multiplying constant. Defaults to 1.

        fact2
            The second table parameter multiplying constant.  Defaults to 1.

        con1
            The constant increment for offset.  Defaults to 0.

        Notes
        -----
        *TOPER operates on table parameters according to: ParR(i,j,k) =
        FACT1*Par1(i,j,k) + FACT2 *Par2(i,j,k) +CON1

        Par1 and Par2 must have the same dimensions and the same variable names
        corresponding to those dimensions. Par1 and Par2 must also have
        identical index values for rows, columns, etc.

        If you want a local coordinate system for the resulting array, you must
        dimension it as such using the *DIM command before issuing *TOPER.

        This command is valid in any processor.
        """
        command = "*TOPER,%s,%s,%s,%s,%s,%s,%s" % (str(parr), str(par1), str(oper), str(par2), str(fact1), str(fact2), str(con1))
        return self.run(command, **kwargs)

    def comp(self, matrix="", algorithm="", threshold="", **kwargs):
        """APDL Command: *COMP

        Compresses the columns of a matrix using a specified algorithm.

        Parameters
        ----------
        matrix
            Name of the matrix to compress.

        algorithm
            Algorithm to use:

            Singular value decomposition algorithm (default). - Modified Gram-Schmidt algorithm.

        threshold
            Numerical threshold value used to manage the compression. Default
            value for SVD is 1E-7; default value for MGS is 1E-14.

        Notes
        -----
        The algorithms available through this command are only applicable to
        dense matrices that were created using the *DMAT command.

        Columns which are linearly dependent on others are removed, leaving the
        independent or basis vectors. The matrix is resized according to the
        new size determined by the algorithm.
        """
        command = "*COMP,%s,%s,%s" % (str(matrix), str(algorithm), str(threshold))
        return self.run(command, **kwargs)

    def mpread(self, fname="", ext="", **kwargs):
        """APDL Command: MPREAD

        Reads a file containing material properties.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including
            directory). If you do not specify the LIB option, the default
            directory is the current working directory. If you specify the LIB
            option, the default is the following search path: the current
            working directory, the user's home directory, MPLIB_DIR (as
            specified by the /MPLIB,READ,PATH command) and /ansys_dir/matlib
            (as defined by installation). If you use the default for your
            directory, you can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        lib
            Reads material library files previously written with the MPWRITE
            command.  (See the description of the LIB option for the MPWRITE
            command.)  The only allowed value for LIB is LIB.

        Notes
        -----
        Material properties written to a file without the LIB option do not
        support nonlinear properties.  Also, properties written to a file
        without the LIB option are restored in the same material number as
        originally defined.  To avoid errors, use MPREAD with the LIB option
        only when reading files written using MPWRITE with the LIB option.

        If you omit the LIB option for MPREAD, this command supports only
        linear properties.

        Material numbers are hardcoded.  If you write a material file without
        specifying the LIB option, then read that file in using the MPREAD
        command with the LIB option, the ANSYS program will not write the file
        to a new material number.  Instead, it will write the file to the "old"
        material number (the number specified on the MPWRITE command that
        created the file.)

        This command is also valid in SOLUTION.
        """
        command = "MPREAD,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def psf(self, item="", comp="", key="", kshell="", color="", **kwargs):
        """APDL Command: /PSF

        Shows surface load symbols on model displays.

        Parameters
        ----------
        item, comp
            Labels identifying the surface load to be shown; see
            Table 227: /PSF - Valid Item and Component Labels.

        key
            Key to turn surface load symbols on or off:

            0 - Off (default).

            1 - On, shown as face outlines.  Line surface loads (SFL) on solid model plots are
                shown as arrows.

            2 - On, shown as arrows.

            3 - On, shown as color filled surfaces.  Line and area surface loads (SFL and SFA)
                on solid model plots are shown as arrows.

        kshell
            Visibility key for shell elements.

            0 - Off (default),  surface load symbols are displayed only on visible load faces.

            1 - On, surface load symbols are displayed even if load face is not visible.

        color
            Visibility key for contour legend.

            ON - The symbols (arrows or face outlines) will show up in color with the legend
                 showing the corresponding color labels (default).

            OFF - The contour legend will not be displayed. The symbols (arrows or face outlines)
                  will show up in grey. The size of the arrows will be
                  proportional to the applied load.

        Notes
        -----
        The /PSF command determines whether and how to show surface loads on
        subsequent model displays.

        If surface loads are applied to solid model entities, only solid model
        plots show the load symbols; node and element plots do not show them
        unless the loads are transferred (SFTRAN or SBCTRAN).  Similarly, solid
        model plots do not show the load symbols if surface loads are applied
        to nodes and elements.  For node and element plots of shell element
        models, the surface load symbols are shown only if the load face is
        visible from the current viewing direction.

        The effects of the /PSF command are not cumulative (that is, the
        command does not modify an existing setting from a previously issued
        /PSF command).  Only the setting specified via the most recent /PSF
        command applies.

        If you issue a postprocessing (POST1) plot command that produces result
        contours (such as PLNSOL), the /PSF command has no effect. This
        behavior prevents conflicting contours in the graphics window.

        When using the radiosity method (Item = RDSF and Comp = ENCL) with Key
        = 2, the radiation arrows point outward from any element face. When
        using SURF154 with KEYOPT(2) = 1, set the Item to PRES and leave the
        Component Label blank.

        /PSF,STAT displays current /PSF settings, and /PSF,DEFA resets them
        back to default.

        Other useful commands are /PNUM,SVAL,1 to show the values of the
        surface loads, /VSCALE to change arrow lengths, and /PBC and /PBF to
        activate other load symbols.

        For beam elements, only the colors representing shear (GREEN) and
        normal (RED) pressures are displayed for the arrows. The color of these
        arrows does not correspond to the magnitudes in the contour legend. The
        length of these arrows does, however, correlate to the relative
        magnitude of the pressures.

        For elements SURF159, SOLID272, SOLID273, PIPE288 and PIPE289, the /PSF
        command is not available when displaying elements with shapes
        determined from the real constants or section definition (/ESHAPE). For
        PIPE288 and PIPE289, only external loads applied via the SFBEAM command
        are displayed.

        This command is valid in any processor.

        Table: 227:: : /PSF - Valid Item and Component Labels

        Pressure loads apply to the element coordinate system (KEYOPT(2) = 0).
        Adjust appropriately for a local coordinate system (KEYOPT(2) = 1). See
        Figure: 153.2:: Pressures in the Element Reference.
        """
        command = "/PSF,%s,%s,%s,%s,%s" % (str(item), str(comp), str(key), str(kshell), str(color))
        return self.run(command, **kwargs)

    def lines(self, n="", **kwargs):
        """APDL Command: LINES

        Specifies the length of a printed page.

        Parameters
        ----------
        n
            Number of lines per page (defaults to 20).  (Minimum allowed = 11).

        Notes
        -----
        Specifies the length of a printed page (for use in reports, etc.).
        """
        command = "LINES,%s" % (str(n))
        return self.run(command, **kwargs)

    def amesh(self, na1="", na2="", ninc="", **kwargs):
        """APDL Command: AMESH

        Generates nodes and area elements within areas.

        Parameters
        ----------
        na1, na2, ninc
            Mesh areas from NA1 to NA2 (defaults to NA1) in steps of NINC
            (defaults to 1).  If NA1 = ALL, NA2 and NINC are ignored and all
            selected areas [ASEL] are meshed.  If NA1 = P, graphical picking is
            enabled and all remaining arguments are ignored (valid only in the
            GUI).  A component name may also be substituted for NA1 (NA2 and
            NINC are ignored).

        Notes
        -----
        Any undefined nodes required for the generated elements are created and
        assigned the lowest available numbers.

        This command is also valid for rezoning.
        """
        command = "AMESH,%s,%s,%s" % (str(na1), str(na2), str(ninc))
        return self.run(command, **kwargs)

    def lcase(self, lcno="", **kwargs):
        """APDL Command: LCASE

        Reads a load case into the database.

        Parameters
        ----------
        lcno
            Load case pointer number [LCDEF,STAT].  Defaults to 1.

        Notes
        -----
        Reads a load case into the database.  Load cases are created as
        described on the LCDEF or LCWRITE commands.  The results portion of the
        database and the applied forces and displacements are cleared before
        reading the data in.  Absolute values [LCABS] and scale factors
        [LCFACT] can be applied during the read operation.
        """
        command = "LCASE,%s" % (str(lcno))
        return self.run(command, **kwargs)

    def octype(self, datatype="", name="", **kwargs):
        """APDL Command: OCTYPE

        Specifies the type of ocean load data to follow.

        Parameters
        ----------
        datatype
            The type of ocean data to be input following this command:

            BASIC - The basic ocean load, required for any ocean loading.

            CURR - An optional drift current.

            WAVE - An optional ocean wave state.

        name
            An eight-character name for the ocean load. An ocean name can
            consist of letters and numbers, but cannot contain punctuation,
            special characters, or spaces.

        Notes
        -----
        The OCTYPE command specifies the type of ocean load data to follow
        (basic, current, or wave). Issue this command before defining your
        ocean load data (OCDATA and OCTABLE).

        Ocean loading applies only to current-technology pipe (PIPE288 and
        PIPE289), surface (SURF154), link (LINK180) and beam (BEAM188 and
        BEAM189) elements.

        An ocean current or wave is accessible repeatedly. For example, it is
        not necessary to input an identical current table again just because
        the drag coefficients of the basic input table have changed.

        The following example shows how you can use the basic (DataType =
        BASIC), current (DataType = CURR), and wave (DataType = WAVE) ocean
        data types within the context of a simple input file fragment:
        """
        command = "OCTYPE,%s,%s" % (str(datatype), str(name))
        return self.run(command, **kwargs)

    def bf(self, node="", lab="", val1="", val2="", val3="", val4="", val5="",
           val6="", **kwargs):
        """APDL Command: BF

        Defines a nodal body force load.

        Parameters
        ----------
        node
            Node to which body load applies.  If Node = ALL, apply to all
            selected nodes [NSEL].  A component name may also be substituted
            for Node.

        lab
            Valid body load label. Load labels are listed under "Body Loads" in
            the input table for each element type in the Element Reference.

        val1, val2, val3, val4, val5, val6
            Value associated with the Lab item or table name reference for
            tabular boundary conditions. To specify a table, enclose the table
            name in percent signs (%) (e.g., BF,Node,TEMP,%tabname%). Use the
            *DIM command to define a table. Use only VAL1 for TEMP, FLUE, HGEN,
            DGEN, MVDI, CHRGD. If Lab = CHRGD for acoustics, VAL1 is the static
            pressure for a non-uniform acoustic medium calculation.

            VAL1 - Mass source with units kg/(m3s) in a harmonic analysis, or mass source rate
                   with units kg/( m3s2) in a transient analysis

            VAL2 - Phase angle in degrees

            VAL3 - Not used

            VAL4 - Not used

            VAL5 - Not used

            VAL6 - Not used

        Notes
        -----
        Defines a nodal body force load (such as temperature in a structural
        analysis, heat generation rate in a thermal analysis, etc.). Nodal body
        loads default to the BFUNIF values, if they were previously specified.

        Table names are valid for Lab value (VALn) inputs in these cases only:

        VAL = %tabname% for temperatures (TEMP), diffusing substance generation
        rates (DGEN), heat generation rates (HGEN), and nodal body force
        densities (FORC).

        VAL1 = %tabname1%, VAL2 = %tabname2%, VAL3 = %tabname3%, VAL4 =
        %tabname4%, VAL5 = %tabname5%, and VAL6 = %tabname6% for velocities or
        accelerations (VELO).

        VAL1 = %tabname1% and VAL2 = %tabname2% for mass sources or mass source
        rates (MASS).

        The heat generation rate loads specified with the BF command are
        multiplied by the weighted nodal volume of each element adjacent to
        that node. This yields the total heat generation at that node.

        Graphical picking is available only via the listed menu paths.

        Body load labels VELO and MASS cannot be accessed from a menu.

        This command is also valid in PREP7.
        """
        command = "BF,%s,%s,%s,%s,%s,%s,%s,%s" % (str(node), str(lab), str(val1), str(val2), str(val3), str(val4), str(val5), str(val6))
        return self.run(command, **kwargs)

    def mfiter(self, maxiter="", miniter="", target="", **kwargs):
        """APDL Command: MFITER

        Sets the number of stagger iterations for an ANSYS Multi-field solver
        analysis.

        Parameters
        ----------
        maxiter
            Maximum number of iterations. Defaults to 10.

        miniter
            Minimum number of iterations. Defaults to 1.

        target
            Target number of iterations. Defaults to 5.

        Notes
        -----
        The number of stagger iterations applies to each time step in an ANSYS
        Multi-field solver analysis. MINITER and TARGET are valid only when
        multi-field auto time stepping is on (MFDTIME).

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFITER,%s,%s,%s" % (str(maxiter), str(miniter), str(target))
        return self.run(command, **kwargs)

    def bste(self, alpha="", **kwargs):
        """APDL Command: BSTE

        Specifies a thermal expansion coefficient for a nonlinear general beam
        section.

        Parameters
        ----------
        alpha
            Coefficient of thermal expansion for the cross section.

        Notes
        -----
        The BSTE command, one of several nonlinear general beam section
        commands, specifies a thermal expansion coefficient for a beam section.
        The value specified is associated with the section most recently
        defined (via the SECTYPE command).

        Related commands are BSAX, BSM1, BSM2, BSTQ, BSS1, BSS2, and BSMD.

        For complete information, see Using Nonlinear General Beam Sections.
        """
        command = "BSTE,%s" % (str(alpha))
        return self.run(command, **kwargs)

    def aux2(self, **kwargs):
        """APDL Command: /AUX2

        Enters the binary file dumping processor.

        Notes
        -----
        Enters the binary file dumping processor (ANSYS auxiliary processor
        AUX2).  This processor is used to dump the contents of certain ANSYS
        binary files for visual examination.

        This command is valid only at the Begin Level.
        """
        command = "/AUX2," % ()
        return self.run(command, **kwargs)

    def rock(self, cgx="", cgy="", cgz="", omx="", omy="", omz="", **kwargs):
        """APDL Command: ROCK

        Specifies a rocking response spectrum.

        Parameters
        ----------
        cgx, cgy, cgz
            Global Cartesian X, Y, and Z location of center of rotation about
            which rocking occurs.

        omx, omy, omz
            Global Cartesian angular velocity components associated with the
            rocking.

        Notes
        -----
        Specifies a rocking response spectrum effect in the spectrum
        (ANTYPE,SPECTR) analysis.

        The excitation direction with rocking included is not normalized to
        one; rather, it scales the spectrum. For more information, see
        Participation Factors and Mode Coefficients.

        This command is also valid in PREP7.
        """
        command = "ROCK,%s,%s,%s,%s,%s,%s" % (str(cgx), str(cgy), str(cgz), str(omx), str(omy), str(omz))
        return self.run(command, **kwargs)

    def vfact(self, factr="", fact1="", fact2="", fact3="", **kwargs):
        """APDL Command: *VFACT

        Applies a scale factor to array parameters.

        Parameters
        ----------
        factr
            Scale factor applied to results (ParR) parameter.  Defaults to 1.0.

        fact1
            Scale factor applied to first parameter (Par1 or ParI).  Defaults
            to 1.0.

        fact2
            Scale factor applied to second parameter (Par2 or ParJ).  Defaults
            to 1.0.

        fact3
            Scale factor applied to third parameter (Par3 or ParK).  Defaults
            to 1.0.

        Notes
        -----
        Applies a scale factor to parameters used in certain *VXX and *MXX
        operations.   Typical scale factor applications are of the form:

        ParR = FACTR*f(FACT1*Par1)

        or

        ParR = FACTR*((FACT1*Par1) o (FACT2*Par2))

        The factors are applied to each input parameter value before the
        operation and to the result value after the operation.  The scale
        factor settings are reset to the default (1.0) after each *VXX or *MXX
        operation.  Use *VSTAT to list settings.

        This command is valid in any processor.
        """
        command = "*VFACT,%s,%s,%s,%s" % (str(factr), str(fact1), str(fact2), str(fact3))
        return self.run(command, **kwargs)

    def pmlopt(self, esys="", lab="", xminus="", xplus="", yminus="", yplus="",
               zminus="", zplus="", **kwargs):
        """APDL Command: PMLOPT

        Defines perfectly matched layers (PMLs) for acoustic and structural
        analyses.

        Parameters
        ----------
        esys
            Element coordinate system number. ESYS may be 0 (global Cartesian)
            or any previously defined local Cartesian coordinate system number
            (>10). Defaults to 0.

        lab
            Label defining the number of dimensions:

            ONE - A one-dimensional PML region.

            THREE - A three-dimensional PML region (default).

        xminus
            For harmonic analysis, normal reflection coefficient in negative X
            direction of ESYS. Defaults to 1.E−3 (equivalent to -60 dB) for a
            harmonic analysis and 30 for a static structural analysis.

        xplus
            For harmonic analysis, normal reflection coefficient in positive X
            direction of ESYS. Defaults to 1.E−3 (equivalent to -60 dB) for a
            harmonic analysis and 30 for a static structural analysis.

        yminus
            For harmonic analysis, normal reflection coefficient in negative Y
            direction of ESYS. Defaults to 1.E−3 (equivalent to -60 dB) for a
            harmonic analysis and 30 for a static structural analysis.

        yplus
            For harmonic analysis, normal reflection coefficient in positive Y
            direction of ESYS. Defaults to 1.E−3 (equivalent to -60 dB) for a
            harmonic analysis and 30 for a static structural analysis.

        zminus
            For harmonic analysis, normal reflection coefficient in negative Z
            direction of ESYS. Defaults to 1.E−3 (equivalent to -60 dB) for a
            harmonic analysis and 30 for a static structural analysis.

        zplus
            For harmonic analysis, normal reflection coefficient in positive Z
            direction of ESYS. Defaults to 1.E−3 (equivalent to -60 dB) for a
            harmonic analysis and 30 for a static structural analysis.

        Notes
        -----
        PMLOPT defines perfectly matched layers (PML) for acoustic or
        structural analyses. Each PML region must have a uniquely defined
        element coordinate system. Normal reflection coefficient values for a
        harmonic analysis must be less than 1.

        Issue PMLOPT,STAT to list the current normal reflection coefficient or
        attenuation factor settings for a PML region. Issue PMLOPT,CLEAR to
        clear all normal reflection coefficient settings and restore them to
        the defaults. Issue PMLOPT,ESYS,CLEAR to clear all normal reflection
        coefficient settings for this element coordinate system and restore
        them to the defaults.
        """
        command = "PMLOPT,%s,%s,%s,%s,%s,%s,%s,%s" % (str(esys), str(lab), str(xminus), str(xplus), str(yminus), str(yplus), str(zminus), str(zplus))
        return self.run(command, **kwargs)

    def pdcmat(self, rlab="", matrix="", name1="", name2="", corr="",
               slevel="", popt="", **kwargs):
        """APDL Command: PDCMAT

        Prints the correlation coefficient matrix.

        Parameters
        ----------
        rlab
            Result set label. Identifies the result set to be used for
            postprocessing. A result set label can be the solution set label
            you defined in a PDEXE command (if you are directly postprocessing
            Monte Carlo Simulation results), or the response surface set label
            defined in an RSFIT command (for Response Surface Analyses).

        matrix
            Keyword for the type of correlation coefficient matrix.

            IO - Matrix of correlation coefficients between random input variables and output
                 parameters.

            II - Matrix of correlation coefficients between random input variables and other
                 random input variables

            OO - Matrix of correlation coefficients between random output parameters and other
                 random output parameters.

            S - Correlation coefficient between a single random parameter (input or output) and
                another random parameter (input or output). The probabilistic
                design parameters must be specified in Name1 and Name2 for this
                option.

        name1, name2
            Parameter names. The parameters must have been previously defined
            as a random input variable or a random output parameter with the
            PDVAR command. These parameters are used for Matrix = S only and
            are ignored for the other Matrix keywords.

        corr
            Keyword for the type of correlation coefficients to be used for the
            output.

            RANK - Spearman rank-order correlation coefficient (default).

            LIN - Pearson linear correlation coefficient.

        slevel
            Significance level. The value for the significance level must be
            between 0.0 and 1.0. The default value is 0.025 (2.5%).

        popt
            Specifies whether the probabilities should be printed with the
            correlation coefficients.

            0 - Print only the correlation coefficients.

            1 - Print both the correlation coefficients and the probabilities (default).

        Notes
        -----
        Prints the correlation coefficient matrix.

        If Rlab is left blank, then the result set label is inherited from the
        last PDEXE command (Slab), RSFIT command (RSlab), or the most recently
        used PDS postprocessing command where a result set label was explicitly
        specified.

        For all correlation coefficients the probabilistic design tool
        evaluates the probability that the correlation coefficient can be
        neglected. The evaluation of this probability is based on statistical
        test theory. The larger this probability is the likelier it is that the
        correlation coefficient does not really reflect an observable
        statistical interdependence between the parameters involved. If this
        probability exceeds the significance level as specified by the SLEVEL
        parameter, the correlation coefficient should be regarded as negligible
        or insignificant. The higher the significance level SLEVEL, the more
        correlation coefficients are considered significant. Using the Popt
        parameter you can also get a list of the probabilities and review them
        as to how far they exceed the significance level or how far they stay
        below it.

        The PDCMAT command cannot be used to postprocess the results in a
        solution set that is based on Response Surface Methods, only Monte
        Carlo Simulations.
        """
        command = "PDCMAT,%s,%s,%s,%s,%s,%s,%s" % (str(rlab), str(matrix), str(name1), str(name2), str(corr), str(slevel), str(popt))
        return self.run(command, **kwargs)

    def yrange(self, ymin="", ymax="", num="", **kwargs):
        """APDL Command: /YRANGE

        Specifies a linear ordinate (Y) scale range.

        Parameters
        ----------
        ymin
            Minimum ordinate scale value.

        ymax
            Maximum ordinate scale value.

        num
            Y-axis number to which range applies (defaults to 1).  Valid
            numbers are 1 to 3 for /GRTYP,2 and 1 to 6 for /GRTYP,3.  If ALL,
            apply to all Y-axes.

        Notes
        -----
        Specifies a linear ordinate (Y) scale range for the line graph display.
        Use /YRANGE,DEFAULT to return to automatic scaling.  For multiple
        Y-axes graphs [/GRTYP], see /GROPT, ASCAL to automatically scale the
        additional Y-axes.

        Automatic scaling will often yield inappropriate range values for
        logarithmic scales (/GROPT, LOGY).

        This command is valid in any processor.
        """
        command = "/YRANGE,%s,%s,%s" % (str(ymin), str(ymax), str(num))
        return self.run(command, **kwargs)

    def rpr4(self, nsides="", xcenter="", ycenter="", radius="", theta="",
             depth="", **kwargs):
        """APDL Command: RPR4

        Creates a regular polygonal area or prism volume anywhere on the
        working plane.

        Parameters
        ----------
        nsides
            The number of sides in the polygon or prism face.  Must be greater
            than 2.

        xcenter, ycenter
            Working plane X and Y coordinates of the center of the polygon or
            prism face.

        radius
            Distance (major radius) from the center to a vertex of the polygon
            or prism face (where the first keypoint is defined).

        theta
            Angle (in degrees) from the working plane X-axis to the vertex of
            the polygon or prism face where the first keypoint is defined.
            Used to orient the polygon or prism face.  Defaults to zero.

        depth
            The perpendicular distance (either positive or negative based on
            the working plane Z direction) from the working plane representing
            the depth of the prism.  If DEPTH = 0 (default), a polygonal area
            is created on the working plane.

        Notes
        -----
        Defines a regular polygonal area anywhere on the working plane or prism
        volume with one face anywhere on the working plane.  The top and bottom
        faces of the prism are polygonal areas.  See the RPOLY, POLY, RPRISM,
        and PRISM commands for other ways to create polygons and prisms.
        """
        command = "RPR4,%s,%s,%s,%s,%s,%s" % (str(nsides), str(xcenter), str(ycenter), str(radius), str(theta), str(depth))
        return self.run(command, **kwargs)

    def tbdata(self, stloc="", c1="", c2="", c3="", c4="", c5="", c6="",
               **kwargs):
        """APDL Command: TBDATA

        Defines data for the material data table.

        Parameters
        ----------
        stloc
            Starting location in table for entering data.  For example, if
            STLOC = 1, data input in the C1 field applies to the first table
            constant, C2 applies to the second table constant, etc.  If
            STLOC=5, data input in the C1 field applies to the fifth table
            constant, etc.  Defaults to the last location filled + 1.  The last
            location is reset to 1 with each TB or TBTEMP command.

        c1, c2, c3, . . . , c6
            Data values assigned to six locations starting with STLOC.  If a
            value is already in this location, it is redefined.  A blank value
            leaves the existing value unchanged.

        Notes
        -----
        Defines data for the table specified on the last TB command at the
        temperature specified on the last TBTEMP command (if applicable). The
        type of data table specified in the last TB command determines the
        number of data values needed in TBDATA. Data values are linearly
        interpolated for temperatures that fall between user defined TBTEMP
        values. See Material Models in the Material Reference for the number of
        data values required for different material behavior options.

        This command is also valid in SOLUTION.
        """
        command = "TBDATA,%s,%s,%s,%s,%s,%s,%s" % (str(stloc), str(c1), str(c2), str(c3), str(c4), str(c5), str(c6))
        return self.run(command, **kwargs)

    def esort(self, item="", lab="", order="", kabs="", numb="", **kwargs):
        """APDL Command: ESORT

        Sorts the element table.

        Parameters
        ----------
        item
            Label identifying the item:

            ETAB - (currently the only Item available)

        lab
            element table label:

            Lab - Any user-defined label from the ETABLE command (input in the Lab field of the
                  ETABLE command).

        order
            Order of sort operation:

            0 - Sort into descending order.

            1 - Sort into ascending order.

        kabs
            Absolute value key:

            0 - Sort according to real value.

            1 - Sort according to absolute value.

        numb
            Number of elements (element table rows) to be sorted in ascending
            or descending order (ORDER) before sort is stopped (remainder will
            be in unsorted sequence) (defaults to all elements).

        Notes
        -----
        The element table rows are sorted based on the column containing the
        Lab values. Use EUSORT to restore the original order. If ESORT is
        specified with PowerGraphics on [/GRAPHICS,POWER], then the nodal
        solution results listing [PRNSOL] will be the same as with the full
        graphics mode [/GRAPHICS,FULL].
        """
        command = "ESORT,%s,%s,%s,%s,%s" % (str(item), str(lab), str(order), str(kabs), str(numb))
        return self.run(command, **kwargs)

    def adgl(self, na1="", na2="", ninc="", **kwargs):
        """APDL Command: ADGL

        Lists keypoints of an area that lie on a parametric degeneracy.

        Parameters
        ----------
        na1, na2, ninc
            List keypoints that lie on a parametric degeneracy on areas from
            NA1 to NA2 (defaults to NA1) in steps of NINC (defaults to 1).  If
            NA1 = ALL (default), NA2 and NINC will be ignored and keypoints on
            all selected areas [ASEL] will be listed.  If NA1 = P, graphical
            picking is enabled and all remaining arguments are ignored (valid
            only in the GUI).  A component name may be substituted in NA1 (NA2
            and NINC will be ignored).

        Notes
        -----
        See the Modeling and Meshing Guide for details on parametric
        degeneracies.

        This command is valid in any processor.
        """
        command = "ADGL,%s,%s,%s" % (str(na1), str(na2), str(ninc))
        return self.run(command, **kwargs)

    def prpath(self, lab1="", lab2="", lab3="", lab4="", lab5="", lab6="",
               **kwargs):
        """APDL Command: PRPATH

        Prints path items along a geometry path.

        Parameters
        ----------
        lab1, lab2, lab3, . . . , lab6
            Labels identifying the path items to be printed.  Up to six items
            may be printed at a time.  Predefined path geometry items XG, YZ,
            ZG, and S [PDEF] may also be printed.

        Notes
        -----
        Prints path items with respect to a geometry path (as defined by the
        PATH  and PPATH commands).  Path items and their labels must have been
        defined with the PDEF, PVECT, PCALC, PDOT, PCROSS, or PRNEAR commands.
        Path items may also be displayed with the PLPATH and PLPAGM commands.
        See the PRANGE command for range control of the path.
        """
        command = "PRPATH,%s,%s,%s,%s,%s,%s" % (str(lab1), str(lab2), str(lab3), str(lab4), str(lab5), str(lab6))
        return self.run(command, **kwargs)

    def couple(self, **kwargs):
        """APDL Command: COUPLE

        Specifies "Node coupling" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "COUPLE," % ()
        return self.run(command, **kwargs)

    def operate(self, **kwargs):
        """APDL Command: OPERATE

        Specifies "Operation data" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "OPERATE," % ()
        return self.run(command, **kwargs)

    def upgeom(self, factor="", lstep="", sbstep="", fname="", ext="",
               **kwargs):
        """APDL Command: UPGEOM

        Adds displacements from a previous analysis and updates the geometry of
        the finite element model to the deformed configuration.

        Parameters
        ----------
        factor
            Multiplier for displacements being added to coordinates.  The value
            1.0 will add the full value of the displacements to the geometry of
            the finite element model.  Defaults to 1.0.

        lstep
            Load step number of data to be imported.  Defaults to the last load
            step.

        sbstep
            Substep number of data to be imported.  Defaults to the last
            substep.

        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        This command updates the geometry of the finite element model according
        to the displacement results of the previous analysis and creates a
        revised geometry at the deformed configuration.  This command works on
        all nodes (default) or on a selected set of nodes.  If this command is
        issued repeatedly, it creates a revised geometry of the finite element
        model in a cumulative fashion, i.e., it adds displacement results on
        the previously generated deformed geometry. The solid model geometry is
        not updated by this command.

        When UPGEOM is issued, the current finite element model is overwritten
        by finite element information from the results file. For this reason,
        it is important that the finite element information in the results file
        matches the finite element model in which the nodal coordinates are
        being updated. No changes should be made to the model before the UPGEOM
        command is issued.
        """
        command = "UPGEOM,%s,%s,%s,%s,%s" % (str(factor), str(lstep), str(sbstep), str(fname), str(ext))
        return self.run(command, **kwargs)

    def tsres(self, array="", **kwargs):
        """APDL Command: TSRES

        Defines an array of key times at which the time-stepping strategy
        changes.

        Parameters
        ----------
        array
            Identifies an Nx1x1 array parameter containing the key times at
            which the heat transfer time-stepping strategy changes (the time
            step is reset to the initial time step based on DELTIM or NSUBST
            settings).  The array name must be enclosed by % signs (e.g.,
            %array%).  See *DIM for more information on array parameters.

        Notes
        -----
        Time values in the array parameter must be in ascending order and must
        not exceed the time at the end of the load step as defined on the TIME
        command. The time increment between time points in the array list must
        be larger than the initial time step defined on the DELTIM or NSUBST
        command.  Time values must also fall between the beginning and ending
        time values of the load step.  For multiple load step problems, you
        must either change the parameter values to fall between the beginning
        and ending time values of the load step or reissue the command with a
        new array parameter.  To clear the array parameter specification, issue
        TSRES,ERASE.  Results can be output at the requested time points if the
        array or time values in the array are also specified in the OUTRES
        command using FREQ=%array%.  Use this command to reset the time-
        stepping strategy within a load step. You may need to reset the time-
        stepping strategy when using tabular time-varying boundary conditions.

        See Steady-State Thermal Analysis of the Thermal Analysis Guide  for
        more information on applying boundary conditions via tabular input.
        See Transient Thermal Analysis of the Thermal Analysis Guide for more
        information on defining the key time array.
        """
        command = "TSRES,%s" % (str(array))
        return self.run(command, **kwargs)

    def vlist(self, nv1="", nv2="", ninc="", **kwargs):
        """APDL Command: VLIST

        Lists the defined volumes.

        Parameters
        ----------
        nv1, nv2, ninc
            List volumes from NV1 to NV2 (defaults to NV1) in steps of NINC
            (defaults to 1).  If NV1 = ALL (default), NV2 and NINC are ignored
            and all selected volumes [VSEL] are listed.  If NV1 = P, graphical
            picking is enabled and all remaining command fields are ignored
            (valid only in the GUI).  A component name may also be substituted
            for NV1 (NV2 and NINC are ignored).

        Notes
        -----
        An attribute (TYPE, MAT, REAL, or ESYS) listed as a zero is unassigned;
        one listed as a positive value indicates that the attribute was
        assigned with the VATT command (and will not be reset to zero if the
        mesh is cleared); one listed as a negative value indicates that the
        attribute was assigned using the attribute pointer [TYPE, MAT, REAL, or
        ESYS] that was active during meshing (and will be reset to zero if the
        mesh is cleared).  A "-1" in the "nodes" column indicates that the
        volume has been meshed but there are no interior nodes.  The volume
        size is listed only if a VSUM command has been performed on the volume.
        Volume orientation attributes (KZ1 and KZ2) are listed only if a
        VEORIENT command was previously used to define an orientation for the
        volume.

        This command is valid in any processor.
        """
        command = "VLIST,%s,%s,%s" % (str(nv1), str(nv2), str(ninc))
        return self.run(command, **kwargs)

    def pltrac(self, analopt="", item="", comp="", trpnum="", name="",
               mxloop="", toler="", option="", escl="", mscl="", **kwargs):
        """APDL Command: PLTRAC

        Displays a particle flow or charged particle trace on an element
        display.

        Parameters
        ----------
        analopt
            Analysis option

            FLUID - Particle trace in fluid flow (default)

            ELEC - Particle trace in electric field

            MAGN - Particle trace in magnetic field

            EMAG - Particle trace in presence of both electric and magnetic fields

        item
            Label identifying the item to be contoured.  Valid item labels are
            shown in Table 222: PLTRAC - Valid Item and Component Labels
            below.  Some items also require a component label.  If Item is
            blank, display only the path trajectory.

        comp
            Component of the item (if required).  Valid component labels are
            shown in Table 222: PLTRAC - Valid Item and Component Labels below.

        trpnum
            Trace point number for storing trajectory data for use with PATH
            logic. Defaults to 0 (no trajectory path data is stored for further
            processing with PATH logic).

        name
            Name of prefix of array variable. Defaults to TRAC. NamePOIN stores
            trajectory path points for trace point number TRPNum. If Analopt =
            ELEC, MAGN, or EMAG, two additional array parameters, NameDATA and
            NameLABL, store trajectory path data and labels for the same
            TRPNum.

        mxloop
            Maximum number of loops traced by a particle.  Defaults to 25 for
            Opt = FLUID; otherwise, defaults to 1000.

        toler
            Length tolerance used for particle trajectory geometry calculation.
            Valid only for Analopt = ELEC, MAGN, or EMAG.  If particle trace
            appears to terminate inside an element, adjusting the length
            tolerance may be necessary.  Defaults to 1.0 x 10-8.

        option
            Flow trace option:

            0 - Use the undeformed mesh for computing the flow trace.

            1 - Use the deformed mesh for computing the flow trace.

        escl
            Electric field scale factor. Setting this scale factor affects only
            the tracing, not the field solution results. A negative factor
            corresponds to the opposite vector direction. Valid only for
            Analopt = ELEC or EMAG. Defaults to 1.

        mscl
            Magnetic field scale factor. Setting this scale factor affects only
            the tracing, not the field solution results. A negative factor
            corresponds to the opposite vector direction. Valid only for
            Analopt = MAGN or EMAG. Defaults to 1.

        Notes
        -----
        For a specified item, the variation of the item is displayed along the
        particle trace as a color-contoured ribbon.  The TRPOIN command must be
        used to define a point on the trajectory path.  Multiple traces may be
        displayed simultaneously by defining multiple trace points.  Issue the
        TRPLIS command to list the current tracing points.  Issue the TRPDEL
        command to delete tracing points defined earlier.   Use the PAPUT
        command with the POIN option to retrieve the particle trajectory points
        as path points.

        The model must be 3-D for the ELEC, MAGN, and EMAG analysis options.

        Three array parameters are created at the time of the particle trace:
        TRACPOIN, TRACDATA and TRACLABL. These array parameters can be used to
        put the particle velocity and the elapsed time into path form.   The
        procedure to put the arrays into a path named PATHNAME is as follows:

        Not used if Analopt = FLUID.  If working in the GUI, use the "All
        information" option to retrieve information from all three arrays at
        once.

        If OPTION is set to 1, the deformed mesh is based on the displacement
        degrees of freedom UX, UY, and UZ, which must be available in the load
        step.

        Table: 222:: : PLTRAC - Valid Item and Component Labels

        See the Basic Analysis Guide for more information on particle flow and
        charged particle traces.  See Animation in the Basic Analysis Guide for
        information on particle trace animation.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "PLTRAC,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(analopt), str(item), str(comp), str(trpnum), str(name), str(mxloop), str(toler), str(option), str(escl), str(mscl))
        return self.run(command, **kwargs)

    def sdelete(self, sfirst="", sl_ast="", sinc="", knoclean="", lchk="",
                **kwargs):
        """APDL Command: SDELETE

        Deletes sections from the database.

        Parameters
        ----------
        sfirst
            First section ID to be deleted; defaults to first available section
            in the database.

        slast
            Last section ID to be deleted; defaults to last available section
            in the database.

        sinc
            Increment of the section ID; defaults to 1.

        knoclean
            Pretension element cleanup key (pretension sections only).

            0 - Perform cleanup of pretension elements (delete pretension elements and
                reconnect elements split during PSMESH).

            1 - Do not perform cleanup.

        lchk
            Specifies the level of element-associativity checking:

            NOCHECK - No element-associativity check occurs. This option is the default.

            WARN - When a section, material, or real constant is associated with an element, ANSYS
                   issues a message warning that the necessary entity has been
                   deleted.

            CHECK - The command terminates, and no section, material, or real constant is deleted
                    if it is associated with an element.

        Notes
        -----
        Deletes one or more specified sections and their associated data from
        the ANSYS database.
        """
        command = "SDELETE,%s,%s,%s,%s,%s" % (str(sfirst), str(sl_ast), str(sinc), str(knoclean), str(lchk))
        return self.run(command, **kwargs)

    def lcsl(self, nl1="", nl2="", nl3="", nl4="", nl5="", nl6="", nl7="",
             nl8="", nl9="", **kwargs):
        """APDL Command: LCSL

        Divides intersecting lines at their point(s) of intersection.

        Parameters
        ----------
        nl1, nl2, nl3, . . . , nl9
            Numbers of lines to be intersected.  If NL1 = ALL, NL2 to NL9 are
            ignored and the intersection of all selected lines is found.  If
            NL1 = P, use graphical picking to specify lines (NL2 to NL9 are
            ignored).

        Notes
        -----
        Divides intersecting (classifies) lines at their point(s) of
        intersection.  The original lines (and their corresponding keypoint(s))
        will be deleted by default.  See the BOPTN command for the options
        available to Boolean operations.  Element attributes and solid model
        boundary conditions assigned to the original entities will not be
        transferred to the new entities generated.
        """
        command = "LCSL,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nl1), str(nl2), str(nl3), str(nl4), str(nl5), str(nl6), str(nl7), str(nl8), str(nl9))
        return self.run(command, **kwargs)

    def aux12(self, **kwargs):
        """APDL Command: /AUX12

        Enters the radiation processor.

        Notes
        -----
        Enters the radiation processor (ANSYS auxiliary processor AUX12).  This
        processor supports the Radiation Matrix and the Radiosity Solver
        methods.

        This command is valid only at the Begin Level.
        """
        command = "/AUX12," % ()
        return self.run(command, **kwargs)

    def suget(self, surfname="", rsetname="", parm="", geom="", **kwargs):
        """APDL Command: SUGET

        Moves surface geometry and mapped results to an array parameter.

        Parameters
        ----------
        surfname
            Eight character surface name.

        rsetname
            Eight character result name.

        parm
            APDL array parameter name (up to 32 characters).

        geom
            Switch controlling how data is written.

            ON (or 1 or YES) - Writes geometry data and interpolated results information to the parameter.

            OFF (or 0 or NO) - Writes only interpolated results information to the parameter. (Default)

        Notes
        -----
        For Geom = OFF (or 0 or NO), only results information is written to
        this parameter.

        For Geom = ON (or 1 or YES), both geometry data and results information
        are written to this parameter.  Geometry data includes 7 data items:
        (GCX, GCY, GCZ, NORMX, NORMY, NORMZ, and DA). Results information is
        then written to the 8th column of the parameter. SetNames of GCX, GCY,
        GCZ, NORMX, NORMY, NORMZ, and DA are predefined and computed when SUCR
        is issued.
        """
        command = "SUGET,%s,%s,%s,%s" % (str(surfname), str(rsetname), str(parm), str(geom))
        return self.run(command, **kwargs)

    def powerh(self, **kwargs):
        """APDL Command: POWERH

        Calculates the rms power loss in a conductor or lossy dielectric.

        Notes
        -----
        POWERH invokes an ANSYS macro which calculates the time-averaged (rms)
        power loss in a conductor or lossy dielectric material from a harmonic
        analysis.  The power loss is stored in the parameter PAVG.  Conductor
        losses include solid conductors and surface conductors approximated by
        impedance or shielding boundary conditions. The power loss density for
        solid conductors or dielectrics is stored in the element table with the
        label PLOSSD and may be listed [PRETAB] or displayed [PLETAB].  PLOSSD
        does not include surface losses. The elements of the conducting region
        must be selected before this command is issued.  POWERH is valid for
        2-D and 3-D analyses.
        """
        command = "POWERH," % ()
        return self.run(command, **kwargs)

    def czdel(self, grp1="", grp2="", grp3="", **kwargs):
        """APDL Command: CZDEL

        Edits or clears cohesive zone sections.

        Parameters
        ----------
        grp1
            Initial group of cohesive zone elements to be deleted.

        grp2
            Final group of cohesive zone elements to be deleted.

        grp3
            Increment for selected groups.

        Notes
        -----
        The CZDEL command edits or deletes the interface elements and nodes,
        along with the associated changes made to the underlying plane or solid
        elements created during a previous CZMESH operation.

        Each CZMESH operation will create groups of elements and nodes with
        component names in the format CZME_EL01 (elements) and CZME_ND01
        (nodes). The final number of this format will be the number used for
        grp1 and grp2. If grp1 = ALL, all nodes and elements created by the
        CZMESH command will be deleted. After using CZDEL, all the user-defined
        components will be unselected.

        The CZDEL command is valid for structural analyses only.
        """
        command = "CZDEL,%s,%s,%s" % (str(grp1), str(grp2), str(grp3))
        return self.run(command, **kwargs)

    def supr(self, surfname="", rsetname="", **kwargs):
        """APDL Command: SUPR

        Print global status, geometry information and/or result information.

        Parameters
        ----------
        surfname
            Eight character surface name. If SurfName = ALL, repeat printout
            for all selected surfaces.

        rsetname
            Eight character result set name.

        Notes
        -----
        When no arguments are specified, SUPR generates a global status summary
        of all defined surfaces. If only SurfName is specified, the geometry
        information for that surface is printed. If both SurfName and RSetName
        are specified, the value of the results set at each point, in addition
        to the geometry information, is printed.
        """
        command = "SUPR,%s,%s" % (str(surfname), str(rsetname))
        return self.run(command, **kwargs)

    def gopr(self, **kwargs):
        """APDL Command: /GOPR

        Reactivates suppressed printout.

        Notes
        -----
        Reactivates printout suppressed with the /NOPR command.  The /GO
        command has the same function except that it does not produce a command
        response from the program.

        This command is valid in any processor.
        """
        command = "/GOPR," % ()
        return self.run(command, **kwargs)

    def plchist(self, spec="", freqpt="", **kwargs):
        """APDL Command: PLCHIST

        Plots a histogram of the frequency response of each sector for the
        given CYCSPEC specification.

        Parameters
        ----------
        spec
            CYCSPEC specification number (ordered 1 to N in the order input;
            use CYCSPEC,LIST to view the current list order). Defaults to 1.

        freqpt
            Harmonic frequency point to plot (the data set number NSET or
            CUMULATIVE on SET,LIST). Defaults to the current SET frequency.

        Notes
        -----
        Following a cyclic mode-superposition harmonic analysis, this command
        creates a histogram plot of the result item given by a CYCSPEC
        specification versus the sector number. A CYCCALC command must have
        been issued prior to this command.
        """
        command = "PLCHIST,%s,%s" % (str(spec), str(freqpt))
        return self.run(command, **kwargs)

    def lcomb(self, nl1="", nl2="", keep="", **kwargs):
        """APDL Command: LCOMB

        Combines adjacent lines into one line.

        Parameters
        ----------
        nl1
            Number of the first line to be combined.  If NL1 = ALL, NL2 is
            ignored and all selected lines [LSEL] are combined.  If NL1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NL1 (NL2 is ignored).

        nl2
            Number of the second line to be combined.

        keep
            Specifies whether to keep the input entities:

            0 - Delete lines NL1 and NL2 and their common keypoint.  Keypoints will not be
                deleted if they are meshed or if they are attached to other
                lines.  Lines will not be deleted if they are attached to
                different areas.

            1 - Keep NL1, NL2, and their common keypoint.  (The common keypoint will not be
                attached to the output line.)

        Notes
        -----
        Combines adjacent lines into one line (the output line).  This
        operation will effectively "undo" the LDIV operation.  Line divisions
        are set to zero (use LESIZE, etc. to modify).  Lines attached to the
        same area(s) can also be combined.  See also the LCCAT command for line
        concatenation capability.
        """
        command = "LCOMB,%s,%s,%s" % (str(nl1), str(nl2), str(keep))
        return self.run(command, **kwargs)

    def omega(self, omegx="", omegy="", omegz="", **kwargs):
        """APDL Command: OMEGA

        Specifies the rotational velocity of the structure.

        Parameters
        ----------
        omegx, omegy, omegz
            Rotational velocity of the structure about the global Cartesian X,
            Y, and Z axes.

        Notes
        -----
        This command specifies the rotational velocity of the structure about
        each of the global Cartesian axes (right-hand rule).  Rotational
        velocities may be defined in these analysis types:

        Static (ANTYPE,STATIC)

        Harmonic (ANTYPE,HARMIC) -- Full or mode-superposition

        Transient (ANTYPE,TRANS)  -- Full or mode-superposition

        Substructuring (ANTYPE,SUBSTR)

        Modal (ANTYPE,MODAL)

        The OMEGA command supports tabular boundary conditions (%TABNAME_X%,
        %TABNAME_Y%, and %TABNAME_Z%) for OMEGA_X, OMEGA_Y, and OMEGA_Z input
        values (*DIM) for full transient and harmonic analyses.

        Rotational velocities are combined with the element mass matrices to
        form a body force load vector term.  Units are radians/time.  Related
        commands are ACEL, CGLOC, CGOMGA, DCGOMG, and DOMEGA.

        See Analysis Tools in the Mechanical APDL Theory Reference for more
        information.

        If you have applied the Coriolis effect (CORIOLIS) using a stationary
        reference frame, the OMEGA command takes the gyroscopic damping matrix
        into account for the elements listed in the “Stationary Reference
        Frame” heading in the notes section of the CORIOLIS command. The
        element axis must pass through the global Cartesian origin. ANSYS
        verifies that the rotation vector axis is parallel to the axis of the
        element; if not, the gyroscopic effect is not applied. After issuing
        the OMEGA command when the Coriolis or gyroscopic effect is present, a
        subsequently issued CMOMEGA command has no effect.

        In a mode-superposition harmonic or transient analysis, you must apply
        the load in the modal portion of the analysis. Mechanical APDL
        calculates a load vector and writes it to the MODE file, which you can
        apply via the LVSCALE command.

        This command is also valid in PREP7.
        """
        command = "OMEGA,%s,%s,%s" % (str(omegx), str(omegy), str(omegz))
        return self.run(command, **kwargs)

    def uimp(self, mat="", lab1="", lab2="", lab3="", val1="", val2="",
             val3="", **kwargs):
        """APDL Command: UIMP

        Defines constant material properties (GUI).

        Parameters
        ----------
        mat
            Material number.

        lab1, lab2, lab3
            Material property labels (see the MP command for valid labels).

        val1, val2, val3
            Values corresponding to three labels.

        Notes
        -----
        Defines constant material properties.  This is a command generated by
        the Graphical User Interface (GUI) and will appear in the log file
        (Jobname.LOG) if material properties are specified using the Material
        Properties dialog box. This command is not intended to be typed in
        directly in an ANSYS session (although it can be included in an input
        file for batch input or for use with the /INPUT command).
        """
        command = "UIMP,%s,%s,%s,%s,%s,%s,%s" % (str(mat), str(lab1), str(lab2), str(lab3), str(val1), str(val2), str(val3))
        return self.run(command, **kwargs)

    def csdele(self, kcn1="", kcn2="", kcinc="", **kwargs):
        """APDL Command: CSDELE

        Deletes local coordinate systems.

        Parameters
        ----------
        kcn1, kcn2, kcinc
            Delete coordinate systems from KCN1 (must be greater than 10) to
            KCN2 (defaults to KCN1) in steps of KCINC (defaults to 1).  If KCN1
            = ALL, KCN2 and KCINC are ignored and all coordinate systems are
            deleted.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "CSDELE,%s,%s,%s" % (str(kcn1), str(kcn2), str(kcinc))
        return self.run(command, **kwargs)

    def ask(self, par="", query="", dval="", **kwargs):
        """APDL Command: *ASK

        Prompts the user to input a parameter value.

        Parameters
        ----------
        par
            An alphanumeric name used to identify the scalar parameter.  See
            *SET for name restrictions.

        query
            Text string to be displayed on the next line as the query (32
            characters maximum).  Characters having special meaning (such as $
            ! ,) should not be included.

        dval
            Default value assigned to the parameter if the user issues a blank
            response.  May be a number or character string (up to 8 characters
            enclosed in single quotes).  If a default is not assigned, a blank
            response will delete the parameter.

        Notes
        -----
        Intended primarily for use in macros, the command prints the query
        (after the word ENTER) on the next line and waits for a response.  The
        response is read from the keyboard, except in batch mode [/BATCH], when
        the response(s) must be the next-read input line(s).  The response may
        be a number, a character string (up to 8 characters enclosed in single
        quotes), a parameter (numeric or character) or an expression that
        evaluates to a number.  The scalar parameter is then set to the
        response value.  For example,  *ASK,NN,PARAMETER NN  will set NN to the
        value entered on the next line (after the prompt ENTER PARAMETER NN).

        The *ASK command is not written to File.LOG,  but the responses are
        written there as follows:  If *ASK is contained in a macro, the
        response(s) (only) is written to File.LOG on the line(s) following the
        macro name.   If not contained in a macro, the response is written to
        File.LOG as a parameter assignment (i.e., Par = "user-response").

        If used within a do-loop that is executed interactively, *ASK should be
        contained in a macro.  If not contained in a macro, *ASK will still
        query the user as intended, but the resulting log file will not
        reproduce the effects of the original run.

        This command is valid in any processor.
        """
        command = "*ASK,%s,%s,%s" % (str(par), str(query), str(dval))
        return self.run(command, **kwargs)

    def vmesh(self, nv1="", nv2="", ninc="", **kwargs):
        """APDL Command: VMESH

        Generates nodes and volume elements within volumes.

        Parameters
        ----------
        nv1, nv2, ninc
            Mesh volumes from NV1 to NV2 (defaults to NV1) in steps of NINC
            (defaults to 1).  If NV1 = ALL, NV2 and NINC are ignored and all
            selected volumes [VSEL] are meshed.  If NV1 = P, graphical picking
            is enabled and all remaining command fields are ignored (valid only
            in the GUI).  A component name may also be substituted for NV1 (NV2
            and NINC are ignored).

        Notes
        -----
        Missing nodes required for the generated elements are created and
        assigned the lowest available numbers [NUMSTR].  During a batch run and
        if elements already exist, a mesh abort will write an alternative
        database file (File.DBE) for possible recovery.

        Tetrahedral mesh expansion [MOPT,TETEXPND,Value] is supported for both
        the VMESH and FVMESH commands.
        """
        command = "VMESH,%s,%s,%s" % (str(nv1), str(nv2), str(ninc))
        return self.run(command, **kwargs)

    def pwedge(self, xcentr="", ycentr="", xlrad="", angle1="", angle2="",
               **kwargs):
        """APDL Command: /PWEDGE

        Creates an annotation wedge (GUI).

        Parameters
        ----------
        xcentr
            Wedge X center location (-1.0 < X < 2.0).

        ycentr
            Wedge Y center location (-1.0 < Y < 1.0).

        xlrad
            Wedge radius length.

        angle1
            Starting angle of wedge.

        angle2
            Ending angle of wedge.  The wedge is drawn counterclockwise from
            the starting angle, ANGLE1, to the ending angle, ANGLE2.

        Notes
        -----
        Creates an annotation wedge to be written directly onto the display at
        a specified location.  This is a command generated by the Graphical
        User Interface (GUI) and will appear in the log file (Jobname.LOG) if
        annotation is used.  This command is not intended to be typed in
        directly in an ANSYS session (although it can be included in an input
        file for batch input or for use with the /INPUT command).

        All wedges are shown on subsequent displays unless the annotation is
        turned off or deleted.  Use the /LSPEC and the /PSPEC command to set
        the attributes of the wedge.

        This command is valid in any processor.
        """
        command = "/PWEDGE,%s,%s,%s,%s,%s" % (str(xcentr), str(ycentr), str(xlrad), str(angle1), str(angle2))
        return self.run(command, **kwargs)

    def askin(self, nl1="", nl2="", nl3="", nl4="", nl5="", nl6="", nl7="",
              nl8="", nl9="", **kwargs):
        """APDL Command: ASKIN

        Generates an area by "skinning" a surface through guiding lines.

        Parameters
        ----------
        nl1
            The first guiding line forming the skinned area.  If NL1 = P,
            graphical picking is enabled and all remaining arguments are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NL1.  If NL1 is negative, the line beginnings and
            ends will be used to direct the skinning of the remaining lines
            (see "Changing the ASKIN Algorithm" below).

        nl2, nl3, nl4, . . . , nl9
            The additional guiding lines for the skinned area (up to 9 total
            lines, including NL1, if using keyboard entry).  If negative (and
            NL1 is negative), the line beginning and end will be temporarily
            interchanged for the skinning operation (see "Changing the ASKIN
            Algorithm" below).

        Notes
        -----
        Generates an area by "skinning" a surface through specified guiding
        lines.  The lines act as a set of "ribs" over which a surface is
        "stretched."  Two opposite edges of the area are framed by the first
        (NL1) and last (NLn) guiding lines specified.  The other two edges of
        the area are framed by splines-fit lines which the program
        automatically generates through the ends of all guiding lines.  The
        interior of the area is shaped by the interior guiding lines.  Once the
        area has been created, only the four edge lines will be attached to it.
        In rare cases, it may be necessary to change the default algorithm used
        by the ASKIN command (see "Changing the ASKIN Algorithm" below).

        When skinning from one guiding line to the next, the program can create
        the transition area in one of two ways:  one more spiraled and one less
        spiraled ("flatter").  By default, the program attempts to produce the
        flatter transition, instead of the more spiraled transition.  This
        algorithm can be changed by inputting NL1 as a negative number, in
        which case the program connects all the keypoints at the line
        "beginnings" (/PSYMB,LDIR command) as one edge of the area, and all the
        line "ends" as the opposite edge, irrespective of the amount of
        spiraling produced in each transition area.

        To further control the geometry of the area (if NL1 is negative), the
        beginning and end of any specified line (other than NL1) can be
        temporarily interchanged (for the skinning operation only) by inputting
        that line number as negative.  See Solid Modeling in the Modeling and
        Meshing Guide for an illustration.
        """
        command = "ASKIN,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nl1), str(nl2), str(nl3), str(nl4), str(nl5), str(nl6), str(nl7), str(nl8), str(nl9))
        return self.run(command, **kwargs)

    def dmpext(self, smode="", tmode="", dmpname="", freqb="", freqe="",
               nsteps="", **kwargs):
        """APDL Command: DMPEXT

        Extracts modal damping coefficients in a specified frequency range.

        Parameters
        ----------
        smode
            Source mode number. There is no default for this field; you must
            enter an integer greater than zero.

        tmode
            Target mode. Defaults to SMODE.

        dmpname
            Array parameter name containing the damping results. Defaults to
            d_damp.

        freqb
            Beginning frequency range (real number greater than zero) or 'EIG'
            at eigenfrequency of source mode. 'EIG' is valid only if SMODE =
            TMODE. Note that EIG must be enclosed in single quotes when this
            command is used on the command line or in an input file. There is
            no default for this field; you must enter a value.

        freqe
            End of frequency range. Must be blank for Freqb = EIG. Default is
            Freqb.

        nsteps
            Number of substeps. Defaults to 1.

        Notes
        -----
        DMPEXT invokes an ANSYS macro that uses modal projection techniques to
        compute the damping force by the modal velocity of the source mode onto
        the target mode. From the damping force, damping parameters are
        extracted. DMPEXT creates an array parameter Dmpname, with the
        following entries in each row:

        response frequency

        modal damping coefficient

        modal squeeze stiffness coefficient

        damping ratio

        squeeze-to-structural stiffness ratio

        The macro requires the modal displacements from the file Jobname.EFL
        obtained from the RMFLVEC command. In addition, a node component FLUN
        must exist from all FLUID136 nodes. The computed damping ratio may be
        used to specify constant or modal damping by means of the DMPRAT or
        MDAMP commands. For Rayleigh damping, use the ABEXTRACT command to
        compute ALPHAD and BETAD damping parameters. See Thin Film Analysis for
        more information on thin film analyses.

        The macro uses the LSSOLVE command to perform two load steps for each
        frequency.  The first load case contains the solution of the source
        mode excitation and can be used for further postprocessing. Solid model
        boundary conditions are deleted from the model.  In addition,
        prescribed nodal boundary conditions are applied to the model.  You
        should carefully check the boundary conditions of your model prior to
        executing a subsequent analysis.

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "DMPEXT,%s,%s,%s,%s,%s,%s" % (str(smode), str(tmode), str(dmpname), str(freqb), str(freqe), str(nsteps))
        return self.run(command, **kwargs)

    def dynopt(self, **kwargs):
        """APDL Command: DYNOPT

        Specifies "Dynamic analysis options" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "DYNOPT," % ()
        return self.run(command, **kwargs)

    def fklist(self, kpoi="", lab="", **kwargs):
        """APDL Command: FKLIST

        Lists the forces at keypoints.

        Parameters
        ----------
        kpoi
            List forces at this keypoint.  If ALL (default), list for all
            selected keypoints [KSEL].  If KPOI = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for KPOI.

        lab
            Force label to be listed (defaults to ALL).  See the DOFSEL command
            for labels.

        Notes
        -----
        Listing applies to the selected keypoints [KSEL] and the selected force
        labels [DOFSEL].

        This command is valid in any processor.
        """
        command = "FKLIST,%s,%s" % (str(kpoi), str(lab))
        return self.run(command, **kwargs)

    def form(self, lab="", **kwargs):
        """APDL Command: FORM

        Specifies the format of the file dump.

        Parameters
        ----------
        lab
            Format:

            RECO - Basic record description only (minimum output) (default).

            TEN - Same as RECO plus the first ten words of each record.

            LONG - Same as RECO plus all words of each record.

        Notes
        -----
        Specifies the format of the file dump (from the DUMP command).
        """
        command = "FORM,%s" % (str(lab))
        return self.run(command, **kwargs)

    def fileaux2(self, fname="", ident="", **kwargs):
        """APDL Command: FILEAUX2

        Specifies the binary file to be dumped.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ident
            ANSYS filename identifier.  See the Basic Analysis Guide for file
            descriptions and identifiers.  If not an ANSYS identifier, Ident
            will be used as the filename extension.

        --
            Unused field.

        Notes
        -----
        Specifies the binary file to be dumped with the DUMP command.
        """
        command = "FILEAUX2,%s,%s" % (str(fname), str(ident))
        return self.run(command, **kwargs)

    def starvget(self, parr="", entity="", entnum="", item1="", it1num="",
                 item2="", it2num="", kloop="", **kwargs):
        """APDL Command: *VGET

        Retrieves values and stores them into an array parameter.

        Parameters
        ----------
        parr
            The name of the resulting vector array parameter.  See *SET for
            name restrictions.

        entity
            Entity keyword.  Valid keywords are NODE, ELEM, KP, LINE, AREA,
            VOLU, etc. as shown for Entity = in the tables below.

        entnum
            The number of the entity (as shown for ENTNUM = in the tables
            below).

        item1
            The name of a particular item for the given entity.  Valid items
            are as shown in the Item1 columns of the tables below.

        it1num
            The number (or label) for the specified Item1 (if any).  Valid
            IT1NUM values are as shown in the IT1NUM columns of the tables
            below.  Some Item1 labels do not require an IT1NUM value.

        item2, it2num
            A second set of item labels and numbers to further qualify the item
            for which data is to be retrieved.  Most items do not require this
            level of information.

        kloop
            Field to be looped on:

            Loop on the ENTNUM  field (default). - Loop on the Item1 field.

            Loop on the IT1NUM field.  Successive items are as shown with IT1NUM. - Loop on the Item2 field.

        Notes
        -----
        Retrieves values for specified items and stores the values in an output
        vector of a user-named array parameter according to:

        ParR = f(Entity, ENTNUM, Item1, IT1NUM, Item2, IT2NUM)

        where (f) is the *GET function; Entity, Item1, and Item2 are keywords;
        and ENTNUM, IT1NUM, and IT2NUM are numbers or labels corresponding to
        the keywords. Looping continues over successive entity numbers (ENTNUM)
        for the KLOOP default.  For example, *VGET,A(1),ELEM,5,CENT,X returns
        the centroid x-location of element 5 and stores the result in the first
        location of A.  Retrieving continues with element 6, 7, 8, etc.,
        regardless of whether the element exists or is selected, until
        successive array locations are filled.  Use *VLEN or *VMASK to skip
        locations. Absolute values and scale factors may be applied to the
        result parameter [*VABS, *VFACT].  Results may be cumulative [*VCUM].
        See the *VOPER command for general details.  Results can be put back
        into an analysis by writing a file of the desired input commands with
        the *VWRITE command.  See also the *VPUT command.

        Both *GET and *VGET retrieve information from the active data stored in
        memory. The database is often the source, and sometimes the information
        is retrieved from common memory blocks that ANSYS uses to manipulate
        information. Although POST1 and POST26 operations use a *.rst file, GET
        data is accessed from the database or from the common blocks. Get
        operations do not access the *.rst file directly.

        The *VGET command retrieves both the unprocessed real and the imaginary
        parts (original and duplicate sector nodes and elements) of a cyclic
        symmetry solution.

        Each of the sections for accessing *VGET parameters are shown in the
        following order:

        *VGET PREP7 Items

        *VGET POST1 Items

        This command is valid in any processor.
        """
        command = "*VGET,%s,%s,%s,%s,%s,%s,%s,%s" % (str(parr), str(entity), str(entnum), str(item1), str(it1num), str(item2), str(it2num), str(kloop))
        return self.run(command, **kwargs)

    def esurf(self, xnode="", tlab="", shape="", **kwargs):
        """APDL Command: ESURF

        Generates elements overlaid on the free faces of selected nodes.

        Parameters
        ----------
        xnode
            Node number that is used only in the following two cases:

        tlab
            Generates target, contact, and hydrostatic fluid elements with
            correct direction of normals.

            TOP - Generates target and contact elements over beam and shell elements, or
                  hydrostatic fluid elements over shell elements, with the
                  normals the same as the underlying beam and shell elements
                  (default).

            BOTTOM - Generates target and contact elements over beam and shell elements, or
                     hydrostatic fluid elements over shell elements, with the
                     normals opposite to the underlying beam and shell
                     elements.

            If target or contact elements and hydrostatic fluid elements are defined on the same underlying shell elements, you only need to use this option once to orient the normals opposite to the underlying shell elements. - REVERSE

            Reverses the direction of the normals on existing selected target elements, contact elements, and hydrostatic fluid elements. - If target or contact elements and hydrostatic fluid elements are defined on the
                              same underlying shell elements, you only need to
                              use this option once to reverse the normals for
                              all selected elements.

        shape
            Used to specify the element shape for target element TARGE170
            (Shape = LINE or POINT) or TARGE169 elements (Shape = POINT).

            (blank) - The target element takes the same shape as the external surface of the
                      underlying element (default).

            LINE - Generates LINE or PARA (parabolic) segments on exterior of selected 3-D
                   elements.

            POINT - Generates POINT segments on selected nodes.

        Notes
        -----
        The ESURF command generates elements of the currently active element
        type overlaid on the free faces of existing elements. For example,
        surface elements (such as SURF151, SURF152, SURF153, SURF154, or
        SURF159) can be generated over solid elements (such as PLANE55,
        SOLID70, PLANE182, SOLID185, or SOLID272, respectively).

        Element faces are determined from the selected node set (NSEL) and the
        load faces for that element type. The operation is similar to that used
        for generating element loads from selected nodes via the SF,ALL
        command, except that elements (instead of loads) are generated. All
        nodes on the face must be selected for the face to be used. For shell
        elements, only face one of the element is available. If nodes are
        shared by adjacent selected element faces, the faces are not free and
        no element is generated.

        Elements created by ESURF are oriented such that their surface load
        directions are consistent with those of the underlying elements.
        Carefully check generated elements and their orientations.

        Generated elements use the existing nodes and the active MAT, TYPE,
        REAL, and ESYS attributes. The exception is when Tlab = REVERSE. The
        reversed target and contact elements have the same attributes as the
        original elements. If the underlying elements are solid elements, Tlab
        = TOP or BOTTOM has no effect.

        When the command generates a target element, the shape is by default
        the same as that of the underlying element. Issue  ESURF,,,LINE or
        ESURF,,,POINT to generate LINE, PARA, and POINT segments.

        The ESURF command can also generate the 2-D or 3-D node-to-surface
        element CONTA175, based on the selected node components of the
        underlying solid elements. When used to generate CONTA175 elements, all
        ESURF arguments are ignored. (If CONTA175 is the active element type,
        the path Main Menu> Preprocessor> Modeling> Create> Elements> Node-to-
        Surf uses ESURF to generate elements.)

        To generate SURF151 or SURF152 elements that have two extra nodes from
        FLUID116 elements, KEYOPT(5) for SURF151 or SURF152 is first set to 0
        and ESURF is issued. Then KEYOPT(5) for SURF151 or SURF152 is set to 2
        and MSTOLE is issued. For more information, see Using the Surface
        Effect Elements in the Thermal Analysis Guide.

        For hydrostatic fluid elements HSFLD241 and HSFLD242, the ESURF command
        generates triangular (2-D) or pyramid-shaped (3-D) elements with bases
        that are overlaid on the faces of selected 2-D or 3-D solid or shell
        elements. The single vertex for all generated elements is at the
        pressure node specified as XNODE. The generated elements fill the
        volume enclosed by the solid or shell elements. The nodes on the
        overlaid faces have translational degrees of freedom, while the
        pressure node shared by all generated elements has a single hydrostatic
        pressure degree of freedom, HDSP (see HSFLD241 and HSFLD242 for more
        information about the pressure node).
        """
        command = "ESURF,%s,%s,%s" % (str(xnode), str(tlab), str(shape))
        return self.run(command, **kwargs)

    def sedlist(self, sename="", kopt="", **kwargs):
        """APDL Command: SEDLIST

        Lists the DOF solution of a superelement after the use pass.

        Parameters
        ----------
        sename
            Name of the superelement in Jobname.DSUB to be listed.  If a
            number, it is the element number of the superelement as used in the
            use pass.  If ALL, list results for all superelements.

        kopt
            List key:

            0 - List summary data only.

            1 - List full contents.  Be aware that the listing may be extensive.

        Notes
        -----
        Lists the degree of freedom solution of a superelement after the
        substructure use pass.  Results may be listed for any superelement on
        File.DSUB.

        This command is valid in any processor.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "SEDLIST,%s,%s" % (str(sename), str(kopt))
        return self.run(command, **kwargs)

    def edload(self, option="", lab="", key="", cname="", par1="", par2="",
               ph_ase="", lcid="", scale="", btime="", dtime="", **kwargs):
        """APDL Command: EDLOAD

        Specifies loads for an explicit dynamics analysis.

        Parameters
        ----------
        option
            Label identifying the load option to be performed.

            ADD - Define a load (default). If Option = ADD, Cname must be a valid node or element
                  component name (or PART number). You must also specify a load
                  curve using Par1 and Par2 (previously defined array
                  parameters) or LCID (a previously defined load curve).

            DELE - Delete specified load. If Lab and Cname are blank, all loads are deleted. Par1,
                   Par2, PHASE, and LCID are ignored for this option.

            LIST - List specified load. If Lab and Cname are blank, all loads are listed. Par1,
                   Par2, PHASE, and LCID are ignored for this option.

        lab
            Valid load labels for loads applied to nodes:

            FX, FY, FZ - Forces.

            MX, MY, MZ - Moments.

            UX, UY, UZ - Displacements.

            ROTX, ROTY, ROTZ - Rotations.

            VX, VY, VZ - Velocities.

            OMGX, OMGY, OMGZ - Angular velocities.

            AX, AY, AZ - Accelerations (on nodes).

            ACLX, ACLY, ACLZ - Base accelerations.

            TEMP - Temperature.

        key
            When Lab = PRESS, KEY = Load key (face number) associated with a
            surface pressure load. Load keys (1,2,3, etc.) are listed under
            "Surface Loads" in the input data tables for each element type in
            the Element Reference.

        cname
            Name of existing component [CM] or PART number [EDPART] to which
            this load is to be applied.  For all load labels except the
            pressure load (Lab = PRESS) and the rigid body loads (Lab = RBxx),
            the component must consist of nodes. For pressure loads, the
            component must consist of elements. For rigid body loads, a part
            number must be input instead of a component name. The part number
            must correspond to a set of elements that has been identified as a
            rigid body [EDMP,RIGID,MAT].

        par1
            Name of user-defined array parameter that contains the time values
            of the load.

        par2
            Name of user-defined array parameter that contains the "data"
            values of the load corresponding to the time values in Par1.

        phase
            Phase of the analysis in which the load curve is to be used.

            0 - Curve is used in transient analysis only (default).

            1 - Curve is used in stress initialization or dynamic relaxation only.

            2 - Curve is used in both stress initialization (or dynamic relaxation) and
                transient analysis.

        lcid
            Data curve ID number representing the load curve to be applied. The
            load curve must have been previously defined using the EDCURVE
            command. If LCID is specified, Par1 and Par2 must be left blank (in
            the GUI, select “None” for Par1 and Par2).

        scale
            Load curve scale factor applied to the specified load curve. The
            scale value is applied to the data in Par2 or to the ordinate data
            in the load curve specified by LCID.

        btime
            Birth time, or time when imposed motion is activated. The default
            is 0.0. Some load types do not support birth and death time; see
            Table 132: Birth Time, Death Time, and CID Support in the Notes
            section for more information.

        dtime
            Death time, or time when imposed motion is removed. The default is
            1 x 1038. Some load types do not support birth and death time; see
            Table 132: Birth Time, Death Time, and CID Support in the Notes
            section for more information.

        Notes
        -----
        If a component name is input (Cname) and the specified component
        definition is changed before the SOLVE command, the last definition
        will be used.

        You can specify the load data by inputting LCID (the ID number of a
        previously defined load curve) or by inputting the two array parameters
        Par1 and Par2 (which contain time and load values, respectively). The
        input for Par1 and Par2 may be a single column array parameter, or a
        specific column from a multi-column array parameter. A starting array
        element number can be specified for Par1 and Par2; if none is
        specified, array element 1 is used by default.
        """
        command = "EDLOAD,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(option), str(lab), str(key), str(cname), str(par1), str(par2), str(ph_ase), str(lcid), str(scale), str(btime), str(dtime))
        return self.run(command, **kwargs)

    def dkdele(self, kpoi="", lab="", **kwargs):
        """APDL Command: DKDELE

        Deletes DOF constraints at a keypoint.

        Parameters
        ----------
        kpoi
            Keypoint for which constraint is to be deleted.  If ALL, delete for
            all selected keypoints [KSEL].  If KPOI = P, graphical picking is
            enabled and all remaining command fields are ignored (valid only in
            the GUI).  A component name may also be substituted for KPOI.

        lab
            Valid degree of freedom label.  If ALL, use all appropriate labels.
            Structural labels:  UX, UY, or UZ (displacements); ROTX, ROTY, or
            ROTZ (rotations); WARP (warping).  Thermal labels: TEMP, TBOT, TE2,
            TE3, . . ., TTOP (temperature). Acoustic labels:  PRES (pressure);
            UX, UY, or UZ (displacements for FSI coupled elements). Electric
            label:  VOLT (voltage).  Magnetic labels:  MAG (scalar magnetic
            potential); AX, AY, or AZ (vector magnetic potentials).  Diffusion
            label: CONC (concentration).

        Notes
        -----
        Deletes the degree of freedom constraints (and all corresponding finite
        element constraints) at a keypoint.  See the DDELE command for details.

        This command is also valid in PREP7.
        """
        command = "DKDELE,%s,%s" % (str(kpoi), str(lab))
        return self.run(command, **kwargs)

    def aux15(self, **kwargs):
        """APDL Command: /AUX15

        Enters the IGES file transfer processor.

        Notes
        -----
        Enters the IGES file transfer processor (ANSYS auxiliary processor
        AUX15), used to read an IGES data file into the ANSYS program.

        This command is valid only at the Begin Level.
        """
        command = "/AUX15," % ()
        return self.run(command, **kwargs)

    def eplot(self, **kwargs):
        """APDL Command: EPLOT

        Produces an element display.

        Notes
        -----
        Produces an element display of the selected elements. In full graphics,
        only those elements faces with all of their corresponding nodes
        selected are plotted. In PowerGraphics, all element faces of the
        selected element set are plotted irrespective of the nodes selected.
        However, for both full graphics and PowerGraphics, adjacent or
        otherwise duplicated faces of 3-D solid elements will not be displayed
        in an attempt to eliminate plotting of interior facets. See the DSYS
        command for display coordinate system issues.

        This command will display curvature in midside node elements when
        PowerGraphics is activated [/GRAPHICS,POWER] and /EFACET,2 or /EFACET,4
        are enabled.  (To display curvature, two facets per edge is recommended
        [/EFACET,2]).  When you specify /EFACET,1, PowerGraphics does not
        display midside nodes. /EFACET has no effect on EPLOT for non-midside
        node elements.

        This command is valid in any processor.
        """
        command = "EPLOT," % ()
        return self.run(command, **kwargs)

    def secmodif(self, secid="", kywrd="", **kwargs):
        """APDL Command: SECMODIF

        Modifies a pretension section

        Parameters
        ----------
        secid
            Unique section number. This number must already be assigned to a
            section.

        norm
            Keyword specifying that the command will modify the pretension
            section normal direction.

        nx, ny, nz
            Specifies the individual normal components to modify.

        kcn
            Coordinate system number. This can be either 0 (Global Cartesian),
            1 (Global Cylindrical) 2 (Global Spherical), 4 (Working Plane), 5
            (Global Y Axis Cylindrical) or an arbitrary reference number
            assigned to a coordinate system.

        Notes
        -----
        The SECMODIF command either modifies the normal for a specified
        pretension section, or changes the name of the specified pretension
        surface.
        """
        command = "SECMODIF,%s,%s" % (str(secid), str(kywrd))
        return self.run(command, **kwargs)

    def kgen(self, itime="", np1="", np2="", ninc="", dx="", dy="", dz="",
             kinc="", noelem="", imove="", **kwargs):
        """APDL Command: KGEN

        Generates additional keypoints from a pattern of keypoints.

        Parameters
        ----------
        itime
            Do this generation operation a total of ITIME times, incrementing
            all keypoints in the given pattern automatically (or by KINC) each
            time after the first.  ITIME must be more than 1 for generation to
            occur.

        np1, np2, ninc
            Generate keypoints from the pattern of keypoints beginning with NP1
            to NP2 (defaults to NP1) in steps of NINC (defaults to 1).  If NP1
            = ALL, NP2 and NINC are ignored and the pattern is all selected
            keypoints [KSEL].  If NP1 is negative, NP2 and NINC are ignored and
            the last |NP1| keypoints (in sequence from the highest keypoint
            number) are used as the pattern to be repeated.  If NP1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NP1 (NP2 and NINC are ignored).

        dx, dy, dz
            Keypoint location increments in the active coordinate system (DR,
            Dθ, DZ for cylindrical, DR, Dθ, DΦ for spherical).

        kinc
            Keypoint increment between generated sets.  If zero, the lowest
            available keypoint numbers are assigned [NUMSTR].

        noelem
            Specifies if elements and nodes are also to be generated:

            0 - Generate nodes and point elements associated with the original keypoints, if
                they exist.

            1 - Do not generate nodes and elements.

        imove
            Specifies whether keypoints will be moved or newly defined:

            0 - Generate additional keypoints as requested with the ITIME argument.

            1 - Move original keypoints to new position retaining the same keypoint numbers
                (ITIME, KINC, and NOELEM are ignored).  Valid only if the old
                keypoints are no longer needed at their original positions.
                Corresponding meshed items are also moved if not needed at
                their original position.

        Notes
        -----
        Generates additional keypoints (and corresponding mesh) from a given
        keypoint pattern.  The MAT, TYPE, REAL, and ESYS attributes are based
        upon the keypoints in the pattern and not upon the current settings.
        Generation is done in the active coordinate system.  Keypoints in the
        pattern may have been defined in any coordinate system.  However, solid
        modeling in a toroidal coordinate system is not recommended.
        """
        command = "KGEN,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(itime), str(np1), str(np2), str(ninc), str(dx), str(dy), str(dz), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def spline(self, p1="", p2="", p3="", p4="", p5="", p6="", xv1="", yv1="",
               zv1="", xv6="", yv6="", zv6="", **kwargs):
        """APDL Command: SPLINE

        Generates a segmented spline through a series of keypoints.

        Parameters
        ----------
        p1, p2, p3, . . . , p6
            Keypoints through which the spline is fit.  At least two must be
            defined.  If P1 = P, graphical picking is enabled and all remaining
            command fields are ignored (valid only in the GUI).

        Notes
        -----
        The output from this command is a series of connected lines (one line
        between each pair of keypoints) that together form a spline.  Note that
        solid modeling in a toroidal coordinate system is not recommended.
        """
        command = "SPLINE,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(p1), str(p2), str(p3), str(p4), str(p5), str(p6), str(xv1), str(yv1), str(zv1), str(xv6), str(yv6), str(zv6))
        return self.run(command, **kwargs)

    def mfconv(self, lab="", toler="", minref="", **kwargs):
        """APDL Command: MFCONV

        Sets convergence values for an ANSYS Multi-field solver analysis.

        Parameters
        ----------
        lab
            Valid labels:

        toler
            Convergence tolerance about program calculated reference value (the
            L2 norm of the new load in a multi-field analysis). Defaults to
            0.01 (1%) for all labels. Must be less than 1.0.

        --
            Unused field.

        minref
            The minimum value allowed for the program calculated reference
            value. If negative, no minimum is enforced. Defaults to 1.0e-6 for
            all labels. Not available in the GUI. MINREF corresponds to
            ||ϕnew|| as defined in Set up Stagger Solution in the Coupled-Field
            Analysis Guide.

        Notes
        -----
        MFCONV sets convergence values for variables at the ANSYS Multi-field
        solver interface.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFCONV,%s,%s,%s" % (str(lab), str(toler), str(minref))
        return self.run(command, **kwargs)

    def ftsize(self, mxloc="", mxev="", mxlod="", **kwargs):
        """APDL Command: FTSIZE

        Defines the fatigue data storage array.

        Parameters
        ----------
        mxloc
            Maximum number of fatigue locations (defaults to 5).

        mxev
            Maximum number of fatigue events (defaults to 10).

        mxlod
            Maximum number of loadings in each event (defaults to 3).

        Notes
        -----
        Defines the size and erases the stress conditions for the fatigue data
        storage array.  A stress condition is a loading (stresses) at a
        particular location (node) for a particular event.  Size is defined in
        terms of the maximum number of locations, events, and loadings.  The
        array size cannot be changed once data storage has begun (without
        erasing all previously stored data).  If a size change is necessary,
        see the FTWRITE command.
        """
        command = "FTSIZE,%s,%s,%s" % (str(mxloc), str(mxev), str(mxlod))
        return self.run(command, **kwargs)

    def mfinter(self, option="", **kwargs):
        """APDL Command: MFINTER

        Specifies the interface load transfer interpolation option for an ANSYS
        Multi-field solver analysis.

        Parameters
        ----------
        option
            Interface load transfer option:

            CONS - Conservative formulation for load transfer.

            NONC - Nonconservative formulation for load transfer (default).

        Notes
        -----
        This command only applies to the interpolation method for forces, heat
        flux, and heat generation. Displacement and temperature transfers are
        always nonconservative.

        For more information on conservative and nonconservative load transfer,
        see Load Transfer in the Coupled-Field Analysis Guide.

        This command is also valid in PREP7.

        See Multi-field Commands in the Coupled-Field Analysis Guide for a list
        of all ANSYS Multi-field solver commands and their availability for MFS
        and MFX analyses.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "MFINTER,%s" % (str(option))
        return self.run(command, **kwargs)

    def exp(self, ir="", ia="", name="", facta="", factb="", **kwargs):
        """APDL Command: EXP

        Forms the exponential of a variable.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the resulting variable (2 to
            NV [NUMVAR]). If this number is the same as for a previously
            defined variable, the previously defined variable will be
            overwritten with this result.

        ia
            Reference number of the variable to be operated on.

        --, --
            Unused fields.

        name
            Thirty-two character name for identifying the variable on the
            printout and displays. Embedded blanks are compressed upon output.

        --, --
            Unused fields.

        facta
            Scaling factor applied to variable IA (defaults to 1.0).

        factb
            Scaling factor (positive or negative) applied to the operation
            (defaults to 1.0).

        Notes
        -----
        Forms the exponential of a variable according to the operation:

        IR = FACTB*EXP(FACTA x IA)
        """
        command = "EXP,%s,%s,%s,%s,%s" % (str(ir), str(ia), str(name), str(facta), str(factb))
        return self.run(command, **kwargs)

    def prerr(self, **kwargs):
        """APDL Command: PRERR

        Prints SEPC and TEPC.

        Notes
        -----
        Prints the percent error in structural energy norm (SEPC) and the
        thermal energy norm percent error (TEPC).  Approximations of mesh
        discretization error associated with a solution are calculated for
        analyses having structural or thermal degrees of freedom.

        The structural approximation is based on the energy error (which is
        similar in concept to the strain energy) and represents the error
        associated with the discrepancy between the calculated stress field and
        the globally continuous stress field (see POST1 - Error Approximation
        Technique in the Mechanical APDL Theory Reference).  This discrepancy
        is due to the assumption in the elements that only the displacements
        are continuous at the nodes.  The stress field is calculated from the
        displacements and should also be continuous, but generally is not.

        Thermal analyses may use any solid and shell thermal element having
        only temperature degrees of freedom.  The thermal approximation is
        based on the total heat flow dissipation and represents the error
        associated with the discrepancy between the calculated nodal thermal
        flux within an element and a continuous global thermal flux.  This
        continuous thermal flux is calculated with the normal nodal averaging
        procedure.

        The volume (result label VOLU) is used to calculate the energy error
        per element (result label SERR for the structural energy error and TERR
        for the thermal energy error).  These energy errors, along with the
        appropriate energy, are then used to calculate the percent error in
        energy norm (SEPC for structural and TEPC for thermal). These
        percentages can be listed by the PRERR command, retrieved by the *GET
        command (with labels SEPC and TEPC) for further calculations, and shown
        on the displacement display (PLDISP), as applicable.

        For structural analyses, the maximum absolute value of nodal stress
        variation of any stress component for any node of an element (result
        item SDSG) is also calculated.  Similarly, for thermal gradient
        components, TDSG is calculated.  Minimum and maximum result bounds
        considering the possible effect of discretization error will be shown
        on contour displays (PLNSOL).  For shell elements, the top surface
        location is used to produce a meaningful percentage value.  SERR, TERR,
        SEPC, TEPC, SDSG, and TDSG will be updated whenever the nodal stresses
        or fluxes are recalculated.

        If the energy error is a significant portion of the total energy, then
        the analysis should be repeated using a finer mesh to obtain a more
        accurate solution.  The energy error is relative from problem to
        problem but will converge to a zero energy error as the mesh is
        refined.  An automated adaptive meshing procedure using this energy
        error is described with the ADAPT macro.

        The following element- and material-type limitations apply:

        Valid with most 2-D solid, 3-D solid, axisymmetric solid, or 3-D shell
        elements.

        The following element types are not valid: SHELL28, SHELL41, and
        SOLID65.

        The model should have only structural or thermal degrees of freedom.

        The analysis must be linear (for both material and geometry).

        Multi-material (for example, composite) elements are not valid.

        Transition regions from one material to another are not valid (that is,
        the entire model should consist of one material).

        Anisotropic materials (TB,ANEL) are not considered.
        """
        command = "PRERR," % ()
        return self.run(command, **kwargs)

    def menu(self, key="", **kwargs):
        """APDL Command: /MENU

        Activates the Graphical User Interface (GUI).

        Parameters
        ----------
        key
            Activation key:

            ON - Activates the menu system (device dependent).

            GRPH - Enters non-GUI graphics mode.

        Notes
        -----
        Activates the Graphical User Interface (GUI).

        Caution:: : if you include the /MENU,ON command in your start162.ans,
        it should be the last command in the file.  Any commands after /MENU,ON
        may be ignored.  (It is not necessary to include the /SHOW and /MENU,ON
        commands in start162.ans if you will be using the launcher to enter the
        ANSYS program.)

        This command is valid in any processor.
        """
        command = "/MENU,%s" % (str(key))
        return self.run(command, **kwargs)

    def smult(self, labr="", lab1="", lab2="", fact1="", fact2="", **kwargs):
        """APDL Command: SMULT

        Forms an element table item by multiplying two other items.

        Parameters
        ----------
        labr
            Label assigned to results.  If same as existing label, the existing
            values will be overwritten by these results.

        lab1
            First labeled result item in operation.

        lab2
            Second labeled result item in operation (may be blank).

        fact1
            Scale factor applied to Lab1. A (blank) or '0' entry defaults to
            1.0.

        fact2
            Scale factor applied to Lab2. A (blank) or '0' entry defaults to
            1.0.

        Notes
        -----
        Forms a labeled result item (see ETABLE command) for the selected
        elements by multiplying two existing labeled result items according to
        the operation:

        LabR = (FACT1 x Lab1) x (FACT2 x Lab2)

        May also be used to scale results for a single labeled result item.  If
        absolute values are requested [SABS,1], the absolute values of Lab1 and
        Lab2 are used.
        """
        command = "SMULT,%s,%s,%s,%s,%s" % (str(labr), str(lab1), str(lab2), str(fact1), str(fact2))
        return self.run(command, **kwargs)

    def sfcum(self, lab="", oper="", fact="", fact2="", **kwargs):
        """APDL Command: SFCUM

        Specifies that surface loads are to be accumulated.

        Parameters
        ----------
        lab
            Valid surface load label.  If ALL, use all appropriate labels.

        oper
            Accumulation key:

            REPL - Subsequent values replace the previous values (default).

            ADD - Subsequent values are added to the previous values.

            IGNO - Subsequent values are ignored.

        fact
            Scale factor for the first surface load value. A (blank) or '0'
            entry defaults to 1.0.

        fact2
            Scale factor for the second surface load value. A (blank) or '0'
            entry defaults to 1.0.

        Notes
        -----
        Allows repeated surface loads (pressure, convection, etc.) to be
        replaced, added, or ignored.  Surface loads are applied with the SF,
        SFE, and SFBEAM commands.  Issue the SFELIST command to list the
        surface loads.  The operations occur when the next surface load
        specifications are defined.  For example, issuing the SF command with a
        pressure value of 25 after a previous SF command with a pressure value
        of 20 causes the current value of that pressure to be 45 with the add
        operation, 25 with the replace operation, or 20 with the ignore
        operation.  All new pressures applied with SF after the ignore
        operation will be ignored, even if no current pressure exists on that
        surface.

        Scale factors are also available to multiply the next value before the
        add or replace operation.  A scale factor of 2.0 with the previous
        "add" example results in a pressure of 70.  Scale factors are applied
        even if no previous values exist.  Issue SFCUM,STAT to show the current
        label, operation, and scale factors.  Solid model boundary conditions
        are not affected by this command, but boundary conditions on the FE
        model are affected.

        Note:: : The FE boundary conditions may still be overwritten by
        existing solid model boundary conditions if a subsequent boundary
        condition transfer occurs.

        SFCUM does not work for tabular boundary conditions.

        This command is also valid in PREP7.
        """
        command = "SFCUM,%s,%s,%s,%s" % (str(lab), str(oper), str(fact), str(fact2))
        return self.run(command, **kwargs)

    def slashtype(self, wn="", type="", **kwargs):
        """APDL Command: /TYPE

        Defines the type of display.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        type
            Display type.  Defaults to ZBUF for raster mode displays or BASIC
            for vector mode displays:

            BASIC or 0 - Basic display (no hidden or section operations).

            SECT or 1 - Section display (plane view).  Use the /CPLANE command to define the cutting
                        plane.

            HIDC or 2 - Centroid hidden display (based on item centroid sort).

            HIDD or 3 - Face hidden display (based on face centroid sort).

            HIDP or 4 - Precise hidden display (like HIDD but with more precise checking). Because all
                        facets are sorted, this mode can be extremely slow,
                        especially for large models.

            CAP or 5 - Capped hidden display (same as combined SECT and HIDD with model in front of
                       section plane removed).

            ZBUF or 6 - Z-buffered display (like HIDD but using software Z-buffering).

            ZCAP or 7 - Capped Z-buffered display (same as combined SECT and ZBUF with model in front
                        of section plane removed).

            ZQSL or 8 - QSLICE Z-buffered display (same as SECT but the edge lines of the remaining 3-D
                        model are shown).

            HQSL or 9 - QSLICE precise hidden display (like ZQSL but using precise hidden).

        Notes
        -----
        Defines the type of display, such as section display or hidden-line
        display.  Use the /DEVICE command to specify either raster or vector
        mode.

        The SECT, CAP, ZCAP, ZQSL, and HQSL options produce section displays.
        The section or "cutting" plane is specified on the /CPLANE command as
        either normal to the viewing vector at the focus point (default), or as
        the working plane.

        When you use PowerGraphics, the section display options (Section,
        Slice, and Capped) use different averaging techniques for the interior
        and exterior results. Because of the different averaging schemes,
        anomalies may appear at the transition areas. In many cases, the
        automatically computed MIN and MAX values will differ from the full
        range of interior values. You can lessen the effect of these anomalies
        by issuing AVRES,,FULL (Main Menu> General Post Proc> Options for
        Outp). This command sets your legend's automatic contour interval range
        according to the minimum and maximum results found throughout the
        entire model.

        With PowerGraphics active (/GRAPHICS,POWER), the averaging scheme for
        surface data with interior element data included (AVRES,,FULL) and
        multiple facets per edge (/EFACET,2 or /EFACET,4) will yield differing
        minimum and maximum contour values depending on the  Z-Buffering
        options (/TYPE,,6 or /TYPE,,7).  When the Section data is not included
        in the averaging schemes (/TYPE,,7), the resulting absolute value for
        the midside node is significantly smaller.

        The HIDC, HIDD, HIDP, ZBUF, ZQSL, and HQSL options produce displays
        with "hidden" lines removed.  Hidden lines are lines obscured from view
        by another element, area, etc.  The choice of non-Z-buffered hidden-
        line procedure types is available only for raster mode [/DEVICE]
        displays.  For vector mode displays, all non-Z-buffered "hidden-line"
        options use the same procedure (which is slightly different from the
        raster procedures).  Both geometry and postprocessing displays may be
        of the hidden-line type.  Interior stress contour lines within solid
        elements can also be removed as hidden lines, leaving only the stress
        contour lines and element outlines on the visible surfaces.  Midside
        nodes of elements are ignored on postprocessing displays.  Overlapping
        elements will not be displayed.

        The ZBUF, ZCAP, and ZQSL options use a specific hidden-line technique
        called software Z-buffering.  This technique allows a more accurate
        display of overlapping surfaces (common when using Boolean operations
        or /ESHAPE on element displays), and allows smooth shaded displays on
        all interactive graphics displays.  Z-buffered displays can be
        performed faster than HIDP and CAP type displays for large models.  See
        also the /LIGHT, /SHADE, and /GFILE commands for additional options
        when Z-buffering is used.

        This command is valid in any processor.
        """
        command = "/TYPE,%s,%s" % (str(wn), str(type))
        return self.run(command, **kwargs)

    def angle(self, wn="", theta="", axis="", kincr="", **kwargs):
        """APDL Command: /ANGLE

        Rotates the display about an axis.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        theta
            Angle (degrees) for changing display orientation (positive,
            counterclockwise about specified axis).

        axis
            Rotation axis:  XS, YS, or ZS (default) for the screen axes;  XM,
            YM, or ZM for the global Cartesian model axes.  ZS is normal to the
            screen; all axes pass through the focus point.

        kincr
            Cumulative rotation key:

            0 - Do not use cumulative successive rotations.

            1 - Use cumulative rotations.  Rotations are relative to the previous rotation.
                View settings (/VIEW) are recalculated.

        Notes
        -----
        Default orientation is YS vertical. When the /XFRM command is set for
        rotation about two points, or for entities, the /ANGLE command is
        functional only for Axis = ZS or ZM and KINCR = 1.

        This command is valid in any processor.
        """
        command = "/ANGLE,%s,%s,%s,%s" % (str(wn), str(theta), str(axis), str(kincr))
        return self.run(command, **kwargs)

    def fl(self, nloc="", node="", scfx="", scfy="", scfz="", title="",
           **kwargs):
        """APDL Command: FL

        Defines a set of fatigue location parameters.

        Parameters
        ----------
        nloc
            Reference number for this location (within MXLOC).  When defining a
            new location, defaults to lowest unused location.  If the specified
            NODE is already associated with a location, NLOC defaults to that
            existing location.

        node
            Node number corresponding to this location (must be unique).  Used
            only to associate a node with a new location or to find an existing
            location (if NLOC is not input).  If NODE = -1 (or redefined),
            erase all parameters and fatigue stresses for this location.

        scfx, scfy, scfz
            Stress concentration factors applied to the total stresses.
            Factors are applied in the global X, Y, and Z directions unless the
            axisymmetric option of the FSSECT is used (i.e., RHO is nonzero),
            in which case the factors are applied in the section x, y, and z
            (radial, axial, and hoop) directions.

        title
            User-defined title for this location (up to 20 characters).

        Notes
        -----
        Repeat FL command to define additional sets of location parameters
        (MXLOC limit), to redefine location parameters, or to delete location
        stress conditions.

        One location must be defined for each node of interest and only one
        node can be associated with each location.  See the FTSIZE command for
        the maximum locations (MXLOC) allowed.  A location will be
        automatically defined for a node not having a location when the FSSECT,
        FSNODE, or FS command is issued.  Automatically defined locations are
        assigned the lowest available location number, unity stress
        concentration factors, and no title.
        """
        command = "FL,%s,%s,%s,%s,%s,%s" % (str(nloc), str(node), str(scfx), str(scfy), str(scfz), str(title))
        return self.run(command, **kwargs)

    def ldrag(self, nk1="", nk2="", nk3="", nk4="", nk5="", nk6="", nl1="",
              nl2="", nl3="", nl4="", nl5="", nl6="", **kwargs):
        """APDL Command: LDRAG

        Generates lines by sweeping a keypoint pattern along  path.

        Parameters
        ----------
        nk1, nk2, nk3, . . . , nk6
            List of keypoints in the pattern to be dragged (6 maximum if using
            keyboard entry).  If NK1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).  If
            NK1 = ALL, all selected keypoints (except those that define the
            drag path) will be swept along the path.  A component name may also
            be substituted for NK1.

        nl1, nl2, nl3, . . . , nl6
            List of lines defining the path along which the pattern is to be
            dragged (6 maximum if using keyboard entry).  Must be a continuous
            set of lines.

        Notes
        -----
        Generates lines (and their corresponding keypoints) by sweeping a given
        keypoint pattern along a characteristic drag path.  If the drag path
        consists of multiple lines, the drag direction is determined by the
        sequence in which the path lines are input (NL1, NL2, etc.).  If the
        drag path is a single line (NL1), the drag direction is from the
        keypoint on the drag line that is closest to the first keypoint of the
        given pattern to the other end of the drag line.

        The magnitude of the vector between the keypoints of the given pattern
        and the first path keypoint remains constant for all generated keypoint
        patterns and the path keypoints.  The direction of the vector relative
        to the path slope also remains constant so that patterns may be swept
        around curves.  Keypoint and line numbers are automatically assigned
        (beginning with the lowest available values [NUMSTR]).  For best
        results, the entities to be dragged should be orthogonal to the start
        of the drag path.  Drag operations that produce an error message may
        create some of the desired entities prior to terminating.
        """
        command = "LDRAG,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nk1), str(nk2), str(nk3), str(nk4), str(nk5), str(nk6), str(nl1), str(nl2), str(nl3), str(nl4), str(nl5), str(nl6))
        return self.run(command, **kwargs)

    def sfalist(self, area="", lab="", **kwargs):
        """APDL Command: SFALIST

        Lists the surface loads for the specified area.

        Parameters
        ----------
        area
            Area at which surface load is to be listed.  If ALL (or blank),
            list for all selected areas [ASEL].  If AREA = P, graphical picking
            is enabled and all remaining command fields are ignored (valid only
            in the GUI).  A component name may be substituted for AREA.

        lab
            Valid surface load label.  If ALL (or blank), use all appropriate
            labels.  See the SFA command for labels.

        Notes
        -----
        This command is valid in any processor.
        """
        command = "SFALIST,%s,%s" % (str(area), str(lab))
        return self.run(command, **kwargs)

    def prvect(self, item="", lab2="", lab3="", labp="", **kwargs):
        """APDL Command: PRVECT

        Prints results as vector magnitude and direction cosines.

        Parameters
        ----------
        item
            Predefined vector item (from Table 226: PRVECT - Valid Item and
            Component Labels below) or a label identifying the i-component of a
            user-defined vector.

        lab2
            Label identifying the j-component of a user-defined vector. In most
            cases, this value must be blank if Item is selected from
            Table 226: PRVECT - Valid Item and Component Labels. Individual
            principal stresses (Item = S) or principal strains (Item = EPxx)
            may be printed by specifying the value as 1, 2, or 3.

        lab3
            Label identifying the k-component of a user-defined vector.  Must
            be blank if Item is selected from list below or for 2-D user
            defined vector.

        labp
            Label assigned to resultant vector for printout labeling (defaults
            to Item).

        Notes
        -----
        Prints various solution results as vector magnitude and direction
        cosines for the selected nodes and/or elements.  For example, PRVECT,U
        prints the displacement magnitude and its direction cosines for all
        selected nodes.  For nodal degree of freedom vector results, direction
        cosines are with respect to the results coordinate system RSYS. For
        element results, direction cosines are with respect to the global
        Cartesian system. Item components may be printed with the PRNSOL
        command.  Various results also depend upon the recalculation method and
        the selected results location [LAYER, SHELL, NSEL, and ESEL].  Items
        may be selected from a set of recognized vector labels (Item) or a
        vector may be defined from up to three scalar labels (Item,Lab2,Lab3).
        Scalar labels may be user-defined with the ETABLE command.

        Portions of this command are not supported by PowerGraphics
        [/GRAPHICS,POWER].

        Table: 226:: : PRVECT - Valid Item and Component Labels
        """
        command = "PRVECT,%s,%s,%s,%s" % (str(item), str(lab2), str(lab3), str(labp))
        return self.run(command, **kwargs)

    def vmask(self, par="", **kwargs):
        """APDL Command: *VMASK

        Specifies an array parameter as a masking vector.

        Parameters
        ----------
        par
            Name of the mask parameter.  The starting subscript must also be
            specified.

        Notes
        -----
        Specifies the name of the parameter whose values are to be checked for
        each resulting row operation.  The mask vector usually contains only 0
        (for false) and 1 (for true) values.  For each row operation the
        corresponding mask vector value is checked.  A true value allows the
        operation to be done.  A false value skips the operation (and retains
        the previous results).  A mask vector can be created from direct input,
        such as M(1) = 1,0,0,1,1,0,1; or from the DATA function of the *VFILL
        command.  The NOT function of the *VFUN command can be used to reverse
        the logical sense of the mask vector.  The logical compare operations
        (LT, LE, EQ, NE, GE, and GT) of the *VOPER command also produce a mask
        vector by operating on two other vectors.  Any numeric vector can be
        used as a mask vector since the actual interpretation assumes values
        less than 0.0 are 0.0 (false) and values greater than 0.0 are 1.0
        (true).  If the mask vector is not specified (or has fewer values than
        the result vector), true (1.0) values are assumed for the unspecified
        values.  Another skip control may be input with NINC on the *VLEN
        command.  If both are present, operations occur only when both are
        true.  The mask setting is reset to the default (no mask) after each
        *VXX or *MXX operation.  Use *VSTAT to list settings.

        This command is valid in any processor.
        """
        command = "*VMASK,%s" % (str(par))
        return self.run(command, **kwargs)

    def rmaster(self, node="", lab="", **kwargs):
        """APDL Command: RMASTER

        Defines master nodes for the ROM method.

        Parameters
        ----------
        node
            Node number at which master degree of freedom is defined  If Node =
            P, graphical picking is enabled and all remaining command fields
            are ignored (valid only in the GUI).

        lab
            Valid labels are "ADD" (default) and "DEL".

        Notes
        -----
        Defines master nodes for the ROM.  Master nodes are used to track the
        total displacement of a structure in the operating direction [RMANL].
        They may be used as attachment points for 1-D structural elements
        during a ROM use pass via the UX degree of freedom.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMASTER,%s,%s" % (str(node), str(lab))
        return self.run(command, **kwargs)

    def lsclear(self, lab="", **kwargs):
        """APDL Command: LSCLEAR

        Clears loads and load step options from the database.

        Parameters
        ----------
        lab
            Label identifying the data to be cleared:

            SOLID - Delete only solid model loads.

            FE - Delete only finite element loads.

            INER - Delete only inertia loads (ACEL, etc.).

            LFACT - Initialize only load factors (on DCUM, FCUM, SFCUM, etc.).

            LSOPT - Initialize only load step options.

            ALL - Delete all loads and initialize all load step options and load factors.

        Notes
        -----
        Loads are deleted, and load step options are initialized to their
        default values.

        This command is also valid in PREP7.
        """
        command = "LSCLEAR,%s" % (str(lab))
        return self.run(command, **kwargs)

    def pstatus(self, wn="", **kwargs):
        """APDL Command: /PSTATUS

        Displays the global or window display specifications.

        Parameters
        ----------
        wn
            Window number for status (defaults to global specifications).

        Notes
        -----
        Displays the current global or window display specifications.  Global
        display specifications are common to all windows (e.g. /SHOW, etc.).
        Window display specifications are specific to one window (e.g. /VIEW,
        /TYPE, etc.).

        This command is valid in any processor.
        """
        command = "/PSTATUS,%s" % (str(wn))
        return self.run(command, **kwargs)

    def bucopt(self, method="", nmode="", shift="", ldmulte="", rangekey="",
               **kwargs):
        """APDL Command: BUCOPT

        Specifies buckling analysis options.

        Parameters
        ----------
        method
            Mode extraction method to be used for the buckling analysis:

            LANB - Block Lanczos

            SUBSP - Subspace iteration

        nmode
            Number of buckling modes (i.e., eigenvalues or load multipliers) to
            extract (defaults to 1).

        shift
            By default, this value acts as the initial shift point about which
            the buckling modes are calculated (defaults to 0.0).

        ldmulte
            Boundary for the load multiplier range of interest (defaults to ).

        rangekey
            Key used to control the behavior of the eigenvalue extraction
            method (defaults to CENTER):

            CENTER - Use the CENTER option control (default); the program computes NMODE buckling
                     modes centered around SHIFT in the range of (-LDMULTE,
                     +LDMULTE).

            RANGE - Use the RANGE option control; the program computes NMODE buckling modes in the
                    range of (SHIFT, LDMULTE).

        Notes
        -----
        Eigenvalues from a buckling analysis can be negative and/or positive.
        The program sorts the eigenvalues from the most negative to the most
        positive values. The minimum buckling load factor may correspond to the
        smallest eigenvalue in absolute value, or to an eigenvalue within the
        range, depending on your application (i.e., linear perturbation
        buckling analysis or purely linear buckling analysis).

        It is recommended that you request an additional few buckling modes
        beyond what is needed in order to enhance the accuracy of the final
        solution. It is also recommended that you input a non zero SHIFT value
        and a reasonable LDMULTE value (i.e., a smaller LDMULTE that is closer
        to the last buckling mode of interest) when numerical problems are
        encountered.

        When using the RANGE option, defining a range that spans zero is not
        recommended. If you are seeking both negative and positive eigenvalues,
        it is recommended that you use the CENTER option.

        This command is also valid in PREP7.  If used in SOLUTION, this command
        is valid only within the first load step.

        Distributed ANSYS Restriction: Both extraction methods (LANB and SUBSP)
        are supported within Distributed ANSYS. However, the subspace iteration
        eigensolver (SUBSP) is the only distributed eigensolver that will run a
        fully distributed solution. The Block Lanczos eigensolver (LANB) is not
        a distributed eigensolver; therefore, you will not see the full
        performance improvements with this method that you would with a fully
        distributed solution.
        """
        command = "BUCOPT,%s,%s,%s,%s,%s" % (str(method), str(nmode), str(shift), str(ldmulte), str(rangekey))
        return self.run(command, **kwargs)

    def nwpave(self, n1="", n2="", n3="", n4="", n5="", n6="", n7="", n8="",
               n9="", **kwargs):
        """APDL Command: NWPAVE

        Moves the working plane origin to the average location of nodes.

        Parameters
        ----------
        n1, n2, n3, . . . , n9
            Nodes used in calculation of the average.  At least one must be
            defined.  If N1 = P, graphical picking is enabled and all remaining
            command fields are ignored (valid only in the GUI).

        Notes
        -----
        Averaging is based on the active coordinate system.

        This command is valid in any processor.
        """
        command = "NWPAVE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(n1), str(n2), str(n3), str(n4), str(n5), str(n6), str(n7), str(n8), str(n9))
        return self.run(command, **kwargs)

    def icdele(self, **kwargs):
        """APDL Command: ICDELE

        Deletes initial conditions at nodes.

        Notes
        -----
        Deletes all initial conditions previously specified with the IC command
        at all nodes.

        This command is also valid in PREP7.
        """
        command = "ICDELE," % ()
        return self.run(command, **kwargs)

    def vrotat(self, na1="", na2="", na3="", na4="", na5="", na6="", pax1="",
               pax2="", arc="", nseg="", **kwargs):
        """APDL Command: VROTAT

        Generates cylindrical volumes by rotating an area pattern about an
        axis.

        Parameters
        ----------
        na1, na2, na3, . . . , na6
            List of areas in the pattern to be rotated (6 maximum if using
            keyboard entry).  Areas must lie to one side of, and in the plane
            of, the axis of rotation.  If NA1 = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).  If NA1 = ALL, all selected areas will define the pattern to
            be rotated.  A component name may also be substituted for NA1.

        pax1, pax2
            Keypoints defining the axis about which the area pattern is to be
            rotated.

        arc
            Arc length (in degrees).  Positive follows right-hand rule about
            PAX1-PAX2 vector.  Defaults to 360.

        nseg
            Number of volumes (8 maximum) around circumference.  Defaults to
            minimum required for 90° (maximum) arcs, i.e., 4 for 360°, 3 for
            270°, etc.

        Notes
        -----
        Generates cylindrical volumes (and their corresponding keypoints,
        lines, and areas) by rotating an area pattern (and its associated line
        and keypoint patterns) about an axis.  Keypoint patterns are generated
        at regular angular locations (based on a maximum spacing of 90°).  Line
        patterns are generated at the keypoint patterns.  Arc lines are also
        generated to connect the keypoints circumferentially.  Keypoint, line,
        area, and volume numbers are automatically assigned (beginning with the
        lowest available values).  Adjacent lines use a common keypoint,
        adjacent areas use a common line, and adjacent volumes use a common
        area.

        To generate a single volume with an arc greater than 180°, NSEG must be
        greater than or equal to 2.

        If element attributes have been associated with the input area via the
        AATT command, the opposite area generated by the VROTAT operation will
        also have those attributes (i.e., the element attributes from the input
        area are copied to the opposite area).  Note that only the area
        opposite the input area will have the same attributes as the input
        area; the areas adjacent to the input area will not.

        If the given areas are meshed or belong to meshed volumes, the 2-D mesh
        can be rotated (extruded) to a 3-D mesh. See the Modeling and Meshing
        Guide for more information.  Note that the NDIV argument on the ESIZE
        command should be set before extruding the meshed areas.
        """
        command = "VROTAT,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(na1), str(na2), str(na3), str(na4), str(na5), str(na6), str(pax1), str(pax2), str(arc), str(nseg))
        return self.run(command, **kwargs)

    def edstart(self, restart="", memory="", fsize="", dumpfile="", **kwargs):
        """APDL Command: EDSTART

        Specifies status (new or restart) of an explicit dynamics analysis.

        Parameters
        ----------
        restart
            Status of the analysis (new or restart).

            0 - New analysis (default).

            1 - Simple restart.

            2 - Small restart.

            3 - Full restart.

        memory
            Memory to be used (in words). If blank, LS-DYNA assigns a value
            (default). If more or less memory is needed, specify the number of
            words (a word is usually 32 bits on a workstation).

        fsize
            Scale factor for binary file sizes. Defaults to 7, which is
            (7x262144) = 1835008 words.

        dumpfile
            Name of dump file to use during a restart (for example, d3dumpnn,
            where nn = 01, 02, 03,...,99 and defaults to 01). Leave this field
            blank when running a new analysis (RESTART = 0) so that the default
            dump file d3dump01 will be created.

        Notes
        -----
        EDSTART can be issued before the SOLVE command to specify a new
        analysis, a simple restart, a small restart, or a full restart as
        described below.

        New analysis: For a new analysis, you do not need to issue EDSTART
        unless you want to change the MEMORY or FSIZE option. If you do not
        specify the dump file name, d3dump01 will be created by default.

        Simple restart: This option assumes that the database has not been
        altered. Upon restarting, results will be appended to the existing
        results files. Issue EDSTART,1,,,d3dumpnn to indicate which restart
        file to use as a starting point. The dump file to be used must have
        been created in an earlier run and must be available at the time this
        command is issued.  You would typically use a simple restart when you
        interrupt the LS-DYNA run via Ctrl+C and terminate the run prematurely
        by issuing the "sense switch control" key SW1 (see Solution Control and
        Monitoring in the ANSYS LS-DYNA User's Guide). At this point you should
        be able to view the partial solution using ANSYS postprocessors. After
        you are done viewing the partial solution, you can reenter the solution
        processor and issue EDSTART,1,,,d3dumpnn, followed by SOLVE to continue
        with the analysis. The results will be appended to the results files
        Jobname.RST and Jobname.HIS.  You can perform multiple simple restarts
        by issuing EDSTART,1,,,d3dumpnn multiple times, as needed. The
        solutions in the Jobname.RST file will all be in load step number 1.

        Small restart: This option can be used when minor changes in the
        database are necessary. For example, you can reset the termination
        time, reset the output interval, add displacement constraints, change
        initial velocities, switch parts from a deformable to rigid state, etc.
        (See A Small Restart in theANSYS LS-DYNA User's Guide for a complete
        description of database items that can be changed.) Issue
        EDSTART,2,,,d3dumpnn followed by the commands required to change the
        database, then issue SOLVE. The results will be appended to the results
        files Jobname.RST and Jobname.HIS. You can perform multiple restarts by
        issuing EDSTART,2,,,d3dumpnn multiple times, as needed. The additional
        restart solutions will be stored in Jobname.RST as load step numbers 2,
        3, etc.

        Full restart: A full restart is appropriate when many modifications to
        the database are required. For example, you can change the model
        geometry, apply different loading conditions, etc. Issue
        EDSTART,3,,,d3dumpnn to denote a full restart analysis. The Jobname
        will automatically be changed to Jobname_nn, (nn = 01 initially, and
        will be incremented each time EDSTART,3 is issued for subsequent full
        restarts). After the EDSTART command, you can input any commands needed
        to change the database. (Most commands which are applicable to an ANSYS
        LS-DYNA new analysis are also applicable to full restart analysis. A
        few commands related to contact specifications, initial velocity
        definitions, and adaptive meshing are not supported.) Then issue the
        EDIS command to specify which portions of the model should be
        initialized in the full restart using results data from the d3dumpnn
        file. Finally, issue the SOLVE command. At this point, new results
        files, Jobname_nn.RST and Jobname_nn.HIS, will be created. Time and
        output intervals in the new results files are continuous from the
        previous results files; the time is not reset to zero. (See A Full
        Restart in the ANSYS LS-DYNA User's Guide for a complete description of
        a full restart analysis.)

        This command is also valid in PREP7.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EDSTART,%s,%s,%s,%s" % (str(restart), str(memory), str(fsize), str(dumpfile))
        return self.run(command, **kwargs)

    def rmporder(self, ord1="", ord2="", ord3="", ord4="", ord5="", ord6="",
                 ord7="", ord8="", ord9="", **kwargs):
        """APDL Command: RMPORDER

        Defines polynomial orders for ROM functions.

        Parameters
        ----------
        ord1, ord2, ord3, . . . , ord9
            Polynomial orders for modes. Ordi specifies the polynomial order
            for modei. Modes are ordered as extracted from a modal analysis
            using the RMNEVEC command.  Defaults to 0 if mode i is unused;
            default to nstep(i) -1 for dominant or relevant modes, where
            nstep(i) is the number of equidistant steps in fit range of mode i.
            nstep(i) is automatically set by RMMSELECT or modified by the
            RMMRANGE command.

        Notes
        -----
        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "RMPORDER,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(ord1), str(ord2), str(ord3), str(ord4), str(ord5), str(ord6), str(ord7), str(ord8), str(ord9))
        return self.run(command, **kwargs)

    def mstole(self, method="", namesurf="", namefluid="", **kwargs):
        """APDL Command: MSTOLE

        Adds two extra nodes from FLUID116 elements to SURF151 or SURF152
        elements for convection analyses.

        Parameters
        ----------
        method
            Mapping method:

            0 - Hybrid method (default).

            1 - Projection method.

            2 - Minimum centroid distance method.

        namesurf
            Component name for a group of SURF151 or SURF152 elements. The name
            must be enclosed in single quotes (e.g., 'COM152') when the MSTOLE
            command is manually typed in.

        namefluid
            Component name for a group of FLUID116 elements. The name must be
            enclosed in single quotes (e.g., 'COM116') when the MSTOLE command
            is manually typed in.

        Notes
        -----
        For convection analyses, the MSTOLE command adds two extra nodes from
        FLUID116 elements to SURF151 or SURF152 elements by employing the
        specified mapping method. In the hybrid method, the projection method
        is tried first and if it fails the centroid distance method is used.
        The SURF151 or SURF152 elements and the FLUID116 elements must be
        grouped into components and named using the CM command.

        The SURF151 or SURF152 extra node option must be set for two extra
        nodes (KEYOPT(5) = 2).

        For more information, see Using the Surface Effect Elements in the
        Thermal Analysis Guide.
        """
        command = "MSTOLE,%s,%s,%s" % (str(method), str(namesurf), str(namefluid))
        return self.run(command, **kwargs)

    def cint(self, action="", par1="", par2="", par3="", par4="", par5="",
             par6="", par7="", **kwargs):
        """APDL Command: CINT

        Defines parameters associated with fracture parameter calculations

        Parameters
        ----------
        action
            Specifies action for defining or manipulating initial crack data:

            NEW - Initiate a new calculation and assign an ID.

            CTNC - Define the crack tip node component.

            CENC - Define the crack extension node component, the crack tip node, and the crack
                   extension direction.

            TYPE - Define the type of calculation to perform.

            DELE - Delete the CINT object associated with the specified ID.

            NCON - Define the number of contours to be calculated in the contour-integral
                   calculation.

            SYMM - Indicate whether the crack is on a symmetrical line or plane.

            NORM - Define the crack plane normal.

            UMM - Activate or deactivate the unstructured mesh method.

            EDIR - Crack-assist extension direction.

            PLOT - Plots crack front and crack tip coordinate system.

            CXFE - Define the crack tip element or crack front element set. Valid for XFEM-based
                   crack-growth analysis only.

            RADIUS - Define the radius at which the given value is to be evaluated. Valid for XFEM-
                     based crack-growth analysis only.

            RSWEEP - Define the minimum and maximum sweep angle from existing crack direction. Valid
                     for XFEM-based crack-growth analysis only.
        """
        command = "CINT,%s,%s,%s,%s,%s,%s,%s,%s" % (str(action), str(par1), str(par2), str(par3), str(par4), str(par5), str(par6), str(par7))
        return self.run(command, **kwargs)

    def ltran(self, kcnto="", nl1="", nl2="", ninc="", kinc="", noelem="",
              imove="", **kwargs):
        """APDL Command: LTRAN

        Transfers a pattern of lines to another coordinate system.

        Parameters
        ----------
        kcnto
            Reference number of coordinate system where the pattern is to be
            transferred.  Transfer occurs from the active coordinate system.
            The coordinate system type and parameters of KCNTO must be the same
            as the active system.

        nl1, nl2, ninc
            Transfer lines from pattern beginning with NL1 to NL2 (defaults to
            NL1) in steps of NINC (defaults to 1).  If NL1 = ALL, NL2 and NINC
            are ignored and pattern is all selected lines [LSEL].  If NL1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NL1 (NL2 and NINC are ignored).

        kinc
            Keypoint increment between sets.  If zero, the lowest available
            keypoint numbers are assigned [NUMSTR].

        noelem
            Specifies whether nodes and elements are also to be generated:

            0 - Generate nodes and elements associated with the original lines, if they exist.

            1 - Do not generate nodes and elements.

        imove
            Specifies whether lines will be moved or newly defined:

            0 - Generate additional lines.

            1 - Move original lines to new position retaining the same keypoint numbers (KINC
                and NOELM are ignored).  Valid only if the old lines are no
                longer needed at their original positions.  Corresponding
                meshed items are also moved if not needed at their original
                position.

        Notes
        -----
        Transfers a pattern of lines (and their corresponding keypoints and
        mesh) from one coordinate system to another (see analogous node
        transfer command, TRANSFER).  The MAT, TYPE, REAL, and ESYS attributes
        are based upon the lines in the pattern and not upon the current
        settings.  Coordinate systems may be translated and rotated relative to
        each other.  Initial pattern may be generated in any coordinate system.
        However, solid modeling in a toroidal coordinate system is not
        recommended.  Coordinate and slope values are interpreted in the active
        coordinate system and are transferred directly.  Lines are generated as
        described in the LGEN command.
        """
        command = "LTRAN,%s,%s,%s,%s,%s,%s,%s" % (str(kcnto), str(nl1), str(nl2), str(ninc), str(kinc), str(noelem), str(imove))
        return self.run(command, **kwargs)

    def sueval(self, parm="", lab1="", oper="", **kwargs):
        """APDL Command: SUEVAL

        Perform operations on a mapped item and store result in a scalar
        parameter.

        Parameters
        ----------
        parm
            APDL parameter name.

        lab1
            Eight character set name for the first set used in calculation.

        oper
            Operation to perform:

            SUM - Sum of lab1 result values.

            INTG - Integral of lab1 over surface.

            AVG - Area-weighted average of a result item [Σ(lab1*DA) / Σ(DA)]

        Notes
        -----
        The result of this operation is a scalar APDL parameter value. If
        multiple surfaces are selected when this command is issued, then the
        operation is carried out on each surface individually and the parameter
        reperesents the culmulative value of the operation on all selected
        surfaces.
        """
        command = "SUEVAL,%s,%s,%s" % (str(parm), str(lab1), str(oper))
        return self.run(command, **kwargs)

    def avres(self, key="", opt="", **kwargs):
        """APDL Command: AVRES

        Specifies how results data will be averaged when PowerGraphics is
        enabled.

        Parameters
        ----------
        key
            Averaging key.

            1 - Average results at all common subgrid locations.

            2 - Average results at all common subgrid locations except where material type
                [MAT] discontinuities exist. This option is the default.

            3 - Average results at all common subgrid locations except where real constant
                [REAL] discontinuities exist.

            4 - Average results at all common subgrid locations except where material type
                [MAT] or real constant [REAL] discontinuities exist.

        opt
            Option to determine how results data are averaged.

            (blank) - Average surface results data using only the exterior element faces (default).

            FULL - Average surface results data using the exterior face and interior element data.

        Notes
        -----
        The AVRES command specifies how results data will be averaged at
        subgrid locations that are common to 2 or more elements.  The command
        is valid only when PowerGraphics is enabled (via the /GRAPHICS,POWER
        command).

        With PowerGraphics active (/GRAPHICS,POWER), the averaging scheme for
        surface data with interior element data included (AVRES,,FULL) and
        multiple facets per edge (/EFACET,2 or /EFACET,4) will yield differing
        minimum and maximum contour values depending on the  Z-Buffering
        options (/TYPE,,6 or /TYPE,,7).  When the Section data is not included
        in the averaging schemes (/TYPE,,7), the resulting absolute value for
        the midside node is significantly smaller.

        PowerGraphics does not average your stresses across discontinuous
        surfaces. The normals for various planes and facets are compared to a
        tolerance to determine continuity. The ANGLE value you specify in the
        /EDGE command is the tolerance for classifying surfaces as continuous
        or “coplanar.”

        The command affects nodal solution contour plots (PLNSOL), nodal
        solution printout (PRNSOL), and subgrid solution results accessed
        through the Query Results function (under General Postprocessing) in
        the GUI.

        The command has no effect on the nodal degree of freedom solution
        values (UX, UY, UZ, TEMP, etc.).

        For cyclic symmetry mode-superposition harmonic solutions, AVRES,,FULL
        is not supported. Additionally, averaging does not occur across
        discontinuous surfaces, and the ANGLE value on the /EDGE command has no
        effect.

        The command is also available in /SOLU.
        """
        command = "AVRES,%s,%s" % (str(key), str(opt))
        return self.run(command, **kwargs)

    def m(self, node="", lab1="", nend="", ninc="", lab2="", lab3="", lab4="",
          lab5="", lab6="", **kwargs):
        """APDL Command: M

        Defines master degrees of freedom for superelement generation analyses.

        Parameters
        ----------
        node
            Node number at which master degree of freedom is defined.  If ALL,
            define master degrees of freedom at all selected nodes (NSEL).  If
            NODE = P, graphical picking is enabled and all remaining command
            fields are ignored (valid only in the GUI).  A component name may
            also be substituted for NODE.

        lab1
            Valid degree of freedom label. If ALL, use all appropriate labels.
            Structural labels:  UX, UY, or UZ (displacements); ROTX, ROTY, or
            ROTZ (rotations). Thermal labels: TEMP, TBOT, TE2, TE3, . . ., TTOP
            (temperature).  Electric labels:  VOLT (voltage).

        nend, ninc
            Define all nodes from NODE to NEND (defaults to NODE) in steps of
            NINC (defaults to 1) as master degrees of freedom in the specified
            direction.

        lab2, lab3, lab4, . . . , lab6
            Additional master degree of freedom labels.  The nodes defined are
            associated with each label specified.

        Notes
        -----
        Defines master degrees of freedom (MDOF) for superelement generation.
        If defined for other analyses, MDOF are ignored.  If used in SOLUTION,
        this command is valid only within the first load step.

        Repeat M command for additional master degrees of freedom.  The limit
        for the number of master nodes used is determined by the maximum system
        memory available.

        The substructure (ANTYPE,SUBSTR) analysis utilizes the matrix
        condensation technique to reduce the structure matrices to those
        characterized by a set of master degrees of freedom.

        Master degrees of freedom are identified by a list of nodes and their
        nodal directions.  The actual degree of freedom directions available
        for a particular node depends upon the degrees of freedom associated
        with element types (ET) at that node.  There must be some mass (or
        stress stiffening in the case of the buckling analysis) associated with
        each master degree of freedom (except for the VOLT label).  The mass
        may be due either to the distributed mass of the element or due to
        discrete lumped masses at the node.  If a master degree of freedom is
        specified at a constrained point, it is ignored.  If a master degree of
        freedom is specified at a coupled node, it should be specified at the
        prime node of the coupled set.

        Substructure analysis connection points must be defined as master
        degrees of freedom.

        This command is also valid in PREP7.
        """
        command = "M,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(node), str(lab1), str(nend), str(ninc), str(lab2), str(lab3), str(lab4), str(lab5), str(lab6))
        return self.run(command, **kwargs)

    def pdanl(self, fname="", ext="", **kwargs):
        """APDL Command: PDANL

        Defines the analysis file to be used for probabilistic looping.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        The analysis file containing the deterministic, parameterized model
        must be specified if the probabilistic analysis is performed
        interactively. The file must exist at the time the PDANL command is
        issued. In this file, where /PREP7 and /PDS occur, they must be the
        first nonblank characters on the line (do not use the $ delimiter on
        any /PREP7 and /PDS command lines).

        By default the analysis files specified with PDANL are executed from
        the top. All definitions of random input variables (for example, APDL
        parameters defined as random input variables with the PDVAR command,
        using *SET or Pname = ... ) are ignored in the analysis file. The PDS
        takes control of setting the values of random input variable values for
        each loop.

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "PDANL,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def mp(self, lab="", mat="", c0="", c1="", c2="", c3="", c4="", **kwargs):
        """APDL Command: MP

        Defines a linear material property as a constant or a function of
        temperature.

        Parameters
        ----------
        lab
            Valid material property label.  Applicable labels are listed under
            "Material Properties" in the input table for each element type in
            the Element Reference.  See Linear Material Properties in the
            Material Reference for more complete property label definitions:

            ALPD - Mass matrix multiplier for damping.

            ALPX - Secant coefficients of thermal expansion (also ALPY, ALPZ).

            BETD - Stiffness matrix multiplier for damping.

            Note:If used in an explicit dynamic analysis, the value corresponds to the percentage of damping in the high frequency domain. For example, 0.1 roughly corresponds to 10% damping in the high frequency domain. - BETX

            Coefficient of diffusion expansion (also BETY, BETZ) - BVIS

            Bulk viscosity - C

            Specific heat - CREF

            Reference concentration (may not be temperature dependent) - CSAT

            Saturated concentration - CTEX

            Instantaneous coefficients of thermal expansion (also CTEY, CTEZ) - CVH

            Heat coefficient at constant volume per unit of mass - DENS

            Mass density. - DMPR

            Constant structural damping coefficient in full harmonic analysis or damping ratio in mode-superposition analysis. - DXX

            Diffusivity coefficients (also DYY, DZZ) - EMIS

            Emissivity. - ENTH

            Enthalpy. - EX

            Elastic moduli (also EY, EZ) - GXY

            Shear moduli (also GYZ, GXZ) - HF

            Convection or film coefficient - KXX

            Thermal conductivities (also KYY, KZZ) - LSST

            Electric loss tangent - LSSM

            Magnetic loss tangent - MGXX

            Magnetic coercive forces (also MGYY, MGZZ) - MURX

            Magnetic relative permeabilities (also MURY, MURZ) - MU

            Coefficient of friction - NUXY

            Minor Poisson's ratios (also NUYZ, NUXZ) (NUXY = νyx, as described in Stress-Strain Relationships in the Mechanical APDL Theory Reference) - PERX

            Electric relative permittivities (also PERY, PERZ) - Note:  If you enter permittivity values less than 1 for SOLID5, PLANE13, or
                              SOLID98, the program interprets the values as
                              absolute permittivity. Values input for PLANE223,
                              SOLID226, or SOLID227 are always interpreted as
                              relative permittivity.

            PRXY - Major Poisson's ratios (also PRYZ, PRXZ) (PRXY = νxy, as described in Stress-
                   Strain Relationships in the Mechanical APDL Theory
                   Reference)

            QRATE - Heat generation rate for thermal mass element MASS71. Fraction of plastic work
                    converted to heat (Taylor-Quinney coefficient) for coupled-
                    field elements PLANE223, SOLID226, and SOLID227.

            REFT - Reference temperature.  Must be defined as a constant; C1 through C4 are
                   ignored.

            RH - Hall Coefficient.

            RSVX - Electrical resistivities (also RSVY, RSVZ).

            SBKX - Seebeck coefficients (also SBKY, SBKZ).

            SONC - Sonic velocity.

            THSX - Thermal strain (also THSY, THSZ).

            VISC - Viscosity.

        mat
            Material reference number to be associated with the elements
            (defaults to the current MAT setting [MAT]).

        c0
            Material property value, or if a property-versus-temperature
            polynomial is being defined, the constant term in the polynomial.
            C0 can also be a table name (%tabname%); if C0 is a table name, C1
            through C4 are ignored.

        c1, c2, c3, c4
            Coefficients of the linear, quadratic, cubic, and quartic terms,
            respectively, in the property-versus-temperature polynomial.  Leave
            blank (or set to zero) for a constant material property.

        Notes
        -----
        MP defines a linear material property as a constant or in terms of a
        fourth order polynomial as a function of temperature. (See the TB
        command for nonlinear material property input.) Linear material
        properties typically require a single substep for solution, whereas
        nonlinear material properties require multiple substeps;  see Linear
        Material Properties in the Material Reference for details.

        If the constants C1 - C4 are input, the polynomial

        Property = C0 + C1(T) + C2(T)2 + C3(T)3 + C4(T)4

        is evaluated at discrete temperature points with linear interpolation
        between points (that is, a piecewise linear representation) and a
        constant-valued extrapolation beyond the extreme points. First-order
        properties use two discrete points (±9999°). The MPTEMP or MPTGEN
        commands must be used for second and higher order properties to define
        appropriate temperature steps. To ensure that the number of
        temperatures defined via the MPTEMP and MPTGEN commands is minimally
        sufficient for a reasonable representation of the curve, ANSYS
        generates an error message if the number is less than N, and a warning
        message if the number is less than 2N. The value N represents the
        highest coefficient used; for example, if C3 is nonzero and C4 is zero,
        a cubic curve is being used which is defined using 4 coefficients so
        that N = 4.
        """
        command = "MP,%s,%s,%s,%s,%s,%s,%s" % (str(lab), str(mat), str(c0), str(c1), str(c2), str(c3), str(c4))
        return self.run(command, **kwargs)

    def vglue(self, nv1="", nv2="", nv3="", nv4="", nv5="", nv6="", nv7="",
              nv8="", nv9="", **kwargs):
        """APDL Command: VGLUE

        Generates new volumes by "gluing" volumes.

        Parameters
        ----------
        nv1, nv2, nv3, . . . , nv9
            Numbers of the volumes to be glued.  If NV1 = ALL, all selected
            volumes will be glued (NV2 to NV9 will be ignored).  If NV1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NV1.

        Notes
        -----
        Use of the VGLUE command generates new volumes by "gluing" input
        volumes.  The glue operation redefines the input volumes so that they
        share areas along their common boundaries.  The new volumes encompass
        the same geometry as the original volumes.  This operation is only
        valid if the intersections of the input volumes are areas along the
        boundaries of those volumes.  See the Modeling and Meshing Guide for an
        illustration.  See the BOPTN command for an explanation of the options
        available to Boolean operations.  Element attributes and solid model
        boundary conditions assigned to the original entities will not be
        transferred to the new entities generated.

        The VGLUE command results in the merging of areas, lines, and keypoints
        at the common volume boundaries. The areas, lines, and keypoints of the
        lower numbered volume will be kept. This means one must be aware of
        volume numbering when multiple VGLUE commands are applied to avoid any
        "ungluing" of geometry.
        """
        command = "VGLUE,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nv1), str(nv2), str(nv3), str(nv4), str(nv5), str(nv6), str(nv7), str(nv8), str(nv9))
        return self.run(command, **kwargs)

    def undelete(self, option="", nstart="", nend="", **kwargs):
        """APDL Command: UNDELETE

        Removes results sets from the group of sets selected for editing.

        Parameters
        ----------
        option
            Specifies which sets are to be removed from the selected sets.

            SET - Specifies one or more particular sets in the results file that are to be
                  removed from the group of sets selected for deletion.

            ALL - Removes all selected sets that are currently selected for deletion.

        nstart
            The first set to be removed from the set selected for deletion.

        nend
            The final set to be removed from the set selected for deletion.
            This field is used only if operating on more than one sequential
            set.

        Notes
        -----
        Use this command if you have previously marked a set for deletion (with
        the DELETE command) and now wish to keep that set instead of deleting
        it.
        """
        command = "UNDELETE,%s,%s,%s" % (str(option), str(nstart), str(nend))
        return self.run(command, **kwargs)

    def vedit(self, par="", **kwargs):
        """APDL Command: *VEDIT

        Allows numerical array parameters to be graphically edited.

        Parameters
        ----------
        par
            Name of the array parameter to be edited.

        Notes
        -----
        Invokes a graphical editing system that displays array parameter values
        in matrix form, and allows the use of the mouse to edit individual
        values.  The starting array subscripts must be defined, such as
        *VEDIT,A(4,6,1), to indicate the section of the array to be edited.
        The array section starts at the specified array element and continues
        to the maximum extent of the array parameter.  Row and column index
        values may be set or changed in any plane, and those values will be
        applied to all planes. The menu system must be on [/MENU] when this
        command is issued.  Graphical editing is not available for character
        array parameters.  The *VEDIT command can not be used in a macro or
        other secondary input file.

        This command is not applicable to 4- or 5-D arrays.

        This command is valid in any processor.
        """
        command = "*VEDIT,%s" % (str(par))
        return self.run(command, **kwargs)

    def cqc(self, signif="", label="", forcetype="", **kwargs):
        """APDL Command: CQC

        Specifies the complete quadratic mode combination method.

        Parameters
        ----------
        signif
            Combine only those modes whose significance level exceeds the
            SIGNIF threshold.  For single point, multipoint, or DDAM response
            (SPOPT,SPRS, MPRS or DDAM), the significance level of a mode is
            defined as the mode coefficient of the mode, divided by the maximum
            mode coefficient of all modes.  Any mode whose significance level
            is less than SIGNIF is considered insignificant and is not
            contributed to the mode combinations.  The higher the SIGNIF
            threshold, the fewer the number of modes combined.  SIGNIF defaults
            to 0.001.  If SIGNIF is specified as 0.0, it is taken as 0.0.
            (This mode combination method is not valid for SPOPT,PSD.)

        label
            Label identifying the combined mode solution output.

            DISP - Displacement solution (default).  Displacements, stresses, forces, etc., are
                   available.

            VELO - Velocity solution.  Velocities, "stress velocities," "force velocities," etc.,
                   are available.

            ACEL - Acceleration solution.  Accelerations, "stress accelerations," "force
                   accelerations," etc., are available.

        forcetype
            Label identifying the forces to be combined:

            STATIC - Combine the modal static forces (default).

            TOTAL - Combine the modal static plus inertial forces.

        Notes
        -----
        Damping is required for this mode combination method.  The CQC command
        is also valid for PREP7.
        """
        command = "CQC,%s,%s,%s" % (str(signif), str(label), str(forcetype))
        return self.run(command, **kwargs)

    def vfquery(self, srcelem="", tarelem="", **kwargs):
        """APDL Command: VFQUERY

        Queries and prints element Hemicube view factors and average view
        factor.

        Parameters
        ----------
        srcelem
            Elements representing the source radiating surfaces used to query
            the view factor at the target element(s). If SRCELEM = P, graphical
            picking is enabled (valid only in the GUI). If SRCELEM = ALL, all
            selected elements will have their view factors queried. A component
            name may also be substituted for SRCELEM. Selected elements must be
            flagged for surface to surface radiation in order to query view
            factors (SF, SFA, or SFE with Lab = RDSF). The view factors must
            have been previously computed.

        tarelem
            Element for view factor query. If TARELEM = P, graphical picking is
            enabled (valid only in the GUI). If TARELEM = ALL, all selected
            elements will have their view factors queried. A component name may
            also be substituted for TARELEM. Selected elements must be flagged
            for surface to surface radiation in order to query view factors
            (SF, SFA, or SFE with Lab = RDSF). The view factors must have been
            previously computed.

        Notes
        -----
        View factors for each target element will be printed.

        An average view factor for all target elements will be computed.  (Use
        *GET  to retrieve the average value).

        When resuming a database, issue the command VFOPT,READ before issuing
        the VFQUERY command.
        """
        command = "VFQUERY,%s,%s" % (str(srcelem), str(tarelem))
        return self.run(command, **kwargs)

    def mplist(self, mat1="", mat2="", inc="", lab="", tevl="", **kwargs):
        """APDL Command: MPLIST

        Lists linear material properties.

        Parameters
        ----------
        mat1, mat2, inc
            List materials from MAT1 to MAT2 (defaults to MAT1) in steps of INC
            (defaults to 1).  If MAT1= ALL (default), MAT2 and INC are ignored
            and properties for all material numbers are listed.

        lab
            Material property label (see the MP command for labels).  If ALL
            (or blank), list properties for all labels.  If EVLT, list
            properties for all labels evaluated at TEVL.

        tevl
            Evaluation temperature for Lab = EVLT listing (defaults to BFUNIF).

        Notes
        -----
        For Lab = EVLT, when the property is from tables, the MPPLOT command
        will not be valid because the property could be a function of more than
        temperature.

        This command is valid in any processor.
        """
        command = "MPLIST,%s,%s,%s,%s,%s" % (str(mat1), str(mat2), str(inc), str(lab), str(tevl))
        return self.run(command, **kwargs)

    def dsys(self, kcn="", **kwargs):
        """APDL Command: DSYS

        Activates a display coordinate system for geometry listings and plots.

        Parameters
        ----------
        kcn
            Coordinate system reference number.  KCN may be 0,1,2 or any
            previously defined local coordinate system number.

        Notes
        -----
          Boundary condition symbols, vector arrows, and element coordinate
        system triads are not transformed to the display coordinate system. The
        display system orientation (for the default view) is X horizontal to
        the right, Y vertical upward, and Z out of the screen (normal).

        Line directions and area directions (/PSYMB,LDIR and /PSYMB,ADIR) are
        not plotted for DSYS >0.

        When you create ANSYS 3-D annotation, the coordinates are stored to the
        database in the DSYS that was active at the time of creation. Changing
        the DSYS does not change the annotation coordinate data in the
        database.

        This command is valid in any processor.
        """
        command = "DSYS,%s" % (str(kcn))
        return self.run(command, **kwargs)

    def afun(self, lab="", **kwargs):
        """APDL Command: *AFUN

        Specifies units for angular functions in parameter expressions.

        Parameters
        ----------
        lab
            Specifies the units to be used:

            Use radians for input and output of parameter angular functions (default). - Use degrees for input and output of parameter angular functions.

        Notes
        -----
        Only the SIN, COS, TAN, ASIN, ACOS, ATAN, ATAN2, ANGLEK, and ANGLEN
        functions [*SET, *VFUN] are affected by this command.
        """
        command = "*AFUN,%s" % (str(lab))
        return self.run(command, **kwargs)

    def lplot(self, nl1="", nl2="", ninc="", **kwargs):
        """APDL Command: LPLOT

        Displays the selected lines.

        Parameters
        ----------
        nl1, nl2, ninc
            Display lines from NL1 to NL2 (defaults to NL1) in steps of NINC
            (defaults to 1).  If NL1 = ALL (default), NL2 and NINC are ignored
            and display all selected lines [LSEL].

        Notes
        -----
        Mesh divisions on plotted lines are controlled by the LDIV option of
        the /PSYMB command.

        This command is valid in any processor.
        """
        command = "LPLOT,%s,%s,%s" % (str(nl1), str(nl2), str(ninc))
        return self.run(command, **kwargs)

    def atype(self, **kwargs):
        """APDL Command: ATYPE

        Specifies "Analysis types" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "ATYPE," % ()
        return self.run(command, **kwargs)

    def bss2(self, val1="", val2="", t="", **kwargs):
        """APDL Command: BSS2

        Specifies the transverse shear strain and force relationship in plane
        XY for beam sections.

        Parameters
        ----------
        val1
            Transverse shear strain component (γ2).

        val2
            Transverse shear force component (S2).

        t
            Temperature.

        Notes
        -----
        The behavior of beam elements is governed by the generalized-
        stress/generalized-strain relationship of the form:

        The BSS1 command, one of several nonlinear general beam section
        commands, specifies the transverse shear strain and transverse shear
        force relationship for plane XY of a beam section. The section data
        defined is associated with the section most recently defined (via the
        SECTYPE command).

        Unspecified values default to zero.

        Related commands are BSAX, BSM1, BSM2, BSTQ, BSS1, BSMD, and BSTE.

        For complete information, see Using Nonlinear General Beam Sections.
        """
        command = "BSS2,%s,%s,%s" % (str(val1), str(val2), str(t))
        return self.run(command, **kwargs)

    def fllist(self, nloc1="", nloc2="", ninc="", **kwargs):
        """APDL Command: FLLIST

        Lists the fatigue location parameters.

        Parameters
        ----------
        nloc1, nloc2, ninc
            List location parameters from NLOC1 (defaults to 1) to NLOC2
            (defaults to NLOC1) in steps of NINC (defaults to 1).  If NLOC1 =
            ALL, NLOC2 and NINC are ignored and all locations are listed.
        """
        command = "FLLIST,%s,%s,%s" % (str(nloc1), str(nloc2), str(ninc))
        return self.run(command, **kwargs)

    def point(self, **kwargs):
        """APDL Command: POINT

        Specifies "Point flow tracing settings" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "POINT," % ()
        return self.run(command, **kwargs)

    def outaero(self, sename="", timeb="", dtime="", **kwargs):
        """APDL Command: OUTAERO

        Outputs the superelement matrices and load vectors to formatted files
        for aeroelastic analysis.

        Parameters
        ----------
        sename
            Name of the superelement that models the wind turbine supporting
            structure. Defaults to the current Jobname.

        timeb
            First time at which the load vector is formed (defaults to be read
            from SENAME.sub).

        dtime
            Time step size of the load vectors (defaults to be read from
            SENAME.sub).

        Notes
        -----
        Both TIMEB and DTIME must be blank if the time data is to be read from
        the SENAME.sub file.

        The matrix file (SENAME.SUB) must be available from the substructure
        generation run before issuing this command. This superelement that
        models the wind turbine supporting structure must contain only one
        master node with six freedoms per node: UX, UY, UZ, ROTX, ROTY, ROTZ.
        The master node represents the connection point between the turbine and
        the supporting structure.

        This command will generate four files that are exported to the
        aeroelastic code for integrated wind turbine analysis. The four files
        are Jobname.GNK for the generalized stiffness matrix, Jobname.GNC for
        the generalized damping matrix, Jobname.GNM for the generalized mass
        matrix and Jobname.GNF for the generalized load vectors.

        For detailed information on how to perform a wind coupling analysis,
        see Coupling to External Aeroelastic Analysis of Wind Turbines in the
        Mechanical APDL Advanced Analysis Guide.
        """
        command = "OUTAERO,%s,%s,%s" % (str(sename), str(timeb), str(dtime))
        return self.run(command, **kwargs)

    def cp(self, nset="", lab="", node1="", node2="", node3="", node4="",
           node5="", node6="", node7="", node8="", node9="", node10="",
           node11="", node12="", node13="", node14="", node15="", node16="",
           node17="", **kwargs):
        """APDL Command: CP

        Defines (or modifies) a set of coupled degrees of freedom.

        Parameters
        ----------
        nset
            Set reference number:

            n - Arbitrary set number.

            HIGH - The highest defined coupled set number will be used (default, unless Lab =
                   ALL).  This option is useful when adding nodes to an
                   existing set.

            NEXT - The highest defined coupled set number plus one will be used (default if Lab =
                   ALL).  This option automatically numbers coupled sets so
                   that existing sets are not modified.

        lab
            Degree of freedom label for coupled nodes (in the nodal coordinate
            system).  Defaults to label previously defined with NSET if set
            NSET already exists. A different label redefines the previous label
            associated with NSET.  Valid labels are: Structural labels:  UX,
            UY, or UZ (displacements); ROTX, ROTY, or ROTZ (rotations) (in
            radians); HDSP (hydrostatic pressure). Thermal labels: TEMP, TBOT,
            TE2, TE3, . . ., TTOP (temperature).  Fluid labels:  PRES
            (pressure);  VX, VY, or VZ (velocities).  Electric labels:  VOLT
            (voltage);  EMF (electromotive force drop);  CURR (current).
            Magnetic labels:  MAG (scalar magnetic potential); AX, AY, or AZ
            (vector magnetic potentials);  CURR (current). Diffusion label:
            CONC (concentration). Explicit analysis labels:  UX, UY, or UZ
            (displacements).

        node1, node2, node3, . . . , node17
            List of nodes to be included in set. Duplicate nodes are ignored.
            If a node number is input as negative, the node is deleted from the
            coupled set. The first node in the list is the primary (retained)
            node, and the remaining nodes represent the removed degrees of
            freedom. If NODE1 = ALL, NODE2 through NODE17 are ignored and all
            selected nodes (NSEL) are included in the set.  If NODE1 = P,
            graphical picking is enabled and all remaining command fields are
            ignored (valid only in the GUI).  A component name may also be
            substituted for NODE1.

        Notes
        -----
        Do not include the same degree of freedom in more than one coupled set.
        Repeat CP command for additional nodes.

        Coupling degrees of freedom into a set causes the results calculated
        for one member of the set to be the same for all members of the set.
        Coupling can be used to model various joint and hinge effects.  A more
        general form of coupling can be done with constraint equations (CE).
        For structural analyses, a list of nodes is defined along with the
        nodal directions in which these nodes are to be coupled.  As a result
        of this coupling, these nodes are forced to take the same displacement
        in the specified nodal coordinate direction.  The amount of the
        displacement is unknown until the analysis is completed.  A set of
        coupled nodes which are not coincident, or which are not along the line
        of the coupled displacement direction, may produce an applied moment
        which will not appear in the reaction forces.  The actual degrees of
        freedom available for a particular node depends upon the degrees of
        freedom associated with element types (ET) at that node. For scalar
        field analysis, this command is used to couple nodal temperatures,
        pressures, voltages, etc.

        For an explicit dynamic analysis, the only valid DOF labels for
        coupling are UX, UY, and UZ. Since the rotational DOF (ROTX, ROTY,
        ROTZ) are not allowed. The CP family of commands should not be used in
        an explicit analysis to model rigid body behavior that involves
        rotations. If CP is used in this manner, it could lead to nonphysical
        responses.

        A set of coupled nodes which are not coincident, or which are not along
        the line of the coupled displacement direction, produce an artificial
        moment constraint.  If the structure rotates, a moment may be produced
        in the coupled set in the form of a force couple.  This moment is in
        addition to the real reaction forces and may make it appear that moment
        equilibrium is not satisfied by just the applied forces and the
        reaction forces. Note, however, that in an explicit dynamic analysis,
        this artificial moment will not be produced. Rather, just the applied
        forces and the reaction forces will satisfy the moment equilibrium in
        the model. Thus, in an explicit analysis, the magnitude of nodal
        displacements for this set of nodes will depend on the distance from
        each node to the center of the coupled set, and the direction of
        displacement will depend on the resulting moment. This may lead to a
        nonphysical response in some cases.

        Additional sets of coupled nodes may be generated from a specified set.
        Degrees of freedom are coupled within a set but are not coupled between
        sets.  No degree of freedom should appear in more than one coupled set.
        Such an appearance would indicate that at least two sets were in fact
        part of a single larger set.  The first degree of freedom of the
        coupled set is the "prime" degree of freedom.  All other degrees of
        freedom in the coupled sets are eliminated from the solution matrices
        by their relationship to the prime degree of freedom.  Forces applied
        to coupled nodes (in the coupled degree of freedom direction) will be
        summed and applied to the prime degree of freedom.  Output forces are
        also summed at the prime degree of freedom.  Degrees of freedom with
        specified constraints (D) should not be included in a coupled set
        (unless the degree of freedom is prime).

        If master degrees of freedom are defined for coupled nodes, only the
        prime degree of freedom should be so defined. The use of coupled nodes
        reduces the set of coupled degrees of freedom to only one degree of
        freedom.

        The removed degrees of freedom defined by the CP command cannot be
        included in any CE or CERIG command.
        """
        command = "CP,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(nset), str(lab), str(node1), str(node2), str(node3), str(node4), str(node5), str(node6), str(node7), str(node8), str(node9), str(node10), str(node11), str(node12), str(node13), str(node14), str(node15), str(node16), str(node17))
        return self.run(command, **kwargs)

    def ekill(self, elem="", **kwargs):
        """APDL Command: EKILL

        Deactivates an element (for the birth and death capability).

        Parameters
        ----------
        elem
            Element to be deactivated. If ALL, deactivate all selected elements
            [ESEL]. If ELEM = P, graphical picking is enabled and all remaining
            command fields are ignored  (valid only in the GUI). A component
            name may also be substituted for ELEM.

        Notes
        -----
        Deactivates the specified element when the birth and death capability
        is being used. A deactivated element remains in the model but
        contributes a near-zero stiffness (or conductivity, etc.) value (ESTIF)
        to the overall matrix. Any solution-dependent state variables (such as
        stress, plastic strain, creep strain, etc.) are set to zero.
        Deactivated elements contribute nothing to the overall mass (or
        capacitance, etc.) matrix.

        The element can be reactivated with the EALIVE command.

        ANSYS, Inc. recommends using element deactivation/reactivation
        (EKILL/EALIVE) for linear elastic materials only. For all other
        materials, validate the results carefully before using them.

        This command is also valid in PREP7.
        """
        command = "EKILL,%s" % (str(elem))
        return self.run(command, **kwargs)

    def endrelease(self, tolerance="", dof1="", dof2="", dof3="", dof4="",
                   **kwargs):
        """APDL Command: ENDRELEASE

        Specifies degrees of freedom to be decoupled for end release.

        Parameters
        ----------
        --
            Unused field.

        tolerance
            Angle tolerance (in degrees) between adjacent elements. Defaults to
            20°. Set TOLERANCE to -1 to indicate all selected elements.

        dof1, dof2, dof3, dof4
            Degrees of freedom to release. If Dof1 is blank, WARP is assumed
            and Dof2, Dof3, and Dof4 are ignored.

            WARP - Release the warping degree of freedom (default).

            ROTX - Release rotations in the X direction.

            ROTY - Release rotations in the Y direction.

            ROTZ - Release rotations in the Z direction.

            UX - Release displacements in the X direction.

            UY - Release displacements in the Y direction.

            UZ - Release displacements in the Z direction.

            BALL - Create ball joints (equivalent to releasing WARP, ROTX, ROTY, and ROTZ).

        Notes
        -----
        This command specifies end releases for the BEAM188, BEAM189, PIPE288,
        and PIPE289 elements. The command works on currently selected nodes and
        elements. It creates end releases on any two connected beam elements
        whose angle at connection exceeds the specified tolerance. From within
        the GUI, the Picked node option generates an end release at the
        selected node regardless of the angle of connection (angle tolerance is
        set to -1).

        Use the CPLIST command to list the coupled sets generated by the
        ENDRELEASE command.

        Note:: : You should exercise due engineering judgement when using this
        command, as improper use may result in mechanics that render a solution
        impossible.
        """
        command = "ENDRELEASE,%s,%s,%s,%s,%s" % (str(tolerance), str(dof1), str(dof2), str(dof3), str(dof4))
        return self.run(command, **kwargs)

    def dist(self, wn="", dval="", kfact="", **kwargs):
        """APDL Command: /DIST

        Specifies the viewing distance for magnifications and perspective.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        dval
            Distance along the view line from the observer to the focus point
            (defaults to value producing full-window display).  Distances "too
            close" to the object will produce excessive magnifications.  If
            DVAL = AUTO, zero, or blank, the program will calculate the
            distance automatically.  If DVAL = USER, the distance of last
            display will be used (useful when last display automatically
            calculated distance).

        kfact
            DVAL interpretation key:

            0 - Interpret numerical DVAL values as described above.

            1 - Interpret DVAL as a multiplier on the current distance (DVAL of 2 gives twice
                the current distance; 0.5 gives half the current distance,
                etc.).

        Notes
        -----
        The scale factor is relative to the window shape.  For example, for
        objects centered in a square window and with parallel projection (no
        perspective), a distance of :  /2 (+10%) produces a full window
        magnification, where :  is the largest in-plane vertical or horizontal
        dimension.  See also /AUTO and /USER commands.

        This command is valid in any processor.
        """
        command = "/DIST,%s,%s,%s" % (str(wn), str(dval), str(kfact))
        return self.run(command, **kwargs)

    def dsum(self, signif="", label="", td="", forcetype="", **kwargs):
        """APDL Command: DSUM

        Specifies the double sum mode combination method.

        Parameters
        ----------
        signif
            Combine only those modes whose significance level exceeds the
            SIGNIF threshold.  For single point, multipoint, or DDAM response
            (SPOPT, SPRS, MPRS, or DDAM), the significance level of a mode is
            defined as the mode coefficient of the mode, divided by the maximum
            mode coefficient of all modes.  Any mode whose significance level
            is less than SIGNIF is considered insignificant and is not
            contributed to the mode combinations.  The higher the SIGNIF
            threshold, the fewer the number of modes combined. SIGNIF defaults
            to 0.001.  If SIGNIF is specified as 0.0, it is taken as 0.0.
            (This mode combination method is not valid for SPOPT, PSD.)

        label
            Label identifying the combined mode solution output.

            DISP - Displacement solution (default).  Displacements, stresses, forces, etc., are
                   available.

            VELO - Velocity solution.  Velocities, "stress velocities," "force velocities," etc.,
                   are available.

            ACEL - Acceleration solution.  Accelerations, "stress accelerations," "force
                   accelerations," etc., are available.

        td
            Time duration for earthquake or shock spectrum.  TD defaults to 10.

        forcetype
            Label identifying the forces to be combined:

            STATIC - Combine the modal static forces (default).

            TOTAL - Combine the modal static plus inertial forces.

        Notes
        -----
        This command is also valid for PREP7.
        """
        command = "DSUM,%s,%s,%s,%s" % (str(signif), str(label), str(td), str(forcetype))
        return self.run(command, **kwargs)

    def kfill(self, np1="", np2="", nfill="", nstrt="", ninc="", space="",
              **kwargs):
        """APDL Command: KFILL

        Generates keypoints between two keypoints.

        Parameters
        ----------
        np1, np2
            Beginning and ending keypoints for fill-in.  NP1 defaults to next
            to last keypoint specified, NP2 defaults to last keypoint
            specified.  If NP1 = P, graphical picking is enabled and all
            remaining command fields are ignored (valid only in the GUI).

        nfill
            Fill NFILL keypoints between NP1 and NP2 (defaults to |NP2-NP1|-1).
            NFILL must be positive.

        nstrt
            Keypoint number assigned to first filled-in keypoint (defaults to
            NP1 + NINC).

        ninc
            Add this increment to each of the remaining filled-in keypoint
            numbers (may be positive or negative).  Defaults to
            (NP2-NP1)/(NFILL + 1), i.e., linear interpolation.

        space
            Spacing ratio.  Ratio of last division size to first division size.
            If > 1.0, divisions increase.  If < 1.0, divisions decrease.  Ratio
            defaults to 1.0 (uniform spacing).

        Notes
        -----
        Generates keypoints (in the active coordinate system) between two
        existing keypoints.  The two keypoints may have been defined in any
        coordinate system. However, solid modeling in a toroidal coordinate
        system is not recommended.   Any number of keypoints may be filled in
        and any keypoint numbering sequence may be assigned.
        """
        command = "KFILL,%s,%s,%s,%s,%s,%s" % (str(np1), str(np2), str(nfill), str(nstrt), str(ninc), str(space))
        return self.run(command, **kwargs)

    def sfa(self, area="", lkey="", lab="", value="", value2="", **kwargs):
        """APDL Command: SFA

        Specifies surface loads on the selected areas.

        Parameters
        ----------
        area
            Area to which surface load applies.  If ALL, apply load to all
            selected areas [ASEL].  If Area = P, graphical picking is enabled
            and all remaining command fields are ignored (valid only in the
            GUI).  A component may be substituted for Area.

        lkey
            Load key associated with surface load (defaults to 1).  Load keys
            (1,2,3, etc.) are listed under "Surface Loads" in the input data
            table for each element type in the Element Reference.  LKEY is
            ignored if the area is the face of a volume region meshed with
            volume elements.

        lab
            Valid surface load label.  Load labels are listed under "Surface
            Loads" in the input table for each area type in the Element
            Reference.

        value
            Surface load value or table name reference for specifying tabular
            boundary conditions.

        value2
            Second surface load value (if any).

        Notes
        -----
        Surface loads may be transferred from areas to elements with the SFTRAN
        or SBCTRAN commands.  See the SFGRAD command for an alternate tapered
        load capability.

        Tabular boundary conditions (VALUE = %tabname% and/or VALUE2 =
        %tabname%) are available for the following surface load labels (Lab)
        only: : PRES (real and/or imaginary components), CONV (film coefficient
        and/or bulk temperature) or HFLUX, and RAD (surface emissivity and
        ambient temperature). Use the *DIM command to define a table.

        This command is also valid in PREP7.
        """
        command = "SFA,%s,%s,%s,%s,%s" % (str(area), str(lkey), str(lab), str(value), str(value2))
        return self.run(command, **kwargs)

    def gcdef(self, option="", sect1="", sect2="", matid="", realid="",
              **kwargs):
        """APDL Command: GCDEF

        Defines interface interactions between general contact surfaces.

        Parameters
        ----------
        option
            Option to be performed.

            (blank) - Retain the previous Option setting between SECT1 and SECT2.

            AUTO - Define auto asymmetric contact between surfaces SECT1 and SECT2.

            SYMM - Define symmetric contact between surfaces SECT1 and SECT2.

            ASYM - Define asymmetric contact with SECT1 as the source (contact) surface and SECT2
                   as the target surface.

            EXCL - Exclude contact between surfaces SECT1 and SECT2. MATID and REALID are ignored.

            DELETE - Remove the given definition from the GCDEF table. MATID and REALID are ignored.

            Note that GCDEF,DELETE,ALL,ALL does not remove the entire GCDEF table; it merely removes any existing GCDEF,,ALL,ALL definitions, while leaving intact any existing GCDEF definitions that are more specific.  - To remove the entire GCDEF table, issue GCDEF,DELETE,TOTAL.

            It is good practice to list all definitions using GCDEF,LIST,ALL,ALL before and after a GCDEF,DELETE command. - LIST

            List stored GCDEF data entries. MATID and REALID are ignored. GCDEF,LIST,ALL,ALL lists the entire GCDEF table, including more specific GCDEF definitions. - TABLE

        sect1, sect2
            Section numbers representing general contact surfaces (no
            defaults). Labels ALL and SELF are also valid input. See
            SECT1/SECT2 Interactions for a description of how the various
            inputs for SECT1 and SECT2 are interpreted.

        matid
            Material ID number for general contact interaction properties at
            the SECT1/SECT2 interface. If zero or blank, the previous setting
            of MATID for SECT1/SECT2 (if any) is retained.

        realid
            Real constant ID number for general contact interaction properties
            at the SECT1/SECT2 interface.  If zero or blank, the previous
            setting of REALID for SECT1/SECT2 (if any) is retained.

        Notes
        -----
        GCDEF defines the interface interaction between general contact
        surfaces identified by SECT1 and SECT2. GCDEF commands are order
        independent in most cases.

        GCDEF definitions should be issued after GCGEN. They are saved in the
        database and are written to and read from .CDB files.

        See General Contact in the Contact Technology Guide for more
        information on the overall procedure to create general contact.

        SECT1/SECT2 Interactions

        The most specific types of general contact definitions are those
        described below:

        The remaining general contact definition types can be overridden by the
        above two general contact definition types:
        """
        command = "GCDEF,%s,%s,%s,%s,%s" % (str(option), str(sect1), str(sect2), str(matid), str(realid))
        return self.run(command, **kwargs)

    def ulib(self, fname="", ext="", **kwargs):
        """APDL Command: *ULIB

        Identifies a macro library file.

        Parameters
        ----------
        fname
            File name and directory path (248 characters maximum, including the
            characters needed for the directory path).  An unspecified
            directory path defaults to the working directory; in this case, you
            can use all 248 characters for the file name.

        ext
            Filename extension (eight-character maximum).

        --
            Unused field.

        Notes
        -----
        Identifies a macro library file for the *USE command.  A library of
        macros allows blocks of often used ANSYS commands to be stacked and
        executed from a single file.  The macro blocks must be enclosed within
        block identifier and terminator lines as shown in the example below.
        If you want to add comment lines to a macro block, you may place them
        anywhere within the macro block.  (This includes placing them directly
        on the lines where the macro block identifier and the macro block
        terminator appear, as shown in the example.)  Do not place comment
        lines (or any other lines) outside of a macro block.

        The name of the macro library file is identified for reading on the
        *ULIB command.   The name of the macro block is identified on the *USE
        command.  The commands within the macro block are copied to a temporary
        file (of the macro block name) during the *USE  operation and executed
        as if a macro file of that name had been created by the user.  The
        temporary file is deleted after it has been used.  Macro block names
        should be acceptable filenames (system dependent) and should not match
        user created macro file names, since the user macro file will be used
        first (if it exists) before the library file is searched.  Macro blocks
        may be stacked in any order.  Branching  [*GO or  *IF] external to the
        macro block is not allowed.

        This command is valid in any processor.
        """
        command = "*ULIB,%s,%s" % (str(fname), str(ext))
        return self.run(command, **kwargs)

    def exprofile(self, ldtype="", load="", value="", pname="", fname="",
                  fext="", fdir="", **kwargs):
        """APDL Command: EXPROFILE

        Exports interface loads or loads on selected nodes to an ANSYS CFX
        Profile file.

        Parameters
        ----------
        ldtype
            Load type:

            SURF  - Surface load.

            VOLU  - Volumetric load.

        load
            Surface loads:

            DISP  - Displacement (in a static analysis) or mode shape and global parameters (in a
                    modal analysis).

            MODE  - Normalized mode shape and global parameters (in a modal analysis only).

            TEMP  - Temperature.

            HFLU  - Heat flux.

        value
            If a positive integer, specifies the number of the surface or
            volume interface. If 0 (zero), the selected nodes or Named
            Selection are used.

        pname
            Field name in CFX Profile file (32-character maximum). Defaults to
            jobname_bcploadnumber for a surface load and jobname_subdloadnumber
            for volumetric load.

        fname
            The CFX Profile filename (248-character maximum). Defaults to
            jobname_bcploadnumber for a surface load and jobname_subdloadnumber
            for a volumetric load.

        fext
            The Profile file extension (8-character maximum). Defaults to.csv.

        fdir
            The Profile file directory (8-character maximum). Defaults to
            current directory.

        Notes
        -----
        By default, the EXPROFILE command assumes the data it writes to the
        Profile file are in SI units. For models not described in SI units,
        issue the EXUNIT command as needed to write the correct unit labels on
        the Profile file.

        For a modal analysis, if Load = DISP or MODE, global parameters
        including mass, frequency, and maximum displacement are also written to
        the ANSYS CFX Profile file. You should therefore issue the EXUNIT
        command for DISP, TIME, and MASS.

        Verify that the coordinate system is set to the global Cartesian
        (RSYS,0) before using this command.

        To transfer multiple loads across an interface, specify a unique file
        name and extension for each load.

        Force (FORC) and heat generation (HGEN) are per-unit volume.

        For modal analysis, this command does not support the following mode-
        extraction methods (MODOPT): unsymmetric matrix (UNSYM), the damped
        system (DAMP), or the QR-damped system (QRDAMP).

        To write the normalized (instead of non-normalized) mode shapes from a
        modal analysis to the file:

        Use Load = MODE.

        Verify that the mode shapes are normalized to the mass matrix
        (MODOPT,,,,,,OFF), the default behavior.

        Verify that the scale factor is set to 1.0 (SET,,,1.0), the default
        value.

        For loads not specified directly via commands (such as SF and BF),
        loads must first be read into the database (SET or LCASE).

        Distributed ANSYS Restriction: This command is not supported in
        Distributed ANSYS.
        """
        command = "EXPROFILE,%s,%s,%s,%s,%s,%s,%s" % (str(ldtype), str(load), str(value), str(pname), str(fname), str(fext), str(fdir))
        return self.run(command, **kwargs)

    def user(self, wn="", **kwargs):
        """APDL Command: /USER

        Conveniently resets /FOCUS and /DIST to USER.

        Parameters
        ----------
        wn
            Window number (or ALL) to which command applies (defaults to 1).

        Notes
        -----
        Conveniently resets scale parameters to USER on the /FOCUS and /DIST
        commands.  Scale parameters will be internally respecified to those
        used for the last display.  Convenient when the last scale parameters
        were automatically calculated.  User specified parameters hold until
        changed or removed [/AUTO].  Parameters may be reset on the individual
        commands after this command has been issued.

        This command is valid in any processor.
        """
        command = "/USER,%s" % (str(wn))
        return self.run(command, **kwargs)

    def mptemp(self, sloc="", t1="", t2="", t3="", t4="", t5="", t6="",
               **kwargs):
        """APDL Command: MPTEMP

        Defines a temperature table for material properties.

        Parameters
        ----------
        sloc
            Starting location in table for entering temperatures.  For example,
            if SLOC = 1, data input in the T1 field applies to the first
            constant in the table.  If SLOC = 7, data input in the T1 field
            applies to the seventh constant in the table, etc.  Defaults to the
            last location filled + 1.

        t1, t2, t3, . . . , t6
            Temperatures assigned to six locations starting with SLOC.  If a
            value is already in this location, it will be redefined.  A blank
            (or zero) value for T1 resets the previous value in SLOC to zero.
            A value of zero can only be assigned by T1.  Blank (or zero) values
            for T2 to T6 leave the corresponding previous values unchanged.

        Notes
        -----
        Defines a temperature table to be associated with the property data
        table [MPDATA].  These temperatures are also used for polynomial
        property evaluation, if defined [MP].  Temperatures must be defined in
        non-descending order.  Issue MATER $ STAT to list the current
        temperature table.  Repeat MPTEMP command for additional temperatures
        (100 maximum).  If all arguments are blank, the temperature table is
        erased.

        For clear definition, the temperature range you define with the MPTEMP
        command should include the entire range you'll use in subsequently
        defined materials.  To assist the user in this, the first (and only the
        first) excursion out of the temperature range defined by the MPTEMP
        commands is flagged with a warning message.  Similarly, the reference
        temperature (TREF or MP,reft commands) should also fall in this same
        temperature range.  If not and MP,alpx was used, a note will be output.
        If not, and MP,ctex or MP,thsx was used, an error message will be
        output.

        This command is also valid in SOLUTION.
        """
        command = "MPTEMP,%s,%s,%s,%s,%s,%s,%s" % (str(sloc), str(t1), str(t2), str(t3), str(t4), str(t5), str(t6))
        return self.run(command, **kwargs)

    def dfswave(self, kcn="", radius="", psdref="", dens="", sonic="",
                incang="", npara="", sampopt="", **kwargs):
        """APDL Command: DFSWAVE

        Specifies the incident planar waves with random phases for a diffuse
        sound field.

        Parameters
        ----------
        kcn
            Local coordinate system:

            N - Coordinate system number. Default = 0.

            DELETE - Delete defined incident diffused planar waves.

        radius
            Radius of the reference sphere on which the incident planar waves
            are distributed with equal energy. Defaults to 50 x the half-
            maximum dimension of the structural panel.

        psdref
            Reference power spectral density. Default = 1.

        dens
            Mass density of incident planar wave media. Default = 2041 kg/m3.

        sonic
            Sound speed in incident planar wave media. Default = 343.24 m/s)

        incang
            Maximum incident angle (0o <= degree <= 180o) against the positive
            z axis in the local coordinate system KCN. Default = 0o.

        npara
            Number of divisions on the reference sphere with cutting planes
            parallel to the x-y coordinate plane of the local coordinate
            system. Default = 20.

        sampopt
            Random sampling option:

            ALL - Initializes the random generator of incident planar wave phases and samples the
                  phases at each solving frequency.

            MULT - Initializes the random generator of incident planar wave phases at the first
                   frequency and samples the phases at each solving frequency.

            MONO - Initializes the random generator of incident planar wave phases and samples the
                   phases only once at first solving frequency so that the same
                   phases are used over the whole frequency range for each
                   incident planar wave.

        Notes
        -----
        Issue the DFSWAVE command to activate a diffuse sound field. (The AWAVE
        command does not activate a diffuse sound field.)

        The SURF154 surface element must be defined on the surface of the
        structural solid element for the excitation.

        The acoustic elements and the absorbing boundary condition must be
        defined in the open acoustic domain. Do not define the acoustic domain
        on the excitation side.

        The PLST command calculates the average transmission loss for multiple
        sampling phases at each frequency over the frequency range.

        The symmetry of a panel structure cannot be used to reduce the
        simulation size, as the incident plane waves have varying random phase
        angles. The z axis of the Cartesian coordinate system (KCN) must be
        consistent with the panel’s outward normal unit vector at the center of
        the panel’s sending side.
        """
        command = "DFSWAVE,%s,%s,%s,%s,%s,%s,%s,%s" % (str(kcn), str(radius), str(psdref), str(dens), str(sonic), str(incang), str(npara), str(sampopt))
        return self.run(command, **kwargs)

    def hbc(self, wn="", key="", **kwargs):
        """APDL Command: /HBC

        Determines how boundary condition symbols are displayed in a display
        window.

        Parameters
        ----------
        wn
            Window reference number. This number can be any window numbered 1
            to 5, or ALL (for all active windows). Defaults to 1

        key
            Key to enable/disable hidden surface boundary condition symbol
            display for 2-D graphics devices and to request improved pressure
            contour display for 2-D and 3-D devices: Key = ON, YES or 1 will
            show your BC symbols on the hidden surfaces and use an improved
            pressure contour display. Key = OFF, NO or 0 (default) will hide
            the symbols .
        """
        command = "/HBC,%s,%s" % (str(wn), str(key))
        return self.run(command, **kwargs)

    def get(self, par="", entity="", entnum="", item1="", it1num="", item2="",
            it2num="", **kwargs):
        """APDL Command: *GET

        Retrieves a value and stores it as a scalar parameter or part of an
        array parameter.

        Parameters
        ----------
        par
            The name of the resulting parameter. See *SET for name
            restrictions.

        entity
            Entity keyword. Valid keywords are NODE, ELEM, KP, LINE, AREA,
            VOLU, PDS, etc., as shown for Entity = in the tables below.

        entnum
            The number or label for the entity (as shown for ENTNUM = in the
            tables below). In some cases, a zero (or blank) ENTNUM represents
            all entities of the set.

        item1
            The name of a particular item for the given entity. Valid items are
            as shown in the Item1 columns of the tables below.

        it1num
            The number (or label) for the specified Item1 (if any). Valid
            IT1NUM values are as shown in the IT1NUM columns of the tables
            below. Some Item1 labels do not require an IT1NUM value.

        item2, it2num
            A second set of item labels and numbers to further qualify the item
            for which data are to be retrieved. Most items do not require this
            level of information.

        Notes
        -----
        *GET retrieves a value for a specified item and stores the value as a
        scalar parameter, or as a value in a user-named array parameter. An
        item is identified by various keyword, label, and number combinations.
        Usage is similar to the *SET command except that the parameter values
        are retrieved from previously input or calculated results. For example,
        *GET,A,ELEM,5,CENT,X returns the centroid x-location of element 5 and
        stores the result as parameter A. *GET command operations, along with
        the associated Get functions return values in the active coordinate
        system unless stated otherwise. A Get function is an alternative in-
        line function that can be used to retrieve a value instead of the *GET
        command (see Using In-line Get Functions for more information).

        Both *GET and *VGET retrieve information from the active data stored in
        memory. The database is often the source, and sometimes the information
        is retrieved from common memory blocks that the program uses to
        manipulate information. Although POST1 and POST26 operations use a
        *.rst file, *GET data is accessed from the database or from the common
        blocks. Get operations do not access the *.rst file directly. For
        repeated gets of sequential items, such as from a series of elements,
        see the *VGET command.

        Most items are stored in the database after they are calculated and are
        available anytime thereafter. Items are grouped according to where they
        are usually first defined or calculated. Preprocessing data will often
        not reflect the calculated values generated from section data. Do not
        use *GET to obtain data from elements that use calculated section data,
        such as beams or shells. Most of the general items listed below are
        available from all modules. Each of the sections for accessing *GET
        parameters are shown in the following order:

        *GET General Entity Items

        *GET Preprocessing Entity Items

        *GET Solution Entity Items

        *GET Postprocessing Entity Items

        *GET Probabilistic Design Entity Items

        The *GET command is valid in any processor.
        """
        command = "*GET,%s,%s,%s,%s,%s,%s,%s" % (str(par), str(entity), str(entnum), str(item1), str(it1num), str(item2), str(it2num))
        return self.run(command, **kwargs)

    def combine(self, filetype="", **kwargs):
        """APDL Command: COMBINE

        Combines distributed memory parallel (Distributed ANSYS) files.

        Parameters
        ----------
        filetype
            Type of solution file to combine. There is no default; if (blank),
            the command is ignored.

            RST - Structural results file (.RST)

            RTH - Thermal results file (.RTH)

            RMG - Magnetics results file (.RMG)

            RSTP - Linear perturbation results file (.RSTP)

            EMAT - Element matrix file (.EMAT).

            ESAV - Element saved data file (.ESAV)

            MODE - Modal results file (.MODE)

            MLV - Modal load vector file (.MLV)

            IST - Initial state file (.IST)

            FULL - Full matrix file (.FULL)

            RFRQ - Reduced complex displacement file (.RFRQ)

            RDSP - Reduced displacement file (.RDSP)

        Notes
        -----
        The COMBINE command is used within the AUX2 auxiliary processor to
        combine local solution files from a distributed memory parallel
        solution into a single, global file. Before using this command, you
        must enter the AUX2 processor by issuing the /AUX2 command.

        In a distributed memory parallel (Distributed ANSYS) solution, you can
        use the DMPOPTION command to bypass the file combination step, causing
        all individual local files to be kept on the local disks in the current
        working directory. Later on, you can start a new distributed memory
        parallel solution and use the COMBINE command to combine local files
        into a global file for a downstream solution or another operation
        (e.g., postprocessing with /POST1). For example, the command
        COMBINE,RST will combine local results files (JobnameN.RST) into a
        global results file (Jobname.RST).

        When the COMBINE command is used in a subsequent Distributed ANSYS
        session, the number of processors must be the same as in the
        distributed memory parallel solution that generated the files.

        When running on a cluster, the local solution files must be available
        in the working directory on each node in the subsequent session. As an
        example, consider the following command line used to generate local
        solution files:

        Different machines can be used in the subsequent session to combine
        these files. However, the total number of cores must remain unchanged
        (seven in the above case), and the local files must be copied to the
        working directory (or directories) on each of the machines used in the
        subsequent session.
        """
        command = "COMBINE,%s" % (str(filetype))
        return self.run(command, **kwargs)

    def datadef(self, **kwargs):
        """APDL Command: DATADEF

        Specifies "Directly defined data status" as the subsequent status
        topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "DATADEF," % ()
        return self.run(command, **kwargs)

    def resp(self, ir="", lftab="", ldtab="", spectype="", dampratio="",
             dtime="", tmin="", tmax="", inputtype="", **kwargs):
        """APDL Command: RESP

        Generates a response spectrum.

        Parameters
        ----------
        ir
            Arbitrary reference number assigned to the response spectrum
            results (2 to NV [NUMVAR]).  If this number is the same as for a
            previously defined variable, the previously defined variable will
            be overwritten with these results.

        lftab
            Reference number of variable containing frequency table (created
            with FILLDATA or DATA command).  The frequency table defines the
            number and frequency of oscillating systems used to determine the
            response spectrum. The frequency interval need not be constant over
            the entire range. Frequencies must be input in ascending order.

        ldtab
            Reference number of variable containing the input time-history.

        spectype
            Defines the type of response spectrum to be calculated:

            0 or 1 - Displacement (relative to base excitation)

            2 - Velocity (relative to base excitation)

            3 - Acceleration response spectrum (absolute)

            4 - Pseudo-velocity

            5 - Pseudo-acceleration

        dampratio
            Ratio of viscous damping to critical damping (input as a decimal
            number).

        dtime
            Integration time step. This value should be equal to or greater
            than the integration time step used in the initial transient
            analysis performed to generate the input time-history (LDTAB).

        tmin, tmax
            Specifies a subset of the displacement-time history to be used in
            the response spectrum calculation.  Defaults to the full time
            range.

        inputtype
            Defines the type of the input time-history:

            0 - Displacement (default)

            1 - Acceleration

        Notes
        -----
        This command generates a response spectrum from a displacement or
        acceleration time-history and frequency data. The response spectrum is
        defined as the maximum response of single degree of freedom systems of
        varying frequency (or period) to a given input support excitation.

        A response spectrum analysis (ANTYPE, SPECTR with SPOPT, SPRS or MPRS)
        requires a response spectrum input. This input can be determined from
        the response spectrum printout or display of this command.

        If a response spectrum is to be calculated from a given displacement
        (or acceleration) time-history, the displacement time-history may be
        input to a single one-element reduced linear transient dynamic
        (ANTYPE,TRANS) analysis, so that the calculated output (which should be
        the same as the input) will be properly located on the file.

        The integration time step (argument DTIME on the RESP command) and the
        damping coefficient (argument dampRatio) are constant over the
        frequency range. The number of calculations done per response spectrum
        curve is the product of the number of input solution points (TMAX-
        TMIN)/DTIME and the number of frequency points (frequencies located in
        variable LFTAB).

         Input solution points requested (using DTIME and the frequency range)
        at a time not corresponding to an actual displacement solution time on
        the file are linearly interpolated with respect to the existing points.

        For the details of the response spectrum calculation, see POST26 -
        Response Spectrum Generator (RESP).
        """
        command = "RESP,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(ir), str(lftab), str(ldtab), str(spectype), str(dampratio), str(dtime), str(tmin), str(tmax), str(inputtype))
        return self.run(command, **kwargs)

    def aplot(self, na1="", na2="", ninc="", degen="", scale="", **kwargs):
        """APDL Command: APLOT

        Displays the selected areas.

        Parameters
        ----------
        na1, na2, ninc
            Displays areas from NA1 to NA2 (defaults to NA1) in steps of NINC
            (defaults to 1).  If NA1 = ALL (default), NA2 and NINC are ignored
            and all selected areas [ASEL] are displayed.

        degen
            Degeneracy marker:

            (blank) - No degeneracy marker is used (default).

            DEGE - A red star is placed on keypoints at degeneracies (see the Modeling and Meshing
                   Guide ).  Not available if /FACET,WIRE is set.

        scale
            Scale factor for the size of the degeneracy-marker star.  The scale
            is the size in window space (-1 to 1 in both directions) (defaults
            to .075).

        Notes
        -----
        This command is valid in any processor.  The degree of tessellation
        used to plot the selected areas is set through the /FACET command.
        """
        command = "APLOT,%s,%s,%s,%s,%s" % (str(na1), str(na2), str(ninc), str(degen), str(scale))
        return self.run(command, **kwargs)

    def meshing(self, **kwargs):
        """APDL Command: MESHING

        Specifies "Meshing" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "MESHING," % ()
        return self.run(command, **kwargs)

    def define(self, **kwargs):
        """APDL Command: DEFINE

        Specifies "Data definition settings" as the subsequent status topic.

        Notes
        -----
        This is a status [STAT] topic command.  Status topic commands are
        generated by the GUI and will appear in the log file (Jobname.LOG) if
        status is requested for some items under Utility Menu> List> Status.
        This command will be immediately followed by a STAT command, which will
        report the status for the specified topic.

        If entered directly into the program, the STAT command should
        immediately follow this command.
        """
        command = "DEFINE," % ()
        return self.run(command, **kwargs)

    def dv3d(self, lab="", key="", **kwargs):
        """APDL Command: /DV3D

        Sets 3-D device option modes.

        Parameters
        ----------
        lab
            Mode label:

            ACCU - Allows ANSYS to use the accumulation buffer for OpenGL graphics. Activating
                   this feature will provide faster model rotation when shaded
                   backgrounds are in use. This feature is off by default.

            ACTR - Label term to designate the cursor position as the center for automatic dynamic
                   rotational center capability.  The subsequent Key value (see
                   below) turns this capability on and off. This feature is on
                   by default. (Available for OpenGL displays only)

            ANIM - Animation mode.  The ANIM option allows you to create animation frames in
                   pixmap mode instead of display list mode.  This may improve
                   large model performance, but it eliminates local
                   manipulation while animation is in progress. This feature is
                   on by default.

            ANTI - Label term to control Anti-aliasing, a smoothing technique for your graph
                   plots. (see below) The subsequent Key value turns this
                   capability on and off. The default for this feature is off.
                   (Available for OpenGL displays only).

            CNTR - Switches banded contours on (1) or off (0) for your 3–D contour display. The
                   default is 1 (ON). Other contour parameters such as number
                   of contours or the increment and range are defined using the
                   /CONTOUR command. When either 9 or 128 contours are
                   specified via /CONTOUR, this command is ignored and a smooth
                   contour is always displayed.

            DGEN - Local manipulation degenerate mode.  You access the DGEN option to set wire-
                   frame local manipulation mode for 3-D devices (device
                   dependent). This feature is off by default.

            DLIST - With DLIST, you can specify whether screen updates and redraws will be
                    performed using the ANSYS Display List (off), or the 3-D
                    device's Display List (on). DLIST is on by default for
                    Windows systems, but off for Linux.

            DELS - You use DELS to suppress contour display screen overwrites when /NOERASE is
                   active. This prevents the bleed-through that occurs when you
                   overlay contour plots.

            TRIS - Triangle strip mode. Tri-stripping provides faster 3-D display capabilities and
                   is on by default. Some display enhancements, such as
                   texturing, are adversely affected by tri-stripping. You can
                   turn off tri-stripping in order to improve these display
                   functions. Be sure to turn tri-stripping on after the
                   desired output is obtained.

        key
            The following key options apply to Lab = ACCU:

            0 - (OFF)  The accumulation buffer is not accessed. (default)

            1 - (ON)  Access to the buffer is enabled.

        Notes
        -----
        ANSYS uses display list animation for its 3-D models. This memory
        resident array method interfaces with the OpenGL model information to
        allow the program to efficiently pan, zoom, rotate and dynamically
        manipulate your model during animation. The logo, legend, contour and
        other annotation items are produced in 2-D and will not appear when
        /DV3D, ANIM, 0 is in effect. To display these items, use /DV3D, ANIM,
        1. All screen data will be displayed, but manipulation of the model
        will not be possible.
        """
        command = "/DV3D,%s,%s" % (str(lab), str(key))
        return self.run(command, **kwargs)

    def mopt(self, lab="", value="", **kwargs):
        """APDL Command: MOPT

        Specifies meshing options.

        Parameters
        ----------
        lab
            Meshing option to be specified (determines the meaning of Value):

            AORDER - Mesh by ascending area size order.  Set Value to ON to mesh smaller areas
                     first. Using this results in finer meshes in critical
                     areas for volume meshes; this can be used for cases where
                     SMRTSIZE does not mesh as needed. Default is OFF.

            EXPND - Area mesh expansion (or contraction) option.  (This option is the same as
                    SMRTSIZE,,,EXPND.) This option is used to size internal
                    elements in an area based on the size of the elements on
                    the area's boundaries.

            Value is the expansion (or contraction) factor. For example, issuing MOPT,EXPND,2 before meshing an area will allow a mesh with elements that are approximately twice as large in the interior of an area as they are on the boundary. If Value is less than 1, a mesh with smaller elements on the interior of the area will be allowed. Value for this option should be greater than 0.5 but less than 4.  - Value defaults to 1, which does not allow expansion or contraction of internal
                              element sizes (except when using AESIZE sizing).
                              If Value = 0, the default value of 1 will be
                              used. The actual size of the internal elements
                              will also depend on the TRANS option (or upon
                              AESIZE or ESIZE sizing, if used).

            TETEXPND - Tet-mesh expansion (or contraction) option. This option is used to size
                       internal elements in a volume based on the size of the
                       elements on the volume's boundaries.

            Value is the expansion (or contraction) factor.  For example, issuing MOPT,TETEXPND,2 before meshing a volume will allow a mesh with elements that are approximately twice as large in the interior of the volume as they are on the boundary. If Value is less than 1, a mesh with smaller elements on the interior of the volume will be allowed. Value for this option should be greater than 0.1 but less than 3.   - Value defaults to 1, which does not allow expansion or contraction of internal
                              element sizes.  If Value = 0, the default value
                              of 1 will be used. If Value is greater than 2,
                              mesher robustness may be affected.

            The TETEXPND option is supported for both the VMESH and FVMESH commands.  Tet-mesh expansion is the only mesh control supported by FVMESH. - TRANS

            Mesh-transition option. Controls how rapidly elements are permitted to change in size from the boundary to the interior of an area. (This option performs the same operation as SMRTSIZE,,,,TRANS.)   - Value is the transitioning factor. Value defaults to 2.0, which permits
                              elements to approximately double in size as they
                              approach the interior of the area.  (If Value =
                              0, the default value of 2 will be used.) Value
                              must be greater than 1 and, for best results,
                              should be less than 4.  The actual size of the
                              internal elements will also depend on the EXPND
                              option (or upon AESIZE or ESIZE sizing, if used).

            For a quad mesh with any element size, this option has no effect, as the program strictly respects any face size to ensure the most uniform quad mesh possible. To obtain a graded mesh using this option, apply LESIZE to the lines of the desired face. - AMESH

            Triangle surface-meshing option.  Valid inputs for Value are:     - DEFAULT

            Allows the program to choose which triangle mesher to use.  In most cases, the program chooses the main triangle mesher, which is the Riemann space mesher.  If the chosen mesher fails for any reason, the program invokes the alternate mesher and retries the meshing operation. - MAIN

            The program uses the main triangle mesher (Riemann space mesher), and it does not invoke an alternate mesher if the main mesher fails.  The Riemann space mesher is well suited for most surfaces. - ALTERNATE

            The program uses the first alternate triangle mesher (3-D tri-mesher), and it does not invoke another mesher if this mesher fails.  This option is not recommended due to speed considerations.  However, for surfaces with degeneracies in parametric space, this mesher often provides the best results. - ALT2

            The program uses the second alternate triangle mesher (2-D parametric space mesher), and it does not invoke another mesher if this mesher fails.  This option is not recommended for use on surfaces with degeneracies (spheres, cones, etc.) or poorly parameterized surfaces because poor meshes may result. - QMESH

            Quadrilateral surface meshing option.  (Quadrilateral surface meshes will differ based on which triangle surface mesher is selected.  This is true because all free quadrilateral meshing algorithms use a triangle mesh as a starting point.)  Valid inputs for Value are:     - DEFAULT

            Let the program choose which quadrilateral mesher to use.  In most cases, the program will choose the main quadrilateral mesher, which is the Q-Morph (quad-morphing) mesher.  For very coarse meshes, the program may choose the alternate quadrilateral mesher instead.  In most cases, the Q-Morph mesher results in higher quality elements.  If either mesher fails for any reason, the program invokes the other mesher and retries the meshing operation.  (Default.) - MAIN

            The program uses the main quadrilateral mesher (Q-Morph mesher), and it does not invoke the alternate mesher if the main mesher fails. - ALTERNATE

            The program uses the alternate quadrilateral mesher, and it does not invoke the Q-Morph mesher if the alternate mesher fails.  To use the alternate quadrilateral mesher, you must also select MOPT,AMESH,ALTERNATE or MOPT,AMESH,ALT2. - VMESH

            Tetrahedral element meshing option.  Valid inputs for Value are:     - DEFAULT

            Let the program choose which tetrahedra mesher to use.   - MAIN

            Use the main tetrahedra mesher (Delaunay technique mesher).  (GHS3D meshing technology by P. L. George, INRIA, France.)  For most models, this mesher is significantly faster than the alternate mesher. - ALTERNATE

            Use the alternate tetrahedra mesher (advancing front mesher).  This mesher does not support the generation of a tetrahedral volume mesh from facets (FVMESH).  If this mesher is selected and you issue the FVMESH command, the program uses the main tetrahedra mesher to create the mesh from facets and issues a warning message to notify you. - SPLIT

            Quad splitting option for non-mapped meshing.  If Value = 1, ON, or ERR, quadrilateral elements in violation of shape error limits are split into triangles (default).  If Value = 2 or WARN, quadrilateral elements in violation of either shape error or warning limits are split into triangles.  If Value = OFF, splitting does not occur, regardless of element quality. - LSMO

            Line smoothing option. Value can be ON or OFF.  If Value = ON, smoothing of nodes on area boundaries is performed during smoothing step of meshing.  During smoothing, node locations are adjusted to achieve a better mesh.  If Value = OFF (default), no smoothing takes place at area boundaries. - CLEAR

            This option affects the element and node numbering after clearing a mesh.  If Value = ON (default), the starting node and element numbers will be the lowest available number after the nodes and elements are cleared.  If Value = OFF, the  starting node and element numbers are not reset after the clear operation. - PYRA
        """
        command = "MOPT,%s,%s" % (str(lab), str(value))
        return self.run(command, **kwargs)

    def sfbeam(self, elem="", lkey="", lab="", vali="", valj="", val2i="",
               val2j="", ioffst="", joffst="", lenrat="", **kwargs):
        """APDL Command: SFBEAM

        Specifies surface loads on beam and pipe elements.

        Parameters
        ----------
        elem
            Element to which surface load is applied.  If ALL, apply load to
            all selected beam elements (ESEL).  If Elem = P, graphical picking
            is enabled and all remaining command fields are ignored (valid only
            in the GUI).  A component name may be substituted in Elem.

        lkey
            Load key associated with surface load (defaults to 1).  Load keys
            (1, 2, 3, etc.) are listed under "Surface Loads" in the input table
            for each element type in the Element Reference.  For beam and some
            pipe elements, the load key defines the load orientation.

        lab
            Valid surface load label.  Load labels are listed under "Surface
            Loads" in the input table for each element type in the Element
            Reference.  Structural labels:  PRES (pressure).

        vali, valj
            Surface load values at nodes I and J.  If VALJ is blank, it
            defaults to VALI.  If VALJ is zero, a zero is used.

        val2i, val2j
            Second surface load values at nodes I and J.  Currently not used.

        ioffst, joffst
            Offset distance from node I (toward node J) where VALI is applied,
            and offset distance from node J (toward node I) where VALJ is
            applied, respectively.

        lenrat
            Offset distance flag:

            0  - Offset is in terms of length units (default).

            1  - Offset is in terms of a length ratio (0.0 to 1.0).

        Notes
        -----
        Specifies surface loads on the selected beam elements. Distributed
        loads are applied on a force-per-length basis (that is, the width of
        the underlying element is not considered). To list and delete surface
        loads applied with this command, use the SFELIST and SFEDELE commands,
        respectively.

        If no offset values (IOFFSET and JOFFSET) are specified, the load is
        applied over the full element length. Values may also be input as
        length fractions, depending on the LENRAT setting. For example,
        assuming a line length of 5.0, an IOFFST of 2.0 with LENRAT = 0 or an
        IOFFST of 0.4 with LENRAT = 1 represent the same point.  If JOFFST =
        -1, VALI is assumed to be a point load at the location specified via
        IOFFST, and VALJ is ignored. (IOFFSET cannot be equal to -1.) The
        offset values are stepped even if you issue a KBC,0 command.

        Offsets are only available for element types BEAM188 and PIPE288 if
        using the cubic shape function (KEYOPT(3) = 3) for those element types.

        To accumulate (add) surface loads applied with this command, use the
        SFCUM,,ADD command. Use the same offset values used on the previous
        SFBEAM command (for a given element face); otherwise, the loads do not
        accumulate. If no offsets are specified, the command applies the
        previous offset values.

        This command is also valid in PREP7.
        """
        command = "SFBEAM,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s" % (str(elem), str(lkey), str(lab), str(vali), str(valj), str(val2i), str(val2j), str(ioffst), str(joffst), str(lenrat))
        return self.run(command, **kwargs)

    def space(self, node="", **kwargs):
        """APDL Command: SPACE

        Defines a space node for radiation using the Radiation Matrix method.

        Parameters
        ----------
        node
            Node defined to be the space node.

        Notes
        -----
        A space node is required in an open system to account for radiation
        losses.

        If using SPACE with the ANSYS Multi-field solver (MFS),  you must
        capture this command in the command file using MFCMMAND. This step is
        necessary because at the end of each field computation, this command is
        unset.
        """
        command = "SPACE,%s" % (str(node))
        return self.run(command, **kwargs)

    def dalist(self, area="", **kwargs):
        """APDL Command: DALIST

        Lists the DOF constraints on an area.

        Parameters
        ----------
        area
            List constraints for this area.  If ALL (default), list for all
            selected areas [ASEL].  If P1 = P, graphical picking is enabled and
            all remaining command fields are ignored (valid only in the GUI).
            A component name may also be substituted for AREA.

        Notes
        -----
        Lists the degree of freedom constraints on an area previously specified
        with the DA command.

        This command is valid in any processor.
        """
        command = "DALIST,%s" % (str(area))
        return self.run(command, **kwargs)
